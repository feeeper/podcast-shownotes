[
  {
    "segment_id": "145bf7c4-063f-4e95-8197-7f26f812c3b1",
    "episode_id": "bde3ea8f-40df-481b-a11e-e9414e878a61",
    "episode_number": 292,
    "segment_number": 3,
    "text": "Ну, то есть... Это грустно. Я понимаю, почему так устроено, я понимаю, что мир так устроен, и что большие компании так работают, но я хотел бы, чтобы они работали чуть лучше. Но я не знаю, что для этого нужно сделать. Если у вас есть мысли, что для этого нужно сделать, я бы сразу с ними ознакомился. Я думаю, что там уже таким же образом сидит мальчик-тинейджер. Да, но я не имел в виду, что там сидят только девочки, конкретно у меня попалась девочка. Первый шаг, мне кажется, совершенно правильный. Надо завести подкаст и в этом подкасте объявлять об этой проблемы. Пошли к следующей теме? Да, да, я вообще думал, может быть, эту тему нужно было и скипать, но мне очень хотелось побомбить. А следующая тема для любителей головоломок, олимпиадного программирования и всякого такого. Если помните, в свое время, я не знаю, как сейчас дела обстоят, в свое время был и сейчас, наверное, есть. Такой дядя Роман Душкин, автор энного количества книг по функциональному программированию и блогер, и пытаюсь вспомнить, чем он еще примечательен, по-моему, он в МИФИ вел функциональную программированию какое-то время. Сейчас занимается вроде чем-то связанным с искусством интеллектом, по крайней мере интересуется и медициной. Я какое-то время не следил, а ты его ЖЖ все еще читаешь? Мне куда-то приходит, то ли в твиттер приходит, в ленту, то ли еще куда-то трансляция того, что он пишет. В общем, я какое-то время не следил, но в свое время он устраивал конкурсы по функциональному программированию, в которых часто выигрывали программы на C++, но это неважно. И там были разные интересные задачи, как превратить слона, муху в слона, как перевести волка к козу и капусту через реку, решение с судоку, чего-то такое. На самом деле в какой-то момент ты понимаешь, что все эти задачи решаются более-менее схожим образом. Большинство из них сходится к поиску на графах. Поиск на графах – это либо поиск в ширину, либо в глубину, либо алгоритм «А звездочка», который ты с правильно подобранной евристикой даже можешь доказать, что надзирное решение является как бы минимальным. Путь на графе является минимальным. Оптимальным. Оптимальным, спасибо. У меня тут попалась интересная задача, которая похожа на липядную, но не совсем вкладывается в эту парадигму. На самом деле это головоломка, пазл настольный, который мне показал брат, который недавно в подкаст приходил. И там у тебя есть пакетик, в нем 5 фигур, фигурки, треугольнички, квадратики, всякое такое. Тебе нужно их собрать в один большой квадрат. Притом есть два варианта. Ты должен собрать квадрат из четырех предложенных фигурок, ну не сказано каких, либо используя все 5 фигур. Притом из четырех собирается вообще изи, буквально за пару секунд. Из пяти фигур чуточку сложнее. Там нужно, ну ты как бы догадываешься, что тут как-то начинает против себя работать интуиция, и нужно фигурки максимально упоротым образом сложить, тогда все сходится. Ну то есть как бы у меня, я не буду врать сколько заняло, но условно говоря один вечер. А потом меня посетила мысль, а было бы прикольно это автоматизировать. Написать программу, вот как тогда в конкурсах по олимпиадному программированию, как бы написать программу, которая собирает из фигур квадрат. Я взял фигурки, измерил их аккуратненько линеечкой, постарался так, чтобы было поточнее. Поискал библиотеки, ну мне в последнее время, когда я пишу для себя, нравится делать это на питоне. Поэтому, моя первая мысль была взять SimPy, есть такая библиотека, она на самом деле как-то правильно называется, символиных вычислений. То есть когда вот у тебя есть в аналитическом виде уравнение, ты их можешь там упростить, проинтегрировать, вот это вот все. Но там также есть дополнительный функционал, связанный с фигурами. Но это был, ну с геометрическими фигурами. Но это была не очень хорошая идея ее использовать, вот эта задача, потому что SimPy работает с геометрическими примитивами, как преимущественно с фигурами без площади, как с контуром, то есть как с кривой. Поэтому у него, например, нет из коробки методов уровня, по-моему, посчитать площадь он может, но он не может посчитать площадь пересечения двух фигур, или сделать между ними логическое или логическое, и всякие такие операции именно с фигурами на площади. Поэтому это была плохая идея, я поискал еще, нашел библиотеку Шейпли, и в ней уже были реализованы все нужные методы, в принципе, их можно реализовать самому, просто я старею и мне лень таким заниматься. В итоге я пытался решить эту задачку, и я не очень сильно преуспел, она оказалась не так проста, как я думал. То есть я предлагаю еще пообсуждать, кто как ее решал бы, но мои попытки оказались не очень успешными, за какое-то разумное время теми методами, которые я пробовал, задача вот так логидемически не решается. Что делать? Я решил, задам-ка я эту задачу нашим слушателям. Потому что я не очень большой фанат алибиадного программирования, но может кому-то хорошо зайдет некоторым людям и нравится челлендж, придумывать такие хорошие, интересные алгоритмы. Может быть есть прям готовые алгоритмы под эту конкретную задачу, но я с ними никогда не столкнулся. Задачу вы найдете полную формулировку на форуме, вместе с примером кода, картинка и так далее. И предлагается написать программу, которая решает этот пазл и выводит результат. Вот так вот эти фигурки если соединить, то будет квадратик. Я предлагаю обсудить, кто и как решал бы эту задачу. Мне кажется, ее достаточно просто решить. Так, продолжай. Во-первых, нужно узнать площадь. Когда ты посчитаешь площадь, ты можешь посчитать длину одной стороны. Хорошо, ты это знаешь. Дальше ты можешь перебором узнать всего пять фигур. Полный перебор. Ты можешь узнать из каких фигур состоит хотя бы одна сторона. Из каких фигур? Подожди, ты меня потерял. Давай для простоты. Мы рассматриваем задачу собрать из заданных фигур квадрат. Не вот там 4 с 5. Мы точно знаем, что фигур 5. Без разницы. Они же примерно одинаковые будут. То есть, 5 фигур у тебя есть квадрат. Ты считаешь сумму всех площадей. У тебя получается площадь Х. Это мы выселяем. Ты знаешь сторону квадрата. Понятно, что сторона в этом квадрате будет состоять из каких-то сторон всех этих фигур. Ты не можешь взять половину стороны и сделать, чтобы была часть квадрата. Ты знаешь все длины сторон. И ты просто перебором смотришь из каких составляющих частей будет состоять одна из сторон. Там будет 4 разных варианта. Может их будет больше, но должно быть 4. Дальше ты просто пытаешься их составить таким образом, что у тебя конец одной фигуры всегда... В смысле угол любой из фигур совпадает с углом любой другой фигуры. А как ты это формализуешь? А как ты это формализуешь? Ты имеешь в виду как на компьютере, в виде программы на питоне сделать так, чтобы он подставлял все эти фигуры вплотную друг другу? Когда ты говоришь, что известна сторона квадрата, окей. Известна длина каждой из сторон гуру, согласен. Мы можем найти N-ое количество вариантов, которые могут составлять сторону квадрата. Хорошо. А вот тут начинаются всякие неудобные моменты. Тебе нужно выяснить, что если ты эту фигуру будешь поворачивать и вот так ставить, то одна из сторон выходит за квадрат. И тебе такой вариант уже не подходит. Потом ты говоришь, что тебе нужно найти, если ты смог вписать фигуры, тебе нужно найти все их углы, принадлежащие квадрату. Хорошо, ты нашел их, все углы и твои дальнейшие действия. Для начала я бы вел примитивы, лежитость левой или с правой стороны от линии. Для того, чтобы определять, попадаем мы в квадрат или не попадаем. Выходит она за рамки квадрата или не выходит. Это уже реализованно, в Шейпле тебе даже делали это. Прям чудесно. Во-вторых, ты можешь реализовать подгон двух фигур по какой-то... По стороне А в одной фигуре, по стороне Б в другой фигуре. То есть, ты таким образом их поворачиваешь между собой, чтобы они соприкасались именно этими сторонами. Мне кажется, это тоже достаточно легко реализуемая штука. Когда ты их соприкоснул между собой, ты можешь двигать их вдоль этой оси, для того, чтобы они совпали по углу. Соответственно, у тебя полный начинается перебор, который когда-нибудь закончится результативно. Самое сложное – это реализовать примитивы, а дальше у тебя просто уже получается перебор. То есть, поставить все углы, соприкоснув все стороны и посмотреть, что получится. Я понял твою идею. Она звучит правдоподобно. Я этот подход не пробовал. Поэтому, если кто-то из слушателей чувствует в себе силу это проверить, то приходите к нам. Я предлагаю постить на форуме, потому что там есть возможность постить картинки и код. И продемонстрируйте свое решение. И еще Broadforce, может быть. Broadforce очень плохо работает. Ты уже понял, какую я Broadforce имею в виду? Не понял. Случайным образом размещать фигуры внутри квадрата и ждать, пока они наконец не будут пересекаться. Их площадь будет равняться площади квадрата. У меня было две мысли, которые я пробовал и после чего я забил. Сначала я подумал, что было бы прикольно это решать с генетическим алгоритмом. Он был реализован, но он совсем не хочет нормально сходиться. Тебя программа рисует очень прикольные картинки. Я полчаса шовшал и вот так их скомкал. Смотри, вписалось же. Ты такой, да, чувак. Спасибо, конечно, здорово получилось. Посмотри, вот такие фигуры. Потому что у тебя размер фигуры с небольшой погрешностью. Но я повторюсь, я это измерял. И тебе нужно с точностью до какой-то япсулы допускать пересечение. И ты говоришь, давай увеличим штраф за пересечение фигур. И уходят дальше думать. Выдает тебе такие... Вот я же почти вписал. А, да, дружище ты старался. Но нет, это все немножко не то. Генетический алгоритм выглядит очень забавно, но не решает задачу. Второй, моей мыслью, была... Во-первых, еще одна маленькая подсказка. Если внимательно посмотреть на фигуры... Я не могу это строго доказать математически. Но достаточно очевидно, что не имеет смысла поворачивать фигуры на углы не кратные 45 градусов. Поэтому у каждой фигуры есть только 8 поворотов. Это существенно засуживает пространство поиска. И второй, моей мыслью, была... Возьмем фигуры, отсортируем их по площади в порядке убывания. То есть, сначала самая большая по площади фигура. Разместим ее с координатой 0,0. В самом углу квадрата. И вычислим ту площадь, которую она заняла, из площади квадрата. Возьмем вторую фигуру по площади самой большой. И найдем такое положение, опять же, перебором. При котором оно выходит за пределы той фигуры, которая осталась предыдущего шага, не более чем на Эпсилон. То есть, максимально покрывает оставшуюся фигуру. И поскольку у нас фигуры сначала идут самые большие, то мы максимально сокращаем пространство поиска еще на самом первом шаге. Плюс, таким образом, если память не подводит, у квадрата сторона получается 44 единицы. И на самом деле ты можешь... Это еще одна из идей была. Ты по началу можешь искать не очень точное решение. Взять Эпсилон побольше, найти примерное решение, а потом его уточнить. Поэтому ты можешь, например, с шагом в один пиксель, в одну единицу, whatever. Таким образом, ложить фигуры. Ты знаешь, что число поворотов ты сократил, ты знаешь, что достаточно восьми. Плюс, на самом деле ты знаешь, что... Сейчас я вспомню. Первую фигуру имеет смысл... Вот при таком алгоритме первую фигуру имеет смысл поворачивать только на 0 градусов и на 45 градусов в силу симметрии задачи. Потому что, если повернешь на 90, то ты будешь укладывать ту же фигуру, но просто в квадрат, который ты повернул на 90, что довольно бессмысленно. Потому что когда ты поворачиваешь квадрат на 90, то получается то же самое. Надеюсь, я понятно объяснил. Ты знаешь, что первую фигуру в таком переборе имеет смысл поворачивать только на 0 и на 45. Но такой алгоритм тоже работает плохо. Он либо ищет очень долго, вы не дождетесь, либо находит неправильно. Потому что ты задираешь большой эпселон и он укладывает... Опять пересует вот эти картинки. Ну я очень старался, вот смотри, впихнул уже. Вот. Поэтому, да, этот путь весь перспективен. А вот то, что предлагает Ваня, можно попробовать. Но опять же, там возникают вопросы, какой у вас будет глубина поиска в итоге. Дождетесь левой ответа. И насколько вам удастся формализовать то, что Ваня описывает. Вопросы, дополнения. Мне кажется, было бы интересно все-таки каким-нибудь монтаж. Там, гляньте в этот чат выпуска. Я не очень понимаю, что происходит, но возможно, вы что-то когда прочитаете скажете. Ну, в кратце, комментарии в чате комментируют. Комментируют ситуацию с DPD, что как бы ну... Там комментарии, там не вопрос, то, что да, все очень плохо. Вот. И предлагают решение задачи, которые тоже с этой комментарией, а не вопрос. Поэтому, как бы, заинтересованным предлагаю прийти в чат и ознакомиться. А у меня есть другая идея. А что если подойти к этой сдаче немножко другим образом? Что если перевернуть ее в то, что нам нужно разрезать квадрат на такие составляющие? Что если мы будем пытаться резать квадрат разными способами и перебирать способы разрезания квадрата, чтобы в итоге получить фигуры такие? Может это будет легче? Это хорошая мысль, интересная. Я не долго не думал. Она... В чем сложность? Ты не знаешь, что из нарисованных фигур, где граница квадрата, а где как бы то, чем ты будешь резать, поэтому тебе опять придется перебирать разные варианты, понимаешь? И не уверена, что ты понимаешь, что имеешь в виду? Я пытаюсь сказать, что задача была бы намного проще, если бы, типа, у тебя было дано 5 кривых незамкнутых, и сказать, вот, порежьте квадрат. Но в этой задаче ты не знаешь, у тебя любая сторона может быть как стороной квадрата, и чем ты режешь. Поэтому у тебя немножко количество комбинаций увеличивается. Это не значит, что задача не решается этим образом. Я просто говорю, что она чуть сложнее, чем может казаться. Я сейчас не понял, что ты имеешь в виду, что сторона квадрата может быть тем, что ты режешь. Я не понимаю, что ты говоришь. Ты предложила свести задачу к нарезанию квадрата. Квадрат режется ломанами. Проблема в том, что у тебя в исходной формулировке ломанных нет. У тебя есть фигуры замкнутые. И под множество их сторон образуют те ломаные, которыми ты предлагаешь резать. Но ты не знаешь, какие стороны, ну, то есть, какую часть из отрезков, образующих их стороны, необходимо использовать. Я поняла, что ты теперь имеешь эту... Получается, что у тебя каждая ломаная может быть как стороной квадрата, так и сборной стороной квадратов. Да, но это часть нарезания по факту. Да, да, да. Я не хочу против такого поповения. Там будут дополнительные условия, но мне бы интересно это было поисследовать. Вот, мне интересно. Мне кажется, что есть более... Опять же, я смотрю на эту задачу, я вижу, что это должно быть какое-то очень изящное и красивое решение. Вот, типа, знаешь, перевернуть ее, эту задачу в что-то другое и решить ее очень просто и изящно. Вот прям вот я смотрю на это и ощущение такое. Но опять же, возможно, это мой, как это, привычка такие задачки решать и просмотр всяких олимпиадных задачек. Но мне не... Ну, мне не думать, что я должна быть брутфорсом это решать. Но мне должно быть более красивое решение. Мне интересно, найдется ли у нас среди более 5 тысяч человек хотя бы один слушатель, который сможет ее решить, опубликует прям такое нормальное, честное решение и каким именно способом он ее решит. Но, в принципе, если удастся как-то сократить время перебора, я ничего не имею против решения перебором, пожалуйста, просто он не должен длиться там 5 дней. Посмотрим, у кого из слушателей есть куча свободного времени? Ну, я не думаю, что это прям куча. Это вопрос интереса к этой задаче и просто желание. То есть, ну, мне не настолько интересно ее решить. Мне было интересно вот именно попробовать, а справится ли генетический алгоритм, он не справился. Вот. Ну, и у меня как-то интерес, ну, в общем-то пропал. Может быть, через какое-то время он снова вернется, не знаю. Вот, ну, я подумал, будет интересно предложить эту задачу нашим слушателям и вдруг кому-то будет интересно ее решить. Пойдемте дальше. Согласен. Пойдемте дальше. Квадрат мы решили. Нет, еще. Тогда, может быть, я свою тему расскажу? Давай. Прежде, чем мы придем на обсуждение, потому что непонятно, как долго у нас обсуждение затянет, я хочу рассказать про тему, которую, по-моему, давным-давно занеслись темы слушателей, хотя я, может быть, обманываю, потому что я не помню, откуда взялась эта тема. Это... Прости, как в том ненависти. Шамо приполжло, да? Наверное, я не знаю такого нигда. Ну, сидит девочка в песошнице, что-то живет. К ней подходит мальчик, говоришь, девочка, девочка, а что ты живешь? Не знаю, шамо приполжло. Все понятно. Да, вот это оно. Это рассказ про отладку сетевых проблем, проблем в продакшене Гитхаба. И мне эта статья чрезвычайно понравилась. Я, наверное, сравнил бы ее с расследованием, которое какой-нибудь, не знаю, Шарлак Холмс и доктор Ватсон совершают, когда вы из расследования это получается такая цепочка из, не знаю, 20 разных шагов, совершенно разных окружениях, и вы приходите в конце концов к результату, которого вы совсем-совсем не ожидали.",
    "result": {
      "error": "API request failed: Error code: 400 - {'error': 'Trying to keep the first 4874 tokens when context the overflows. However, the model is loaded with context length of only 4096 tokens, which is not enough. Try to load the model with a larger context length, or provide a shorter input'}",
      "stack_trace": "Traceback (most recent call last):\n  File \"/home/andrei/Projects/podcast-shownotes/scripts/build_search_eval_dataset.py\", line 157, in generate_search_query\n    response = await self.client.chat.completions.create(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/resources/chat/completions/completions.py\", line 1927, in create\n    return await self._post(\n           ^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1767, in post\n    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1461, in request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1562, in _request\n    raise self._make_status_error_from_response(err.response) from None\nopenai.BadRequestError: Error code: 400 - {'error': 'Trying to keep the first 4874 tokens when context the overflows. However, the model is loaded with context length of only 4096 tokens, which is not enough. Try to load the model with a larger context length, or provide a shorter input'}\n"
    }
  }
]