[
  {
    "segment_id": "98546a37-186c-48dd-941b-b2a94149329f",
    "episode_id": "ab7653fd-dcf2-4e76-96f7-632c26ada347",
    "episode_number": 358,
    "segment_number": 9,
    "text": "делается вручную то есть вы вручную должны импортировать rc или арк атомик референс календинг и ваш объект как положить в это атомик референс календинг передать ему ownership на своим объектом после чего вы получаете структуру арка каждый раз когда вы будете делать и клон вы будете создавать новую то есть увеличивать количество ссылок как только количество слоя стикнет нуля объект и все что содержится разрушится я понял я понял какую разницу ты хотел почерпнуть так вот у этого подхода у обоих как у почета ссылок как и у описанного тобой механизма владения когда ты понимаешь что с этого места этот этим объектом я больше не владею надо память освободить у него есть сильные слабые стороны слабая сторона заключается в том по сравнению с гц что гц он обходит живые объекты и копирует их ну либо выделенную память либо ну смотря как реализован гц или если это слабо локатор то этого иначе работает минус подходы выбранного в росте в том что ты обходишь мертвые объекты и обычно и престика такая что мертвых объектов их больше это не значит что в расе неправильный подход что он не эффективен и так далее но это компромисс который они выбрали и который считаю важным озвучить все тоже и все плюс компромиссы те же самые но в java и в го наоборот они обходят живые объекты подождите но ведь если у тебя есть мертвый объект уже в любом случае когда-то соберется да просто вопрос в том сложности обхода то есть у тебя это обход графа позволить попробуем может быть другими словами объяснить то есть что происходит в java рассмотрим такой прощенный сценарий да ты сделал стап за ворлд это не совсем правда мы допустим ты смотришь ага я знаю что вот эти объекты они живые посмотрим на что они слой за что они слой за год я все обошел это марк потом я же ну опять же возможно разные реализация там в простейшем случае я беру живые объекты копирую их вообще в новую кучу это не так как она работает но для простоты вот то что я обошел я скопировал а все предыдущий выделенный память целиком взял и грохнул вообще потому что я знаю что живое скопировал остальное все мертвое в расти получается наоборот ты обходишь мертвые объекты и освобождаешь выделенный по них память давайте забудем что в росте есть gc это очень запутывающе действительно было фраза смотри ты объявил применную x равняется 2 своей функции все функция завершается в этот момент у тебя вставляется просто что x дропается но в такой реализации она просто жила на стойке на то совсем простые SD здесьrewario� wichtig Tamam даже если не желан即 даже если имеется связка стек juicy со сек啦 крinees quests колод sulfon так и будет по две secrets меня п вал으로 diskutно р editor на founders della g Norwegian просто взять и выкинуть память потому что тебе нужно обойти посмотреть а что там еще что он еще на что он еще ссылался чтобы это тоже освободить кстати выше было сказано что там все если плюс плюс вот всегда используется обход мертвых объектов это не совсем правда как напишешь например в позграсте есть мемори контексты которые наверное мне сложно будет чем-то провести аналоги но эта штука была реализована потому что у тебя есть транзакции которые пользователи может обортить и которые могут с exception обортиться и когда это происходит тебе нужно вот просто вот всю память которая на этом уровне вложенности транзакции было выделено вот просто ты знаешь что вот вся эта память она больше не нужно и ты грохаешь это все я кстати позареваю что раз может подобное делать я думаю что это учитывая что там сегменты управляет памятью очень может быть что мы сейчас как раз вот говорим о том что возможно раз выделяет его под какую-то задачу память это вот в одном месте и когда мы типа выходим за пределы видимости мы просто скорее всего можем весь сегмент освободить это интересная мысль между прочим я не уверен что так работает но мне кажется так может быть я к сожалению не слишком погружен в кишочки но такое важное отличие от джавы хип здесь используется явно то есть чтобы поместить какой-то объект на хип он должен быть либо точно не детерминированного размера там типа вектор хэш мапа либо вы должны сделать это вручную есть такой тип данных бокс и вы можете поместить объект в бокс и тогда он будет жить на хипе но по молчанию все старается как может больше жить на стэке я же правильно понимаю что если ты создаешь просто посреди скопа создаешь вектор чего-то скажем вектор строк оно все ляжет на хип но когда оно выйдет с контекста оно все будет аккуратненько освобождено да я не уверен что механизм на освобождение как именно это происходит как он мэнажит страницы памяти но идея такая там я предлагаю от управления памяти пойти дальше хорошо в сущности",
    "result": {
      "query": "garbage collection memory management"
    }
  }
]