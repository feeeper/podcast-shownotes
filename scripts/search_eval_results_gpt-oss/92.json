[
  {
    "segment_id": "52d1e82d-14c9-45e4-987c-79501ef7bc57",
    "episode_id": "eb8bc1ab-a149-4d85-b45b-54ae7fc5dd8d",
    "episode_number": 92,
    "segment_number": 8,
    "text": "Все любят пинать ирланг за то, что там нет нормальных строк. На самом деле в ирланге есть целых три типа строк. И в эликсире, соответственно, тоже. И они обладают достаточно уникальными фичами. То есть, есть строки как строки. Это список уникальных пойнтов. И это вот реально инты, которые могут вылезать за 256. Ну и понятное дело, это список со всеми вытекающими. То есть по нему, с одной стороны, можно, не знаю, удобно замачиваться, и его можно обойти символ за символом. Но при этом этот список, он односвязанный, и вот там странная асимптотика может быть. И он памяти много жрет. Поэтому если вам нужно гонять данные, вы со списком работать не хотите. Вы можете работать со списком, если у вас есть небольшой кусочек, с которым вы хотите что-то сделать. Во-вторых, там есть бинари. Ну это просто любой кусок данных. Ну и строки у нас стоят в UTF-8. Поэтому достаточно разумно сказать, что в принципе строкой может быть бинарь, в которой UTF-8. И это тоже поддерживается. Там есть операции для работы с такими строками. На самом деле в Elixir строки это в первую очередь. Наконец, есть фича, которая, мне кажется, я не знаю, я ее больше нигде вообще не видел. Может где-то это еще есть, я просто не видел. Называется списки ввода-вывода IOLists. Это потрясающая вещь, потому что по сути это позволяет построить такой... То есть список ввода-вывода это либо бинари, либо список из бинари, или строки, или другого такого списка. То есть по сути у нас может быть дерево, достаточно развесистое, которое в себе содержит как бы... В результате содержит бинари или строки обычные, которые находятся в том же списке. То есть получается либо бинари, либо отдельные коды символов. И рекурсивно могут уходить в другие списки. Чем это классно? Казалось бы, зачем вообще-то кому-то в голову может прийти странная замороченная структура данных? Во-первых, это позволяет нам внезапно континировать строки за от-единицы. То есть у нас есть большой кусок темплейта, который мы прочитали с файла. А дальше нам нужно вставить буквально один интержест, который нам показывает число пользователей на сайте, например. Дальше у нас идет снова какой-то кусок, который мы прочитали с файла. Дальше мы, собственно, должны отрендерить то, что у нас на страничке. Это, возможно, будет более-менее 50 на 50 примешку куски, прилетевшие с базы, куски, прилетевшие с файла. И, наконец, у нас внизу будет какой-нибудь днище. Не знаю, подскажите мне. У нас будет какой-то днище страницы, и оно тоже, скорее всего, кусок, всякое с файла. В общем, все это как билдеры в Java. Да. И вот просто подвешивается структура данных. И каждый раз, когда мы кусок файла склеиваем с чем-то не из файла, для нас это операция, которая заует единицы. В принципе, да, билдеры в Java, наверное, это близкая штука. Я, кстати, не знаю, какой билдер в Java с этим. Что еще прикольно у списков ввода-вывода, в том, что потом их совершенно не обязательно сплющивать. Их можно просто, как есть такой список, отдать системе ввода-вывода BIM, то бишь виртуальной машинной каприкурке с верланкой или Xeer. И оно просто знает, как с этим работать. То есть, в любом случае, у нас для вывода нужно сделать OAT на операции. То есть, ну, здесь нет никакого пути избежать этого. А вот зато конкретнировать мы конкретнируем дешево. И поскольку у нас система ввода-вывода всегда такое поддерживает, мы можем вот такую структуру развесистую просто забросить в систему, отдать верлангу, и оно очень здорово это выведет. Больше того, оно на самом деле достаточно умное, и оно будет делать некоторые дополнительные оптимизации, про которые я не буду рассказывать, если вы достаточно заинтригованы играть на статью. Там просто прикольно показываются адресами и вызовами, что на самом деле оно еще местами делает довольно забавно претурбации.",
    "result": {
      "query": "Elixir IOList string performance"
    }
  }
]