[
  {
    "segment_id": "0ef727cc-763d-427f-b4b7-2e17e539745d",
    "episode_id": "471321c4-2bad-4fe9-bcdf-f58d634fd1ed",
    "episode_number": 357,
    "segment_number": 6,
    "text": "И удивительно, как такая простая вещь, но она тоже выземела эффект разорвавшейся бомбы, и многие говорили, нет, это же ужасно, никто теперь ничего не поймет. Как я буду понимать, что у меня за тип? Я же просто теперь умру, я не смогу просто читать этот Java-код, вот этот Kotlin, пожалуйста, оставьте хипстером, а нам, господам, позвольте писать полностью. Но я лично, конечно, полностью поддерживаю эту штуку, потому что, особенно если мы говорим о generic-тип, или особенно когда есть какие-то страшные типы, которые возникают из каких-то сторонних библиотек или просто они почему-то очень сложные, и это просто не помещается в одну строчку кода, приходится переносить просто потому что она очень длинная. Мне кажется, это очень классная штука, тем более, что она внедрена была очень так аккуратно, вы не всегда можете использовать var. На самом деле, как вы уже упомянуты, стримы без этого довольно неприятно использовать. Да, например, если вы хотите сохранить промежуточное состояние стрима, когда вы его не достроили куда-нибудь, то да, там будет какой-то ужас, там будет супер тип, ну там будет стрим, от чего-то, а скорее всего у вас там какие-то промежуточные типы, которые возникают, если вы там пары гоняете или тройки, то там начнется. Также есть еще такая библиотека JOOC, которая занимается тем, что билдит SQL запросы, вот, и у нее тоже очень много дженериков, и у нее очень длинные бывают дженерики, там 7 параметров типа, то есть там result set от, и она там говорит вам у вас там int, string, long, не знаю, что-нибудь еще, что-нибудь еще, вот, и смотреть на это, конечно, без крови в глазах нельзя. И как раз в 10 java появился интерфейс для сборщиков мусоров, и вот эта штука, которая на самом деле третий тип, да, мы говорили о языковых фичах, о платформенных фичах, и это скорее такие maintenance улучшения для непосредственно программистов, которые делают GDK. Для них это позволило в 11 java, например, написать с одной стороны шуточный сборщик мусора, который называется epsilon gc, с другой стороны он оказался очень многим полезен. Собственно epsilon gc это сборщик мусора, который не собирает мусор, который при заполнении памяти вам говорит все, конец, мы приехали, память кончилась. Что абсолютно офигенно для консольных утилит. Ну, то есть типа если тебе нужно что-то сделать, скорее всего, в константной памяти, или во всяком случае в том объеме памяти, в котором ты думаешь, что ты уложишься и как бы вперед, зачем вообще собирать мусор, тратить на это время? Ну да, кстати, о таком я даже не думал, если честно, но epsilon gc получил опять же особую любовь в среде программистов, которые пишут для трейдеров, которым приходилось раньше как-то настраивать свои сборщики мусора, чтобы они никогда не включались и чтобы у них не было никакого runtime overhead, теперь им этого делать не нужно, и просто включают epsilon gc и больше никогда элоцируют память до того предела, как, в принципе, возможно. В конце торгования перезагружают свою программу. Так что да, epsilon gc действительно прикольная штука. Если вы хотите просто понять, как работают сборщики мусора, вы можете посмотреть его код, он достаточно компактный. Также в 11 джайвер появилась крутая штука, которая кажется настолько очевидной, но не была в джаве, и это HTTP-клиент. Он появился изначально, по-моему, в девятке, как бета-фича, то есть там есть специальный режим, который сейчас вот с этими короткими релизами начали активно использовать, когда фичи включаются самим пользователям по ключикам, то есть предполагается, что эта фича еще не готова, и она может измениться, она может вообще удалиться, и вот такие фичи стали появляться, они обкатываются в реальной жизни, потом под обратной связи от разработчиков возможно какие-то изменения в будущем. Так вот появился HTTP-клиент, которым можно пользоваться, если раньше был HTTP URL Connection какой-то такой класс. Ну, в общем, чтобы сделать HTTP-запрос и забрать откуда ответ раньше, нужно было сделать очень много всяких телодвижений, поэтому никто никогда не использовал стандартную библиотеку, всегда все шли в зависимости, это либо там тот же, что вам предоставляет Spring, как скорее всего, если у вас есть Backend, у вас есть, скорее всего, есть Spring в обычном приложении, или OK HTTP, или еще что-то, или еще что-то. Вот теперь он появился, и это достаточно круто, опять же, можно писать программы без зависимости, и это очень удобно. Другая штука, которая появилась в 11 java, это выход в open source Flight Recorder. Я уже немного его затронул. Flight Recorder это такая часть GVM, которая была раньше только в Oracle GVM, которая позволяет получать диагностическую информацию, профилировать ваше приложение с очень низким overhead. В java всегда был интерфейс, который звучит как thread get all stack traces, по-моему. То есть там есть такой диагностический интерфейс через интерфейс GMX, который позволяет вам каким-то образом узнавать вещи о работающей виртуальной машине. И одним из таких является как раз thread get all stack traces. И профилировщики, которые работали, они вот вызывали этот метод очень много раз, и таким образом они очень сильно влияли на производительность. И Flight Recorder позволяет вам добавить сэмплирующий профайлер вашу виртуальную машину практически с нулевым overhead, его можно включать в Prod, вы можете постоянно профилировать, и только если у вас что-то тормознуло, вы приходите, забираете последнюю порцию данных, которая вам нужна, и анализируете ее. Потому что у него внутри есть встроенный ринг-буфер, который будет просто затирать старые данные, вы можете сказать, храни на диске 200 мегабайт, пожалуйста, не больше, и он будет просто удалять старые данные. И это был последний гвоздь в решетку Oracle JDK, теперь, по-моему, нет никакой разницы, вообще, по-моему, там просто нет проприетарного кода. То есть, возможно, он там есть, но не думаю, что он приносит что-то полезное. И вот как раз с реализацией GSC интерфейса первым сборщиком мусора, который появляется в основном репозитории Java, это ZGC, ну, кроме Epsilon, естественно. ZGC – это низкопаузный сборщик мусора от разработчиков из Oracle. Он позволяет вам получить паузы уровня меньше одной миллисекунды, ну, паузы, я говорю сейчас о stop the world паузах, когда GVM полностью останавливается. Может он, как они заявляют, дать вам возможность останавливаться меньше, чем на одну миллисекунду, грубо говоря, в 99% и для всяких специфических нагрузок, опять же, это очень важно, когда вы не можете остановиться хотя бы на 100 миллисекунд, потому что G1 как раз вам даст…",
    "result": {
      "query": "Java 11 generics HTTP client Flight Recorder"
    }
  }
]