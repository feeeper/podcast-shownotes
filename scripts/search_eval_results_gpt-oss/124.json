[
  {
    "segment_id": "17e0759c-2fa3-42cf-a8f6-cd112a442cc9",
    "episode_id": "6e66aeea-33f1-40cd-acda-d8adc4bfb4db",
    "episode_number": 124,
    "segment_number": 7,
    "text": "В общем, достаточно интересный парень. В общем, история началась с чего? С того, что в проект Request зарепортили багу, и бага звучало примерно так, что при запросе большого файла все становится медленным и процесс сожирается на 100%, ну как обычно звучат баги. На приближайшем рассмотрении оказалось, что все не так весело, и по сути там что было? Там из Request уходил запрос на некий SSL сервер за каким-то большим файлом, ну например, какой-то ISO, каким-то ISO образом. И потом этот файл учитывался чанками по 100 мегабайт, и так получилось, что при чанках 100 мегабайт процесс сожирается на 100%, а пропускная способность снижается до 1 мегабита в секунду, что вообще ни в какие ворота. При дальнейших экспериментах выяснилось, что при 10 мегабитах чанков, если чанка 10 мегабит, то производительность отлично, все работает хорошо, процессор не сжирается. Если больше 100, то начинает снижаться, а при 1 гигабайте производительность, пропускная способность уже 100 кб в секунду. То есть видна какая-то корреляция уже. Дальше они начали разбираться, и выяснилось, что при профилировании, что основная проблема в куске, где работает P OpenSSL, где выделяется буфер для P OpenSSL, передается туда через FFI питоновский, и там OpenSSL в этот буфер вычитывает данные какие-то. И оказалось, по сути, что в этом FFI, по умолчанию в этой функции, стоит, что нужно этот буфер, когда ты выделяешь для питона, и он зануляется. В итоге ребята отключили это поведение. Почему? Потому что им не нужно занулять этот буфер, так как они его передают в OpenSSL, OpenSSL его перезаписывает, возвращает размер записанного, и нам пофигу, какие там данные до этого лежали. И как бы все стало хорошо. На этом, казалось бы, история закончена, баг починен, но потом другой парень спросил, в чем вообще дело, почему память зануляется, что происходит. Потому что, ну, собственно, дальше Кори рассказывает о том, что такое локация и так далее, я не знаю, нужно ли об этом рассказать подробно. Локация памяти. Я думаю, нет, наши слушатели должны быть в курсе. Но там достаточно интересно, локации происходят различными функциями, типа malloc и так далее. malloc выделяет просто память затребованного размера и с мусором. То есть это память, которую уже когда-то использовалось этим же процессором. Есть еще одна функция, это calloc, это функция по сути такая же, но она выделяет память заданного размера для определенного количества объектов. То есть по сути это выделение идет для некого re. И эта функция, она как раз зануляет память. Но по сути в операционных системах, нормальных, у вас же память, процесс выделяется виртуально. Соответственно, когда запрашивается память на локацию, по сути она реально не выделяется, как физическая, а просто помечаются некие виртуальные странички, что она выделена. Это часто используется для мемори мэппинга на файлы и так далее. То есть по сути, как только вы обращаетесь к этой памяти, происходит пэйдж фолд, операционная система что-то делает, например, если это мемори мэппинг, то она файл в эту область читает. Но в случае, когда вы выделяете зиро, выделяете кусок памяти, который должен быть заполнен нулями, операционная система ссылается на некую область памяти, которая нулевая, и это передонли. Соответственно, как только вам нужно что-то туда записать, копион в райд срабатывает, и вы туда что-то будете записывать. И если вы выделяете гигабайт и так далее, то по сути у вас ничего не выделяется, это все очень быстро работает. Прям мгновенно. Но в данном случае, в данном конкретном примере, почему-то этого не происходило. В общем, он написал кусок кода, который, по сути, в цикле выделяет 100 мегабайтный кусок через этот сиалог, и тут же очищает его. И получилось, что под линуксом все работало, ну, как и должно быть. То есть, это все очень быстро отработало, потому что ничего не выделяется. Но под макоси оказалось, что работает все не так, как надо, и вот этот кусок кода, луп, он работал там порядка 8 с чем-то минут. Вот. Потом он этот корень начал профилировать, что же такое в этой макоси происходит. И оказалось, что макоси реально зануляет странички. То есть она берет и записывает в каждую страничку нули. Ну, понятно, через оптимизированные функции memset, но все равно это происходит очень долго. И она ест весь процессор на этом. Как бы это не самое ожидаемое поведение, поэтому корень полез в исходники. Извини, ревью. Я так вброшу и верну тебе слово. Если я правильно помню, сиалог, как и весь остальной юзерспейс, в макоси это FreeBSD. Поэтому мне сейчас очень интересно, каково поведение на FreeBSD. Ну, я не знаю, на то похоже ли оно на FreeBSD. Скорее всего оно уже было переписано компанией Apple. Суть в чем? В том, что в Apple код аллокации для больших кусков от 127 кб до 125 мб, там есть такая константа, а локатор пытается переиспользовать уже использованные до этого процессом страницы, чтобы не перезапрашивать их у операционной системы. Почему это сделано? Потому что запрос у операционной системы страничек новых, это по сути выход в контекст операционной системы, это overhead какой-то. Вот такая оптимизация. Соответственно проблема в том, что если вы в первый раз запросили и выделили этот буфер, который с нулями, и у вас этот буфер ссылается в виртуальную память, которая на самом деле не выделенная, и вы даже ничего не записали в этот буфер, так в следующий раз, как только вы запрашиваете еще раз такой же буфер, макось берет и записывает в этот буфер нули, несмотря на то, что этой памяти даже вообще еще нет. Вот. В общем, ребята нашли этот баг, это такая оптимизация, которая привела к такому багу для приводеления вот таких больших кусков. Они зарепортили этот баг, я не знаю насчет того, починили или не починили Apple этот баг, но этот баг он так хорошо показывает, что даже если разрабатываете софт на каком-то языке высокого уровня, вроде питона, то иногда в вашем софте могут быть такие проблемы, что вам нужно залезать в уровни ниже в код ядра, в код операционной системы и так далее, чтобы решить эти проблемы. Я вот специально открываю одну страничку, да, я писал об этом в 2011 году, что если вы, не важно на чем вы пишете, вам нужно знать, как работает что-то внизу и иногда в это воздаваться. Да. Хорошо, вопросы, дополнения. Коль скоро их нет, то я расскажу про, я думаю, уже страшный баян, но мне он очень доставил, поэтому я хочу рассказать. Называется Startup Simulator. Валер, расскажи мне, ты должен знать, насколько это реально баян, то есть больше года или меньше года? Я ни разу не слышал. Это очень интересная игра от Toggle.com, должно быть ты обращаешь известные компании, Валеру, да или нет? Нет. Совершенно неизвестные компании, но она очень клевая, она сделана как карточная игра, ну то есть ты играешь владельцем стартапа.",
    "result": {
      "query": "Python OpenSSL buffer zeroing issue"
    }
  }
]