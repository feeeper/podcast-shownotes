[
  {
    "segment_id": "e22fc03c-d433-4a87-80b2-6fa70906f2ca",
    "episode_id": "c3c274b6-f7cc-49fb-9d05-5946fcf6cde1",
    "episode_number": 35,
    "segment_number": 13,
    "text": "Ну, знаешь, проблема всех DSL'ей состоит в том, что они написаны именно разработчиками для той же команды, в которой это было, ну, именно для себя они пишутся. И только приходит какой-то новый человек в команду, ему нужно вникать вот в эти все детали этого DSL'я, и они совершенно неочевидны для него, совершенно непонятны. Ему, по сути, приходится изучать ещё один новый язык, поверх того, что он уже и так знает. Вместо того, чтобы брать то, что все знают, ты берёшь скалист, вот он знает скалу, ему нужно ещё изучать какой-то ваш свой DSL. И самое вообще замечательное в этой истории со всеми DSL'ями, что все округ кричат про эти DSL'и, говорят, ой, как это здорово, как это круто, но при этом большинство своём людей даже плохо понимают, как их нужно правильно проектировать. Они не читали книжку про, там, DSL'и того же Фаулера, они просто взяли и как-то написали что-то, какое-то своё поделие, а потом, вот, давайте будем с этим разбираться, давайте, ну, это же DSL, это же круто, это же здорово, и это вот в этом я вижу такую проблему. Мне кажется, ты переоцениваешь проблему, потому что я ни разу не сталкивался с тем, чтобы какое-то DSL было выучить сложнее, чем просто новый фреймворк. Абсолютно одинаково тебе, ты в первую очередь учишь вокабуляр и, как бы, грубо говоря, грамматику, то есть, что у тебя является в этом фреймворке или DSL-е существительным, а что глаголом. Всё. Ну, вот удивительное дело, когда читаешь просто библиотеку, чем обычный, ты вот чётко распределяешь, вот у тебя, тут у меня методы, тут у меня объекты, тут у меня какие-то кейс-классы, и как-то всё становится на своей полочке. А тут изобретается какая-то ещё новая структура поверх того, что и так можно было сделать с помощью библиотеки. Мы получаем, вот, что получаем. Ну, я не знаю, я когда читаю какой-то код, я не пытаюсь думать о том, что это метод или кейс-класс, я пытаюсь думать о том, что оно делает, с точки зрения ответа на этот вопрос, тебе неважно, оно там через пробел написано или через точку, и стоит там в скобочке или нет, тебе в любом случае нужно посмотреть на название какого-то глагола, посмотреть, что им передаётся в качестве аргументов, скорее всего, это существительный или другой глагол, и пойти посмотреть, что оно так и делает. В код или в документацию, и мне кажется, с этой точки зрения совершенно одинаково, что там, как бы, насколько там регулярный синтаксис, без разницы вообще. Ну, моё мнение касается, кстати, DSL, я пока не вижу каких-то особых преимуществ в них, я, ну, не знаю, всё, что можно сделать DSL, можно сделать и обычными библиотечными вызовами, и, ну да, оно делает код более там коротким, но, не знаю, тут сложный вопрос, потому что взять ту же АКУ, где вот есть ASK, есть TEL для актеров, ты можешь ASK заменить вопросом, а TEL заменить восклицательным знаком. Да, в принципе, это, наверное, более читаемо, хотя… Ну, знаешь, в смысле, всё определение супервизоров и само… Да, говори. Самоопределение актеров, оно гораздо больше похоже на какой-то DSL, на самом-то деле, потому что замена просто на какой-то оператор это классический приёмчик, который есть вообще много где, ну, их тоже искали использовать, например, в коррекциях стандартных, а вот как раз описание актера каким-то словами как-то периодически случается, это гораздо больше похоже на нелюбимый тобой DSL. Это, с одной стороны, а, во-вторых, такой ещё момент, иногда DSL, как бы чаще всего DSL оправдан, если у него модель вычисления, она оторвана от того, что у тебя есть в основном языке. То есть, если тебе нужен какой-то сайт-совер или, не знаю, какой-то бэктрекинг или что-то ещё такое, то есть фича, которая в твоём языке в самом себе не встречается, тебе нужно либо это в случае Haskell завернуть в специальную монадку, либо в случае языка с макросами завернуть в какой-нибудь макрос или что-нибудь ещё, и потом, то есть ты пишешь код, как будто бы это какой-то такой немножко другой язык, у которого немножко другая модель вычислений, и потом ты вот этот код, который написан на немножко другом языке, ты передаёшь его интерпретатору, который встроен в твою программу, и уже оно на самом деле его выполняет. То есть если модель вычислений другая, то это оправданно. Смотри, говоря о DSL-ех, ну какое вообще предназначение? Чтобы делать более простым код, чтобы он был более понятным, и возьмём один из первых DSL-ех, это SQL, типичный пример, который приводится, как правило. И для чего он вообще был нужен, сделан? Для того, чтобы мы могли дать этот SQL, чтобы у нас бизнес-аналитики его выучили, и смогли делать какие-то отчётики по нашим базам данных. Это вот предназначение этого DSL-а. То же самое для DSL-а, которое получается при разработке каких-то библиотек. И получается, что мы как бы делаем так, чтобы эта библиотека была как можно более простая, мол, производится такая аналогия между пользователями твоей библиотеки, и вот этими бизнес-аналитиками, которые не умеют программировать, но знают SQL. То же самое здесь программисты. Они не могут использовать твою библиотеку, зато знают этот твой DSL. А зачем это нужно? У нас же программисты, не бизнес-аналитики, они вполне адекватные, разумные люди, они в состоянии выучить и разобраться с библиотекой, зачем им давать какой-то такой, не знаю, какой-то, как бы тут выразиться, ненормальный, скажем, API, а какой-то DSL. По-моему, это называется птичий язык. Я не уверен, правда. Я, возможно, повторю то, что ты хотела сказать. Как мне кажется, библиотека должна решать задачу. И если у тебя есть даже, возьмем пример, клиент к ММКШ, у него там создается клиент с указанием сервера, и потом есть методы setGet. Но такая простая библиотечка, это уже DSL, и она решает какую-то задачу. Если ты хочешь еще как-то что-то нагрузить поверх этого, нужно понимать, для чего ты это делаешь. В случае со всякими ORM, обычно проблема решается в том, что ты абстрагируешься от конкретной базы данных, вот как с SQL, он абстрагирует тебя от представления данных на диске, от конкретной субботы. И, возможно, ты хочешь дополнительно type-чекать то, что ты обычно не type-чекаешь. И проблема со ScalaTest, про которую ты упоминал, в том, что он действительно своим DSL-ем особо ничего не решает, он ни от чего не абстрагирует, он ничего не type-чекает, наоборот, он такой вот, мы хотим писать should be not, прям буквками, потому что это классно. Но справедливости ради, в ScalaTest есть, по-моему, три или четыре DSL-а на выбор, ты можешь использовать точно так же, как в JUnity, и все будет хорошо. А мне вот интересно, что Надя обо всем этом думает. Надя тихонечко сидит и думает, что нужно все-таки почитать про Haskell, потрогать его и посмотреть, что вообще сейчас в мире происходит. Надя, ну ты же пишешь на Ruby, тут же модные хипстеры, пившись смузи, понаписали всяких, прости господи, разных DSL-ей, таких как rake, что там еще есть, капистраны, вот это все. Может, у вас кто-то из этого в проекте пользуется, может, у тебя есть какая-то личная боль. Что такое rake, расскажите, пожалуйста. Rake – это make для Rails, ну и в принципе для Ruby. Хорошо, спасибо. Да, ничего плохого в них не вижу. То же самое, по сути, как и ant для Java, например, так, maven и все остальное. Капистрана, да, у них была большая травма с переходом на новую версию, они никак вообще backwards, не compatible. Я недавно перетаскивал один проект, как раз-таки со второго на третий, капистрана, и это было жуть. Извини, вопрос спрошу, извини, что перебиваю, а какой-нибудь профит был от переезда? От переезда профит? Да. На самом деле стало все более организовано, скажем так. Код, по моим личным ощущениям, выглядит почище, скажем. Это не может быть архефактом того, что просто пока ты его перевозила, ты его просто местами переписала, это не может быть поэтому? Это тоже, но, не, на самом деле, в капистрана 2, по сути, в основном все решалось вызовом команды из консоли, которую ты запихиваешь в строчку, если тебе нужно какой-то специальный диплоймент, экшен какой-то выполнять специальный. Но в капистрана 3, например, они вынесли бандл туда, они вынесли скуп, то есть у себя оно меньше, есть такого, что может сломаться именно в самой командной строке. Получается, я не уверена, насколько они систему поддерживают, хотя они, в принципе, все примерно одинаковые. Но для меня стало более структурированным. С другой стороны, я должна признать, что я немножечко, видимо, просила где-то в понятии DSL, и как-то не относила их к DSL. Ну, насчет капистрана я согласен, потому что капистрана, ну, он так, то есть, да, его, по сути, он больше библиотека, хотя местами DSL, но Rake в чистом виде DSL, мне кажется. Ну, это да. Rake, да, окей. В принципе, в проектах оно используется, что там, базу мигрируешь чаще всего. А, нет, да-да, да. Аступа, кстати, много не использовала Rake, я бы сказала. Да, поскольку переход на OCQL убирает надобность мигрирования. Вот. Что сказать? Ну, поговорили про DSL и как раз затронули тему Haskell'а. И у нас есть тут статья по поводу ID для Haskell'а, который Саша нам принес. Я думаю, он нам хочет рассказать что-нибудь по этому поводу. Ну, да, я хочу рассказать, что это не статья, а Haskell Russian. Я туда некоторое время назад забрасывал на тему «Ребята, а в чем вы пишете на Haskell'е?» Потому что с тех пор, как я открыл для себя идею, мне очень трудно заставить себя писать что-то в Vim'е. Хотя, справедливости ради, я недавно писал тут небольшой девопсовский скрипт на Perl'е и писал его в Vim'е вполне успешно, пока он не разросся за 200 строк. Вот. И, ну, если вас интересует тема ID для Haskell'а, то вот, почитайте это обсуждение. Какие выводы я для себя сделал, что... Да. Я извиняюсь, немножко отвлекся. Что самые нормальные ID для Haskell'а на данный момент это Lexa, как ни странно. Она умеет не все, но очень многое. И на ней прям приятно писать. Она там типы VVS, показывает документацию по библиотекам в системе установленном и так далее. Далее. Про Eclipse я уже все рассказал. Что там все очень-очень плохо, как ни странно, в плане Haskell'а. Также Роман Чепляка написал в своем блоге небольшую статью по тему ID для Haskell'а. Он их несколько попробовал. Но сделал вывод, что писать в этом блоке не нужно. Если ты писал в Vim'е и был прав, надо дальше писать в Vim'е на Haskell'а. Также я попросил его рассказать, как у него настроен Vim для Haskell'а. Роман обещал подумать на эту тему. И меня очень удивило в обсуждении. В этом обсуждении в Haskell'е Russian пришел Сергей Зефиров и сказал... Сергей, да. И сказал, что пишет в Midnight Commander'е и не нуждается ни в каких ваших EDE, потому что код надо больше читать, чем писать. А когда ты его пишешь, его нужно писать очень просто, чтобы ты простым редактором мог все найти, запомнить, где что находится, чтобы все было настолько просто. И вообще идея такая, что EDE позволяет тебе создать сложность, а не как бы... Ну, она создает сложность, и потом позволяет ее терпеть. Когда тексту редактор не позволяет тебе этого терпеть, и поэтому, когда ты пишешь в Vim'е или в MC Edit, то у тебя все становится проще и понятнее. И мне кажется, это уже не первый раз, когда я слышу эту идею. Эта идея была озвучена Никитой Прокоповым. Она еще до него была. Это было не в русскоязычном стигменте. Я эту мысль в англоязычном интернете читал еще за долго до... Когда-то не было mainstream. Вероятно. Когда еще не оббивались музией, не обтыкывались планшетами. Но вы как вообще? Согласны с этим или нет? Мне кажется, что-то в этом и есть, но я где-то подвох. Я на 200% согласен, потому что вот когда я писал на Ирландии, я посматривал на ирландский плагин для EDE, но что-то как-то мне не особо... Прям чувствовала необходимость. А вот я... Вот этот проект на Scala, паравечерний, который я писал, ну невозможно вообще в ВВЕ писать на Scala. Просто... Да, просто вообще ты руки сломаешь, нужна поддержка. Не согласен. Я писал, не сломал. Ну в смысле? Нужно как-то все время на типы смотреть, нужно документацию полить, нужно создавать эти иерархии каталогов, которые мне дает. На Haskell по-твоему как пишут? На Haskell там гораздо проще на типы смотреть. Я вот на Haskell, Vim я успешно писал в EDE, но если со Scala не осилил.",
    "result": {
      "query": "dsl learning curve issues"
    }
  }
]