[
  {
    "segment_id": "357c6011-0a53-4d2f-98c3-78829b541743",
    "episode_id": "736c0b0f-9d3a-436d-b30d-41a765c825eb",
    "episode_number": 5,
    "segment_number": 3,
    "text": "Ну да, там есть ограничения. Ну вот. Еще одна хорошая новость. Вы слышали про такую компанию, называется Xamarin. Нет, слышал. X-A-M-A-R-I-N, Xamarin. На OpenNet была новость про то, что они получили кучу бабла, 54 миллиона долларов инвестиций. У компании, у них интересный бизнес, они делают фреймворк для программирования под мобилки с использованием языка программирования C-Sharp. При этом ты, ну, якобы один раз используешь этот фреймворк и можешь скомпилировать свою приложенку в нативный код под Windows, iOS, Android. Вот. Идея интересная, но я общался с мобильными разработчиками и краткий ответ, что там все не так здорово. То, что оно и повисает, и глючит, и так далее, и тому подобное. То есть, сама идея, она хорошая, но на практике оно все не так здорово, и люди часто предпочитают нативные решения. Ты знаешь, я тоже общалась с людьми, которые используют Xamarin, я не скажу, что они недовольны. Используют, и вроде как неплохо получается. Ты понимаешь, это всегда такой вопрос компромисса. То есть, вот тут шел нота, я прилеплю ссылку на картинку, там на тему нативные решения против вот таких фреймворков типа Xamarin. То, что нативные решения это такой долгий-долгий лабиринт, в конце которого тебя ждет такой большой красивый замок. А вот такие фреймворки это прямая дорога, но к такой полуразвалившейся хижине. Ну, в принципе, да. Для таких фреймворков, если они будут использовать, скажем, они будут выбирать все общее между всеми платформами. И оно будет работать одинаково плохо везде. Ну, как напишешь. Но в принципе, все-таки для нативных решений не будет быстрее и лучше. Когда мы говорим о мобильных приложениях, то нам нужно красивые приложения. У Xamarin, у них еще что интересно, они не только фреймворк делают, у них есть платформа для тестирования мобильных приложений. Вот буквально сегодня в Твиттере проходила картинка, я ее ретвитил, но сейчас уже вряд ли найду. Там на тему, сколько всего бывает вариаций разрешения экрана под Android. Там их тысяча. И что предлагает Xamarin, это платформа, на которой у тебя есть много реальных устройств. И предлагается автоматически твое приложение установить на эти устройства, прогнать твои автоматические тесты. Уж не знаю, как они пишутся. И в случае, если какой-то тест фейлится, то тебе высылается отчет, что вот на таком-то телефоне с такими-то параметрами вот такой-то тест не прошел, вот тебе скриншот. Вообще эта идея лежала на поверхности. Мне непонятно, почему ее 5 лет назад не сделали. 5 лет назад, это типа в 2009. Ну да. То есть когда стартует большая крупная контора, у которой есть необходимость в этой штуке, мне кажется, давно надо было это все написать. Ты имеешь в виду протесты, да? Да-да-да. Ну а как начать? Просто 5 лет назад, наверное, не было такого разделения на разные экраны. Да ладно. Да ладно, не было тогда еще. Всегда это было. В момент старта Андроида там уже было больше девайсов, чем у всех айфонов вместе взятых. Насколько я видел, я сам не участвовал, но видел с той стороны, на практике оно немножко проще. То есть ты собираешь статистику по тем же логам, что у тебя 50% пользователей твоего... Правда, в данном случае речь была о сайте. Ну, я думаю, к приложениям это тоже применимо, что у тебя такой-то процент пользователей использует айфон, не знаю, четвертой версии, такой-то процент сидит под Galaxy S, какой-то последний. И, в общем, ты берешь наиболее популярные мобилки, не знаю, так, чтобы покрыть процентов 90, например, твоих пользователей. В достаточно крупной компании их не трудно купить, и ты реально сидишь там, все прокликиваешь на них. Ты представляешь, какой большой парк? Ну, в смысле, нет, ну подожди, у тебя сидят те же 2 QA, просто перед ними там десяток мобилок, и они там тестируют. Несчастные люди. Ужас. А как же автоматические тесты? Современная цивилизация достижения никак, да? Ты же понимаешь, что никакой глупый бездушный робот никогда не заменит настоящего живого человека с душой. Ну, это как, с душой особенно. Мне вот интересно по поводу Oxymarin. Ну, то есть, если он на C-Sharp, для Дот-нета понятно, а для того же Android получается он в байт-код для Dalvik в итоге комперируется? Либо как это происходит? Что он кроссплатформенный получается? Ну, я ни разу не мобильный разработчик, и я так понимаю, никто из нас не раз... То есть, мне просто стало интересно, я задумалась, а для того же iOS там тоже какой-то байт-код, либо что-то другое? Для Android, я знаю, можно писать на C++, не знаю, можно ли писать целое приложение исключительно на C++. Подозреваю, что можно. Давайте не будем гадать, а то нас заклюет пользователь. Если кто-то знает, пожалуйста, расскажите, мне интересно. Да, расскажите, кто занимается мобильной разработкой, что такое нативное мобильное приложение под Android. Если в нем... Можно ли написать под Android вообще без дешавы? И Oxymarin. Нет, в частности вопрос следующий. Каким образом Oxymarin реализует крусподформенность? Вот. А что еще реализует крусподформенность? Ну прям, сегодня подкаст плавных переходов. Это универсальный переход, всегда так можно. Надо принять на вооружение. Но мне не получается это сделать так. У меня так тоже не выходит, это ты у нас один специалист. В общем, вышел новый стандарт C++ 14. Точнее, он уже стал готов и выйдет в ближайшее время, если вот сейчас не выходит. Прошло голосование, прошло... Среди группы, как называется группа-то, я забыл. И в общем они решили, что да, пора выпускать 14. В целом, плюсы сейчас будут получать достаточно регулярно новую версию, новый стандарт, потому что они поняли, что вот эти вот десятилетние стандарты, на которые все никак не могут перейти, это неправильное решение и надо как-то более быстро двигаться. Получилось там много новых ситч, и все плюсники радуются, я надеюсь. Мне кажется, что все плюсники, они все еще сидят там на... На старых версиях. Да, да, да, там 80-го лохматого года, я не помню какого. И вряд ли там будут на что-то переходить в ближайшее будущее, потому что поверх этого всего понаписано там самопальных фрейлорков. Я думаю, что вот вокруг меня мало кто использует настоящие плюсы даже 11-го года, не то что 14-го там в бете, я не знаю. Потому что большинство людей, которые пишут какие-то крупные платформы, больше используют как это, C с классами, чем настоящие вот глубокие возможности C++. Ну и в принципе, куда эволюционирует C++? Мне кажется, он превращается в какого-то монстра. Это что, он превращается в Haskell? Вот ты послушай все основные фичи, которые добавили. Function return type deduction, alternate type deduction on declaration и так далее, и тому подобное. То есть везде вычисление типов, везде вот это вот... Ну короче, в Haskell он превратится в тип. Автоматический вывод типов, то есть он уже давно есть с 11 года, это то, чего даже в Java нет. Частичный автоматический вывод типа, я почитала про это статьи, там не все работает так, как хотим. Конечно. С некоторыми ограничениями. До настоящего Haskell. Ну получилось что, они добавили ключевое слово авто, это наподобие такого... Нет, авто уже был. Авто уже был давно. Нет, они добавили именно как вывод, как тип по сути авто. Он был, он был. Они просто добавили возможность дополнительного... Я уже давно на C++ не смотрела, но собственно по сути это у меня очень было похоже на то, как в Java есть. Object, самый верхний класс, тоже самое и там. Вот ты делаешь тип возвращаемый авто, и тебе оно все автоматически конвертируется, как они говорят выводится. Ну вот на что-то было похоже, когда я читала. А еще интересно было про лямбды. У них лямбды обозначаются двумя скобками квадратными. А вообще с лямбдами там отдельная история. Это какая-то странная идея, как-то вот вообще, почему они так решили, почему не дать какое-то название этому, ну блин. Сделано для сохранения обратной совместимости и для не введения новых ключевых скоб, потому что если у тебя есть int лямбда, а ты такая классная в стандарте C14 решила там сделать ключевое слово лямбда, то у тебя все, программа не соберется. А кстати в 14 версии добавили generic лямбдес. Ну вот прям, ну полпути к хаскеле уже сделано. Только зачем, если можно взять хаскель? Ну так же. А еще они добавили это, optional. Такая штука, которая может быть либо нам, либо каким-то объектам. Тоже очень знакомо. Зачем мочить язык, усложнять его, там какими-то стандартами работать? Ну то есть, хочешь хаскель, ну возьми хаскель, напиши, прилинкуй его даже в C++, он замечательно к нему линкуется и туда и обратно. Ну или возьми язык D. А что с ним? А с ним тоже вышла какая-то новая версия 2.0.66. Надо же, и что там интересного? Если честно, я не очень сильно слежу за языком D. И мне вот интересно, слушатели, кто-нибудь вообще его использует или не использует. На работе. А вообще этот язык, скажем, характеризует функциональный объект, ориентированный, куда он относится. Типизация строгая, не строгая. Говори, Саша, я думаю ты больше. Ну я сам не то чтобы много писал, но я там знакомился с книжкой. Это C++, прилизанный, очень такой хорошо вылизанный, то есть нормальный, в хорошем смысле C++, с автоматической сборкой мусора. По-моему, с легковесными тредами даже. И единственное, в чем они запороли идею, то что ты на нем еще можешь делать всякие низковыровневые вещи, там типа чуть ли не на ассемблере писать. Это прямо в самом D все есть. Но при этом есть подмножество D, называется SaveD. Это такая, по сути, правильная компилируемая Java. Слушай, а мне кажется что-то на Go похоже, нет? Go это не язык. Я не могу воспринимать как язык что-то, я извиняюсь, переслушайте за меня, где нет нормальных контейнеров. Понимаешь, да? А в D это все есть. Это из C++ берет. Из STD, да? Ну нет. Или свой написали? Нет, вот представь себе, что ты делаешь с самого начала с нуля C++, решаешь сделать его со сборкой мусора и без всяких ужасов, ошибок при компиляции шаблонов и так далее. Или представь себе, что ты взяла Java, где дженерики с самого начала правильные, и решил сделать ее копилируемой. Вот это примерно ты получишь представление о D. Ну в принципе в Java есть Just-in-Time компиляция. Ну так она Just-in-Time, а тут она AOT. Ну, согласна, да. Прямо сегодня день троллинга, слушайте. Давайте перейдем к следующей теме. Так, следующая тема. К слову о троллинге. В прошлый выпуск мы говорили про анализаторы кода, и я вспомнила интересную статью, тема которая вообще мне очень интересует. Это Bug Prediction Tools. И когда я была в Штатах, в прошлый раз на конференции, был деклад, как раз-таки про это и рассказывались. Рассказывали идею про то, каким образом помогают Bug Prediction Tools в разработке. И нашла статью гугловую на эту тему.",
    "result": {
      "query": "Xamarin cross‑platform mobile development pros cons"
    }
  }
]