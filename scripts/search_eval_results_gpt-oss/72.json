[
  {
    "segment_id": "f785f88b-3fbf-4067-95c8-9998b4388e00",
    "episode_id": "771dbc75-7472-431d-acf2-2c2ffb3101d5",
    "episode_number": 72,
    "segment_number": 5,
    "text": "Большая-большая простыня JSON. Угадай откуда. Ну там тестовые данные, например, которые большая простыня JSON. Я бы программу написал, если честно. Ну может быть, но мне в Vim это было офигенно удобно. Вим с этим даже не поперхивает, если это делают. Или другой вариант, когда ты берешь DataDump с продакшена, с баз данных, ты хочешь его заимпортировать в свой CI-инваридент, чтобы там примерно такую же нагрузку иметь. Но ты там некоторые вещи не хочешь, чтобы они с продакшена уходили, ты берешь быстренько в Vim парой команд убираешь, и без никакого написания программы ты просто своим текстом в Vim сделаешь то, что тебе нужно. С Adam. Ну с Adam тоже можно было бы, наверное, но с Adam нужно было бы как-то более умно это делать, а тут я совсем в лоб стел. И мне главное было видно все, что я делаю, что с Adam еще можно промахнуться, так сказать. Ну ок. Дальше слушатель Azazeo предлагает Свете посмотреть на Fsharp, такой Haskell-слэшл-камэл для DotNet-платформы. Я думаю, Света будет слушать этот выпуск и она обязательно посмотрит. На самом деле есть очень интересная особа, которую мы может быть даже когда-нибудь позовем. Вот. Я слышал, там есть проблемы с часовыми поясами. Ну да, да. Ну в общем, мы постараемся позвать какого-нибудь Fsharper'а. Вот. Как-нибудь. На самом деле нам было бы интересно послушать про это. Слушатель Amrien предлагает полить немного грязи на Oxamarin, но собственно я думаю, я знаю специального человека, которого тоже надо позвать. Так что это наверное будет отдельный выпуск. Посвященный поливанию грязи на Oxamarin. Как выбрать язык программирования, спрашивает слушатель Sadian. Я смотрел ту статейку. Это она не... А, это Mail.ru, я слышал, есть такая же от Яндекса, по-моему. В общем, какая-то команда внутри Mail.ru написала статью, как они выбрали Go. Вот. То есть, они его сравнивали с... Они решили что-то там новое писать. И, соответственно, писать они решили какие-то сервисы. Соответственно, у них были в кандидатах Go, Scala, Rust и... И кто-то еще. И Noda. И получается, что они решили все это посравнивать. Их интересовало не сколько из серии, какой язык хороший, какой язык плохой. А из серии, сколько он держит запросов в секунду. И количество пакетов и всякое такое прочее. Стабильно занимал какие-то первые места. Интересный момент, который мне показался действительно любопытным, это то, что когда они посадили свой сервис, пустые сервисы за Nginx, то разрыв между платформами очень-очень сильно сократился. И, откровенно говоря, в этот момент стало понятно, что в общем-то особого смысла выбирать между ними по бенчмаркам Hello World нет. То есть, там разрыв был такой, в серии даже не на порядок, а так, в серии, 2 в 3-4 раза. То есть, ну, такой. Ты знаешь, если я правильно читаю этот их бенчмарк, у них раст по скорости слива вообще всем языкам, включая пей. Там, мне кажется, наоборот, там average latency. Это latency все-таки? Да. То есть, вот на месте, в котором они пишут, что там какие-то... Да. Ну, в общем, как его зовут? В общем, статейка хорошая, но на самом деле ситуация какая? Команда захотела выбрать Go и решила написать какую-то штуку для того, чтобы объяснить, почему они выбрали Go. Молодцы. И что? То есть, язык обычно выбирают именно из предпочтений, а потом сами себе доказывают, что они сделали правильный выбор. Это всегда так происходит. Очень редко выбирают, потому что нужда заставила. Обычно уже система есть какая-то готовая, и вот по готовой системе начинают уже смотреть, что же делать, если у нас там кто-то где-то тормозит. Окей. А, правда, Саш, постскаут вообще это графики размера комьюнити. Да, это... Замечательные, кстати, графики по размеру комьюнити, они там, например, меряют количество людей, у которых есть резюме на сайте Хахау, где у них указана та или иная технология. Там нашлось там 40 с чем-то, по-моему, программистов на Rust. Простите. Да. Или меряют количество пакетов, например, сравнивают спокойненько цифры с репозиториями. У Визуков, где есть репозитория, там, допустим, для Scala есть Marvin, для Nanda есть NPM и все такое прочее, но для Go они используют GodDoc. GodDoc это такая штука, которая по всем открытым площадкам, типа Bitbucket и GitHub автоматом генерируют документацию по проектам на Go. Но получается так, что если я фокну какой-нибудь проект на Go, то GodDoc для моего Focka тоже сгенерит документацию, поэтому когда считаешь количество пакетов на Go, то и Focka тоже считаются, поэтому непонятно, как можно таким образом считать количество пакетов всего. Следующую тему снова добавил Cdn, Rapidoid, Web Framework на Java без фигни, скажем так. Я так понял, это реальный Web Framework с лямбдами и красивым DSL, прям почти няшно выглядит, но круто, кому-нибудь есть что сказать? Следующую тему добавил слушатель Airat Shigapov, я извиняюсь, если произношу неправильно. Некий security researcher получил доступ к ключам Амазона и не только, к ключам от Амазона к Инстаграму. В ответ Facebook стал звонить с угрозами его роботодазеля. Скандалы, интриги, расследования. Кто ознакомился? Я не стал, это стандартная история, очень часто большие компании таким образом реагируют. Кто-то кого-то недопонял, кто-то с кем-то недоговорился, и появляется большая истеричная пастыня текстов. Понятно. Остальные темы нахожу не очень интересными и набравшими большое количество голосов. Возражения? Нету. Очень хорошо. Следующую тему добавил Андрей. Да, есть статья на Medium, которая называется 12 Fractured Apps. По мотивам такого известного набора правил, который называется 12 Fractured Apps, на тему как строить современные сервисы. 12 Fractured Apps написал где-то в 2012 году Адам Виггинс, который создатель Heroku. И соответственно его принципы, они на самом деле описывают то, как хороший сервис должен себя вести, чтобы его на пауз подобной Heroku легко можно было загружать. Соответственно, товарищ в этой новой статье, которая называется 12 Fractured Apps, говорит, что все решили писать такие маленькие сервисы и все такое прочее, а на деле не все так просто. И получается, что с ними есть определенные косяки. Например, если там приложение при запуске начинает коннектиться к базе, а база еще не поднята, потому что база в отдельном контейнере где-то там на другом сервере или еще где-то, то наше приложение, люди часто пишут приложение таким образом, что просто либо падает, либо висит в непонятном состоянии. То же самое касается, например, каких-то конфигураций, что можно что-то прочитать, а ключика нигде нет, и поэтому приложение падает. И вот он пишет из серии не надо делать таким образом, а делайте попроще из серии. Он рассказывает в начале, как люди пытаются эти проблемы решать, что начинают выносить больше в какую-то конфигурацию, в Enquistation Layer, то есть из серии, допустим, в начале писать скрипты для развертывания, что в начале у нас поднимались контейнеры с базой, а уже потом контейнеры с приложением, что в момент, когда они поднялись, база уже была поднята и все такое прочее. Говорит, что это все сложно, получаются большие какие-то навороченные вот эти скрипты на Ants или еще на чем-то, и что оно того не стоит. Лучше гораздо проще внутри своего проложения просто там сделать каком-нибудь Exponential Retry для того, чтобы проверять в ActionBase или там использовать дефолтовые параметры для того, чтобы читать конфигурацию, то есть если какого-то ключа нет, использовать значение по умолчанию, и что вот таким вот образом мы здорово можем упростить себе жизнь в эпоху Docker, Kubernetes и всего такого прочего. На самом деле тут есть очень интересный момент. Это не просто упрощает развертывание. На самом деле, если ваше приложение считает, что база должна быть, то у этого есть такое неприятное последствие. Если база данных ложится во время работы вашего приложения, и ваше приложение ложится вместе с ней, то возможно это не так. Нет, рано. Да, чуть-чуть рано. Ну то есть, во-первых, потому что я тут недавно, ну как некоторые возможно уже слышали, я пересел на Ruby и кульхужит его на рельсу. На самом деле, та самая рельса, она была довольно сильно под нас кастомизирована, и мы там до поры до времени использовали, в качестве базы использовали только React с Redis. А потом в какой-то момент нам понадобилась реляционная штука, потому что именно что реляционная была нужна. И я впервые для себя в жизни увидел ActiveRecord. Именно вот в таком виде, в какой-то он в Ruby. На самом деле, так понимаю, вообще любой ActiveRecord себя так ведет. Оставив в стороне проблемы ActiveRecord как подхода в целом, то конкретно Ruby ActiveRecord он считает, что если коннекшена к базе нет, то ваше приложение работать не должно. Ну то есть, как же, в базе же нет, что же еще приложению-то делать, кроме как в базу ходить. И знаешь, ну вот, наверное, юзкейс, для которого рельсы изначально делали, наверное, это может быть даже правда. Но дело в том, что многие приложения давно немного не так устроены. И что они часто имеют 2, 3, 4, 5 баз данных. И там база лежит, ну сходим в кэшик, база лежит, покажем красивую страничку с тем, что база прилегла. Или там обслужим как можем. И вот сам факт того, что вы умеете обслужить прилегшую базу, вместо того, чтобы лечь всему приложению целиком, это на самом деле хороший показатель того, что вы можете плавно деградировать, вместо того, чтобы просто уйти в небытие. При малейшей проблеме операционной стороне. Согласен. Кстати, я еще забыл сказать, что статью ты написал сом KC Fightower, это такой известный чувак изначально из CoreOS, по-моему, он то ли сетио был, то ли еще кто-то, а сейчас он в гугле и рулит проектом кубернетов. Ну вообще, мне статья показалась рекламой докера. Вот так вот, если на скидку. А вот кстати, посмотрите-ка, вот здесь докер классно решит. И вот здесь докер классно решит. И вообще, вот здесь вообще докер супер. Ну да. И даже если докера не использовать, все равно как-то советы более-менее такие нормальные. Если докера не использовать, тогда статья бесполезна, читайте оригинал 12 правил. Дак нет, нет. Там же идея-то в том, что как это, Twelfactor если ему слепо следовать, то как раз можно налететь на правильную, то есть, грубо говоря, рубио приложение, оно прекрасно вполне себе twelfactored, может быть. Тебе twelfactored application, насколько я помню, я могу ошибаться. Даже gem есть в алле. Если ты делаешь gem install twelfactor, и оно стало twelfactor. То есть вот настолько. По-моему, оно совершенно не требует того, что умение переживать падение базы данных. То есть, может быть, это... Ну нет там такого как-то пункта, что, мол, вы обязаны уметь переживать падение базы данных. Вы обязаны уметь переживать то, что ваше приложение выключили, подняли в другом месте. Это обязаны. Я предлагаю дать гостю последнее слово и последнюю тему. Вот выбирай одну из двух. Одну из двух? Ну, на самом деле, смотри. У меня как бы есть плаг, который я просто говорю из серии «Сходите по ссылочке, вбейте ответ». Поэтому я сделаю хитро. Я скажу про обе. Давай, жги. Во-первых, мы думаем сделать клевую джез-комфу в Киеве весной, и поэтому мы спрашиваем в опросе серии «Кого вы хотите увидеть?», потому что мы не знаем, кого именно мы хотим пригласить. И там просто статья, формочка-опросник на тему «Чуваки, скажите, кого вы хотите встретить у нас?». А вторая статья такая от какого-то там hiring agency, которая опросили фаундеров и руководителей менеджеров компании, в которые в свое время вкладывался Y-комбинатор. То есть это не просто там маленькие стартапчики, но и крупные компании, которые когда-то были маленькими стартапчиками. На тему «Каких вы хотите разработчиков у нас увидеть?». И там интересная выборка в плане того, что они им позадавали какие-то вопросы, и в результате у них есть такая табличка на тему серии «Какая направленность разработчика?» и «Какие компании его хотят?», без указания компаний. Интересных моментов два. Первое – это то, что нет такого единого критерия, что если у разработчика есть опыт допустим того-то, то значит его везде хотят. И второй момент, что всем интересно, почти всем интересно, что у него есть продуктовый опыт и заряд на то, чтобы делать клевые продукты, решать бизнес и всякое такое, но при этом никто не хочет enterprise разработчиков и никто не хочет разработчиков, так как у них написано «academic background», то есть людей, которые занимаются какими-то исследованиями. Что на фоне общего интереса к AI очень-очень странно звучит. А еще они написали из серии, что если у человека есть опыт Java, то для многих компаний это прям вообще красный флаг, и они просто человека не смотрят. То есть вот я, например, смотрю на свое резюме, у меня есть опыт Java, но при этом есть опыт продуктовой разработки, я понимаю, что я вот такой непонятный разработчик, поэтому...",
    "result": {
      "query": "JSON editing in Vim large dataset"
    }
  }
]