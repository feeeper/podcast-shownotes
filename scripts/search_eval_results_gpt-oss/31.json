[
  {
    "segment_id": "3a710b81-b3ef-4de0-8d5f-aef759e45970",
    "episode_id": "aaa1493c-6a08-4945-a9d0-cc6d5b54e564",
    "episode_number": 31,
    "segment_number": 2,
    "text": "По поводу схем лес и схемы, тут странности. Это старый добрый конфликт, кафедрал Уэдболар. И я сталкивался с тем, когда есть в организации общие репозитории этих самых IDL-ек, как они в GRPC, как они в Corby, как в Protobuf. У каждого отдела есть какой-то набор своих схем, они все эти свои схемы коммитит в этот один общий репозиторий. После этого все остальные отделы перекомпилируются со свежей версией, у всех все разваливается. Есть вот один такой вариант, я его наблюдал. Было весело. Другой вариант, когда у всех все без схемы, у всех какие-то недокументированные JSON-API, когда ты так по ходу разбираешься, что значит то или иное поле, ну как-то и так плохо, и так плохо. Но есть же промежуточный вариант, как он называется, свагер, который тебе генерирует документацию к твоему ресту. А генерированная документация из чего генерируется? Из исходников? А в исходниках комментарии написано, а комментарии там адекватные, ну вот оно все туда и выпирается. Ну оно не совсем из исходников, из комментариев. Там пишутся кое-где комментарии, а кое-где навешиваются нужные аннотации, и оно прямо берет твой объект и генерирует из него JSON. Так что это более похоже на правду. Нет, это имеется в виду автоматическое преобразование Java объектов в JSON или что-то иное? Ну, я про Java не скажу, я скажу про Scala. И в Scala, возможно, ты описываешь свои реквесты, респонсы в виде кейс-классов, говоришь, что вот это у меня будет объект-реквест, это будет объект-респонс, и тебе Swagger сгенерирует JSON по этому объекту. Ну, Jackson в Java то же самое делает, ему можно как-то подкрасть еще аннотациями, поля, например, переименовать как-то. Ну, то есть поле, которое в Java называется edoc, в JSON будет называться так. Ну, то есть, в принципе, возможно сгенерировать документацию? Ну, тут же не совсем, я не совсем понимаю, говорим ли мы о документации или об автоматическом преобразовании объектов из одного формата в другой. То есть у нас есть объект в памяти, родной Java объект или родной Scala объект, мы там вызываем какую-то функцию библиотечки, мы получаем строку, в которой лежит JSON, соответствующий этому объекту, в котором поля там уложены, соответствующие поля там преобразованы в строчки. Это как бы один вариант. Другой вариант, это когда нам надо именно описание сервиса каким-то образом сгенерировать, что вот этот сервис отвечает на запросы вот по таким-то урлам, что вот в эту туру надо кидать объект такого-то формата, а в ответ получится объект такого формата или ошибка вот такого формата. Это немножко две разные вещи. Та вещь, которая описание урлов с тем, какого формата объекты туда кидаются, это во времена SOAP это был VSDL, какой-то язык такое описания. То есть там, я помню, какие-то там средства для создания вот этих вот SOAP endpoint, они позволяли там на отдельном порту поднять сервис, который кидается именно описанием сервиса. То есть ты хочешь каким-то сервисом воспользоваться, ты ему там на параллельный порт стучишься и получишь XML, в который перечислены все endpoint в этом сервисе и все описания классов, с которыми можно туда посылать и получать ответы. Ну, просто мне кажется, что вот этот вот протобаф и вот эти схемы, это некоторое переосмысление SOAP и, скажем, просто то же самое, но под другим углом. Ну и при этом ждёт меньше гораздо трафика, например, как минимум. Да. Ну, корба тоже, кстати, компактно укладывалась, как бы серилизованная корба, она достаточно хорошо в такие бинарные форматы укладывалась, и XML неплохо газипуется. Кстати, по поводу вот Rift'а я вспомнила, насколько я знаю, там не просто идёт возможность, вот у нас есть схема сообщения, мы сгенерировали по нему модель нашу данных, но там ещё есть какие-то заглушки типа сервисов, так ли это, Саша? Да, есть сервисы. То есть, а что это собой представляет? То есть ты генерируешь не только модель, но ещё и сервис, либо это в каком-то ином виде? Мы это очень быстро выпилили. А почему? Честно говоря, не помню. Просто это был, знаешь, таким одним из преимуществ Rift'а, а я отслышала от людей, и мне хотелось узнать, так ли это. Но я не скажу, насколько это преимущество, прям, и я не помню, с чем там были проблемы, там были какие-то проблемы, это я помню. Чего-то оно то ли как-то падало неудачно, то ли было блокирующим, я не помню. И в любом случае, по крайней мере, то, что мы использовали, это был тупо запрос-ответ. А иногда тебе нужна труба, в которую просто без запроса что-то сыпется. Это стриминг называется, и это как отдельная фича у многих таких библиотек прописывается. Кстати, у Protobuf тоже есть понятие сервис, оно по крайней мере определено в стандарте, но очень многие реализации Protobuf этот сервис не реализуют. Просто потому, что никому это обычно нахрен не нужно, все по своему себе реализуют. Ну, либо он автоматически сгенерированный сервис, получается такой страшненький, что прочитав его исходники хочется сразу его выкинуть и написать по-нормальному. Ведь обычно не рассчитано на то, что ты их не будешь писать. Ой, читать. Я, кстати, могу сказать, в чем проблема с этими сервисами, которые из коробки прям готовые, с тем, что их не очень просто отлаживать. Если ты гоняешь, ну, не важно, трифты, протобуф, все что угодно, но используешь их тупо как для сервизации, то ты в своей реализации сервиса, там, вебсокет, у тебя, http, не важно, ты можешь писать какие-то логи, что пришел запрос такой-то, пришел ответ такой-то, ну, послали ответ такой-то. А если у тебя готовый сервис, который просто нагенерен, то там не всегда такое есть. Ну, зависит от того, вкрутили ли создатели этого сервиса возможность туда-таки вкрутить, ну, ручки просунуть. Ну, а понятно, в бинарном виде это утомительно. А что собой представляют эти сервисы? Это прямо REST тебе дается, либо какая-то другая оболочка? Ну, тебе там условно генерится класс сервис, у которого там, я правда не помню, это уже было больше нескольких месяцев назад, как это было, то ли у тебя какой-то хендлер, он реквест, нужно реализовать самому, то ли, ну, то есть клиент, понятно, как сделан, ты пишешь IP порт сервера и там делаешь, послать тот, сделать тот. А на серверной стороне я не помню, как это реализовывалось. Ну, то есть, может быть, возможно в этих хендлеры дописать свою логику, в том числе и логирование? А, может быть. Нет, тут как бы вопрос в том, что тебе придется в каждую отдельную функцию писать отдельное логирование, а не так, что мне просто вызвали endpoint такой-то с объектом таким-то. Ну, хорошо. Антон, а ты хотел что-то про HTTP добавить? А, у меня недавно в твиттер-ленте проскочило, что и SPDY, и HTTP2, это всё из-за того, что люди не смогли понять, освоить как-то Stream Control Transmission Protocol. Достаточно интересная вещь, в которой основные фичи, из-за которых продают SPDY и HTTP2, то, что можно в одном потоке одновременно несколько подпотоков передавать, то, что можно с сервера какой-то push делать, которого клиент не попросил. Поправь меня, я правильно, я не ошибаюсь, говоря, что это такой UDP с гарантией доставки? Я что-то такое когда-то слышал, видел, но уже забыл. Нет, это не MUTP, ты, скорее всего, говоришь про MUTP, а речь идёт о STCP, ты, может быть, даже помнишь перлангутку, модуль STCP? Только здесь это SCTP, так и что с ним? Ну, я думаю, слово обратно Антону. С ним то, что вот эти основные фичи, которыми продают SPDY и продают HTTP2, там были реализованы давно. Одна только незадача, насколько я понимаю, он в Windows не реализован по умолчанию, он есть в Linux, в FreeBSD и во многих остальных платформах, но в Windows его нету. По какой-то причине. И, в принципе, многие протоколы делают что-то похожее. И если вот там посмотреть в разные бинарные вещи, вот был в своё время такой, но он до сих пор есть, протокол для Flash видеостриминга RTMP. Там тоже, по сути, открывалось TCP соединение, а внутри него передавались специального вида бинарного фрейма, у фреймов были идентификаторы как бы каналов внутри этого TCP соединения, что позволяло одновременно по одному каналу посылать аудио, по другому каналу посылать видео, а по третьему каналу делать какое-то РПЦ. И в этом РПЦ и сервер мог вызвать клиента, и клиент мог вызвать сервера. Такая вот штука. Если посмотреть на бинарный протокол Cassandra, который SQL сейчас, там тоже внутри TCP завёрнуты фреймы, и в этих фреймах есть идентификатор, я не помню, как там это называется, тоже что-то вроде канала, когда ты внутри одного TCP соединения можешь одновременно несколько диалогов поддерживать. А в HTTP в нём нет как такового соединения, там сразу идёт вот эта пачка из нескольких диалогов. Ты сказал по поводу Cassandra SQL, это протокол? Да. А разве это не query language для Cassandra? Так, поначалу у Cassandra был Drift, потом они Drift объявили деприкейт, и перешли на вот SQL. Я не уверен, что я точно правильно назвал именно название этого протокола. То есть да, SQL это язык вот этих запросов. Ну, это, мне кажется, ты, наверное, спутал. То есть это язык запросов, это не протокол, или может быть я путаю что-то? Но этот язык запросов, он по Drift не отправляется. Общение с Cassandra на этом языке запросов происходит по специальному отдельному бинарному протоколу, у которого там своя структура фреймов, у которого нет схем Drift, у которого нет вот этого RPC как такового. В принципе можно в шоу-ноуты кинуть ссылку на этот Cassandra протокол. Кидай-кидай. Ну, в общем, что я хотел сказать, то что вот эта идея, когда мы расширяем наш протокол для того, чтобы внутри одного соединения или сеанса между двумя сущностями происходило одновременно несколько диалогов, и любая из сторон могла инициировать какую-то передачу данных, это уже было давно, это реализовано во многих разных протоколах, и, ну, очередное повторение того, что уже было. Почему-то я не удивляюсь. Всё же ходит по кругу, это нормально. Кстати, что у нас ещё такое «ходило по кругу»? Кто-нибудь может вспомнить? Вопрос нашим слушателям. Если вы помните, что «ходило по кругу», напишите нам в комментариях, потому что мы тут все дружно подвисли. Что ещё подвисло? Это следующая тема, которую Светлана добавляла в выпусков 3 или 5 назад. Ну, где-то так. Видела в твиттере у кого-то ссылку на презентацию человека из Линкедына по поводу их архитектуры и как они подходят к процессу разработки. Довольно спорная презентация, не могу сказать, что я вам посоветую её смотреть, но в целом могу рассказать какие-то ключевые поинты и то, что мне было интересно услышать.",
    "result": {
      "query": "swagger generated docs from scala case classes"
    }
  }
]