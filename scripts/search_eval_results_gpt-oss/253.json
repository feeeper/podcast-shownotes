[
  {
    "segment_id": "301d3072-5ad5-4eeb-9bf0-560df9395f87",
    "episode_id": "8e7508a2-1e1c-4d1e-818b-ebcb7a88a1c5",
    "episode_number": 253,
    "segment_number": 3,
    "text": "Да, я прервался в самый интересный момент, видимо, в какой. Про обработку бэка. В общем, да, функция try, идея именно в том, что последнее значение, если это ошибка, прокидывается наверх, если она не nil, а если nil, то просто тесное значение возвращается. Короче, об этом можно много не говорить, потому что это все от коти. То есть комьюнити обсуждало эту идею примерно месяц. Все были в целом глобально недовольны, то есть были люди довольны. Ну там было, как сказать, много, на мой взгляд, политического противостояния, что, наверное, не очень хорошо. Но было много именно идельных идей, предложений, почему это плохо, как это в проблемах и так далее. Одна проблема именно авторитетского прислушивались, это то, что теперь это стало сильно сложно отлаживать. То есть когда у вас есть простой линейный код, типа там, эфирный run nil, он как бы его много, там, глаз замыливается, там, и нужно это все там замечать и так далее. Но с другой стороны, там, можно, не знаю, breakpoint поставить, отложить, точнее, print добавить, там, coverage, корректную почту и так далее, тест написать. А если это трек, он онлайн, который работает таким хитрым образом, то ничего сделать нельзя. В итоге этот эксперимент отложили, как минимум, а может быть и вообще никогда его больше не будет. Посмотрим. Все, с ошибками можно заканчивать и переходить к гораздо менее сворочевой теме, это генерике. Это не моя, это автор Влада Раскалкс так пошутил. Генерики в Go... Подожди, подожди, почему это противоречиво? Ну, как сказать, генерики в Go по большому счету не нужны. В 99% случаев они не нужны. Решительно не согласен. С другой стороны, этот 1% случаев, это на самом деле нифига не мало, да, то есть как бы, ну это много. Если ты считаешь количество кодов, количество разработчиков, ногой и так далее, 1% довольно много, и поэтому, в общем, этот 1% сейчас и думает, что с этим всем делать. А почему ты не согласен? Ты считаешь, что генерики вообще постоянно всегда нужны тебе? Я просто считаю, что как только тебе нужно писать структуру, ну скажем, я пытался писать на Go пару раз, когда генерики бы пригодились, то есть у меня такой пример, по которому я постоянно, как это, которым я постоянно вылазил, я когда ковырял Terraform плагин к нему, где пытался делать, там просто у них такой интерфейс, который вообще весь антипизированный, весь построен на кастинг пустому интерфейсу, и вот там как минимум можно было бы с генериками воспользоваться. Плюс любая ситуация, когда хочется написать какую-то структуру данных, вобщенную, там, опять же, вариант один из двух, или написать ее для интерфейса пустого, или написать ее для какого-то конкретного типа примитива, если в следующий раз понадобится писать ее заново. Третья история – это про то, что в Go довольно низкоуровневый примитив для конкурентности, и если хочется писать какой-то абстрактный общий алгоритм для конкурентности, то в некоторых ситуациях, опять же, хочется писать его для какого-то абстрактного типа, а не для интерфейса. То есть в этой ситуации иногда интерфейсы помогают, но не для всего, что хочется написать, это хорошо работает, как мне кажется. Но я уже деталей не помню. И эти задачи, они такие, что они не встречаются в практике каждый день, то есть если у вас есть кодовая база, которую вы постепенно подпиливаете для чего-то, и, скажем, она занимается чем-то таким, не знаю, веб-сервис, ходит в базу данных, отдает байтики в сокет по HTTP, это не то, чтобы очень нужно, но если вы начинаете писать что-нибудь, я не знаю, какой-нибудь тот же самый, как ROTC-DB, например, я уверен, что у них такие проблемы были, потому что там бывают специализированные структуры данных, потом, ой, а нам нужно что-то похожее еще раз написать в другом месте, опять же, там всякие библиотеки, я представляю, что такое может быть нужно. И как человек, который в целом привык писать на языках, или вообще с такой, условно, несуществующей типизацией, типа Elixir, или на языках, где прям вообще все по хардкору, типа Scala, мне вот эта типизация уровня Go, она мне кажется как бы ни туда, ни сюда, то есть она как бы уже мешает писать фигак-фигак, а вроде не дает достаточно способов выразить ограничения, которые хочется выразить. Ну, в общем, большая часть того, что ты сказал, она происходит именно к кастомным данным, и здесь я с тобой полностью согласен, то есть генерики нужны для вот таких структур данных, хочешь постоянно анбоксить свой тип, заворачивать их в интерфейсы, каждый тип, и хочешь, чтобы это было эффективно, ну и такие же алгоритмы, да, то есть алгоритмы конкурентости, в частности, когда ты хочешь, чтобы они были безопасные, но при этом не заворачивать все в интерфейсы. Я бы сказал, что в интерфейсе заворачивать все не так уж и проблематично часто, но если это структура данных, особенно если ты хочешь, чтобы структура данных были на базовых типах, которые не один интерфейс, то да. В школе статераформы, когда я последний раз об этом говорил, кажется, что там нет большой проблемы сделать нормальные интерфейсы, не пустые, да, если просто людей заставлять эти интерфейсы реализовывать, их будет довольно много, и видимо поэтому они решили, вместо того, чтобы поддерживать кучу интерфейсов и как-то их совместимые с ТВЛ, они решили сделать, что окей, мы ничего не поддерживаем, вот вам пустой интерфейс, и идите на башню с сами. Ну это, наверное, не очень хороший подход, может быть, я там что-то не понимаю, есть какие-то другие причины, но вот там с интерфейсом можно сделать проблему. Один из разработчиков ГО, который по совместительству один из разработчиков ГЦЦ и автора Голдлинкера, Ян Лэнстейлер, он как раз на Дефраконе сделал большой доклад. Он один из тех людей в ГО-тим, которые за Джанель Лену топят и хочут их, и он написал уже пять пропозывов про Джанель Лену. Этот вот пятый пока что идет дальше от всех остальных, все остальные уже забили, а на этот еще пока нет, его пока продолжают использовать. То есть сначала он долго, медленно, неторопливо с примерами пытается убить Гойфрева, что Джанельке нужны. Если кратко, все сводится к тому, что если вы хотите сделать... Вам нужно писать обертку на интерфейсы или заворачивать элементы слайса в интерфейс. Сори, можешь повторить, пожалуйста, что ты говорил, потому что у меня пропадал полностью. Ну вот смотри, у тебя есть слайс, допустим, строк, и ты пишешь функцию, которая этот слайс разворачивает. Ну ты, значит, делаешь цикл, меняешь их местами, индекс меняешь и все такое. Дальше ты хочешь сделать такую же функцию для интопа. Окей, ладно, скриптпастил, заменил стринг на инт, отлично. Дальше такую же для флоута. В этот момент ты начинаешь думать, какие у тебя есть варианты. Первый — кодогенерация. Ты берешь любую толзу для кодогенерации, которых уже вагоном маленькая тележка, делаешь темплейт. По сути, такие темплейты, к счастью. Это хорошо в некоторой степени, но имеют толзы, они на самом деле имеют одну проблему, которая в нутренном трюнинге решиться не может. Весь этот трюнинг, он не знает на самом деле ничего про твои типы, тексты и шаблоны. И как пример, если у тебя есть, допустим, стринги, и ты хочешь написать функцию, которая из слайса строк делает уникальный слайс строк. Довольно просто, эффективный способ это сложить в мапу, наверное. Но допустим, вы об этом не подумали, и делаете функцию, которая это все сультирует. Для этого нужна эта цена, на сравнение меньше. После этого такая генериф функция типа на темплейтах, она не будет работать, если там будут не строки, а указатели на строки. Потому что указатели на строки можно сравнить напрямую, ну нельзя сравнить напрямую, это просто не скин. А даже если было бы можно, то это бы работало не так. То есть указатели надо сначала будет резюмировать, а потом уже сравнивать. Ну и соответственно, траекторию на нил добавить и так далее. То есть эти темплейты, они не знают ничего про ваши типы, не знают какие операции на них определенные, не знают, правильные ли эти элементы, меньше или какой-то метод вызывать, типа less на этом типе. Первый вариант, который у тебя есть, как бы ничего не делать, просто пасть руками. Третий вариант, у тебя реализовать какой-то интерфейс на каждом типе этого слайса. То есть у тебя будет слайс не строк, допустим, и слайс не int, и слайс не float, а слайс твоего интерфейса, не знаю, там компаратора какого-нибудь. И дальше тебе нужно будет любой базовый тип в этот интерфейс сначала заворачивать, потом приложить слайс, вызывать функцию, потом достать обратно и опять разворачивать. Такой плюс-минус джава подход, но если я не прав, не бейте меня, я джава на самом деле не знаю. И четвертый вариант, это определить тип для самого слайса целиком. То есть у тебя есть там не просто слайс стрингов, отдельный тип называется string.slice, на нем все это реализовано. Ну и все, на самом деле, все эти 4 метода так или иначе Go используют до сих пор. То есть если посмотреть на смертный байк, когда сальсируются строки, там почти все эти подходы и есть. И наконец-то подходим мы к тому, что все-таки решить это в другом языке. Их основная идея это использовать подмножество самого Go для того, чтобы описывать контракты на функции, и эти контракты описывают типы. То есть я даже не знаю, есть ли что-то подобное в других языках, я такого не видел, но с другой стороны, опять же, у меня не супер широкий кругозор по всем языкам, которые существуют в мире, поэтому я не знаю. То есть идея в том, что когда вы пишете какую-то функцию, которая зависит от типа T, вы перед этим небольшим контрактом описываете, что этот T может. И этот контракт это не интерфейс, то есть он обладает большей гибкостью, с одной стороны, с другой стороны, он не является самостоятельным типом, и он как бы не присутствует в языке в других местах. То есть для интерфейса вы можете делать применную, объявить применную этого типа интерфейс, вы дальше присылаете ей значение для контракта, что ничего такого нет. Но с другой стороны, контракты могут быть экультивными, могут определять свой контракт через себя, через другой тип этого контракта, могут использовать не только методы функции, но и операторы и так далее. Вот, ну тут, так сказать, не знаю, что еще можно говорить, это довольно большой доклад, большая тема, сложная, и это явно не в этом году это все будет. И может быть даже и не в следующем. В общем, большая и долгая. Но возможно, какой-то эксперимент, первый какой-то реальный код уже будет в следующем году. Так, про generic есть? Да. Что ты думаешь по поводу симпса? Симпса, он мне просто очень лисп напоминает, теперь там возле названия функции добра скоба, человек это страшно, по-моему. Вообще, мне это напоминает трейты из RAS, то есть трейт, то есть вопроса через генерик. То есть в RAS это сделано через трейты, то есть там все типы, они могут реализовать какие-то трейты, то есть это поведение. И там их можно сравнить, и стандартные типы, они просто реализуют эти трейты. Я как-то не особо понимаю, почему они не пошли этим путем, хотя походу шли. Ну вот вообще была одна идея, есть один контр-пропозал, что вместо того, чтобы делать удаленный контракт, давайте сделаем просто определим метод на базовых типах. И сделаем соглашение, что у вас сравниваются пременные A и B, а у оба, которые и ты, то это то же самое, как будто на вызове метода LESS с аргументом B. Но там есть свои проблемы, это разные типы, мы знаем, что это по C++, так можно очень далеко пойти. Перегрузка операторов и всем таким прочим. Поэтому особого желания у всех не возникло так делать. Но идея интересная, да. Поэтому нету стандартных таких трейтов, стандартных интерфейсов для базовых типов, и видимо не будет. Базовые типы будут совсем базовые. Что как бы и хорошо, и плохо одновременно. В частности, если бы у нас были бы какие-то интерфейсы на стандартных типах, можно было бы определить, свой какой-то тип может работать через range. Прямо сейчас работает только для стандартных типов, для жестко указанных каких. Нельзя сделать свой тип, который был бы со стим с ренджем. Подобный механизм позволил бы это сделать, но видимо его не будет. По крайней мере пока что не планируется. Но тем не менее, пропозылы, альтернативные контракты, которые пытаются делать что-то такое, они есть. Мне даже в чем-то нравится, что нету трейта, что они не сделали такую штуку, потому что по опыту C++ это просто развод утки и зоопарки, потом ты смотришь в коды и не сильно понимаешь, что это рейндж каких-то комплексных сил будет делать, или что-то такое. Но честно говоря, да, все равно. Смотрю на синтаксис, расскажи, что ты думаешь про эти скобочки. Я на Lansdraver, он вообще разработчик на C++, поэтому он много пишет на C++, и его прямое мнение, что не нужно делать треплейты как в C++, это его конечно не может не радовать.",
    "result": {
      "query": "Go generics pros cons discussion"
    }
  }
]