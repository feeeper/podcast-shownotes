[
  {
    "segment_id": "87717444-a4c3-48b2-8de4-17978dc00d13",
    "episode_id": "a1000849-a5ae-4c5f-b830-55e574e16d1e",
    "episode_number": 85,
    "segment_number": 12,
    "text": "То есть, ну вот все боют хвалы скала Яка, что у вас при этом все возможные библиотеки из скала мира остаются, это такая же история, как с рельсами и EventMachines, как только вы берете вот эту вот асинхроничную, у вас резко библиотек не становится, или становится сильно меньше. Хотел сказать про хатскиль в защиту, что в принципе, вот представь себе нормальный проект, который ты хорошо организовал, да, с CI, с тестами, с код-ревью, с альфа-бета, вот это все, в принципе, писать можно о чем угодно. То есть, ты хоть на C++, хоть на хатскиль, если ты это нормально тестируешь, то все будет нормально. Там, с property-based тестами и так далее. Ну, просто смотри, для меня прям большая принципиальная проблема, это не сломать мозг в какой-то сложной логике, ввиду сходить в 10 мест и собрать из этого ответ. Ну, я не знаю, в той же самой скале, если у тебя одно из этих 10 мест дает очень-очень большой JSON, я, кажется, как раз уже ругался на это в каком-то старом, наверное, год назад ругался, что если вдруг один из этих концов дает огромный JSON, то внезапно можно поставить существующими JSON-парсиями, можно внезапно поставить скейлер-раком. Ничего такого подходящего среди популярных библиотек нет. Есть одна такая полуэкспериментальная библиотека на итератах, ею можно воспользоваться. А так вот прям хорошего поточного парсера JSON, которым можно скармливать байтики, который не пытается перекинуть на себя управление вводом-выводом, их как-то вот нет. И так во многом, это не только проблема с JSON и ACCA, это проблема много с чем. То есть, когда у нас в виртуальной машине, которая не умеет асинхроничную, или там в языке, где стандартная библиотека не умеет асинхроничную, есть куча библиотек, которые тоже ее не умеют, и мы туда притаскиваем асинхронный фреймворк, у нас резко все плохо и неудобно. И получается, что Erlang, Go и Haskell, это такие три технологии, где асинхроничная на уровне виртуальной машины, поэтому там все сравнительно хорошо. В Java мире тоже должно стать хорошо, потому что они прям стандартную Java сейчас протаскивают, стримы и фьючу, уже там, наверное, одну мажорную версию как есть. Подожди, футуры? Футуры там есть давно, но только они там сделаны очень криво, ну в смысле они не блокирующие, в смысле совсем блокирующие, но в смысле они такие были, потом они сделали какие-то новые футуры, которые вроде как получше, но там все не как у людей в общем. Ну я со своим говном в ноты тоже не буду с вами проспеть, ваш разговор про асинхроничную надо. Кстати, в Node все сравнительно хорошо, но удивление, там этим неудобно пользоваться, но там хотя бы изначальный посыл платформы был в том, что ребят, у нас все асинхронно будет, поэтому там хотя бы все библиотеки асинхронно написаны. Это да, это да, но насчет того, что неудобно, сейчас есть работы вот этот асинхроэйт и есть рикс, но мне тоже кажется, что даже с асинхроэйтом или с риксом это недостаточно высокого уровня API, в плане того, что оно конечно композабельно и все такое, но мне кажется, что это недостаточно высокий уровень. И код когда получается, он совершенно не читабельный, ну нафиг. Следующую тему принес Андрей Басонченко, я извиняюсь, если произношу плохо, про то, что Citus теперь open source и мержится обратно в Postgres, я был на PGConf в Москве на докладе, человек из Citus, я, к сожалению, не помню, кто именно это был, и там история примерно такая, что да, действительно, они взяли весь Citus и запихнули его в extension, ну в смысле в contrib, это здесь называется contrib, к Postgres, то есть в плагин. Нужно отметить, что Citus это не так, что смотрите, Cassandra поверх Postgres, там с фейловером и вот это все, это решение для таких тяжелых вычислений, ALAP запросов, то есть вы поднимаете 100 Postgres, вливаете туда нужные данные, потом делаете такой селект на виртуальные таблицы, и оно параллелится по сотне машин, то есть оно реально очень круто параллельно считает ALAP, но это не то, про что вы можете думать, так просто хочу отметить. Если у вас падает одна из машин, все становится очень плохо, если у вас Netsplit, то ничего не работает, то есть они это прямым текстом на своих презентациях говорят, потому что они решают другие задачи. А вообще нет, тут нужно еще сказать, что это хорошо иллюстрирует, знаете, есть срач на тему GPL против BSD, что круче, вот аргумент, что GPL круче, потому что в него все обязаны контрибьютить, он совершенно невалиден, потому что нам это демонстрирует и CLANG, потому что в него действительно коммитит очень много людей из Apple, из Google, ну вот я рассказывал, чувак фуллтайм работает в Google, пишет LLVM, по очень простой причине, если ты хочешь, даже если тебе нужно что-то поменять в бизнешном проекте, ты от него формулся и у тебя свой проект, ты все равно очень сильно хочешь, чтобы это",
    "result": {
      "query": "асинхронные библиотеки скала"
    }
  }
]