[
  {
    "segment_id": "0f7cb9de-f9d8-4f96-b914-f1156a13ad9e",
    "episode_id": "c8bbde55-3719-4c4e-9075-be6ee2edfa4d",
    "episode_number": 82,
    "segment_number": 14,
    "text": "Ну а ты сам как думаешь? В принципе, с точки зрения фронта, это всё едино. Я в принципе не вижу какой-то большой проблемы в монолитных приложениях до тех пор, пока они сами себе масштабируются, и код не свален в одну большую пучку. Нет проблемы написать бэкэнд, который это одно приложение, при условии, что оно работает с какой-то кластерной базой данных, или хорошо пошарденной революционной базой данных. И почему бы действительно не делать одно приложение, не разбивать его, при условии, что оно масштабируется. Да, согласен. У меня очень похожая точка зрения тоже, что микросервисы призваны решить какую-то проблему. Если у вас такой проблемы нет по определению, то зачем вам микросервисы тянуть просто так, потому что это модно. То есть если у вас работает ваш бэкэнд так, как он есть, если вы не испытываете проблем с его расширением, и если вам нужно добавить какую-то функциональность, это легко делается, то зачем вам переезжать на микросервисы, только потому что так нужно. Ну все, закопали микросервисы. Как же жить без микросервисов? Вы сейчас напишите монолит, а потом попробуйте его расширить. Чаще всего все маленькие компоненты внутри завязаны друг на дружку. И если вы не держите это в голове, то... Это никак не связано с тем, микросервисы теперь не микросервисы. Там другая проблема возникает, что, допустим, у тебя приложение, ты написал монолит, оно просто ходило в базу, потом ты написал кусочек этого монолита, который очень сильно ходит в диск, а потом еще другой кусочек, который жрет очень много памяти. У тебя получился монолит, который жрет много памяти, ходит в диск и в базу. Если ты сможешь изолировать кусок, например, который ходит много в диск, в отдельный микросервис, то ты у тебя как бы гранулярность приложения увеличивается, ты можешь его разместить на более дешевых суммарно машинах. Понимаешь, примерно о чем я? Да, понимаю. Вот, такая проблема бывает, а то, что там типа, ну, мы наговнокодим так, что все будет совсем связано, но это не проблема архитектуры приложения, это проблема того, что на код ревью все забили, например. Просто чаще всего, если там, скажем, вот команда из трех-четырех человек что-то пишет, оно чаще всего начинает сильно разрушаться, начинает сильно связанным быть, хочешь с тобой или не хочешь. Слушай, я могу тебе показать проект, который 20 лет пишут сотни человек, и там все довольно слабо связано. То есть я повторюсь, все дело в строгости кода ревью. Нет, это однозначно, однозначно. Я говорю про практики. То есть как бы, если ты разбил все на микросервисы с самого начала, то ты не имеешь возможности объединить их, завязаться на какие-то куски, чтобы как бы все получилось очень плохо по качеству. А если у тебя единый монолит, то есть вероятность ненулевая, и она не мизерная. То, что в средней команде разработчиков ты все равно не сможешь потом в дальнейшем легким движением руки разбить их на два сервиса и промасштабировать один, но оставить другой. Так а может тебе не нужно будет их разбивать впоследствии, если ты точно знаешь, какие у тебя требования, ты знаешь, тебе нужно сделать какое-то приложение. Это все очень зависит. Все чуть-чуть проще. Тебе не нужно для решения проблемы, Вань, которую ты озвучил, использовать сервисы, использовать библиотеки. Разбей на артефакты. Разбей на модули, например. То есть тоже давно принятая структура разбиения твоего приложения. Это у тебя будет одна часть, вторая часть, третья часть. Но является ли это микросервисом? Ну, скорее нечем, да. Вот расскажи мне, как ты постброс разобьешь на микросервисах. Ну, идиотизм же, правда? Ну, конечно, да. На модули разбить можно легко. Но то, что ты разбиваешь на модули, не всегда можно растянуть по разным микросервисам. Я имею в виду, даже если это нужно сделать с точки зрения архитектуры. Зачем? Но если один кусок тебе надо ремасштабировать в 100 раз, а второй можно оставить на одной ноде и пусть он работает в одиночку или вдвоем на 2 раза. Нет, нет, важность в плане верности я и не отрицаю. Я это сразу сказал. Но ты не эту проблему поднимал. Я поднимаю проблему, что когда тебе это нужно сделать, и у тебя плохой код-ревью был, то ты можешь наткнуться на большие проблемы. Если ты изначально примерно представлял, что эта проблема у тебя может возникнуть и ты писал исходя из того, что это независимые полностью компоненты, а лучше запускать их даже в отдельных докер-контейнерах с помощью докер-клауда, отсылка к предыдущему теме, то у тебя это все намного проще будет решаться в дальнейшем. Но это слишком сложно. Нет, ну, нужно просто бить программистов палкой за написание плохого кода. И код бы их хороший. Ну зачем микросервисы? Это идеально. Просто можно эту проблему намного проще решить без микросервисов. И без докера. А еще можно писать микросервисы, докер, и все распределенное, и все замечательно, а потом оказывается, что эти микросервисы друг с другом не работают, и мы имеем просто тот же самый монолит, просто размазанный по нескольким контейнерам. И чаще всего бывает, когда ты закладывался на то, что один сервис, вот твой микросервис, будет масштабироваться, а на практике у тебя получается, что тебе не нужно его масштабировать, и вообще твое приложение не взлетело, и его нужно закопать через пару месяцев. А ты всячески старалась и делала такую масштабируемую архитектуру. И не учел накладные расходы носить. Ну это надо просто бить по голове сразу. Как вот там по рукам, а здесь по голове. Все нормально будет. И будут программисты умные. Но я хочу вам сказать, что пока приложение не закопали, мы же в него коммитим, и для коммитов появилась новая интересная туза, которая называется GitKraken. Да, при том коммитим мы, понятное дело, в Git, потому что если ваенный умер, то Меркурия уже там, ну, хоронят в процессе. А там же есть в годе GitHub или что-то в этом годе? То есть можно на GitHub? Нет, Svn нет. GitHub тоже есть, он GitHub. Короче, с... Есть конвертинки. С Hackers News, или Hacker News, я все время забываю, как правильно. Hacker News прилетела ссылка на штуку под названием GitKraken, это UI-чик для GitA, при том очень интересный. Я сам не очень большой любитель GUI для систем контроля версии, но знаю людей, которые их очень любят. И вот это, видимо, специально для них. Эта штука бесплатная, пока что. Пока бесплатная, она находится в бете, исходники закрыты.",
    "result": {
      "query": "pros and cons microservices vs monolith"
    }
  }
]