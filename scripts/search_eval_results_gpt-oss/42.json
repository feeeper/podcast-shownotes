[
  {
    "segment_id": "b7044b2e-3070-4634-a8d2-15fc605414c3",
    "episode_id": "00fa2b4f-b029-4acd-816b-cddf90ea8c6e",
    "episode_number": 42,
    "segment_number": 6,
    "text": "А здесь, получается, я использую те же самые технологии, которые я привык использовать на фронт-энде, я могу их использовать на бэк-энде и наоборот, и это плюс. Ruby я бы взял, если бы я строил REST API. На Ruby написано миллион, вагоны маленькая тележка, каких-то, знаешь, библиотек, джемов, фреймовоков и все такое прочее, и все это комьюнити огромное, оно фокусируется вокруг Ruby on Rails. И поэтому... а Ruby on Rails умеет делать API, такие REST-современные серии, запрос пришел, запрос ушел. Соответственно, если мне нужно писать API, например, делать для него хорошее настроение, для него хорошее варгон-тестирование, какие-то, знаешь, шмотки еще что-то, и куча-куча инструментов, которые есть у меня, и которых у меня может и не быть в других каких-то экосистемах. Я думаю, окей, мне нужна какая-то штука, которая, например, перед каждым тестом заполнит мою базу данных какими-то фейковыми данными, и все это как-то интересно скриптится и все такое прочее. Возможно, я найду какие-то инструменты на Java, на Python, еще где-то. Но я точно уверен, что на Ruby будут такие инструменты. Вот в этот момент я выбрал Ruby. Плюс Python универсальность. В плане того, что, например, я сейчас работаю в компании DataRobot, мы строим предиктивные модели на основе данных, которые пользователи загружают нам. И получается, что на Питоне можно делать какую-то Data Science, обработку Data Set с какой-то вещью, с математикой, с NumPy, с SciPy. И одновременно с этим на Питоне есть классные веб-фреймлоки, и, в общем-то, веб-стек на Питоне писать удобно. Получается, что если у вас под такая же штука, и вы хотите остаться на одной технологии, то это хороший вариант. Но опять же я не могу сказать, что это идеальный вариант. Это как по МИС, как и везде. Когда используете. Смотри, можно взять ту же скалу, например, и будешь использовать скалу на BackEnd, скалу на FrontEnd, скалу на JS. И у нас даже был гость, который про это рассказывал. Да, ты можешь Java на FrontEnd и на BackEnd использовать. Ну, это, знаешь, как-то больно и туда и туда. Согласен, согласен. В общем, вроде как ничего такой язык. Но ГВТ, насколько я знаю, Java вовсе не поддержит. Есть Питон на клиенте, есть Куби на клиенте. То есть, в принципе, ты можешь писать на язык. Другое дело, что сейчас от нас часто ожидают таких интерфейсов, которые сложно сделать без того, чтобы пользоваться теми библиотеками, фреймлоками, инструментами, которые уже на JS написаны. Также, как, например, зачем делать какую-то параллельную обработку данных, я не знаю, на том же Питоне, если есть классный Spark, правильно? Тут тоже самое. Очень сложно из твоей же скалы JS вызывать JavaScript-овый код, и при этом твой код, который в взаимодействии с JavaScript, чтобы он выглядел идиоматичнее. Писать какие-то WebUI из северной части приложений на каком-то транспартическом языке, я считаю, что это не самая хорошая идея. Очень часто хочется двигаться быстро, хочется менять все быстро, и поэтому API очень часто нестабильны. На той же JavaScript-скале тебе нужно для каждого JSON-а написать какую-то схему. А потом, когда проект станет больше, ты вспомнишь про то, что зря мы не писали на статическом языке, потому что ты захочешь писать схемы для всех своих запросов, ответов, потому что никто не будет помнить, какие поля, за что отвечают, почему они приходят там, а не приходят здесь. Но на ранних этапах, когда проект только-только начинается, первые года два этого проекта, бизнесу хочется, чтобы UI развивался быстро, менялся быстро, и очень часто в этом случае именно динамический язык гораздо-гораздо лучше себя показывает. Ну а потом он начинает тормозить, и все переходят на другой строке. Я недавно говорила об этом с коллегой, и мы спорили по поводу динамической статической типизации, когда это хорошо, когда это плохо, и я в итоге пришла к тому мнению, что на больших проектах, по крайней мере я такую точку зрения отставила, что большие проекты писать на динамически типизированных языках сложно. Если вы уверены, что у вас команда будет привязана, то, наверное, это взлетит. Но как только у вас люди начнут меняться, все начнет сильно рассыпаться. И коллега приводил пример, что вы, например, перемножаете матрицы, ну да, частая задача для бизнеса, конечно, и вот какова вероятность того, что ты в функции, которая умеет перемножать матрицы, подашь вместо матрицы какой-то другой тип объекта. Но просто для бизнес-приложений обычно там куча всяких типов разных получается, и трудно помнить, удерживать в голове все возможные варианты. Поэтому все-таки я не вижу возможности на динамически типизированных языках писать реально большие проекты, чтобы вот это и спать спокойно по ночам, ну либо обкладывать их тестами очень сильно. Хотя, ну а если мне дает компилятор из коробки, мне не хочет оно это, например, тратить времени много. Можно глазами пострадавшего вплюнуть? Я же сейчас, как возможно слышали, по большей части пишу на рубе. Вот, пришел на проект уже существующей игры, там довольно основательная кодовая база, и действительно, скажем так, это мой первый опыт использования рубе в большом-большом проекте, и честно сказать, я надеюсь, последний. Потому что тут реально хочется, чтобы это была скала, и чтобы было точно понятно, откуда что пришло. То есть кодовая база, она на самом деле в замечательном состоянии, все реально обложено тестами, то есть я думаю, именно поэтому она работает, и вообще все обложено тестами. По крайней мере, что касается самого бэкэнда. Но при этом есть небольшое исключение из того, что сказал Света. Вот я знаю один единственный язык, на котором я видел очень большие проекты, то есть я не просто их видел, я в них вонзался. Как многие знают, я тут большой фанат ReactCore. Прежде чем стать большим фанатом ReactCore, я довольно долго его изучал. И это, пожалуй, Erlang, особенно не голый Erlang, а Erlang, когда он обильно смазанный TypeSpec, в котором используется Dualizer. Это, пожалуй, исключение, он как раз потому, что типы указаны везде, и они проверяются инструментарием. Типы на стероидах получаются такие. Не то что на стероидах, они скорее наоборот типы бедного человека. Но хотя бы что-то. И еще у Erlang есть такая плюшечка, ты гарантированно знаешь, что стоит у тебя дальше одного процесса не ездить. Это довольно удобно, когда думаешь о том, откуда это приехало. В Scala тоже бывает такая фигня, что ты смотришь и думаешь, откуда у меня этот метод появился, кто мне его сюда подмешал. Или откуда у меня этот стейт взялся. В Erlang еще этого нет, это довольно удобно. И этого очень не хватает в других динамических языках. На самом деле в JavaScript сейчас у нас тоже есть анализаторы типов. Есть прайд от Facebook, который называется Flow. И который действительно набирает популярность. Просто запускаешь эту штуку, и она пытается угадать какие-то теоретики, доказать, что здесь, например, ходят винты, а здесь, например, ходят стройки. И если ты совершаешь какие-то вот такие ошибки, то она будет тебя в этом выравнивать. Есть TypeScript, который достаточно аналогичен как настройка. И оба этих продукта позволяют тебе добавить аннотации к типам, там где надо, там где хочется. Но в целом ты прав. Обычно в таких языках все решается большим-большим набором тестов. И без этого бывает очень сложно. Я участвую в ICFPC, вот этот ICFP Programming Contest. И это трехдневное такое соревнование, в котором команды со всего мира решают одну задачу за трое суток. И мы пришли своей командой к тому, что мы пробовали использовать Scala, мы пробовали пытаться писать на Java, и в результате мы пришли к тому, что для нас хорошо работает динамический язык при условии того, что мы пишем с тестами. И все равно где-то вот в таком быстром режиме попробовал, написал, не сработало, попробовал еще раз, и в таком быстром режиме хакатона мы все равно приходим к концу третьих суток, потому что у нас начинаются проблемы с типизацией. А в реальных проектах это гораздо менее такая больная тема, потому что в реальных проектах редко ты вкладываешь строки с сантами, обычно ты их просто показываешь где-то в интерфейсе и все. Но это как раз подтверждает твою идею, что для маленьких проектов самое то, да? Да, для маленьких проектов или для каких-то, знаешь, даже если это большой проект, но если это большой проект, можно разделить. На маленькие кусочки, да? Да, в общем-то оно везде так работает. Кто-то говорит, что тестами мы заменяем типизацию, но я бы так не сказал, обычно мы проверяем флоу, что все вызвалось в том нужном порядке, где-то в конце мы проверяем результат, мы редко проверяем именно типы входных, выходных данных, нас это редко волнует. Опять же, да, если типизация динамическая, то как бы дактайпинг, если оно ведет себя так, как тебе хочется, то все отлично. Да, так, ну а следующее письмо, говорю, следующая тема, это грустная для лично меня новость, хотя я этим продуктом и не пользовался, Eclipse Fp больше все, все совсем все. Автор сказал, что он не будет больше поддерживать его, это Eclipse IDE для Haskell, и ну вот грустно мне, что популяризация Haskell уменьшается. А я думаю, что это больше проблема с самим Eclipse, как я уже говорил, я писал плагины под Eclipse, писать плагины под Eclipse, отручей, именно для языков, это очень неблагодарное дело, потому что у них внутри своя модель трудов, у них там свои какие-то джобы, еще там что-то, и я вижу, как многие языки отказываются, многие проекты отказываются на то, чтобы использовать Eclipse как базу. Груфи, например, тоже сказали, что больше не будут развивать плагины под Eclipse, есть сейчас плагин под IDE, который развивает JetBrains, но я не знаю, будет ли JetBrains его поддерживать, но мне кажется, что тут больше вопросов и в Eclipse, а не в конкретном плагине. Кстати, а ты какое IDE используешь? Когда я пишу на Node, то это либо Vim, либо Sublime Text, либо чаще всего в последнее время Online IDE. Бывает часто, что несколько проектов параллельно, и поэтому, знаешь, просто подняли где-то бокс и просто на него хотите что-то там писать, мне гораздо удобнее, чем разворачивать окружение локально и думать об этом постоянно. А для Java я пользовался Eclipse, да, я один из тех людей. Я не могу сказать, что идея там плохая, неплохая, но в Eclipse была такая фильмфича для меня, Save Actions, то есть ты мог сказать, когда фарт сохраняется, сделай мне то, то, то, то и то. И я не могу представить, как люди без этого могут работать. У меня на Save Actions, например, Final 10 проставлялись, или, например, убирали лишние скобки. Если я вижу, что я написал какое-то большое выражение, и у меня пропали скобки, я думаю, окей, выражение слишком сложное, надо его как-то прорефактировать. И вот такие вещи, сейформатива, еще что-то. То есть вот такая мелкая фича, но это фича, из-за которой я долго-долго сидел на Eclipse. Но сейчас уже не сидишь. Да, потому что в последний раз Java, например, я трогал только этой осенью, это было полгода назад, и на тот момент был тоже поддержка API для клиента, и API уже был написан, его нужно было чисто чуть-чуть поменять. Но программировать на Java без IDE достаточно сложно, потому что забываешь импорты какие-то добавить, или еще что-то, и потом оказывается, что твой код падает, даже если ты все предусмотрел, как тебе кажется. Это да, да. У меня вопрос к тебе, Андрей, расскажи нам про Node и EOGS. Это смешная история, вообще смешная история. Когда появился Ryan Dahl, это такой реконеджер 16-го геомании, он его написал, он его вводил где-то полгода, и после этого попросился из серии, ребята, кто-нибудь, поддержите проект, пожалуйста, потому что мне нужна работа, мне нужны деньги, и Joint вызвался. Joint на тот момент, это такая компашка, которая делает свое облако, свою систему для дата-центров, и они весь свой скриптинг внутри делали не на Perl, не на Python, большинство людей, а делали именно на JavaScript, на тот момент они взяли Ryan, для того, чтобы эти скрипты запускать, и конечно, по",
    "result": {
      "query": "Ruby vs Python backend development"
    }
  }
]