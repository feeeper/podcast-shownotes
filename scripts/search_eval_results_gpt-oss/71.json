[
  {
    "segment_id": "f2d590d6-b6f9-4ae3-8049-be206a27849e",
    "episode_id": "90aee601-5b6e-4b1c-a6b1-c4ad461ff644",
    "episode_number": 71,
    "segment_number": 3,
    "text": "Вот, как этот софт пишется, кем он пишется, довольно интересное такое. Не то чтобы зрелище, но это послушать, как это происходит, очень занятно. Потому что один разработчик, он писал на Delphi, ему нравилось, все было хорошо. Второй разработчик писал на C-Sharp под .NET, ему тоже все нравилось, все было хорошо. Но в итоге они сошлись на Go. Вот, представляете, как бывает? Ох, то есть все, Go победит мир. И всем срочно с Явы переходить на Go. Ну нет, скажем, это такой пример того, как можно вне эти компанию протащить Go, и что можно показать, что это довольно интересно, и программисты других языков будут переходить. А как бы ты протаскивала Rust? По поводу Rust, там тоже было упоминание, но Rust показался довольно сложным, и его невозможно за один вечер изучить, в отличие от Go. Так это же плюс языка. А где же нужно побыстрее в продакшн? Молодец. Ага, побыстрее в продакшн. Цензурно выражаясь. Окей. Но, кстати, кроме шуток, мы тут ставили небольшой пинг-понг-тест на Go, и Go нам показал, чисто в пинг-понг, по х2тп, что-то порядка 68 тысяч запросов в секунду. Мы даже мало выбили, он больше может. Но это был совсем такой нейт, без всяких мизераций, просто взяли и сделали. Не особо старались, наверное. А дальше тема, на которую мы переходим, про Rust. Кто-то уже упомянул его. Я только что о нем говорил, про Rust, вышла Rust m5. Я, честно говоря, посмотрел ченчлог, они поменяли, улучшили, дополнили, еще более лучший каргой теперь у нас есть. В целом, на этом капитально, я бы не сказал, что что-то изменилось, но стало получше, поприятнее, и баги закрывают поведение, всякое там разное, улучшают, допиливают. Но чтобы теперь стало в 10 раз лучше, я бы не сказал. Кстати, все в курсе о новости, что Mozilla заявила, что в 2016 году они, то есть в наступающем, уже Rust и сервер притащат в Firefox, насколько я понял, чуть ли не целиком. Такие дела. Прям таки возьмут и сразу целиком. Прям таки, по кусочкам, да, они его перетащат на место, что это будет в течение 2016 года. То есть это не то, что мы начнем и сделаем, а вот прям. Я прошу proof в шоу-ноты. Proof кину, чтобы не скучать по клавиатуре, если никто не против, после уже подкаста. После шейн-записи. Окей. Кто-то что-то еще про Rust расскажет? Нет, к сожалению, нет больших любителей. У нас Rustaman главное творился. К сожалению. Но там действительно такой релиз, типа у нас карга стала прям вообще супер крутой, прям почти можно в продакшен. Ну, здорово. А кстати, кто не знает вообще хоть одного программиста, который сейчас пишет на Rust? Я знаю одного ровно. Отлично. И ты знаешь одного ровно. В продакшене? А, в продакшене? Нет. Таких упоротых, по-моему, вообще нет. Ну или хотя бы, который рассматривает ее. Потому что написать, дай мы Hello World. В Mozilla рассматривает. Да, кстати, в Mozilla. Но то есть ни одного знакомого. Ну, Саксесс, Торис, нету у Rust до сих пор. Вы знаете, по-моему, написать в современном мире новый рендеринг для HTML, параллельный рендеринг, чтобы он проходил там, а если 3, уже достижение не из маленьких. Вот прям совсем-совсем не из маленьких. Это точно. Потому что это очень большая, прости, я закончил мысль, большая боль поведения браузера и как, ну, вот с поддержкой стандартов, которых сейчас уже очень много, и как они должны себя вести. И, ну, это прям вот достойно всяческого уважения. То есть нужно было что-то задушевать вместе. Я когда это начинал, я даже не очень верил, что у них получится. Да, я полностью тебя поддерживаю. Но просто, когда Rust выходил, там была версия 1.0, и все прям говорили, о, отличный язык, надо на нем что-нибудь написать, тем более, что Mozilla пишет. И я думал, ну, пройдет полгодика, и начнут появляться хоть какие-то проекты, которые там, Success Stories, какие-то, ну, хоть что-нибудь. То есть сейчас я вижу только какие-то проекты на GitHub, но вот так, чтобы на слуху что-то было, такого нет вообще. А помните, что я говорила давно-давно про Rust? На меня потом накинулись все. То, что не нужно никому? Нет, то, что я в него не верю. Ну, я не верю. Кстати, к вопросу о безопасных языках и вере, как раз следующая тема, очень удачная. Статья на Hacker.ru, компания Veracode подсчитала, какие языки порождают больше всего багов. То есть мы знаем, что Rust везет за безопасность, и конкуренции, но еще и за безопасность. И, собственно, ребята подсчитали, а в каких языках реально много багов, то есть штук на мегабайт, я так понял. Да, на мегабайт хода. Подожди, они имеют в виду в языках либо в программах, написанных на этих языках? В программах, написанных на этих языках. А, все, все, вопрос. И C++, и C, даже не в пятерке. То есть C++ на шестом месте по этому исследованию. Обязан бросить, потому что, во-первых, мерить код мегабайтами, это что-то новое в аналитике программ. Это хорошо забытое старое, я бы сказала. Ну, наверное, да. Причем можно еще скомпилированный код в мегабайтах мерить, вообще прекрасно. Жалко, что не строчки считали. Надо было считать строки. Вот, ну да, как мы все понимаем, что выразительность языка, она разная. А что еще интересно, эти уязвимости, они очень к вебу привязаны, к Cross-Origin и так далее. То есть каких-то там ошибок в рамках времени выделения или еще чего-то, там нет. Там именно внешние атаки смотрятся. И я бы прямо не сказал, что вот это есть истинно в конечной инстанции, стоит ориентироваться, привык при языке на вот эту статью. Это же как это, ложь, наглая ложь и статистика. Вот здесь ярчайший пример. Да, про ярчайший пример, вот статистики в самом плохом смысле этого слова, мне кажется. Интересно, а PHP, они как мерили мегабайты? Вообще вот чисто это получается, PHP это чисто код в мегабайтах, я правильно понимаю? Да-да-да, все верно. А Java они компилировали в bytecode? Нет-нет-нет, ребята. Они тоже это, по моему сортам, мерили, конечно. То есть они взяли какой-нибудь Spring, померили, сколько он весит в метрах, там исходники, напустили какой-нибудь анализатор. Интересно, они с библиотеками это мерили либо просто код, только без библиотек, своего приложения. И без рантайма. А тут написано так, изучив сотни тысяч программ, написанных на языках таких-то, таких-то, программ. Сотни тысяч. Пришли к выводу, что самые небезопасные языки это PHP, ASP и CodeFusion. Наиболее надежными оказались Java и .NET. Правда, C++ еще меньше багов на мегабайт имеет, чем Java и .NET, поэтому это утверждение выглядит странным. Слушай, а сколько интересно на GitHub C++, Java и .NET программ открытых? Я имею в виду сотни тысяч, наберутся они там, нет? Откуда они сто сотни тысяч взяли? На плюсах мне вот интерес. Нет, я думаю это всего разных программ. А, то есть это не на каждом языке сто тысяч. А, ну понятно. Нет, ну сотни же. То есть в каждом языке по сто тысяч взяли? Да, да, да. Всего сто тысяч программ написано в таких-то языках? Нет, они говорят не сотню, а сотни. А тут у нас всего десяток. То есть получается каждому по сто тысяч. В общем, вопрос так, видимо, останется нерешенным. Ну, короче, для тех, кто хочет набросить на RAST, можно кидать ссылку и говорить, что смотрите, в C++ нет проблем с безопасностью. Нет, надо кидать ссылку и говорить, а RAST здесь нет в этом списке, значит, в нем нет проблем, все отлично. Ну, лучший код, как известно, это ненаписанный код. В нем по предельнее может быть проблем. Поэтому RAST точно побеждает. И как раз в тему лучший код, ненаписанный код, это Java 9 не будет, да, я так понимаю? Вот я хотела сделать этот переход. Лучший язык, который не выпустили. Да, тут у нас грустные новости, Java 9 можно не ожидать. В 2016 году, правда. Тут сразу, чтобы всех успокоить. Ребята просто не успевают, я принес проект JXL, разделение Java машины на компоненты, которые можно собирать, он задерживается. Немножко пересисывайте там, по-моему, месяца на 3 или на 4. В итоге в начале 2017-го все будет именно готово к продакшну, как заявляет, опять же, Oracle. Что интересно, я не знаю, вот как раз хотел спросить, кто-нибудь пробовал, в Java 8 появились стейджи, если я все правильно помню, вы можете разделять Java машину на стейдж 1, стейдж 2, стейдж 3, это будет набор библиотек. Кто-нибудь пробовал пересобирать и использовать это? Я, кстати, ни разу не слышала про стейджи. Я что-то пропустила? Я, может быть, сейчас путаю, может, как не стейдж назывался, одну секундочку. Ну, факт в том, что на данный момент есть ЯАП-версия, Java 9 с проектом JXL, так что для тех, кто хочет попробовать, посмотреть, как оно, можно хоть прямо сейчас скачать и потрогать это. Кому не терпится. А тем временем, пока Паша ищет и смотрит, как это называется, у Саши есть тема про шапку. Да, это так. Коротенькая тема. Это интересная статья на Medium, автор Colt McAnlis. Автор Colt McAnlis. Статья про неисследованные области в области зажатия данных. Простите за кламбур. В предметной области зажатия данных. То есть, сначала статья начинается с такого небольшого обзора, что в целом алгоритмы сжатия ищут какие-то ну, не то, что компромиссы, но, например, берется какая-то задача, где важна очень скорость распаковки, и подбирается алгоритм, который максимально быстро распаковывает. А при этом внутри это, не знаю, классический LZ-77 с модификациями традиционными. И статья дает обзор направлений, в которых, по мнению автора, недостаточно было сделано исследований, которые ему кажутся перспективными. То есть, он говорит, что в области алгоритма сжатия данных есть еще куча вообще неисследованных. Например, есть такая проблема, что если мы возьмем последовательность данных, которая хорошо сжимается, а потом переставим в ней куски, может оказаться, что она сжимается уже намного хуже. Или вообще не сжимается. Легко представить, например, какой-нибудь бинарничек, в котором какие-то баитики, потом очень много нулей, потом опять какие-то баитики. Он очень хорошо сожмет с текущими алгоритмами. Но если мы вот эти нули разбавим данными из других мест файла, то он будет сжиматься уже довольно фигово. По мнению автора, это большая проблема, потому что что за фигня? У нас одни и те же данные, по сути, мы их немножко переставили, и уже не можем их сжать. Это проблемы, которые, по его мнению, заслужили изучение. Я сразу скажу, тут легких задач нет в этой области. Если бы они были легкие, их бы давно решили. Второе направление, это есть такой алгоритм, называется BWT, по именам авторов, трансформация Барруса Уиллера. Там идея в следующем, что для некоторых данных ты можешь применить вот этот алгоритм, у него есть такая особенность, что он делает перестановку байтов в данных, и можно сделать обратную перестановку. При этом тебе никаких дополнительных данных не нужно. Ты знаешь, что ты просто прогнал алгоритм в одну сторону, получил перестановку, прогнал другой алгоритм в другую сторону, получил оригинальные данные. Но при этом вот та перестановка, которую ты получаешь в результате, она намного лучше сжимается, как правило. При этом есть несколько моментов. Люди плохо понимают, почему это работает. То есть просто экспериментально доказано, что это хорошо работает. И вторая проблема, что этот алгоритм, он фактически единственный, и изобрели его как-то вообще случайно. Там есть ссылка в этой статье, ссылка на статью, где это описано. И по мнению автора, это тоже перспективное направление в алгоритме сжатия данных. Понять, какие еще есть алгоритмы перестановки, которые помогут сжимать данные более эффективно. И последнее направление, это вообще взрыв мозга. Идея заключается в следующем, что давайте писать алгоритмы сжатия, которые для конкретных данных будут генерировать программу, которая максимально оптимальным образом сожмет данные. Понятно, не только программы, но еще какие-то входные данные для нее. То есть мы фактически пишем программу, которая распаковывает саму себя в данные распакованные. И понятно, что для почти любых данных можно придумать программу, которая их довольно неплохо сожмет. Ну, если данные вообще в принципе как-то сжимаются. И эта область, она тоже практически не исследована. В качестве примера здесь приводится такая очень красивая картинка, которая на вид она довольно сложная, но генерируется она очень небольшой программкой фрактальным алгоритмом. То есть ее можно очень круто сжать. Вот такая обзорная статья. Если вы интересуетесь алгоритмами сжатия, я очень рекомендую ее к ознакомлению. Обещал, что это будет короткая тема, но он болтал минут пять. Но интересно. Да, статья прекрасная. А я вспомнил, как называется, прошу прощения, ошибся. Это называется не стейдж, а комплект профайл в Яве. Как раз-таки восьмой они появились. Вот, такое слышала. Но на практике не использовала. Ага. А я попытался однажды собрать эти самые комплект профайлы. И оно работает, но смешно то, что допустим, если вы хотите отправить почту из вашего актера или из вашей системы, то вам нужен профайл 3, то есть самый крупный из всех возможных. Потому что только там есть поддержка не сети, но каких-то более высоких примитивов явовских. Вот только там. И это было, в общем, бесполезный труд на данный момент. Но было интересно. А зачем, скажем? Ну, обычно я такой проблемы не испытываю. Ну, там больше у тебя джарка получается, меньше джарка. А, это не о джарке речь, это именно о JRE. То есть JRE тоже по ним поднимаешь, и так ты тащишь, допустим, 180 метров, а с ними ты там тащишь компактные, по-моему, метров 20 занимает. И это вполне можно вставить в любой очень маленький, маленькое устройство. А, то есть ты имеешь в виду для... Именно на runtime. Ты имеешь в виду, что для маленького устройства что-то программировал на Java, и поэтому ты хотел такую фичу себе. Да, совершенно верно. Ну, просто я с этим не сталкивалась. Я обычно, ну, большие серваки, там, Java стоит, и один раз поставил, ну и все. Само собой. Только учесть, что мы уже в мире контейнеризации, и вот этого всего, то вот накладные расходы, которые там везде складываются, если там 20 контейнеров напилишь себе, то... Но не все же пользуются контейнерами. Ты же понимаешь, что это не обязательно требование? Не обязательно. Это же зависит от того, как ты проект свой строишь, и надо тебе, это не нужно, это сам решай. Не-не-не, я не говорю, что это естественно в конечной степени. Я просто говорю, что и в большом интерпрайсе, там, или в каких-то таких вещах это тоже имеет место быть. То есть не обязательно устройство маленькое. Может быть просто из-за того, что у вас много Java, должны крутиться на одной машине, вам может понадобиться, чтобы вот runtime environment был покомпактным. За счет этого вы можете установить оперативную память. Вот, как-то так. Я отвалился. Нет, все вместе. Дальше про работу сисадминов и про тяжелое состояние сисадминов в эпоху контейнеров. Кто-то кроме меня прочитал эту тему? Признайтесь. А, вот, Ваня, расскажи нам. Рассказывает Сандра Хенри-Стокер про свой опыт работающего сисадмином с момента, когда она пришла и занималась перфокартами до текущего момента. Делится впечатлениями о том, как менялась техника, как менялись отношения людей, как менялись языки программирования, как менялось все менялось вокруг нее, что динамики стало больше и все стало веселее. И в конце дает некие как сказать, советы тем, кто выбирать себе профессию сисадмина или не выбирать. И в целом мне понравилось. Я имею в виду, оно очень близко к тому видению, которое есть у меня сложилось. Я понимаю, что администраторы, то есть я здесь с Умпутуном почти согласен, но немножко не согласен. Всегда будут люди, которые для больших корпораций поддерживают какие-то большие кластеры решения и так далее. И вот она как раз занимается подобным делом. Я не думаю, что эта область это наряд. Мне кажется, что тем, кто размышляет о том, стоит ли идти в это направление, им надо прочитать обязательно, потому что чаще всего молодые юные системные администраторы имеют очень оптимистичный взгляд на жизнь, а здесь все-таки более суровая реальность, чем у них может быть в голове. Я считаю, статью надо всем нашим службам прочитать. Во-первых, она довольно небольшая и очень легко читается. Во-вторых, она просто такая очень приятная и веселая. Меня, например, очень доставляли разные моменты. Я не помню, какие, но мне больше всего запомнилось. Бла-бла-бла-бла-бла-бла. В самом начале своей карьеры, в скобочках, то есть в первые 10 лет, я занималась тем-то, тем-то, тем-то. Представляете, как человек относится, что такое начало карьеры. То есть у нас 10 лет это уже все, это уже специалист. 30 лет пора в менеджера. Знаете, ребят, я работал там тоже во всех этих больших компаниях. Сейчас работаю. С одной стороны, да, хочется сказать, что зачем мы здесь нужны у системы анализатора, но на самом деле, окей, вы, даже вы все дружно перешли, мы все дружно перешли в облака, сидим такие, а кто в этом облаке настроит сеть? Прям возьмет и пойдет настроит SDN, настроит или не SDN, настроит маршрутизацию и так далее. Это прям свойства протоколов, это свои настройки, это свое понимание. Это первое. Окей. Окей. Я понимаю, о чем ты говоришь, и я с тобой согласен. Окей. Но идея-то, по крайней мере, насколько я понимаю, у Бутуна, у него в том, что чаще всего системных администраторов, больше всего системных администраторов не в крупных компаниях, а в маленьких, в которых эти обязанности может взять на себя обычный разработчик. Разработчик, наверное, должен код пилить. У него есть... Во-первых, у него есть другие дела, во-вторых, разработчики по моему опыту далеко не все круто админят, так что тут все очень спорно. Давайте дальше. А что дальше? Дальше твоя тема, Саша, про виртуозы рассказывай. Дальше моя тема. Тут на OpenEd прилетел обзор текущего состояния дел в проекте... Короче, есть компания Parallels, у нее есть разные проекты, например, OpenVZ и Parallels Cloud Server. И они пилят так называемые Virtuosa 7, которые объединяют эти проекты. То есть OpenVZ это контейнерная виртуализация, Parallels Cloud Server это такой дистрибутив Linux, который вот ты... В 6-й версии он платный, то есть ты его поставил с диска, ввел лицензионный ключ, и на нем ты можешь создавать контейнеры и виртуалки. Оно едет в Open Source, и когда Virtuosa 7 выйдет, это будет прям такой Open Source дистрибутив, на котором будет для создания виртуальных машин KVM, для создания контейнеров будет OpenVZ. И... Но тут обзор того, как проект развивается, не очень интересен, но интересно именно то, что у нас будет это все в Open Source. И в комментариях я задал вопрос, будет ли к нему какая-то web-админка, панелька, на что Сергей Бронников это... Как правильно называется? Community Manager. Он отвечает, что вот прям в Virtuosa 7 нету web-админки, но есть... Можно управлять всем этим хозяйством при помощи libvirt, к которому есть разные web-админки. Приводит ссылку. Тут я буквально прям в процессе записи успел ознакомиться. Это oVirt. Я сразу скажу, я ничем этим не пользовался, поэтому не знаю. oVirt, VM Manager. Это от ISP System. Она за деньги и за бесплатно умеет там типа две виртуалки или два хоста. И mist.io, судя по сайту, это вообще какой-то мониторинг, если честно. Но тем не менее, вот интересно, что вы обо всем этом думаете. Дайте угадаю. OpenVZ не нужно, LXC крутой, да, вот это все. Да. А ты сравнивал? Нет. Не читал, но осуждаю. Ну понятно. Импортозамещение, ты не понимаешь. Импортозамещение. То есть вот будем жить с VirtuOz и всем будет счастье. Я вполне понимаю, что у них может быть хороший продукт и все такое, но вот как бы я вот уже подсел на докеры LXC, я не знаю, виртуалбокс и так далее. Вот на самом деле вот есть киллер фичи у VirtuOz и системы PCS, да, как это правильно ПКС. Да, ПКС. Чтобы вот я все текущее убил, все свои настроенные скрипты и поднятое окружение убил и начал разбираться в VirtuOz и в ПКС для того, чтобы перейти. Если у тебя что-то уже есть в работе, то разумеется, не нужно это ломать и на что-то переходить. Так у всех есть. Простите, а вот есть докер, это просто настройка на LXC, поправьте, если не так. Ну возьмете в OpenVZ. Так и есть. Да, пилим еще под OpenVZ. Насколько я даже знаю, OpenVZ и LXC сейчас там в ядро внесли общую часть про виртуализацию какую-то контейнерную, договорились наконец-таки, ну не прямо сейчас, а в горизонте последних двух лет. И они очень активно пытаются все, что можно вообще положить в ядро, просто его в ядро не берут, потому что слишком много изменений, ну и как обычно в Open Source проектах, а вот да, конечно, крутой код, крутая фича, мы это хотим, но что-то код как-то хреново выглядит, вы можете его как-то по-другому написать, если вы в Open Source комиссии, там всегда так. Так видите, собственно, и в этом же, сейчас скажу, и недавно же даже по FreeBSD притянули патч, который дает базовую поддержку докера, чтобы докер мог работать, джейлы создавать, так что, почему нет? Я думаю, что докер сможет работать потенциально поверх OpenWZ. Конечно, я там глубоко не ковырял, я не настоящий сварщик, я эту маску настройки нашел, но почему нет? Если это будет работать, вопросов нет, можно попробовать. Но просто с текущих всех уже настроенных, как это правильно сказать, инструкций, скриптов уходить я большого смысла не вижу. Я вам могу сказать, что я технологии сравнивал, в смысле LXC и OpenWZ, с докером тоже игрался. Я остаюсь при своем мнении, что докер не нужен, потому что, если вы только не делаете паасы, а из нас очень мало кто делает паасы, LXC против OpenWZ, если ту функционал, OpenWZ, он реально сильно круче, примерно во всем. Но там всегда будут перфекционисты, которые скажут, там, ой, ядро старое, я не хочу, старое ядро на хвост системе. Окей. Окей, я с тобой не согласен, но поехали дальше. Вот мое мнение, что OpenWZ реально как технология контейнерной виртуализации дохрена лучше LXC. Так, а следующая тема, это, Свет, твоя. Моя? Это была волшебная тема. А, волшебная тема, действительно. Произошло чудо. У подкаста появились маркетинговые фишки. Вот, и первая маркетинговая фишка — это наклейки. Вот, таки получилось их распечатать с помощью другого человека. Вот, поэтому, если кому-то интересно, вы можете видеть меня на каких-нибудь там метапах, конференциях и прочих мероприятиях. Не стесняйтесь, подходите, я с радостью буду раздавать наклейки. Гофером раздала? Конечно. И много теперь в мире ноутбуков с наклейкой Девзанподкаст? Как минимум один есть. А, я догадываюсь, чей? Ну, отлично. Чей? Не мой. Нет, мой ноутбук чистый, там никаких наклеек нет. То есть ты перевела просто, подставила кого-то? А ты в офис приди пораньше, наклей все, при том, наклейки вы такие неотзираемые. Нельзя, тогда очень легко у нее уже не будет. На самом деле у нас на работе есть холодильник, куда клеят все наклейки из всяких конференций. И самое парадоксальное, что там больше всего этого гофера. Ну, тем популярным. Он просто забавный. То есть сразу скажем, что вот эта самая крутая фишка в Go, это их как это сказать, символ. Кстати, а наклейка-то много? То есть я видел фоточку Ну, их 30 штук. Ну, пока что, скажем, первая партия пробная, их 30 штук. При возможности отсыпить немного, ну там, ну когда будем пересекаться там мне, Ване, кому-нибудь. Знаешь, я вообще даже думаю, что не вопрос взять и письмом отправить. Я думаю, они даже дойдут. А вдруг не дойдут? А вдруг скроют конверт? Мне вспоминается фоточка, когда там, не знаю, у чувака украли пластиковую ложечку из письма или как-то так. У нас украдут наклейки. И вы там, прикинь, где-нибудь на почте, либо почте России, либо там в билпочте, у кого-то там Дезен. Это же тоже круто. Настоящие фанаты. Так, опять моя темка. Давай еще вот тоже про фанатов, постгресс. У меня, кстати, вот эта ссылка не открывается. 502. Она у меня открывается. Давай со мной тогда продолжим, вообще, поскольку мы уже начали вот это постгресс и и бонг, вот давай повбрасываем. Ну, а что жечь? Ну, окей. Ребята пришли и сказали, вот. Это же какого-то непонимания, что взяли... Ты опять, ну, как бы, извини, я тебя прервал. На Хабрахабре была опубликована статья, которая называется «Постгресс ноэсквей лучше, чем Монгодб?» В скомочках перевод. И вот, что мы о ней думаем. Думаем мы, что в очередной раз это наброс. Потому что базы данных, особенно базы данных, разные. Технологически внизу, то есть SQL и новый SQL, это, в принципе, разные подходы. Так сравнивать, ну, некорректно, скажем так, мягко говоря. Да, постгресс поддерживает JSONP. Да, к нему можно делать запросы. Да, это работает. Вопрос всего остального, это статья, скорее, обзорная, и он говорит, «Воу, вот у нас есть JSONP. Будем его использовать и будем что-то делать». По мере производительности, причем на Kiko синтетики, это инсерты, селекты, все. Ну, окей. Опять же, глубоко баз данных так, в современном мире, мерить, мне кажется, некорректно. Поскольку там есть... На первый план сейчас выходит уже не в производительность тупую, а параметры есть еще, там, отказоустойчивости, параметры, как она там, кластеризуется и поддерживается. Насколько там тяжело писать запросы, и можем ли мы делать что-то вроде MapReduce, допустим. Ну, как-то так. А я с другого конца зайду. Я понял, что в Rambler все на MongoDB, вот, тем не менее, я вот... Ну, ты ее так защищаешь, другой причины быть не может. Ну, у нас есть MongoDB, есть POSBUS, скажем честно. Вот. С другого конца захожу, что я общался с людьми из всем известной компании, то есть все слушатели про нее знают. И разговор был примерно такой, что у нас используется MongoDB, к сожалению. Я такой, типа, да? А почему к сожалению? Ну, потому что, короче, с ней все очень плохо, потому что большой жирный лог на базу данных, ну, в смысле, мы понимаем, что у них, типа, старая версия крутится, никто не спешит обновляться, как обычно. Потому что там данные теряются, потому что нету вьюх, потому что нет транзакций, и вообще мы вот страдаем, у нас сплошная боль с MongoDB. Я говорю, а что же вы ее используете? Ну, потому что админам нашим нравится, она зато, типа, отхазоустойчивая, и там между тремя дата-центрами рефлицируется, и вообще все очень круто. Отхазоустойчивая. Ну, то есть, ключевой момент, нашим админам нравится, но мы, программисты, страдаем. То есть, да, действительно, наверное, из коробки проще настроить отхазоустойчивость в MongoDB, но нужно понимать, что есть еще куча других фичей. И из этого... И это в том числе и в AtomArt, который в Монге у нас не очень есть, да, и не дай бог кому-нибудь попытаться сделать через Mongo синхронизацию как раз вот в кластере, и вы там получите, узнаете много нового о фантомных там чтениях и о том, что такое вариант консорн и как его варить. Так что да, есть специфик, само собой. Мне больше всего табличка, на самом деле, понравилась. Ну, то есть, понятно, да, что бенчмарк наверное немножко, может быть, подогнан, может быть, нет, надо мерить на своих запросах, на своем железе, и статью написали чуваки из EnterpriseDB, насколько я понимаю. Интересно, там Mongo 2.6.0.0.0.0. Ну, та, что везде используется. Отлично. Я тут, ну ладно, не для подкаста. Окей. Вот, а табличка интересная, там из разряда начала разработки у Postgres там типа на четырнадцать, сейчас скажу, на много лет раньше, короче, схемы в Postgres поддерживают и статическую, и динамическую, и, короче, там у Postgres'а, да, да, да, у MongoDB там нет, нет, нет, нет, нет. То есть, как бы по функционалу единственное там что-то... А, шардинг. У MongoDB простой, у Postgres сложный. Ну... Смотрите, вот идем, читаем, Postgres программированы на стороне сервера. И тут рассказывается, что Python, JavaScript, C++, TCL, Perl и многие, многие другие. Чтобы не соврать, по-моему, на Highload'е, это было в 2014 году, выступал как раз товарищ из Postgre, по-моему, на Highload'е, который показывал, как можно из одной хранимой процедуры там, допустим, на Python вызывать хранимую процедуру на Ruby, а из нее хранимую процедуру на Bash, ну, такой, ну, не рекурсивный, а просто вызов хранимой процедуры на разных языках написан. Все ниже, ниже, ниже. А вот, ребята, а вы-то часто пишете хранимые процедуры или функции на PostgreSQL сейчас? — Я довольно много пишу, и у меня был опыт использования вот этих других языков, которые кроме PL или PGSQL. Ты знаешь, иногда в некоторых задачах реально это нужно. То есть, вариант первый, когда у тебя реально много данных, и их быстрее обработаны на стороне сервера, чем гонять там на бэкэнд все время. Это мой любимый кейс. Еще в некоторых случаях у тебя кашируется план запроса, и поэтому его выгоднее опять завернуть в хранимку. То есть, иногда в этом действительно есть смысл. — Да, и вот если еще рекурсивный запрос применять, ты лучше можешь функцию написать. Тоже согласен. Но на каком языке ты пишешь свои хранимые процедуры или функции? — Ты знаешь, если бы я вот сейчас начинал проект, и мне нужно было выбрать язык, я бы, наверное, Python выбрал. Но поскольку это не так, то на PGP я лизкью елю. — Угу, окей. А как ты считаешь, поддержка очень многих языков, там, сотни, десятки, которые поддерживают Postgre, в качестве языков хранимых процедур, это благо или нет? — Ну, я считаю, что благо. Прикинь, у тебя проект на Python, и ты так раз, и можешь хранимки на Python, здорово же. — Ну, нет, потому что контекст разный. То есть просто не получится, это нужно понимать, что происходит. Я просто одно время довелось мне пописать подорога на PLSQL, и я могу тебе сказать, что нет, очень просто взять и начать писать под базу данных не получается, к сожалению. Нужно понимать, что ты находишься в транзакции, что сейчас происходит, каким боком тебе может это выйти. Немножечко с вариационных баз данных я могу понимать, я думаю, немножко не так. Не так красиво выглядит, как стараешься рисовать. — Ну, то есть ты в итоге что доказываешь? — Я доказываю point, что наверное, наличие миллиона языков, которые поддерживают, это не может быть кардинальным плюсом, и говорить, что «а, ну вот мы так, многие другие», — срагусси. — это прям, ну, было бы там несколько языков, хорошо, но вот все подряд туда тащить, ну, я даже не понимаю, почему Postgre это делает. — Не хочешь — не пользуйся, тебя же никто не заставляет. — Зигл и пост. — Да, пусть вводят лучше в периль аналог DBMS-шедулера какого-нибудь, вот что я давно вбрасываю ребятам, потому что ну как-то вот, совсем уже некрасиво. Ну да ладно. — Кстати, если не ошибаюсь, тут не указано, но есть поддержка Lua, и Lua, по-моему, сджит компиляции. То есть если тебе там нужно что-то прям интенсивно считать на стороне базы данных, то вот прям сджитом, прикинь. — Да, почему нет, ну, ладно, я запускаю. Вот. — А есть какая-нибудь статистика по поводу наиболее часто используемых языков для программирования этих хранимок для Postgre? — Тебе статистики сегодня не хватило, чтобы я это не понял? — Мало статистики, хочу больше. — Больше. — Ребят, простите, тут дальше есть отличная строчка, вот в этой же статье. «Бизнес-логика», в промо он говорится «Распределена по клиентским приложениям», а про Postgre говорится «Угадайте что». — Ну, либо-либо. — Да, «Социализованность триггерами и хранимыми процедурами». Или «Распределена по клиентским приложениям». Но тоже такой, можно немножко похалеварить на ту тему, что же лучше у нас, с триггерами и хранимыми процедурами или намазать на клиент «Бизнес-логик». Кто как считает? — Ой, слушай, эта тема, она недавно мусолилась в SD-касте. — Угу, вот только сегодня его слышала. — Вот, я, правда, рекомендую. Я лично за то, чтобы на стороне приложения по возможности, но там чувак довольно убедительно доказывает, что можно и на стороне сервера, и в этом есть преимущество. И я прям послушал и начал ему верить. — Он хорошо очень говорит, и вот тоже адский плюсуясь. Послушайте обязательно этот выпуск. Давайте вот добавим даже шоу-ноты. — Я пока ссылку добычу. — Вот, а что касается моего мнения, то на текущий момент в проекте у нас, в предыдущем моем проекте было очень много хранимых процедур, и вся логика была на, исключительно на этих хранимых процедурах. А потом настало время, когда, ну, базу уже больше некуда масштабировать, и дальше некуда. Ну, все, уперлись, и это становится, скажем, какие-то космические деньги начинают стоить. И после этого все прекрасно понимают, что хранимые процедуры не работают, и приходится все переделывать на другую, скажем, архитектуру, на, скажем, другого уровня все запросы будут абсолютно все иначе. И когда у вас вся логика хранится вот в этом, в процедурах, в триггерах, еще где-то, это очень сложно. То есть это сложно для понимания, сложно для вообще для версионирования, это сложно, неприятно, и это намного тяжелее для разработчика вот в этом во всем копаться, нежели, там, не знаю, разбираться в коде. Я предлагаю озвучить маленькую темку, перейти к тем слушателям, а потом добиться остальной, если будет время. Как вам мысль? Круто я придумал? Да. Маленькая темка про то, что там откуда-то среди-то прилетело, как называется, буллетин, как это будет по-русски? Бюллетень? Ну, да. На сайте Майкрософта о том, что в Майкрософт Офисе найдена критическая уязвимость, позволяющая выполнять произвольный код, ну, то есть как обычно, открываешь вардовый документ, и у тебя полная коллекция самого современного malware. Так что ждем патчик вируснее. Такая вот новость. А кто пользуется? Кто пользуется с чем? Ну, кто из вас пользуется Майкрософт Офисом? Причем здесь я? Ну, мне просто интересна статистика, мы же собираем сегодня. Ну, вот лично я и пожалуй, мои родственники не пользуются. Ну, мне приходится пользоваться. А у меня на работе куча коллег, которые работают на Windows, у них там и Офис, и 1С, и что угодно. Ну, то есть люди пользуются, если ты об этом. У меня родители пользуются прям каждый день, стабильно. Ну, простите, там вектор атаки-то, который указан, это вам присылают письмо, и вы должны открыть, ну, или каким-то образом вы должны получить этот документ и открыть его. Нет, нет, нет, там все проще. Ты ведешь рекурсивно по диску, и по всем самбам, и всему, что к ней присоединено флешкам, там, заражаешь док документы, и все, больше ты ничего не делаешь. Оно само развесится. Ну, то есть пользователь сам пошлет кому надо. Погоди, а можно вопрос? Как ты это сделаешь? Ну, ты malware-то сделаешь, не вопрос, который у тебя выполнится, но ты... То есть настолько низкий уровень доступа, ты можешь начать действовать как пользователь. Ты знаешь, у Microsoft у него очень подробные бюллетени, это сарказм. Ага, я понял. То есть там все очень понятно, и мы понимаем, что он просто еще раз... С примерами шалкода, да, прям steps to reproduce, все, короче. Можно прям во фреймах ставить, завтра соберу. Тема слушателей. Да, Света? Все, я теперь здесь. Давайте переходим к темам слушателей. И первая тема про Clojure Cup от Павла Драбушевича, нашего постоянного слушателя. И он спрашивает про то, когда мы наконец позовем Никиту Прокопова, который участвует в этом хакатоне, и когда он наконец-то нам расскажет про детали этого конкурса. Краткий ответ я не знаю. Ну то есть мы постараемся, если он будет нас слушать, пускай он нам напишет, мы его внесем в список и пообщаемся на эту тему. Дальше вопрос ко мне. Рассказать про C-Sharp, .NET и что-нибудь техническое. Как мне после скалы C-Sharp и вообще среда эта. Даже не знаю, что еще можно рассказывать такого. Ну, так получилось, что на проекте уже существовало много C-Sharp кодов. Этот выбор был сделан давно, и по каким-то историческим причинам так сложилось. Вот почему этот выбор был сделан в пользу C-Sharp и .NET, я пожалуй не смогу компетентно ответить. Что касается моих впечатлений, язык C-Sharp он нормальный вполне. Меня лично сильно бесит то, что методы приходится с большой буквы называть. Очень раздражает. Просто сильно не могу на это смотреть. Так принято? Так принято, да. Это код-конвеншен такой, что ты должен методы называть с большой буквы. Я думал только в Go такой. Нет, ну в Go у тебя же таким образом видимость переменных и методов обозначается. А там все методы с большой буквы, не важно, публичная или приватная. И это не очень удобно. Скажем, ну просто, вот мне что нравилось, когда ты смотришь на Java-код, у тебя по кейсу, ты можешь определить, у тебя там вызывается какой-нибудь вложенный класс, например, либо ну то есть просто визуально на код глядя, ты понимаешь, что у тебя, что вызывается. А здесь как-то становится, ну мне лично, может я не привыкла, но мне как-то сложно. То есть все-таки здесь вызывается что-то вложенная структура, либо все-таки здесь метод вызывается. Ну, мне не очень нравится вот эта история. Дальше, что касается Visual Studio, ну она без шарпера просто не юзабельна. Вот вообще никак. И этим пользоваться практически невозможно. И там доходит до того, что запустить тесты тоже оказывается невозможно. И может тоже как-то все-таки это в принципе сделать тоже как-то, ну есть какие-то способы для этого, я думаю. Но почему-то нет никаких там, не знаю, кнопок, что вот рануть просто нет такого тоже. Ну, то есть, мне на мой взгляд это довольно странно, хотя считается, что Visual Studio такая развитая среда разработки, но вот без этого довязка в виде ReSharper, который делает из неё нормальную ID, оно не очень юзабельно. Вот, поэтому, ну и в принципе тот факт, что мне приходится и использовать для этого виртуалку, чтобы полноценно разрабатывать и, ну скажем, не разрабатывать, а некоторые моменты фиксить и смотреть, как реализовано что-то. И для этого приходится держать виртуалку, и это тоже меня не радует. При этом у меня есть Mono, и у меня есть MonoDevelop, но оно называется наверное Ksamarin Studio. Вот Ksamarin довольно, ну, такая среда, ну этим можно пользоваться тоже, но не все проекты хорошо работают на Mono, и порой ловишь какие-то странные баги, вот поэтому вместо того, чтобы разбираться с этими багами, лучше поставить Visual Studio на Windows, всё как положено, и там будет уже нормально работать. Вот, но я не скажу, что я очень рада этой инфраструктуре, мне очень нравится мир .NET, я бы всячески хотела лимитировать моё общение с этим миром. Если кратко, то так. Дальше вопрос про то, что ведущие думают о Gradle Typing. Мы как раз немного сегодня затронули про MyPy Lang.org для питанистов. Да, было чуть-чуть, в целом, ну, как уже описывал, подсказки это хорошо, лучше подсказать, чем не подсказать, потому что особенно если вы пилите свою open-source библиотеку или комментируете что-то, потому что снаружи не всегда далеко понятно, от чего вы ожидаете, что вам прислали. Ну и плюс статический анализ развивается, и мы двигаемся к тому, что у нас появится возможность это проверять. Спасибо. Вообще тема интересная, потому что ты пишешь, например, на скриптовом языке, как на Python, пишешь без типов, потом, не знаю, например, ты решил, что в той библиотеке хочешь точно знать, какой там интерфейс в плане типов, или ты понял, что вот здесь у тебя может тормозить, и тебе хочется, чтобы интерпретатор, ну, может быть, компилятор, почему нет. Ну да. Вы как-то это место заоптимизировали, ты туда тип немножко написал, стало быстрее. Идея прикольная. Тут еще интересно, что в целом, нельзя сказать, что вы пишете без типов. Ну просто функция, потому что ваша рассчитывания на какой-то ход на генерик, но она рассчитывает. И еще раз, когда вы ожидаете iterable, вы не ожидаете, что вам придет дикт, ну, какая-то хашмап, да, или не ожидаете, что вам придет string, ну, string еще допустимо, но вы не ожидаете, что вам придет констант. Вот совсем вы этого не хотите. И вы ходите к генерикам, но вы просто, это как бы не явно, эти типы у вас скользят сквозь вашу программу, по факту, если посмотреть в корень. Не кажется так? Я насчет скользят не понял. Ну, имеется в виду, что вы пишете функцию, и вы, вот сам внизу какая-то функция, она, допустим, берет и делает, разворачивается список в обратную сторону. Вы не ожидаете, что вам сюда придет генератор, вы не ожидаете, что сюда придет константа какая-то, правильно ведь? Ну, допустим. Допустим. Соответственно, вышестоящий код, он может, вы где-то там делаете какие-то преобразования, и получилось, что у вас вышла константа, и вы ее случайно туда прокинули. Но, вот, типы здесь, как хочешь, не хочешь, а пригодились бы. Правда ведь? Согласен. Поэтому у вас все равно тип, он как бы есть. Он все равно, код исполняющий, он ожидает, что перемены будут какого-то типа, они будут имплементировать какое-то поведение. Может быть более общее, да, там, а не конкретное. Но все равно они должны что-то, какой-то интерфейс в целом. То есть нет функции, которая понимает вообще все, и сделает с ней что-то. Типа это хорошо, да. Вот и ложим, мыслимо. Ну, просто есть такой главный вопрос, вот к питонистам, в принципе. 42. 42. Можно ли вообще на питоне писать большие проекты? Да, 250, по-моему, тысяч строк, это SMS, Plon, Pluzop. Я не знаю, сколько это много. Если соотносить, что в среднем выразительность питон-кода считается к C как 6 к 1, то есть одна строчка питон-кода в среднем равняется 6 строчкам на C, то можно считать. А сколько там тестов написано? Вот вопрос. Я, честно говоря, не считал, но это вместе с тестами. То есть, наверное, очень большая часть этого всего добра написана именно тестами. Я думаю, что да. Почему нет? Вот, скажем, и возникает вопрос, а есть ли смысл и насколько это вообще разумно писать на питоне большие проекты? Вы знаете, разработка на питоне идет со скоростью мысли. Вот хочется быстро запроектипировать что-то и посмотреть, получится или нет. Ты пишешь быстро, я тут не спорю, а когда у тебя команда большая и есть текучка, например, то, мне кажется, из-за того, что питон динамический и у тебя могут возникнуть намного больше проблем, нежели статически типизированным. А задачи бывают разные. Если у тебя типичный веб и тебе нужно выкатывать кучу фичей и просто смотреть, пользуются ли они, нравится, не нравится, пользуются, не пользуются, может они пользуются, не знаю, раз в год, то тебе намного важнее быстро накатать фичу и отдать ее. А если она там начнет тормозить или в ней будут баги, то ты можешь ее всегда откатить, например, или, ну не знаю, если тормозит, то переписать на C и так далее. А еще можно, в принципе, спасаться через фреймворки. То есть фреймворк дает, опять же, понятные точки расширения чаще всего, и в принципе есть наработанная практика, как что-то делается. Почему нет? То есть я думаю, что я уверен, что одному человеку, кто писал на спин фреймворк, в принципе, без минус будет понятно, куда смотреть в коде другого человека на спин фреймворке. Нет? Нет, здесь же идет вопрос скорее про типы, а не про то, что в проекте сложно разобраться. Сложно разобраться будет так или иначе. А так у тебя, в принципе, есть типы, и ты гарантированно не передашь функцию то, что эта функция не ожидает. Окей, согласен. Понятное дело, что чем больше проверок мы можем сделать на этапе компиляции, тем меньше проблем может получиться в рантайме. В итоге получается, что ты вместо того делаешь работу компилятора, которая, в принципе, может тебе быть из коробки, но ты будешь делать это тестами. В чем-то да, в чем-то нет. Ну, в чем-то есть и некоторая вещь, которая достаточно очевидна, и где-то можно пропустить. Окей, кто-то, по-моему, опять заснул. А следующий вопрос наших слушателей. Точнее, тема это про Kotlin. То, что вышла третья бета. Да, мы порадовались. Это очень хорошая новость, но мы идем дальше. Дальше вопрос длинный. С одним голосом. С одним голосом, но он у меня подсортировался высоко. Я не знаю, как это работает, но почему-то он у меня идет высоко. От слушателя SayMyName. Идея какая? Вопрос про бэкап. Скажем, у вас есть папка с фотками, и у вас есть, например, какой-то облачный сервис, куда синкаются эти фотки. Есть, например, Hard Drive, куда вы тоже периодически что-то синкаете. И как вы боретесь с тем, что ваши фоточки, скажем, закарабтились? То есть, где-то там байтики поменялись, попрыгали не туда, и все стало плохо. Как вы боретесь? Я лично никак не борюсь с этим. Подумаешь, одной фоткой больше, одной меньше. Вы знаете же эту историю про бэкапы, что люди делятся не на два типа, те, кто делают бэкапы, и не делают бэкапы, а на три типа. Те, кто делают бэкапы, те, кто не делают бэкапы, и те, кто эти бэкапы регулярно заворачивает. Ну, очевидно, что у вас есть некий источник данных, и вы с него делаете бэкапы, стоит эти бэкапы пытаться хотя бы поднимать, смотреть, что там внутри-то есть. Потому что может история заканчивается плохо. Других вариантов я лично не вижу. Ну, можно еще контрольные суммы какие-то делать, но опять же, поскольку у вас в карактисе источник данных, то есть начальная часть потока данных, то единственный способ это проверка регулярно. Есть еще один способ, это ты можешь скоренить историю изменений. Да, ну, вполне себе. Но это скорее как мы делаем диф-бэкап. Мы же можем делать диф-бэкап, да, и инкрементальный бэкап, и все, и его хранить. Потом по нему откатиться, да, можно. Но так, по-моему, делают более-менее крупные все системы резервного копирования. Ну, как они Бакуло там делают, точно. Ну да, то есть можно не по-моему это делать, а полагаться на ту систему, которую ты используешь. Так вот, если говорить про Corruption, то тут в рассылку PostgreSQL товарищ Томас Вондров прямо в pgsqlhackers.postgreSQL.org написал прекрасную вещь. Silent Data Loss with X4. All Current Versions. И написал он следующее, что, ребята, вы знаете, а мы можем взять и просто потерять все свои данные на вполне себе работающий PostgreSQL. То есть он просто работает, и бац, и нету ничего. Но при одном условии, мы выключили питание. Оказалось, что эта проблема находится на стыке PostgreSQL и того, как он пишет ValLog. ValLog, это для тех, кто не знает, это, я так понимаю, лог транзакции, да, у нас в Postgre. И происходит буквально следующее, когда у нас происходит ротация ValLog, мы это делаем через переименование и дергаем в syscall. Но этот syscall обновляет сам файловый дескриптор вот именно файла, но не обновляет, не заставляет файловую систему обновлять дескриптор директории. И получается, что директория в Linux не видит, что произошло переименование. И при включении питания вы получите стейт, приведущий до переименования, и у вас ValLog, пардон, рекавери пройдет отлично, вы просто получите старые данные. По-моему, это шикарно, лечится это включением data. journal в опциях монтирования вместо default.data.ordered и он даже вот, прям это большое письмо на две страницы убористого текста на маке с применением всяких примеров и возможно сeptoreproduce даже с патчем, чтобы не соврать, и с сифным кодом. Прямо так. Серьезно все. Нужно отметить, что это я не уверен, сказал ты или нет, это не то, что баг в Postgres, это баг, наверное... Это баг дофига где, который обсуждают в рассылке Postgres. И да, файловые системы нужно тюнить под базу данных. Да, и это нужно понимать, но просто это неожиданный баг, то есть вы берете стандартную, дефолтную поставку своего системы операционной, вы надеетесь, что в принципе там разработчики системы понадеялись, означает, что вы рассчитываетесь получить свои данные в каком-то консистентном состоянии, ставите базу данных, рассчитывая, что разработчики понадеялись получить систему в консистентном состоянии, в случае чего. И оказалось, у семерых нянек дитя безглазуют, что а вот раз одни не подумали, и другие не подумали, и все развалилось к черту. Очень такое тоже интересная новость. Лично мне кажется, что это очень неявное поведение именно в Ext4, то есть не очевидно, что в журналируемой файловой системе переименование каталога не журналируется. Да, но там интересно, что это связано не просто с файловой системой, а с определенным системным вызовом, что постгару себя вызывает не fsync, а вызывает... The problem is that while the rename is atomic, it's not guaranteed to be durable without an explicit fsync on the parent directory. То есть смысл в чем? Ренейм у нас атомарный, но это не значит, что у нас fsync будет дернуться. Вот. И они по дефолту делают fdataSync, то есть это вот интересно. Что непонятно, кого винить. И это тоже история в чем-то похожа на предыдущую про товарищей, которые жаловались на Монго, что они взяли драйвер с постгара. Здесь вот товарищи из постгри жалуются на Кернел, ну не на Кернел, а на разработчиков файловой системы. Вот. Такие дела. Все, у кого стоит постгар, на Linux и на x4 советуем проверить, что у вас либо две ветки питания, либо вы правильно савантируете свою директорию. Где у вас лежат ваши данные и в all.log конкретно. Еще я хотел бы осветить маленькую темку и пытался ее как-то связать плавным переходом, что все надо дебажить и проверять, но что-то как-то не получается. Это с резид с r.freebsd прилетела ссылка на старое-старое письмо Линуса Торвальдса 2000 года, сентябрь, про то, что Торвальдс против отладчиков. Может быть это баян, но я вот не видел, и мне было очень интересно. Да. Ты знаешь, я вот в курсе этой истории про Торвальдса, что он против отладчиков, потому что он считает, что отладчики это боль, причем я в курсе тоже не по собственной инициативе, у меня просто один знакомый в одной закрытой организации разрабатывал специализированное гидрооперационную систему. И он периодически рассказывал о всякой боли и говорит, что он в чем-то понимает Торвальдса, потому что почему у отладчиков зло, потому что ты перед тем, как... То есть отладчик, как любой тулинг, дает тебе некую иллюзию того, что может что-то быстро поправить или что стоимость твоей ошибки низка. Вот, я вкратце расскажу письмо Торвальдса. Он как бы начинает свое письмо с того, что все говорят, что отладчики это хорошо, потому что с их помощью можно всегда все отладить, все как-то более наглядно, и вообще инструмент удобный. Если бы у нас не было отладчиков, то представьте, у вас какая-то ошибка, система крашится, перезагружается, ну, это 2000-й год, поэтому тут написано, что у вас начинается медленный тормозной FSCK и вообще там куча времени потрачено. Вот, но никто не объяснил мне Торвальдсу, почему вообще это плохая вещь, почему это обязательно недостатки. Вот, смотрите, у вас, не будь у вас отладчика, вы бы писали код осторожно, вы бы писали его вдумчиво, и вы бы писали вообще в целом простой код и пытались сделать его надежным, потому что, вот, не будь у вас отладчика, вы бы не надеялись на то, что, ну, если крешнется, ничего страшного, там, подрубимся, отладим и так далее. Вот, такая очень глубокая мысль. И да, еще тут где-то два абзаца про то, что я, Линус, совсем недобрый парень, и я вообще никого из вас не люблю и как бы не обязан, поэтому да, я такой грубый, я такой, какой я есть. И вообще, если вам тяжело писать ядро Линукса, ну, как бы, это не моя проблема. Вот. А теперь давай вернемся к твоему знакомому разработчику из очень закрытой организации. Не получится, Наташу. Ааааааааааааа. Вот я хочу добавить по поводу, Саша, твоего твоей речи. Последний, который касается отладчиков. Это, конечно, работает, но почему-то все говорят, что отладчикам пользуются те, кто написали свой код и не могут в нем разобраться.",
    "result": {
      "error": "API request failed: Error code: 400 - {'error': 'Trying to keep the first 14285 tokens when context the overflows. However, the model is loaded with context length of only 4096 tokens, which is not enough. Try to load the model with a larger context length, or provide a shorter input'}",
      "stack_trace": "Traceback (most recent call last):\n  File \"/home/andrei/Projects/podcast-shownotes/scripts/build_search_eval_dataset.py\", line 157, in generate_search_query\n    response = await self.client.chat.completions.create(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/resources/chat/completions/completions.py\", line 1927, in create\n    return await self._post(\n           ^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1767, in post\n    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1461, in request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1562, in _request\n    raise self._make_status_error_from_response(err.response) from None\nopenai.BadRequestError: Error code: 400 - {'error': 'Trying to keep the first 14285 tokens when context the overflows. However, the model is loaded with context length of only 4096 tokens, which is not enough. Try to load the model with a larger context length, or provide a shorter input'}\n"
    }
  }
]