[
  {
    "segment_id": "e9ce68f5-57ae-4812-8624-a37e9f7c752e",
    "episode_id": "b78cdd95-8893-4e69-9adf-b026215c0cb8",
    "episode_number": 446,
    "segment_number": 7,
    "text": "Вот то, чему я научился на этой неделе. Спасибо. У тебя следующая тема была про PgBouncer. Это новость одной строкой. Зарелизился PgBouncer 1.21. Напомню, это connection pooler к Postgres, один из наиболее популярных, если не самый популярный. Второй – это PgPool. И в этом релизе заявлена поддержка prepared statements. Они так и написали, по-моему, в релизе. И здесь написано, что PgBouncer 1.21 – тот самый prepared statements. Раньше это не работало, потому что когда ты создаешь… У тебя проблема, что prepared statement привязан к сессии. Если ты ходишь через PgBouncer, он на каждый… Кстати, это хороший вопрос, что там происходит с транзакциями. Транзакция, я так понимаю, он умеет перевести, да? Транзакция, я так понимаю, он умеет прибивать к конкретной сессии, как будто бы begin, commit, rollback и код ошибок несложно пропарсить. Но я не уверен, я не настолько активный пользователь PgBouncer. Но prepared statements не работали, потому что на каждый следующий запрос тебя могут направить в случайный backend, в случайную реплику. Теперь они это как-то научились хендлить, как для меня остается великой загадкой. Но если вы хотели использовать prepared statements через PgBouncer, то вот версия 1.21 это занесли. Ты, Валера, сталкивался с такой проблемой? Я, мне кажется, ни разу не был с PgBouncer. Ну, потому что ты ирландист, и у тебя все встроено. Да, у меня пулы встроены. Не только ирландист, в принципе, то же самое в Java. Гофер. В Java. В Go, в Java все языки, кроме... В Java нифига. Java... А, ну, в принципе, ты можешь... Я понял. Ну, короче, все, что не PHP, условно говоря. Ну, я думаю, да. В Java, в принципе, можно исхитриться, но, мне кажется, в Java уже может иметь смысл. Ну, там смысл есть. Мне кажется, в Java идея такая, что если ты... Ну, насколько я понимаю, если ты пишешь на Java, в смысле, у тебя язык программирования Java или Scala, но вот ты используешь какой-то инструментарий, который не основан на Java, а на чем-то очень глубоко ремном и проклятом, то у тебя все хорошо. И ты можешь испытать некоторые проблемы тогда, когда ты используешь какие-то вот старые проклятые технологии. Вот. И поскольку я не писал на проклятой Enterprise на Java никогда, то, соответственно, мой опыт с JVM и PostgreSQL, он довольно позитивный. А... Вот нам слушатель... Спасибо большое, слушатель Серж, пишет, что... Пиджи Баунсер следит за транзакциями и прибивает... В смысле, прибивает гостями к, видимо, тому, где использованы стейтменты. Prepared statements. Нет, это комментарий... Ты ошибся. Это комментарий про транзакции. Я сказал, что не был уверен, что там с транзакциями. Вот комментарий такой, что он трекает транзакции и пинит сессию к коннекту пользователя, в смысле, к ПК-баунсеру. Угу. Что ж. Тогда у тебя еще одна тема одной строкой. Дорогие, это просто комментарий вот на тему труда в E-будни разработчиков опенсорса. У PostgreSQL есть документация, а еще у него есть транзакция Rapparound. В документации было сказано, но дословную формулировку не помню, но посыл такой, что вот у нас есть 32-битный XID, и есть... Ну, и они время от времени должны освобождаться, и соответствующий счетчик в базе данных увеличивается. Но если у вас так получилось, что израсходовались все доступные XID, а старые не освободились, такое возможно, например, есть. Вот я... Это самый простой способ воспроизвести XID Rapparound. Открываешь одну транзакцию на запись, то есть там буквально делаешь update одной... таблице. Одну сессию открываешь, делаешь begin, обновление одной таблицы, и куришь бамбук в этой транзакции, в этой сессии, больше ничего не делаешь. В это время в других транзакциях израсходуешь XID. Освободить XID, выделенной первой транзакцией, нельзя, потому что она все еще исполняется. И в какой-то момент твои транзакции на запись встанут с ошибкой, что, простите, мы не можем заалансировать новое XID. Так вот, в документации было сказано, что когда в системе происходит XID Rapparound, то все идет в крифе, в косе, и данные теряются, и паника, и все очень плохо. Я не поверил в свое время, решил проверить, оказалось, что это не так. На самом деле все не слишком плохо. И, по-моему, в подкаст я это приносил, но повторюсь. Приносил, приносил, совершенно точно. Я помню, потому что это был подкаст, который не было, который я слушал, гуляя по Барселоне. Вкратце. Во-первых, XID не нужны транзакциям, которые просто читают данные. Просто вот select сделать, и XID нафиг не нужен. Потому что иначе у тебя не работало бы чтение на репликах, например. На реплике они, в принципе, не могут ничего, ну, менять состояние базы данных. Поэтому если транзакция может быть исполнена на реплике, ты точно знаешь, что ей не нужен XID. Ну, в фонтексе есть прям функция «выдели мне XID». Если ты сделаешь из нее select, то считай, что твоя транзакция – это транзакция на запись. Плюс к этому. Допустим, у тебя случился XID wraparound. В этом случае база данных не падает, данные не теряются, ничего не происходит. У тебя… Ты не сможешь создавать новые транзакции на запись. Транзакции на чтение работают превосходно. И опять же, на тех же репликах никаких проблем. Кроме того, чтобы починить XID wraparound, в документации было написано, что вам нужно выключить систему, включая мастер, обязательно downtime, перевести ее в single user mode, выполнить волшебные команды, короче, какие-то телодвижения, потом ее запустить, и вот там. Реплики должны это подсосать еще. Ничего этого делать не нужно. На самом деле тебе нужно, например, поприбивать те, которые держат XID, из-за которого нельзя старые XID освободить, и тогда у тебя все пройдет. Вот. Оказывается, ты приходишь в сообщество и говоришь, что в документации написано одно, а я проверил, на самом деле происходит другое. И тебе говорят, да-да-да, мы знаем это уже пару лет так, мы просто что-то забили, документацию поправили. Но все нормальные DB это, конечно, знают. Ты такой, окей, хорошо, давайте поправим документацию. Вот. И в целом тема про то, что эти исправления приняты, теперь документация в PostgreSQL правильная, но, блин, это заняло 10 месяцев. То есть это мое нытье про то, как в PostgreSQL все медленно и сложно, поправить пару абзацев документации занимает 10 месяцев. А иногда ты хочешь сделать какой-нибудь патч посложнее, там, я не знаю, переписать slr.io.cache или сделать вообще 64-битные ксиды, чтобы ксидер аппарат случался реже, или там, не знаю, заделить, как это, грубо говоря, впихнуть theson в кору. Понимаете, да, это задачи несколько более сложные, чем поправить три параграфа текста в документации. Можете представить, сколько они времени, сколько времени меня занимают. Такие дела. Я просто поныл. Спасибо. Пожалуйста, Саш. Что ж, настало это время темы слов для выпуска 4.4.6. У нас там всего целая одна тема от слушателя Конра Джелл Гилетти. Извините, я могу неправильно вас читать. В общем, про то, что вышла новая Node.js, из интересного появился экспериментальный флаг, который все файлы без расширения и начавшиеся на слэш 0 асом будут восприниматься как важным.",
    "result": {
      "query": "PgBouncer 1.21 prepared statements support"
    }
  }
]