[
  {
    "segment_id": "f82dc4c2-08dd-4ab9-9489-41dd16221c73",
    "episode_id": "7826c4d6-19d2-46f9-9ee6-e074814adc7e",
    "episode_number": 393,
    "segment_number": 11,
    "text": "И есть тип как сум, то есть сумма, когда ты можешь сказать либо то, либо это, то есть в husky или это там какая-нибудь monada either, вот left или right. А здесь это и выступает янум, когда ты можешь сказать, у меня как бы вот есть янум, в нем там пять кейсов и соответственно значение будет один из этих кейсов. Есть в каком-то виде pattern matching, он не так идеален как варланги, но тоже можно что-то делать. Есть generic, то есть параметрический полиморфизм и фактически это все вместе дает алгебрические типы данных. Показываешь как скала. А? Показываешь, что это похоже на скалу, наверное. Ну да, да, скала по мощнее, наверное. Не знаю, я на скале не программировал, мне тяжело сравнивать. Вот, и я из этого, я вообще люблю языки, в которых есть алгебрические типы данных и они позволяют делать очень классные вещи на очень простом уровне, когда ты можешь довольно легко, вот с помощью вот этих продуктов, продуктов, сумм, ты можешь сделать сложную вещь и она будет понятна, она очень хорошо лжется на то, что тебе надо сделать, то есть как бы вот на бизнес логику. Вот, но при этом есть очень такие не понятные, не очевидные вещи, которые ты не понимаешь с первого взгляда. Вот, к примеру, нил. То есть вот нил, он такой для всех программистов, такой достаточно понятной вещь, то есть это как бы нил, а логично, что это отсутствие чего-либо. Ни фига не понятная вещь в искреле. Да, ну вот как бы, когда ты, когда ты видишь в языке, что написано что-то там, что-то что-то равняется нил, ты понимаешь, но это значит этого чего-то на самом деле нет. Когда ты начинаешь думаться с этого, с про нил с точки зрения типов данных, алгебрических типов данных, в голову сразу приходит вот эта вот хаскель идея optional. То есть как бы у тебя maybe что-то есть, а может быть нет, у тебя тогда будет нил. Вот, и оказывается, что да, на самом деле в свифте есть такая вещь, как optional. Вот, ну давайте сначала про нил. Нил на самом деле проник очень глубоко в язык. То есть когда вы, например, делаете преобразование из строчки в integer, это надо написать int в скобках, там в кавычках единичка, вот, вы получите не тип int, а вы получите тип, это как бы может быть int. Вот, и соответственно это тоже у тебя может быть нил, а может быть integer. Это как бы уже получается у тебя в компиляторе поддержка всего этого есть. Вот, соответственно вот этот вот может быть int, он описывается с помощью int знак вопроса. То есть у тебя даже на уровне синтаксиса есть этот нил. То есть если у тебя int знак вопроса, то может быть либо int, либо нил. И автоматически это получается такой, как бы что-то вроде optional. Есть, соответственно, поддержка, это вот преобразование из может быть int в настоящий int. Называется unwrapping, forced unwrapping. Когда ты ставишь знак восклицания после этого, после переменной. То есть если у тебя переменная a имеет тип int знак вопроса, то получается, что после переменной a знак восклицания не ставишь, и у тебя она превращается в int, а если там был нил, то ты получаешь runtime ошибку. Вот, есть классная такая штука, как optional binding. То есть ты говоришь, если let новая переменная равняется вот в этот вот int знак вопроса, и ты заходишь в если только тогда, когда у тебя там не нил, и ты автоматически определяешь эту переменную, которая там в условии стоит. Это вообще удобная конструкция, классно сделана. И соответственно, новая переменная, она будет только внутри этого блока if. Снаружи она не будет видна, ее как бы там нет. Есть чейнинг. Это когда у тебя, например, структура машины может быть, содержит второго, как его пассажир, он как бы может быть, а может не быть. У этого пассажира может быть, а может быть не быть сумочка. Ну вот если вот такие вот построить модели данных, и все эти вещи можно сделать через чейн, такая цепочка обращения. Соответственно, в машине точка, второй пассажир, точка, может быть сумка, точка, может быть сумки, кошелек. И вот все вот эти вот может быть ставятся через знаки вопроса. Если у тебя на любом этапе нет такого объекта в этом, в том объекте, ну то есть как бы в этой машине нету второго пассажира, вот. Или у этого пассажира нет сумки. У тебя на любом этапе возникает нил, и у тебя как бы в результате выражения получается нил. И вот эта вот вся цепочка на каком-то этапе обрывается, и вот тебе говорится, нет, такого у тебя нет. Очень удобная штука. Знак вопроса, точка, это значит, что может быть есть, а если есть, то давай-ка мы попробуем у него что-то вытащить. Вот, это штука получается, вот этот нил, его работа с нилом, она определена в языке очень глубоко. Вот есть куча всяких-таки вещей. И поэтому, как бы, вот я когда на это все это смотрю, у меня есть ожидание, какое после этого, что значит наверняка в языке есть такой тип как optional. И у этого optional, nil, это второе значение. Ну вот как в хаскеле есть maybe что-то, а есть nil, и значит здесь optional, это тоже nil и какой-нибудь там maybe. Вот, а оказывается, что нет. Оказывается, optional тип есть в языке, но он на самом деле либо non, либо some и соответственно значение этого some. То есть, как бы, у тебя либо отсутствие, это non, либо some что-то. И nil, это получается просто такой, как бы, синтоксический сахар, который внутри себя обозначает, что это как бы optional. Почему вот так было сделано? Я не могу сказать. Потому что nil проще писать, чем non, потому что пользователи привыкли говорить слово nil, а не non. Потому что для того, чтобы сказать non, тебе надо там ставить, что это optional.non или просто .non, потому что в языке нельзя написать. Я еще подозреваю, потому что Objective-C и соответственно в runtime Objective-C nil это была волшебная штука. Да, либо идет из Objective-C. И получается, что вот эти вот все, как бы, вся эта предыстория, она очень сильно влияет на язык. И из этого получается, вот как бы, я знаю хаскель, знаю ирланг, и знаю, как теоретически с типами данных работать, я вижу, когда я вижу nil, у меня есть, у меня складывается какое-то впечатление, что я должен увидеть в описании типов данных. И когда я вижу что-то другое, оказывается, что это совсем не то, что я вижу. А nil просто протащили в язык, как некоторые ключевое слово. Хотя необходимость в этом ключевом слове, ну вообще говоря, отсутствует, если просто с нуля складывать. Но получается, что пользователям так было удобнее, так добавили. И в принципе с ним работать очень удобно. Я прям получаю наслаждение, когда вот... Вот option-C. Резюмируя, он всегда является optional. Тебе не может получиться так, что ты нигде не использовал optional, а приехал nil. Там такого быть не может. То есть ты не можешь сравнить переменную a с nil, потому что думаешь, а вдруг там ничего нет. Если у тебя переменная a optional, тогда ты можешь. А в общем случае, как бы, если это int, то тебе компилятор скажет, слушай, у inta не может быть nil. До свидания. Скажешь, что сделал удачнее, чем в скале с null. А в скале что? Ну в скале у тебя есть optional, а есть null. И это меня в секрет очень забавляет, когда про скалы говоришь, что там более типа безопасное, потому что как только ты начинаешь обмазывать какой-то джавный код скалой, тебя тут же просто null отовсюду вылезает. Приходится очень аккуратненько обмазывать optional. То есть у тебя есть optional, а есть у которого nil тоже некий аналог? Нет, нет, там optional это sum и none. Как привычно везде. Но есть джава, из которой торчат null. Ты можешь сказать option от чего-то, что возвращает null, и оно автоматически конвертнёт. Но если ты не сделаешь этой конверсии явно, типа если ты не попытаешься обернуть optional, то tnil, который и npe вылезти. Очень удобно. Ну в смысле, это сарказм был. Но как бы в защиту надо сказать, что ты видишь, что вот здесь у тебя указатель, а нет, гоню, там же нет указателей. Короче, то, что нуперитивный тип, всё указатель. Характерно, что в теории, вот там, где ты ожидаешь option, тебе может прийти nil. А, да, да, да, потому что это очень офигенно, потому что option тоже является джавным объектом. Привет. На самом деле и в свифте есть подобная штука. То есть, когда у тебя, например, есть option option, ну, например, у тебя есть какая-то функция, которая написана на generic, и она возвращает value как generic со знаком вопроса. То есть, может быть, возвращает value, а может быть, не возвращает value. А если сам value является тоже optional, то у тебя получается два option для одного типа. Понимаете, о чём я говорю? Нет? Не понимаете? Ну, например, у нас есть пользователь... Я понимаю, о чём ты говоришь, но неужели там нельзя сказать, нельзя сделать ограничение на data value? Наверное, да, можно сделать ограничение, и более того, можно даже в коде написать. Ты же можешь всегда оперировать уровнями, что это non типа int<|id|> и ты такой, блин, я что-то не понял, чего меня за нил пришёл, и надо как бы готовиться к этому. Но это не тот уровень, когда у тебя, может, придёт non, а может, тут приходит null. Ну это ещё, конечно, с калей совсем неудобно. Ну и как-то вот так. Вот такая вот тема. Я кучу ссылок принёс в show notes, я везде всё обставил ссылочками. Если хотите поглядеть, почитать, пожалуйста, смотрите. Честно говоря, вот то, что я услышал, звучит довольно проклято. Почему? Почему? Не знаю, а зачем мне две сущности? То есть я услышал, что у тебя есть указатели, а есть optional, или я что-то упустил? Не, не указатели, есть null, есть optional. Optional это на самом деле способ работы с нилом. Насколько я понимаю идею, вот этот non, который является частью optional, его на уровне синтаксиса, то есть как бы сахарочка языка, его превращают non, превращают в нил, и нил превращают в non на уровне синтаксиса и сахаросинтаксиса. То есть ты можешь писать так, можешь писать эдак. И это путает только тех, кто пришёл из другого мира. Я так понимаю, что это было создано для людей, которые пишут, писали на objective-c, потом пришли в свист, и из-за этого проще. Да, это добавляет сложности к пониманию. Но как бы после того, как привыкаешь, я вот non в чистом виде не писал ни разу.",
    "result": {
      "query": "Swift nil optional explanation"
    }
  }
]