[
  {
    "segment_id": "7240b6ad-a45e-47df-9aa1-a66e18609d0b",
    "episode_id": "101671ec-db5e-4cca-b167-ee917b8ab2b3",
    "episode_number": 120,
    "segment_number": 6,
    "text": "А следующая интересная тема, это тема от Ферд. Ферд, это как его полное имя, ребят? По-моему, его зовут Фред, по-моему, Хьюберт, или как-то так. Ферд, это как бы, ну, он себя так пишет, и не знаешь почему. Да, и тема, в общем-то, мы всем знаем и любим Фреда за то, что он написал Learned Samarilink, написал Erlang and Anger, и собственно, он очень быстро из... как это там? Из никого? Нет, я даже не хотел сказать, после написания Learned Samarilink, окончания этой книги, он очень быстро ушёл в, скажем так, гораздо более полезные книги по языку Erlang и вообще, ну там, очень много вещей, которые имеют отношение не только к Erlang, а в целом к любым системам, где есть эти очереди. У него было много блокпостов по этому поводу, было много докладов, вот, собственно, он написал Erlang and Anger, половина которой применима, мне кажется, не только к Erlang. И немаловажный в этом момент, что он эти знания накапливал, в принципе, он доклад постепенно просто, у него был такой стандартный доклад, который он рассказывал раз и разу, а сейчас, тут как-то в Твиттере у него завязалась дискуссия, смейк Christophe Michaeljohn в Твиттере набросил на то, что Unbounded очереди в Erlang это просто зашквар, и типа... Сделайте что-нибудь. Ну не просто сделайте что-нибудь, а что-то типа, там, из-за того, что отсутствие этого в языке by design не оправдывает отсутствие этого в библиотеке. И в принципе, вот он в этом плане прав, на что Фред сказал, ну, в общем, почему бы и нет. Я бы у него пост запилю с обзором существующих решений проблем, точнее проблем решений вот этого всего, после чего через месяц написал, ну, это у меня заняло всего лишь месяц, и собственно ссылку на свой пост я могу сказать только низкий ему поклон за как-то собирание всех его знаний в очередной раз в одном месте, потому что, ладно, есть люди, которые с этим сталкиваются каждый день, просто время в голове держат, особенно если читать Erlang mail list, чем-то из этих библиотек регулярно пользоваться, в принципе, не проблема, но когда нужно, так скажем, какую-то обзорную статью, или там даже сам что-то мог забыть, или кому-то нужно нового в курс дела ввести, вот книжки вроде Erlang and Anger и такого рода статьи, они просто бесценны, потому что они дают именно такой обзор решения таких проблем, которые встают в нагруженных системах, про то, что я, честно говоря, конечно, с миром Java знаком плохо, и с миром Go знаком не очень хорошо, но мне кажется, что в мире Java есть книжка по Java Performance, которая похожа на Erlang Efficiency Guide, но гораздо толще, а вот ничего типа Java and Anger я не знаю, то есть, мне кажется, подскажите мне, если я не прав, но опыт отладки Java в продакшене, в 2 часа ночи тушения пожаров можно получить только путём страданий, а книжки Java and Anger, насколько я знаю, нету. То же самое, то есть про Go мне кажется, там даже нет никакого до сих пор Performance Guide, то есть, есть какие-то разрозные посты, рекомендации, которые при том, ну, то есть, чем ещё хороший Erlang Efficiency Guide, это часть документации OTP, поэтому если что-то меняется, они делают туда как это, amends, поправки, вот, и в Go мне кажется, очень не помешало бы иметь такой вот гайд, в котором вместе с рентаймом были бы небольшие такие заметки о том, что такое хорошо, что такое плохо в существующей версии. Вот, и дальше, собственно говоря, когда появляются какие-то библиотеки для борьбы с проблемами растущих очередей или там какими-то ещё известными проблемами рентайма, или даже в том случае просто подхода, потому что, ну, как только у вас в системе есть очередь, так у вас сразу привет, в справедливости ради в 19-м Erlang можно поставить, в общем-то, можно делать такой внутриерланговый OOM, если не ошибаюсь, то есть там есть такой механизм, который может прийти к индивидуальному процессу внутриерланговой виртуальной машины и лично этому процессу стучать, что в принципе уже лучше, сильно лучше, чем ничего, но на самом деле гораздо лучше, чем это делать какой-то превентивный лоадшеддинг или превентивный бэкпрэжер, ну и бэкпрэжер, в общем, да, ещё можно всякие скейдлеры разные использовать, ну, не Erlang скейдлеры, я имею в виду, библиотека для скейдлинга, библиотека для того, что называется circuit breakers, когда у нас что-то выше по цепочке контроля сломалось и нам хочется, чтобы у нас вся система не сложилась под этим, и там много разных юзкейсов, собственно, я даже, ну, я не знаю, если ты, Ваня, прочитал и говоришь с желанием, я могу передать тебе слово и ты расскажешь про, собственно, содержимое статьи, я, пожалуй, закончен о том, что статья рассматривает кучу разных случаев, берётся такая модельная система по ней, в ней показываются всякие странные ситуации, которые могут возникнуть, и чем мы можем с этим побороться, вот, я, пожалуй, на этом замолчу. Очень отличное вступление, и если бы не два последних предложения, я бы так и не понял, о чём статья.",
    "result": {
      "query": "Erlang queue performance guide"
    }
  }
]