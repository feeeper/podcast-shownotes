[
  {
    "segment_id": "868f8092-9972-4b34-b4cf-4a98f82c3eb6",
    "episode_id": "9844537d-87bd-4c3b-b540-0cc100237188",
    "episode_number": 209,
    "segment_number": 2,
    "text": "Ой, да, давайте. Это так весело всегда, когда что-нибудь ненадежно, не правда ли? Да. В общем, что вы знаете о том, как устроена репликация в PostgreSQL? Да, дорогие коллеги и слушатели. Ну, потому что мне нужна небольшая вводная, чтобы вообще… Ну там байтики туда-сюда. Ну нет, подожди, Саша. Сначала сервера сюда-туда, потом байтики туда-сюда. Давай, Саша, расскажи всем, как в PostgreSQL устроена реплика на самом деле. Если мы говорим, то есть в PostgreSQL для начала есть два вида репликации, логическая и физическая стриминг-репликация. Мы сейчас говорим про физическую стриминг-репликацию, когда мы просто один в один наливаем другую машину. Слушай, я последние сколько там, года два с половиной в подкасте ни о чём, кроме Postgres не говорил, тебе не приходило в голову, что мне может быть уже это надоело? Но в Postgres есть два вида репликации. Ну ты же эксперт. Да-да-да. Есть два вида репликации, физическая и логическая. Логическую занесли, по-моему, в десятки, если я ничего не путаю. Физическая была довольно давно, физическая реплицирует всё, таблички, базы, вообще всё это по сути передача валу по сети, вал это который write-ahead-log, и проигрывание его на репликах. Там тоже есть разные настройки, синхронные и несинхронные, вот это вот всё, там уровни 4 и 5, типа можно вообще не ждать от реплики Ака, можно подождать Ака, что она это записала в вал, но не применила к данным, можно дождаться Ака, что она это записала в вал, применила к данным и теперь все пользователи это видят, прям вот применённое. Там ещё есть отдельная ручка, типа реплика это приняла, записала в память, но не записала в вал, тоже такой компромисс. Это мы говорили про физическую, логическую репликацию, работает ли иначе. Я думаю, логическую можно пустить пока. Ну вот ты задал вопрос, а теперь не слушаешь, вот-вот-вот. Я хочу, чтобы больше про физическую рассказал, ещё больше. А про логическую репликацию, друзья, я оставляю вам изучить в качестве домашнего задания. Да, именно так. Так вот, я ещё хотел спросить, я в принципе понимаю, мне надо будет лучше стыдно это расскажешь, что физическая репликация, она на самом деле, если я верно понимаю, как это происходит, она как бы ведёт себя, как будто бы Postgres поднялся с типа после креша с не до конца чистым хипом и пытается догнаться из вала, который отдельно ему досылает, то есть там есть отдельный процесс WallReceiver, который сосёт вал и докладывает его, а Postgres работает в режиме ой-ой-ой-ой, надо срочно хип обновить, если я правильно понимаю, как это работает. Ну давай так, такую семантику тебе точно никто не гарантирует, более того, такая постановка, она не верна, потому что вал нужно, ну если ты говоришь про процесс рекавери, то он откатит твой cd-чекпоинт, чего реплика явно не делает, ну и так далее. Так нет, я про то и говорю, что реплика, это же собственно рекавери. Ну ещё раз, Валер, процесс рекавери, вот если мы его забыли про репликацию, мы говорим, что рекавери базы после краша, да, шаг первый, откатись до чекпоинта. В случае с репликацией, реплика этого явно не делает, поэтому уже как бы это контрпример, почему это не работает так, как ты думаешь. Ну вот я потому и хочу, чтобы ты в дискуссии поучаствовал, потому что я вот вижу, как бы из-за того, как мне это объясняли коллеги, я сам не участвовал сам в этом ищу, я просто его наблюдал со стороны, это было очень весело, но вот я теперь пытаюсь объяснить, что произошло. В общем, в любом случае, с точки зрения нейминга процессов, есть два процесса, участвующие на реплике в репликации, это один, это полресивер, который принимает байтики с мастера, а второй – это нечто под названием рекавери. Ну вот, оно так называется. Ну проблема, один процесс отвечает за приём данных по сети, второй – за их накатывание, да. Ну, при этом ты мне говоришь, что это не тот же самый рекавери, который рекавери. Ну, нет, подожди, ты когда сказал процесс рекавери, не уточнил, что это видимо, как я сейчас пытаюсь угадать, ты говоришь про процесс перезонной системы или как алгоритм рекавери РСОБД? Про процесс перезонной системы. Ну тогда да, там действительно есть такой процесс. И я так понимаю, он используется не только для репликации? Ну вот за это я уже не берусь говорить, потому что я не смотрел конкретно в кишки этого кода. Ну то есть я подозреваю, что называется рекавери не просто так. Ну то есть почему в реплике крутится что-то под названием рекавери? Почему это вообще основа репликации внезапно? В чём твой вопрос? К чему ты клонишь? Мне кажется, ты к чему-то клонишь. Да, я клоню к тому, что там возможно архитектурно что-то выросло из чего-то другого в какой-то момент. Но это на самом деле даже не так важно. В общем да, я просто хотел глобально описать примерно, что вообще на реплике есть. На реплике есть процесс wall receiver, есть процесс recovery, который накатывает принятые волы на heap. Ну heap, собственно, это дисковая структура с отражением в память. Вот. И есть, собственно, процессы backend, которые цепляются к Postgres, для вашего средения создаётся, собственно говоря, процесс backend, в котором будет включаться запрос. Если у вас есть ещё какие-то, если вы на 10 или более новом Postgres и у вас включены параллельные запросы, у вас могут быть ещё параллелл воркеры. Вот. В общем, у нас как раз была ситуация, когда есть реплика, к ней приходит запрос, он параллеляется, у нас есть параллелл воркеры, то есть участвуют во всей этой штуковине. Получается, ну, по меньшей мере, 4 процесса, 2 из которых входят в интересное состояние. Дело в том, что вот этот вот процесс recovery, он, если никак дополнительно ничего не конфигурировать, он без понятия какие... Ну то есть он просто пытается применить волк к тому, что есть сейчас на heap, и если какая-то транзакция держит snapshot, который текущий вол превращает в тыкву, ну то есть, например, в этом текущем кусочке вола есть какие-то апдейты для строк, которые видит какая-то сейчас бегущая транзакция. Начинает тикать таймер, если вот транзакция укладывается в таймер, то никто никого не отменяет, всё нормально. А если транзакции, там, следующие за ней в этот таймер не укладываются, то их отменят. Есть способ это тюнить, во-первых, можно таймаут длиннее ставить, во-вторых, можно включить так называемый фидбэк. Я не уверен, что именно он делает, я так понимаю, он мастеру что-то сообщает, но это... Можешь, Саш, проследить, как это работает на самом деле, вот этот вот recovery фидбэк? Короткий ответ, я не знаю, как конкретно он работает в Postgres, потому что, повторюсь, вот если взять конкретный кусок Postgres и его код, я никогда туда не лез. А те люди, которые туда лезли, они... Не вернулись? В дырку попали, конечно. Ну, у них как бы весёлые эмоции на лице и сидя на... В любом случае, я немного удивлён, что вот как ты описываешь процесс проигрывания вала, что он ждёт завершения каких-то транзакций, ну, вроде MVCC не просто так придумали. Так нет, смотри, именно на реплике, если нет никакого фидбэка, у неё нет способа сказать мастеру прекратить генерировать вал. Соответственно, ей нужно или бесконечный бэклог накапливать и не применять вал. То есть у тебя же страница, она может так поменяться, что... То есть ты не знаешь заранее, как у тебя поменяется страница, у тебя там останется старая версия тупла или у тебя старый тупл просто станет иквой? Ну, я понял, то есть речь идёт про то, что реплика она должна иметь такой же хип, как на мастере, ну, то есть это в Postgres действительно есть такая семантика. Если меня склероз не подводит. Именно в физической репликации, да, тебе же собственно перелетают изменения страниц. Вот, и да, действительно, я могу понять, как это может быть неудобно для транзакций, которые на чтении сейчас выполняются. Ну, они не обязательно будут на чтении, просто какая-то транзакция держит какой-то снапшот. Подожди, на реплике только на чтении? Да, на реплике только на чтении, да-да-да, безусловно. Вот, ну и собственно говоря, дальше начинается интересное. Есть транзакция, которая пытается себе для параллел-воркеров выделить динамическую shared memory, ну, с довольно большого размера по меркам того, что требуется, ну, то есть там еще несколько мегабайт. И это сискол, он, ну, типа происходит довольно медленно. А временно с этим происходит рекавери, который трогает транзакции, который тоже будет трогать транзакции. И рекавери пытается отменить эту транзакцию, посылая ей cguisr1. А код, как я понял, в том, кто делает сискол, так написано, что он пока не выделит память успешно, без постоянных прерываний или чего-то, он дальше не пойдет, он там будет пытаться снова и снова это делать. А тот, кто посылает сигнал, то есть рекавери, он посылает сигнал, ждет несколько миллисекунд, посылает его снова, ждет несколько миллисекунд, посылает его снова. И в итоге у них получается такой лайвлог. Они оба работают против друг друга. Для нас это выглядело так, что раз в день примерно на реплике одной из довольно важных баз с метаданами, как бы один из процессов, в котором крутится запрос, просто повисает намертво, 100% цепушит и ничего не происходит. Рано или поздно репликация просто заваливается совсем, потому что рекавери перестает что-то применять, то, что получено, и перестает принимать новое, остает на десятки минут и приходится там совсем все врубать и не совсем снова перенаревать реплику, но в общем восстанавливаться до актуального состояния. Мы очень долго не могли понять, что происходит, потому что я сейчас пока объяснил, все довольно просто. Но когда у тебя есть работающий в продакшене подгресс, это не очевидно. Особенно, что к тому моменту, когда ты готов сесть и... То есть это не всегда происходит в моменты, когда ты на работе, тогда происходит момент, когда ты дома и хочется просто, чтобы оно дальше работало, а не разбираться этим вот прямо сейчас. Так что это заняло некоторое количество времени, когда все были, так скажем, у своих компьютеров в рабочее время, к тому моменту, что у нас не сразу появились дебаг-символы нужные, в конце концов звезды сложились удачно, подцепились к этому дебаггерам, то есть просто факт прицепления к дебаггерам к нужному процессу проблем учинил. Потому что если прицепиться к дебаггерам к тому процессу, который посылает сигналы, он очевидно перестает посылать сигналы на время, давая возможность тому, что выделять память, да выделить память и как бы все счастливы. В общем, бэктрейсами, прицеплениями к разным процессам дебаггерам это таки удалось выяснить, где именно происходит race condition, вот. Там уже заслали патч, коллеги, вот такая вот ненадежность в Postgres, надеюсь, это было интересно.",
    "result": {
      "query": "PostgreSQL physical replication internals"
    }
  }
]