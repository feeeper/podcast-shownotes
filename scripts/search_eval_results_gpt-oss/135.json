[
  {
    "segment_id": "981b86e6-0a4a-49d3-8edf-9ec4b9569248",
    "episode_id": "6b62cda8-4e23-4d94-9c34-dfae402c08bd",
    "episode_number": 135,
    "segment_number": 2,
    "text": "То есть JVM-платформа и JVM-байткод. Но в последнее время Scala начинает идти немножечко вбок. Появился ScalaJS несколько лет назад. И его активно продвигают. И он достаточно взрослый сейчас проект. Это компиляция Scala в JavaScript. И сейчас появился проект, его развивают полтора года. Который называется Scala Native. Который про компиляцию Scala в машинный код. Для 8.6, для ARM процессоров. Ну и для всего, что поддерживается в LLVM. Вы не подумайте, он не убил котят, просто он на мьюте. Да-да-да, я просто ставлюсь на мьют, чтобы прокашляться. Вот. От шерсти котов, которых ты поедаешь? Повисло неудобное молчание, видимо я угадал. Я просто смеюсь. Тяжело. Ну, кашляю, смеюсь. Шерсть. Вот это всё. Запивает шерсть просто. Чтобы говорить. Так вот, собственно говоря, фишка в чём. Очень быстро запускается, медленно компилируется. Ну, в принципе, она и так медленно компилировалась. Куда медленнее? Теперь сюда ещё добавляется overhead от LLVM. Соответственно, и все оптимизации, которые делает LLVM, это всё ещё в плюс. К скорости компиляции. Но зато мгновенно взлетающие программы, ahead of time compilation. И всё в таком духе. К слову, у нас в скалолаз-подкасте в последнем выпуске был Денис Шабалин, который разработчик Skull Native. Если вам нужны подробности-подробности и всё про Skull Native, то можно пойти послушать. Это как ссылка. Слушайте, но получается, что он не может оптимизировать код на лету, я правильно понимаю? Ну да, это обычная нативная программа, как на плюсах написали. Да, то есть все плюсы LLVM, которые там умеют самые горячие участки как-то оптимизировать, они здесь уходят автоматически. То есть вы приобретаете одно, но теряете другое. Ну в этом как бы особенности. То есть есть трейд-оффы между ahead of time compilation и just-in-time compilation. Если мы говорим про just-in-time compilation, то мы получаем медленный старт, прогрев, вначале интерпретацию, и потом-потом-потом девиртуализацию, какие-то оптимизации кода на уровне inlining какой-то неявной. А если мы говорим про ahead of time, мы сразу загружаем машинный код в кэш процессора, и всё начинает быстро... Господи, что я несу? И всё начинает быстро работать. Сразу. То есть предоптимизировано. Но мы не получаем оптимизации в рантайме. Всё сильно зависит от приложения, чего вы хотите достичь. Ну да, вот очевидный пример, например, консольные утилиты. Если я хочу достичь мирового сплотства, мне это поможет? Конечно. Зависит от времени. Если ты хочешь достигнуть за 0.2 мс, то только native. Убедил. Вот. В общем, например, если это консольные утилиты, её не очень делают на Java, потому что Java медленно стартует.",
    "result": {
      "query": "Scala Native vs ScalaJS performance"
    }
  }
]