[
  {
    "segment_id": "175cf03e-9116-4c62-a904-0e8e70dd90bf",
    "episode_id": "0f89bfc2-194d-4811-8386-9adf113ced3c",
    "episode_number": 425,
    "segment_number": 4,
    "text": "Валер, а ты как знаток Horizon, его снимают, нет? Там то ли сериал, то ли фильм должен быть сниман. Слушай, я что-то слышал, но я никаких подробностей не знаю. Потому что это все такое, знаешь, пока... У меня дети ждут. Пока нет трейлера, пока нет трейлера, это все вилами по воде, потому что Sony — компания, у которой куча своего видеопродакшна, они могли какому-нибудь, там, не знаю, сценаристу и продюсеру это забросить, а те там еще кому-нибудь забросили, и это может, не знаю, годами вариться в состоянии «а хер знает». Поэтому это мой ответ. Я тем временем посмотрел про фильмы. Тот, который 93-го года, он убыточный. Про фильм, который вышел 5 апреля 2023-го, я ничего не могу сказать. О чем ты можешь сказать? Это про «Severage Side Logic Execution», правда, Саша? Да. Это доклад из серии «Advanced TDAB Systems», курс читает Энди Паплы. 24-й доклад в серии, остался еще один, держитесь. В этот раз он посвящен хранимым процедурам. И тому, как их эффективно исполнять. И на редкость удачный доклад, мне очень понравился. Я много шонуты добавил. Начинается с того, что вот у нас есть в базовых данных хранимки, триггеры, типы, определяемые пользователем UDT, User Defined Types, и функции User Defined Functions. Преимущество их использования в общем случае такое, что, вместо того, чтобы сходить в СУБД, послать запрос, подождать, получить ответ, отработать, послать запрос, подождать и так далее, ты всю логику сваливаешь на СУБД, вызываешь свою хранимку, получаешь результат, и сразу его используешь. Меньше раунд трипов. Считается, что это сложнее отлаживать, особенно если ты своими вызовами еще триггеришь триггеры. Но, в общем, это очень удобно. И это очень удобно. Но, тем не менее, такой подход возможен. Из недостатков UDF. Во-первых, по определению, твоя функция на PL, PG, SQL или на чем-то, она выполняется последовательно. Одна строка за другой. И это достаточно сложно распараллелить. По понятным причинам у тебя просто семантически одна строка должна выполняться перед выполнением следующей. Также UDF это черный ящик с точки зрения оптимизатора запросов. То есть ты не можешь векторизовать исполнение. То есть, как в случае со встроенной функцией min, max, средней, еще что-то, то понятно, как их векторизовывать, а с функцией, которую написал пользователь, не получится. Дальше сообщается, что есть пейпер про систему под названием Фройд. Это штука от Microsoft. Я так понимаю, изначально была какая-то независимая разработка индийских ресерчеров, но потом Microsoft их проспонсировал, перевез к себе и в целом это разработка Microsoft теперь. И идея заключается вот в чем, что мы берем код императивный, на императивном языке, и переписываем его, в случае с Фройдом, не на SQL, он его переписывает в реляционную алгебру. И то, что он переписал, он потом выплевывает выше, и дальше уже оптимизатор, работая с выражением реляционной алгебры, который он подмешивает к контексту, к тому запросу, из которого вызывались UDF, он на все это вместе смотрит, пытается это оптимизировать, лишнее выкинуть, заменить константы, и уже потом исполнить. Такая какая-то идея. Вот, достаточно вообще интересная идея, что процедурный язык может быть переведен в, пусть не самый оптимальный, но он может быть переписан на реляционную алгебру. Но несколько расширенный, как я понимаю, а потом уже оптимизатор с этим будет разбираться. Вот, в докладе очень подробно объясняется, как, например, if-else переписать. При том, n-зе он не на реляционную алгебру переписывает, он на примере SQL показывает, что вот если у вас есть if-else блок, то его можно переписать на SQL вот так, то выплюнуть выше, а дальше оптимизатор разберется. Это достаточно сложно будет пересказать в подкасте словами, то есть вот все эти case, when, зачитать и так далее, поэтому вам придется поверить мне на слово, что это возможно. Кому интересны детали, тот посмотрит доклад. Из ограничений этого движка конкретно, по крайней мере, по состоянию на 2019, система, она вроде продолжила развиваться, но по состоянию на 2019 не поддерживались циклы, не поддерживались исключения, а исключения, как выяснилось, достаточно часто встречаются в UDF-ах, также не поддерживаются всякие странные сценарии, потому что в Perl и SQL ты можешь делать странные вещи, сделать строку, в эту строку положить текстом код SQL запроса и прямо на лету его достроить, а потом выполнить этот запрос. То есть в Perl это называется eval, в Python, я не помню, возможно, так же. Как это называется в Ruby, Валер? eval, наверное, так и называется тоже. Угу. Окей, я просто вообще не знаю, я поэтому спросил. Там просто несколько разных вариантов eval, если правильно помню, там типа можно eval сделать не всего, а только чего-то, типа с разными скупами, по-моему. Вот, вот все названное в Фройде на тот момент не поддерживалось. Приводятся результаты некоторых бенчмарков, не очень воспроизводимые, как я понимаю, но согласно этим бенчмаркам на некоторых нагрузках, Фройд, он может увеличивать производительность прямо в сотни раз. И что важно, это без переписывания кода. То есть вот просто тот серверный код, который был, он такой вжух и в 100 раз быстрее. Не очень понятно, учитывалось ли тут время на оптимизацию этого запроса или считается, что мы один раз закэшировали план и потом его как-то переиспользовали. Я не сильно знаком с функционалом Microsoft SQL Server, чтобы сказать, может он так или не может. Но в целом есть какой-то бенчмарк. На сайте Microsoft есть пейперы во множественном числе, потому что система развивалась. Есть видеозаписи, презентации об этой системе. Все это здорово, все это замечательно, но есть маленькая проблема. Система Фройд, она со всех сторон обложена патентами. Поэтому даже если вы разберетесь, как это работает, вы с большой вероятностью не сможете это обеспечить. Применить на практике. Но если у вас чисто академический интерес, то можно ознакомиться. К счастью, есть альтернативное решение, альтернативный движок. Он описан в пейпере, он называется Compiling PL-SQL-Away. Это разработка немецких ресерчеров. И они использовали другие подходы. В частности, они сразу поддержали цифры, циклы. Циклы они компилируют в рекурсивные Common Table Expressions. Но если вы с рекурсивными запросами работали, то у вас не должно вызывать вопросов, что действительно можно цикл переписать на рекурсе. Еще интересно, у них промежуточное представление, оно не реляционное алгебра, а свой функциональный язык. По сути, они его не называют функциональным языком, даже если у тебя есть переменные. Переменным значение всегда присваивается один раз. Если ты хочешь цикл, то у тебя нет циклов, потому что это функциональный язык. Но ты можешь использовать рекурсию и использовать хвостовую оптимизацию. И потом уже из этого промежуточного представления на функциональном языке ты генерируешь SQL, насколько я помню. Интересный подход. Это их система в том, что она не привязана к конкретной СУБД. Она работает, в принципе, с любой системой, где реализована стандартная SQL. И она может перекручиваться как middleware. Конкретно в Paypal они используют Postgres, но в теории ты можешь так переписывать запросы к другим СУБД тоже. Про рекурсию рассказал. Бенчмарки у этой системы они тестировали... Ресерчеры этого paper тестировали на Postgres 11.3. Они сообщают об ускорении примерно в два раза. Что звучит как-то более реалистично, на мой взгляд. Интересная научная значимость всего этого. Для меня это очень интересная вещь. Это не было достаточно очевидным фактом. Или я об этом мало задумывался. Что ты любой оперативный код можешь переписать на функциональный или декларативный. Что плюс-минус одно и то же. И потом еще его и оптимизировать, чтобы он был короче, понятнее. И в граничных случаях ты можешь его даже до константы свернуть, если хочешь. Такой вот занимательный факт. В принципе, это все по этой лекции. Рекомендую к просмотру. Если заинтересовались, то рекомендую. Можно читать связанные пейперы. Особенно про немецких ресерчеров. Вопрос, возражения, комментарии. Когда это может быть применимо? Это же не в любом диске, если нужно. Ну, наверное, не в любом. Как обычно, есть плюсы и минусы. Если у тебя приложение, которое активно использует хранимое. Ну, UDF и хранимки. То есть у тебя большая часть логики на стороне с UBD. И ты хочешь повысить производительность своего приложения. Ну, потому что зачем все это делается? Затем, что когда ты перевел с императивного кода на декларативный, у тебя система сама решает, как декларативный код исполнять. В частности, она может... В частности, она может его викоризовать. Она может его распараллеливать. Она может... Черт из дела. И если у тебя на стороне базы данных много уже написанной логики. Ты не хочешь ее переписывать. Потому что, в принципе, тебе ничто не мешает не использовать хранимки. И с самого начала использовать рекурсивный запрос. И вот все то же самое. Просто руками написать. Ни единой строчки на APL, PGSQL. Все на SQL. Просто... Просто... В среднем людям сложнее писать на SQL, чем на императивных языках. И если это твой кейс, то ты можешь либо онлайн конвертировать свою существующую логику и получать ускорение за счет этого. Либо ты можешь оффлайн конвертнуть свой код. И выкатить апдейт на систему. Как-то так. Мне кажется, надо идти еще дальше. Мне кажется, вообще надо любую программу иметь возможность... Переписывать в хранимую процедурки или в декларативный код выполнения на PGSQL. То есть, перед началом выполнения программы, ты все константы загоняешь в каком-то виде в какую-то таблицу. А потом просто выполняешь серию SQL-запросов к этой таблице для того, чтобы вытащить результат. А из-за того, что это все тиринг полные языки, ты можешь и там, и там сделать любую логику. То есть, просто PGSQL у тебя будет еще одной средой выполнения твоей программы. Как вам идея? По-моему, богата. Мне нравится то, что ты подчеркнул тот факт, что... Ну, получается, что у нас PL, PG, SQL. И SQL, они выходят, что они эквивалентны. И те, и другие тиринги полны. Опять же, не та идея, которая меня вот прям часто посещала. За которую я активно думал. Насчет хранить константы в таблицах. Я не уверен, что это обязательно лучшая мысль. Нужно брать конкретные запросы, конкретную нагрузку и проверять. При этом можно даже не иметь до конца локального вообще никакой инсталляции. Ты можешь в облако заходить. То есть, вот у тебя сложная вычислительная задача. Ты взял ее, преобразовал в запрос в Postgre, и на самом деле это же могут быть не константы. Ты можешь просто там умножение добавить внутрь. Как-нибудь там сложение, вычитание, все что угодно можешь сделать. Слушай, классно. Богатая идея. На самом деле это предложить какому-нибудь фанату написать. Да, на Postgre можно хоть сложение, хоть вычитание, все что угодно. Представляете, уважаемые слушатели, можно. Можно вычитать даже на Postgre. Что еще можно, это двигаться дальше по темам. Вот, дальше я принес тему из рубрики «Трудовые будни Team Lead». Я столкнулся с интересным кейсом, о котором я хотел бы рассказать. У меня есть коллега в команде, и он обратился с проблемой. У человека проблема. Войдите в положение, представьте.",
    "result": {
      "query": "Horizon film series production"
    }
  }
]