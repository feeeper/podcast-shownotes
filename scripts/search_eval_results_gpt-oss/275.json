[
  {
    "segment_id": "7d66e155-4fc3-45c5-b0b1-0033c9726595",
    "episode_id": "a584566d-1fa9-462a-9a46-57c15d5f0b21",
    "episode_number": 275,
    "segment_number": 4,
    "text": "То есть если у вас в какой-то функции перед релизом происходило очень много изменений, возникает большой риск, что именно в этой функции будет проблема, потому что тестирование тяжело повторить, потому что сроки маленькие остаются перед релизом и так далее. И все эти показатели суммарно, они как раз могут по одиночке использоваться, мы можем взять их все вместе и какой-то индекс по показателю иметь, и смотреть характеристики системы, исходя из всего этого. Но мало кто, соответственно, 2008 года пытался построить структуру организации и посмотреть, как структура организации влияет на качество кода и на предсказуемость количества багов и исправление этих багов. Соответственно, в следующем абзаце, это у них, как это, вторая часть статьи, это связанные работы, и здесь очень много ссылок, десятки ссылок на совершенно разные работы, которые с разных сторон рассматривают. И с точки зрения каждого показателя, то есть code churn, сложность и так далее, каждый берется показатель и рассматривается, как он в истории использовался, кем был введен, в каких статьях, какие показатели и какие характеристики были обнаружены. Очень интересно почитать, прямо ради related work можно посмотреть эту статью. В частности, оказалось, что было несколько попыток посмотреть на влияние организации, структуры организации на качество кода. Я сейчас так сильно размахиваю руками, очень плохо, что вы меня не видите. Но, к сожалению, не было количественных характеристик, только качественных, как бы, вот это влияет, а вот это не влияет, с точки зрения чисел, фактически. И, соответственно, следующая часть этой статьи, это про сам вклад. То есть в качестве вклада они первое рассматривают какие-то метрики, они ввели большое количество метрик по организации, которые можно количественно определять для каждой организации, смотреть, как оно влияет на результат. Во-вторых, они придумали методологию, с помощью которой они систематически пытаются предсказать количество ошибок в каждом модуле, функции, там где угодно, смотря как рассматривать, смотря как вам это нужно. Следующая часть, это они сравнили вот эти вот метрики, которые они только что ввели с стандартными метриками, ну и какие-то результаты показали. Показывали результаты они на, если я не ошибаюсь, на Windows Vista, да, Windows Vista коде, то есть у них был доступ к репозиторию Windows Vista, они посмотрели на структуру программы, они посмотрели на кто коммитил, соответственно, кто какие правки вносил, плюс у них был доступ к организационной структуре этих команд, ну что-то вроде, я не знаю, какая система у них использовалась, они здесь не говорят, но они могли вытаскивать запросы вида, кто является членом данной команды, кто кому подчиняется, вся иерархия была видна, и, соответственно, они могли строить метрики на основе вот этих данных. И, соответственно, они ввели следующие метрики, давайте мы их понемножку перечислим, хотя, наверное, все перечисляют смысл, это их восемь штук, давайте я сейчас для примера покажу, например, количество инженеров, работающих над каждой частью программы, например, берем модуль и количество инженеров, работающих над модулем, количество бывших инженеров, которые сейчас уже не в компании, которые работали над модулем, то есть очевидно, что первая метрика, она показывает, насколько много людей прямо сейчас коммитило, вторая, это особенно вместе с первой показывает, насколько много сейчас знаний у текущей команды по сравнению с теми, кто уже ушел. То есть, если сейчас работает один человек, а когда-то работало сто человек на данном модуле, то очевидно, что один человек будет хуже представлять предыдущую команду. Количество изменений кода, да, то есть частота изменений кода, соответственно каждой командой, глубина… Как бы это объяснить, представьте себе деревовидную структуру. Без картинок тяжело. Древовидную структуру организации. И получается, что на каждом уровне есть какой-то менеджер, под ним есть там еще, какие-то люди и, возможно, следующий менеджер. Потом под ним есть еще какие-то люди и опять какой-то менеджер. И если посмотреть, то получается, что на каждом уровне вот этого дерева, есть люди, которые могут изменять какую-то программу или часть программы. Когда скроешь вот это дерево, можно на каждый уровень приписать, сколько людей на этом уровне непосредственно коммитилов в программу, и сколько суммарно под этим уровнем во всех листях и во всех под деревьях этого дерева, вот данного узла, сколько коммитилов в эту программу. Соответственно можно построить такую нарастающую сумму снизу с листочков к вершине дерева, и вот соответственно все эти цифры можно использовать в качестве метрика. То есть глубина, сколько от каждого узла до самого нижнего листочка, где происходили изменения, вот эти глубины деревьев можно записывать, можно проценты данного узла ко всему дереву. То есть представьте узел организации, и в этом узле организации 5 человек правят код, а во всей организации правит 100 человек код. Соответственно данный узел влияет на 5%, ну это как показатель такая характеристика. Данные 5% к тому, сколько там под ним находится, под ним например еще 20%. И вот все вот эти, если метрики построить, мне сейчас их тяжело перечислять, потому что они здесь объясняют в статье на основе примерографа, без этого примерографа очень тяжело вообще все это рассказывать. И получается, что у них 8 разных метрик, которые характеризуют влияние каждого узла по сравнению со всем деревом, каждого узла, кто сейчас работает по сравнению с тем, кто раньше работал. Они вводят дополнительные метрики, производные от текущих метрик, для того, чтобы посчитать отношения, то есть отношения данной метрики к той метрике и так далее. Все вот эти производные метрики, они четко объясняют, почему они имеют какой-то смысл. Ну например, количество текущих девелоперов по отношению к уволенным девелоперам, ну которые уже не в команде. То есть вот эта метрика, она имеет смысл, чем больше это число, тем лучше текущий код покрыт знаниями текущей команды. И все вот эти метрики, они собрали в большую кучу, в большую таблицу, и эти метрики использовали для того, чтобы пытаться предсказать результат. Я хотел бы отметить, что вот эти метрики, их нужно все-таки немножко там делить на 2 или на 3, потому что если проект не Windows Vista, а вот другой проект, он там раз в год почти с нуля переписывается, то не имеет значения, сколько людей над ним работало раньше. Ну просто как контрпример. Поэтому вот все эти очевидно, они не такие уж очевидны. Поясни, пожалуйста, я не очень понял. Смотри, ты говоришь, что посмотрим отношение числа программистов, которые сейчас работают над проектом версус сколько суммарно над ним работало раньше там, ну в смысле увольных, ну или которые сами ушли. И очевидно, что чем меньше величина этого отношения, тем меньше у текущей команды знаний относительно проекта. Я как контрпример привожу, что если проект существенно переписывается достаточно регулярно, то эта метрика показывает ерунду. Она не показывает ерунду, она просто будет нерелевантна, да, согласен. Ну я это и сказал, будет показывать ерунду. Понял. Дело в чем, они не пытаются показать, что в данном конкретном случае все метрики работают. Их исследование было как раз на тему, какие из метрик показывают наилучший результат. И они попытались взять все возможные метрики для того, чтобы сделать какое-то предсказание.",
    "result": {
      "query": "software metrics organizational structure bug prediction"
    }
  }
]