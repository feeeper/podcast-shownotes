[
  {
    "segment_id": "b5144cd7-879c-46aa-b5e0-64e7a5bd4284",
    "episode_id": "1edcb517-81bb-4871-b6ad-26ed8c901af1",
    "episode_number": 76,
    "segment_number": 9,
    "text": "Во-вторых, мы стараемся компилировать на разных компиляторах, сейчас GCC и Clang. Тоже очень полезная штука, потому что они ловят разные, ну, ворнинги, они ловят разные ошибки, это помогает улучшить код. Профайлеры мы пользуемся на линексе oProfile, это очень известный проект, очень сильно помогает. Но статические анализаторы, мы вообще пробовали всем этим пользоваться, ничего в принципе так сильно не помогло. Единственное, что я могу рекомендовать, это Valgrind. Valgrind очень полезная штука, если есть там с памятью какие-то проблемы, то он находит почти все. К сожалению, медленно, довольно на практике, для базы данных это очень важно, но находит почти все. Я думаю, больше ничем мы таким не пользуемся, потому что в основном этого достаточно. Это и плюс код ревью очень важная вещь. Ну, и добивая тему, какие ты можешь дать рекомендации разработчикам на C++, как на нем писать, не сойти с ума, не посидеть, и заодно твое отношение к исключениям, шаблонам, вот этому всему, то есть какой C++ вы используете? Ну, мы тут все посидели используя C++, поэтому я посоветовать в этом отношении ничего не могу. Но мы сейчас используем C++ 11. C++ 11 намного разработка, конечно, легче, чем было до этого, потому что они добавили там лямбда, добавили очень много полезных вещей. А сейчас стало легче. Но вообще, я отвечаю немножко на другой вопрос, но меня очень интересует Rust, это язык программирования, который разработали в Mozilla. То есть это такой C++, но для следующего, 21-го, или может даже 22-го века, который... Мне кажется, что в Rust они решили все проблемы C++, но без всех этих legacy проблем, которые пришли от C. То есть мне этот язык... Я так чуть-чуть писал маленькие программки, мы им здесь еще не пользуемся, но мне это очень интересно. И что мы стараемся сделать, мы когда пишем C++, мы его пишем... Мы стараемся смотреть, как бы мы это написали на Rust, и делаем примерно так на C++. Это очень сильно помогает. Шаблоны... Ну мы пользуемся... Когда большой проект, мы пользуемся почти всем, что есть в C++. Мы начали с того, что мы использовали очень маленькое количество C++ features, но со временем, как проект начал расти, мы начали все добавлять, и добавлять, и добавлять, и сейчас используем почти все. Но это такая классическая проблема, потому что язык очень большой, он старый, он пришел от C. Единственное, что мы стараемся не делать, мы стараемся писать более современный C++, пользоваться тем, что вошло в C++ 11, и стараться делать как можно меньше таких низкоуровневых вещей, которые позволяет C. Это очень сильно помогает. Но у вас же, например, свои карутины, где-то чуть ли не на ассемблер пришлось пуститься. Да, карутины. У нас есть чуть-чуть ассемблера, на котором написаны карутины. Это все было написано немножко раньше, сейчас все более такие high-level компоненты, они все написаны на C++ 11. Но, конечно, от C в C++ убежать очень тяжело, но что мы стараемся сделать, это писать это все на разных уровнях. То есть у нас вот есть уровни карутины, там все написано на C на ассемблере, а потом на высшем уровне все пишется на C++ 11. Это нормально, работает довольно неплохо на практике, но чтобы это работало, нижний уровень должен очень хорошо быть протестирован, и нельзя как бы смешивать C++ 11 и C на одном уровне, потому что это очень как бы чревато. Когда на разных уровнях используется разный тип кода, это работает на практике неплохо. Но когда в одном уровне смешивается C++ 11 и такие очень низкоуровневые вещи, то это очень тяжело тестировать и много багов получается. Поэтому мы стараемся делать эти вещи на разных уровнях, и на высоком уровне пользоваться только C++ 11. Это не всегда получается, но, по крайней мере, мы как бы стараемся идти в этом направлении. Возвращаясь к приплекатке... Хорошо говори. У меня про репликацию был один вопрос, который я не успел дожидать. Что у вас с геодистрибьюцией? Каждый раз в любом механизме репликации, где есть выделенный мастер, там же всегда есть latency до других дата центров, и если запрос пришел, не знаю, из Зимбабве, а у нас мастер для этого кусочка кластера оказался в США, то у нас latency будет неприятная. Есть ли какое-то решение этих проблем? Выделить эту группу реплик мастер, чтобы был в одной стране, а другую группу реплик в другой, или как-то вообще влиять на это? Есть какие-то возможности, есть ли какие-то планы на это влиять? Да, на это можно влиять. Это все уже есть в базе данных.",
    "result": {
      "query": "C++ 11 coding practices and tools"
    }
  }
]