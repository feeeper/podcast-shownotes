[
  {
    "segment_id": "074c0b07-1099-436c-8bba-9b4be79f8ce3",
    "episode_id": "88ab6104-8c49-44e5-a324-af88c39a7515",
    "episode_number": 168,
    "segment_number": 2,
    "text": "И большое спасибо организаторам ещё раз за то, что пригласили. Если есть вопросы, дополнения, возражения, вот сейчас подходящий момент. Что-нибудь такое, да, я так понимаю, что очень похожее событие есть в Европе, называется Chaos Construction и... Конгресс, да. И вот он проходит, по-моему, где-то в районе января, кольца или конца декабря, где-то в Германии, по-моему, обычно. Ну, и башня конференции, и их много. Есть ещё Black Hat, это наиболее крупная международная. Я имею в виду всё-таки, чтобы была такая же упоротая атмосфера. Ну, мне трудно оценить степень упоротости Black Hat, я там никогда не был, но, насколько я понимаю, у них там с атмосферой нормально. Ну, я на 3C тоже никогда не был, но из того, что мне рассказывали те фоточки, которые я видел, там оно очень сильно похоже на Zero Knights. По камере, по фоточкам. Вот, ну, с 3C мы много раз обсуждали какие-то слайды, пейперы и так далее, и это действительно крутая конференция. Кстати, я не помню, я заносил выпуск или нет, но там ещё и про FBG было, секция достаточно большая. Вот я несколько видосов смотрел про Ice Stick. Это которые Ice Foti, FBG-ашки, но не важно. Как насчёт, я немного отдохну, а вот гости, которые отмалчиваются, расскажут про аксесс-методы в Linux. Как вы смотрите на это, Алексей? Вот это поворот. Да. Ну, давай. В общем, у нас есть статья из блога ScillaDB, если кто не знает, ScillaDB — это такая баз данных, совместимая с Cassandra, написанная на C++. К слову сказать, я знаю, что есть не такое малое количество людей, которые мечтают её переписать на Rust и говорят, что Rust — идеальный язык для напишения подобных систем. Ждём, надеюсь, что появится скоро. Статья описывает, как можно работать с файлами на диске в Linux, какие есть традиционные методы и чуть менее традиционные методы. Самое простое — это мы делаем обычные вызовы read и write, которые, соответственно, блокируются, возвращают нам данные. Если данные есть, то всё довольно быстро работает. Мы идём в кернел, возвращаемся обратно с данными. Если происходит miss, мы не попадаем в кэш, то происходит переключение контекста, диск читает данные, возвращает их в икру, происходит переливание, всё это происходит гораздо дольше. Ну, это в целом, наверное, все так или иначе знают. Второй альтернативный популярный вариант — это map. Мы говорим optfile, когда если мы читаем и попадаем в кэш, то мы вообще из приложения, по сути, не уходим. Если у нас происходит miss, то работает всё примерно так же. Для простоты я запись буду опускать, но все, кто работал с MongoDB, старые версии, прекрасно знают, как работает запись в memorymapped файл. Ну или как она не работает. Как она не работает, когда их много конкурентных. Это, наверное, самое важное в этом плане. Memorymapped очень любят опускать по любому поводу, потому что, вот, посмотри, как всё плохо в Монге. На самом деле, memorymapped не то чтобы универсально плохо работает, но он специально плохо работает, когда у тебя есть к нему много конкурентных записей. И это один большой memorymapped файл, они под ним не распили ни на какие другие подчасти. Не, ну, конечно. На самом деле, memorymapped файл работает очень хорошо, особенно, не знаю, когда у вас данных, может быть, не очень много, да, и они нормально влезают в память, и вам нужен какой-то простой, не знаю, back-end на диске, да. Это довольно неплохо, самое главное, это очень просто запилить. Да, не нужно там извращаться. Но да, вот у нас в Монге ложилось, когда было много записей, в том числе из memorymapped файла. Но это давно было, старый-старый, всё такое. Но справедливости ради, буфер менеджер пишется там за пару дней, такой, ненапряжной работы. Ну, я так, для полноты картины. Ну, это пару дней, а map это одна строчка. Но это один раз. Ну, да, да, может быть. Ну, я имею в виду, что если ты не хочешь, ну, хотя, конечно, тоже такое, это в автоп какой-то уже уходит, но я хочу сказать, что просто если тебе нужно сделать какой-то storage, и перед этим ты не хочешь использовать существующую базу данных, и хочешь сделать бустер на коленке, по какой-либо причине, то обычно mmap довольно неплохое решение. Особенно если у тебя там, не знаю, чтение еще не получилось. Пару дней именно написание буфер менеджера, это просто супер оптимистично. Невероятно оптимистично. Ну, окей. Значит, давайте дальше. Дальше в линксе, ну, в линксе нет нормального, асинхронного, обычного ввода-вывода для файлов, да? Поэтому, соответственно... А, тут я пропустил, есть еще прямой ввод-вывод, когда мы работаем с диском напрямую, и пропускаем кэш в уровне операционной системы. То есть, по сути, мы делаем чтение, и нас система вызывает, когда чтение может идти, и мы получаем прямой доступ к памяти. При этом никакого вычисления внутреннего ядра нет, переключения отрядов нет, мы работаем с памятью напрямую с диском. Вот. Все это довольно быстро. Проблема в том, что всегда происходит переключение контекста, если данных нет. Ну, и это сравнительно сложно. Ну, и, соответственно, есть асинхронный ввод-вывод с прямым вращением к диску, когда мы сабмитим некие события, диск, соответственно, их данные читает, и после этого через прямое вращение к нашим приложениям мы опять же получаем данные. И мы, соответственно, через getEvents сполним для того, чтобы узнать, когда к нам что-то появилось. Ну, и, соответственно, табличка соотношения всех этих параметров. Соответственно, в последнем случае наибольшая сложность кода, но потенциально самые хорошие выигрыши, особенно если мы хорошо понимаем, что мы делаем. То есть, если наша стратегия кэширования, которая есть в ядре, которая универсальная для нашего приложения, не подходит, если мы пишем какой-нибудь супероптимизированный баз данных, то мы очень умные и мы можем сделать такое же сами. Ну, и некоторые другие вещи. То, что за счет того, что нет переключения контекста, нет переключения тарагов, мы тоже выигрываем. Шедулер тоже как бы... Ну, шедулер в ядре, да, он знает, какой его более важный, какой его менее важный. Можно немножко это потенциально с какими-то параметрами, но, опять же, если мы пишем приложение, которое баз данных, которое занимает большую часть машины, на которой она работает, то нам приходится делать шедулер в самом этом приложении. И, соответственно, там у нас уже вполне могут быть какие-то приоритеты, там мы можем расстраивать, что более важно, что нет. Ну, вы, если хотите что-то дополнить, давайте. Я хотел сказать по поводу еще memory map в кейсе использования его с базами данных. С ними есть такая проблема, что, допустим, когда какая-то часть данных, с ней часто идет работа, к ней часто идут запросы, и она горячая, и, соответственно, она вся попадает в мапплинг память. Часть данных, которая на базе, которая в целом не in-memory, а она в целом на диске, и общий объем данных гораздо больше, чем объем памяти, доступный для кэширования. И когда происходит иногда запрос каким-то, возможно, более старым или редко используемым данным, но очень большому объему этих данных, происходит, по сути, полное вымывание всего memory кэша, и все остальные запросы, более горячие запросы к базе данных, они на какое-то время, может быть, даже надолго, тоже начинают работать методами, потому что в кэше ничего нет. И memory map не позволяет управлять этим процессом, то есть если мы знаем, что какой-то запрос, скорее всего, не повторится в ближайшее время, то никакого смысла кэшировать эти страницы в памяти нету. И страницы с данными, которые для этого запроса нужно загрузить, и поэтому... а memory map все равно их загрузит. Вот такая есть проблема. Что касается еще прямого ввода-вывода, в отличие от тех самых способов, здесь нужно делать уравнивание по границе страниц самому, потому что во всех других случаях, если вы, не знаю, читаете один байт, например, с диска, то для вас обычно система, ядро читается целиком. Ну то есть там, 112 или 4 килобайта. А здесь вам нужно все самому делать. Если вы вдруг зачем-то читаете один байт, то вы действительно прочитаете один байт, но потратите на это кучу времени. Ну, скажем так, давайте быть честными, нельзя прочитать с диска один байт. Никогда нельзя прочитать с диска один байт. Ну, хорошо. Я имею в виду, что то, что ты прочитал больше, чем один байт, ты ни на каком уровне не увидишь этого. Если ты захочешь прочитать, не знаю, следующий байт, то нужно делать перепозиционирование и все остальное, в общем, все делать еще раз заново. Ну то есть за счет того, что нет никакого кэша, ничего такого, для тебя это максимально выглядит так, как будто ты прочитал один байт по всем сайд-эффектам, по скорости и так далее. Это пессимистично. Есть же оптимистичный подход, когда у тебя даже на диске есть какой-то кэш, который оптимизирует запросы, и два подряд чтения, скорее всего, из кэша уже будут производиться. Ну да, но это опять же зависит от того, что вы делаете. Если между этими двумя чтениями ничего не было, то скорее всего, да. Но я про оптимистичный подход. Понятно, что рассчитывать на это нельзя. Еще я верно понимаю, что чтобы использовать тот способ, который описывается как самый оптимальный, то есть асинхронный DirectIO, надо по сути всего архитектуру приложения сделать тоже асинхронным. Вроде как да. Основная идея именно в том, что нельзя это сделать синхронно, но будет плохо, соответственно им нужно делать асинхронно. Они вот этот кусок, кстати, вынесли в отдельную библиотеку, которую они даже High Performance Framework называют для его приложения, тоже написано на C++, называется C-Star. И я посмотрел по размеру код, на самом деле он почти такой же, как вся остальная база. Ну нет, смотри, на самом деле C-Star это не именно для чтения с диска, это C-Star, это их такой реаккор, только C-Star. Сравнение с реаккором некорректное, но они же C-Star еще до того, как они его сделают, до того, как они сделают сцилл. Там история такая, что собралась группа очень таких хорошо прокачанных отпоросков, которые занимались разными вещами в разное время, но такими очень низкоуровневыми. Там чуть ли не кто-то из них Detrace сделал, такого рода вещи. Я не уверен точно, что я правильно помню, кто из кто. Но суть в том, что люди, которые очень хорошо понимали, как работает операционная система, решили сделать подмороженную базу данных, которая была бы как Cassandra, только в каком-то определении лучше. И, собственно, чтобы ее сделать, им нужны были какие-то абстракции, и они решили себе написать абстракцию, на которую можно делать правильно. Это C-Star для них получился. Там у него есть определенные клюшки, по-моему, даже его обсуждали, что у них там специальным образом есть affinity того, что считалось бы винодой к ядрам процессора, к очередям сетевых карт и так далее. То есть там у них довольно заморочено, чтобы, грубо говоря, логически единица распределенного приложения максимально точно биндилась на какие-то физические штуки, чтобы оно ни с чем не конкурировало с ресурсами. То есть C-Star это во многом еще и проект. И вполне возможно, что они туда же втащили дисковое IEO. Ну, все так, но единственная поправка, что в исторической перспективе они все-таки начали делать баз данных, потом поняли, что вот этот кусок лучше отдельно обособить, и использовать будет проще, развивать проще и так далее. И они его выделили. Ну, может быть я неправильно поправил по историческому перспективу, в любом случае, пойнт был в том, что C-Star это не библиотека ввода-вывода с диском на DirectIO, это целая большая-большая сложная штука, которая еще много чего другого умеет. Ну да, да, все так. А насчет, касается, кто там, что за умники, то есть автор статьи — это создатель KVM. Так что да. Есть такие умники. Интересно, а чуваки, которые мечтают переписать с целого на раз, они хотят переиспользовать C-Star как-то, или это будет невозможно, потому что C++ несовместим с кассой? Мне кажется, C++ несовместим с желанием переписать на раз. Мне кажется, тема себя все-таки исчерпала, потому что пошло какое-то трололо. Да, а что далеко не трололо, это жучки, которые притворяются USB кабелями. Или кабелями, как правильно, Вань? Я думаю, кабелями. Это вообще жестокая какая-то штука. Расскажешь нам вкратце, в чем суть? Суть, дело в том, что... Я только не понял, это прототип устройства или реальное устройство? Это реальное устройство с eBay, вот это вот все. Ага, вот. Реальное устройство, которое выглядит как обычный USB кабель. Ну там на самом деле не важно, что находится на втором конце кабеля, на втором конце кабеля находится вот этот вот USB разъем, который втыкается в компьютер. И этот USB разъем он сделал немножко большим, но в принципе выглядит вполне нормально. То есть я, когда брошу на него взгляд, я не заподозрю ничего плохого, а на самом деле там есть место достаточно для того, чтобы вставлять сим-карту. И когда вы вставляете сим-карту, вы фактически предоставляете... Ну это там как микроконтроллер, который позволяет через интернет на него заходить, выполнять какие-то команды и делать кучу всего, включая и GPS-позиционирование через вышки сотового оператора и вот это все. То есть такой вполне себе шпионский продукт, который не только посылает данные, но и позволяет как-то обрабатывать данные, то есть вы можете им управлять удаленно. На самом деле это позиционируется как дополнительные средства, например от угона автомобиля, потому что ты можешь такой кабель воткнуть куда-нибудь в прикуриватель, ну через USB, переходник с прикуривателя в USB. И поскольку он не вызывает особого подозрения, или в Powerbank, кстати, то ты всегда знаешь, где твой автомобиль. Но статья на самом деле о том, как авторы решил поговорят в этом устройстве, изучить его работу, зареверсить и так далее, и он там нашел массу интересного. Например, что устройство управляется по SMS главным образом. Он там нашел некоторые недокументированные команды, но это небольшая проблема, потому что основная версия, что прошивка писалась для серии разных устройств, поэтому это нормально, что там есть какие-то недокументированные команды. Но там есть другие страшные вещи, что, например, устройство ломится по GPS или PRS на какие-то сервера производителей, что нигде не документировано, и непонятно, зачем оно это делает. И автору не удалось, по крайней мере на момент, когда я читал, ему не удалось разобраться, зачем это устройство куда-то еще ломится, на момент, когда я это читал, потому что статья, она дополняется. Ему удалось демпить прошивку, то есть ее можно зареверсить, и там, собственно, это откуда он узнал про недокументированные команды, потому что они там в виде строчечек грепаются. И еще он поизучал сам сервер, на который ломится устройство, нашел там раздел с веб-отменкой для управления, и это на самом деле довольно стремно, потому что про эту отменку нигде не написано. То есть посыл такой, что в принципе разработчики этого жучка, они контролируют все устройства, существующие. Могут контролировать. Нет, но совершенно очевидно, что они уже захватывают мир прямо в процессе. Согласен, все машины. Да, ну вот такая интересная статья, если… И кстати, я припоминаю, она не сильно про железо и про… Вот именно железная часть, она именно про… В целом в контексте eBay интересное чтиво. Поэтому я крайне рекомендую. А, да, тут еще оно достаточно сильно фонит, поэтому находится детектором RadioWorld. Оказывается, они продаются на eBay, недорого стоят. Я себе, кстати, один заказал, интересно, дойдет или нет. По-моему, рублей 800 стоил, если память не подводит. Называется CC308. Вот, то есть, ну помимо прочего, вот из статьи вы узнаете, чем можно искать жучки. Да, и еще тут была какая-то интересная история про то, что он отъел у него большое количество денег. На СМСках? Я пытаюсь вычитывать вот эти цитаты, которые я надергал. То есть здесь есть цитаты действительно про то, что несмотря на то, что были отключены все трекинг-функции, устройство все равно куда-то ломилось по интернету. Ну так как это недокументированно, ты никак не ожидаешь, и возможно у тебя этот интернет-трафик очень-очень дорогой. Вторая цитата про то, что действительно есть вот эта обминка, которая недокументированная, и пользователь о ней ничего не знает. Здесь про то речь, что там, где живет автор статьи, есть какие-то сервисные звонки, которые тебе могут позвонить на телефон. И в этом устройстве, когда оно принимает звонок, оно начинает вещать все с микрофона. То есть это как послушивающее устройство, которым ты можешь управлять мобильным. И случилась у него забавная история, которую он потом задним числом понял, посмотрев по логам, что ему на это устройство кто-то позвонил, в течение двух минут слушал все, что происходит. Но автор статьи об этом вообще не мог никак узнать, потому что устройство никак не подает виду, что у нее микрофон включился и так далее. За что с него действительно списывались некие деньги. И самая неприятность, что там нет никакой аутентификации, кто угодно звонит на такой же челк и может слушать происходящее. Такая вот неприятная история. Я так понимаю, нет возможности ограничить, с какого номера можно слушать, а с какого нельзя. В общем, когда мы начали рассказывать эту новость, все захотели побежать и купить, а сейчас все передумали и не хотят покупать. На самом деле я бы не советовал это все побежать и покупать, потому что с шпионским оборудованием в России как-то могут не сильно церемониться, давай так. Я бы лично не заказывал. Есть ли дополнение, вопросы, мысли по этой статье? Ты, Валер, себе в машину такой воткнешь? Нет, для начала нужно машину купить. Ну велосипед воткни, ну ты понял? Ну нет, зачем же. А у вас в Германии велосипеды не угоняют? Угоняют, но куда там USB втыкать? У тебя в велосипеде нет еще USB? Я думаю, у всех велосипедов есть USB, но на самом деле ты можешь спрятать его в раме, правда есть такая проблема, что рама как правило из чего-то металлического и она экранирует радиоволны.",
    "result": {
      "error": "API request failed: Error code: 400 - {'error': 'Trying to keep the first 4951 tokens when context the overflows. However, the model is loaded with context length of only 4096 tokens, which is not enough. Try to load the model with a larger context length, or provide a shorter input'}",
      "stack_trace": "Traceback (most recent call last):\n  File \"/home/andrei/Projects/podcast-shownotes/scripts/build_search_eval_dataset.py\", line 157, in generate_search_query\n    response = await self.client.chat.completions.create(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/resources/chat/completions/completions.py\", line 1927, in create\n    return await self._post(\n           ^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1767, in post\n    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1461, in request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1562, in _request\n    raise self._make_status_error_from_response(err.response) from None\nopenai.BadRequestError: Error code: 400 - {'error': 'Trying to keep the first 4951 tokens when context the overflows. However, the model is loaded with context length of only 4096 tokens, which is not enough. Try to load the model with a larger context length, or provide a shorter input'}\n"
    }
  }
]