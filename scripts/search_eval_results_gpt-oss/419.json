[
  {
    "segment_id": "8db3a3ce-8b8e-43db-b970-a41a0eb42c86",
    "episode_id": "10841c48-8e8c-4d20-842a-484db16b3ce4",
    "episode_number": 419,
    "segment_number": 6,
    "text": "Если я запускаю что-то на своем железе, то вот смотри выше, если там будет неотключаемая телеметрия, типа мы тут на вашем железе, работаем, но мы будем жрать сесевой трафик в любое удобное нам время, и нам все равно, что вы пишете подкаст, мы тут у вас пол канала отожрем, но мне такое не по душе. То есть если у меня такой софт будет мне мешать заниматься какой-то активностью привычной, то я серьезно займусь поиском альтернатив этому софту. Окей, ладно, возвращаясь к Go. Дело было в начале февраля. Расскокс, который техлит языка Go, сказал, что давайте мы сделаем прозрачную телеметрию для тулчейна Go. В частности для компилятора, для линкера и так далее, но в первую очередь для компилятора. Это в отличие от существующей телеметрии для Go разработчиков, рантайма, которая никуда не шлется, то есть когда работает Go программа, она автоматически может трекать, сколько было выделений памяти и так далее, и вам, как разработчику, поискать для этой программы все эти информации. В принципе, доступно, то есть все встроенные метрики, рантаймы там есть. Речь не об этом. Речь о том, что как раз они хотели сделать прозрачную телеметрию в компиляторе, чтобы отвечать на такие вопросы, которые баг-репорты и опросы пользователей не могут выяснить. То есть, когда есть баг-репорт, там есть, как правило, информация о версии, шаги, как это продюсить и так далее, но нет информации, насколько это часто случается. То есть, если много похожих репортов, часто их нужно руками дедублицировать и объединять. Иногда есть какие-то системы голосования за баг-репорты, но тоже не всегда понятно, то есть многие люди могут пойти, увидеть, что такой репорт уже есть и уйти, не оставить голоса. Возможно, есть какие-то кейсы, которые очень редко воспроизводятся, и поэтому ищу их нет, но они могут быть критичны, например, там какой-нибудь случайный краш или повреждение данных. Вот. С другой стороны, Go проводит, проводит опросы примерно раз в год или сейчас раз в полгода в последнее время. Довольно большие опросы, которые занимают относительно большое время, чтобы их заполнить, но это хорошая статистика, но опять же, там нельзя очень глубоко идти в какие-нибудь детали. И для того, чтобы отвечать на некоторые вопросы, было предложение сделать симметрию. Какие, например, вопросы? Какие самые популярные цели кросс-компиляции для Go? Как часто используются кросс-компиляции вообще? Какие самые популярные версии C-компиляторов на хосте? Какие самые популярные операционные системы? Операционные системы, например, в опросе это можно выяснить, но, допустим, сейчас на вопросы, которые я назвал, нет. Какой хитрейт в кэш-компиляции? Сколько есть пакетов в среднем в модуле? Какой, допустим, процент проприетарных модулей и неопределенных модулей? Какие команды самые популярные? Как часто команда Go работает в режиме GoPath, а не в режиме модулей? И так далее, и так далее, и так далее. И, в принципе, можно было бы на все эти вопросы найти ответы, если бы в Go была произвольная симметрия. Но, с другой стороны, понятно, что многие люди этого опасаются. Гораздо менее аргументированно, чем вы сейчас сказали. Поэтому была проделана большая работа. Написаны три большие статьи с примерами, зачем это нужно и как мы это сделаем. Вот.",
    "result": {
      "query": "Go compiler telemetry transparency"
    }
  }
]