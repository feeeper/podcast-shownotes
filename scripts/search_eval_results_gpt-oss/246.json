[
  {
    "segment_id": "504e74bd-9d50-4be8-a57b-941137ed8634",
    "episode_id": "6a7c0e85-1e66-48c4-8043-16b0aa31af9d",
    "episode_number": 246,
    "segment_number": 3,
    "text": "Это такая штука, которая обычно используется как middleware. Если вы используете Apache Fling, Apache Drill или что-нибудь в этом духе, возможно, эта штука у вас уже работает где-то под капотом. Или вы об этом не знаете даже. Она позволяет… Она прикидывается GDBC сервером, в который можно засылать запросы. Но там можно не только и запросы, можно еще кое-что делать. В общем, типичный юзкейс. Вы засылаете в нее SQL-запрос через JDBC или ODBC. Она его парсит, оптимизирует и исполняет на том, на чем у вас к ней есть коннекторы. По описанию это неотличимо от какого-нибудь Apache Drill. Но Apache Drill, он как бы распределенный execution engine, он уже шипится с какими-то драйверами, он там уже, не знаю, векторизует все такое. А Calcite, он гораздо более… у него гораздо более маленький скоп. Это чисто parser-sql, планировщик расширяемый и, собственно, парочка… ну, не парочка, там несколько больше коннекторов к разным всяким штукам. Но, в общем, они не универсальны ни ко всему подряд. Наверное, это такая штука, которая клевая, если вам нужно… А, я еще про одну штуку забыл сказать, прежде чем я перейду к use-кейсам. Можно не только на SQL-запросы писать, что вот еще меня очень порадовало, можно напрямую оперировать узлами планировщика, то есть можно просто собрать себе, скажем, такой план типа «хочу scan, потом filter, потом aggregate, потом еще один filter того, что агрегировалось, и потом, короче, такая-то проекция, и, короче, поехали». Вот, можно так делать. Но, правда, все равно потом этот план попробую еще раз оптимизировать сам, но, в общем, оно немножко может быть прозрачнее, чем некоторые SQL-запросы. Ну, или, например, если у вас вообще какой-то кастомный язык, то есть я видел его, он используется в каком-то апачевом проекте, который заменяет что ли Prometheus или что-то такое, и там типа из этого Prometheus PromQL строится вот такой дерево-план, и оно уже исполняется на каком-то хранилище, то есть вот так это можно использовать. То есть зачем вообще сгонять SQL, если мы запросили у нас невосQL и на входе у нас на самом деле PromQL. Вот. Он хорош, если вы знаете, в такой подгресс foreign data wrapper, но если вы не умеете писать foreign see, на что-то такое хочется сделать, вот, и вы знаете Java или Scala, вот кольца это примерно вот оно. Если вам хочется SQL или просто какой-то другой QL, но с умным планером для вашего какого-то хранилища, которое вы делаете сами, то есть, не знаю, вы пишете какую-нибудь базу данных, например, и вы хотите к ней за язык запросов. Оно не настолько клево будет, как, не знаю, какой-нибудь векторизованный исполнятель запросов, но во всяком случае оно умеет оптимизировать, и оно умеет кодегенерировать и даже джитить. То есть уже немало, так если подумать. Оно умеет, ну вообще одно из крутых фичей, то что очевидно за счет нескольких планировщиков, ой, сорри, за счет нескольких драйверов, один из которых это JDBC драйвер, он может ходить в другие SQL-хранилища. То есть можно, например, поджонить данные, которые лежат у вас где-то в файликах с данными, которые у вас лежат где-то в какой-то SQL-базе. Оно, в принципе, при всем при этом умеет достаточно агрессивный pushdown. То есть на моих, собственно, то, с чем я игрался, я даже писал, я не писал никаких кастумных коннекторов, мне было интересно, насколько он сможет SQL-запрос запушдаунить куда-нибудь, в общем, внедро. То есть, типа, если напишу какой-нибудь сложный запрос, насколько оно в JDBC просунется как есть, он почти полностью его просовывает, там я, по-моему, только sort limit не просовывал в одном случае. Можно придумать планировщику свои ноды и свои правила. Вот, как-то так. Из минусов при работе, если вы ходите через эту штуку сразу в JDBC, у вас есть довольно недешевая оплата при входе. То есть даже после того, как Java программа, если гонять в цикле, после того, как там произошел какой-то уже warm-up и все, сам код, самого кольца это заджитился, все равно планировщик может занимать там несколько, ну, сотню миллисекунд или типа того. То есть, грубо говоря, у вас там запрос 5 миллисекунд в Postgres ходит. А у вас планировщик в кольцах это все транит еще сколько-то там, много миллисекунд, но то, чтобы просто превратить ваш какой-то план или SQL в SQL для Postgres, что немножко ой, если у вас на самом деле маленькие запросы. Ну и очевидно, что, как я уже упомянул, то, что он там на JIT это будет медленнее, чем специализированный викторизованный движок. С другой стороны, если я правильно понимаю, как это работает, туда можно насовать своих каких-то викторизованных операторов, и я так делать не пробовал, но походу можно. Дрилл, если его использовать, значит, как-то оно работает. Вот, как-то так. Есть какие-нибудь вопросы? Нет вопросов. Похоже, что это. Что? Что? Похоже, никому не интересно, вроде. Ну вот, никому не интересно писать свой SQL, SQL своим базом данных пределовочных. Ну и не надо. Не, не берем. Ну что же это такое? Всем теперь foreign data wrapper писать, да? Или как? Просто понимаешь, для того, чтобы что-то брать, этому должно исполниться 5 лет. Вот.",
    "result": {
      "query": "Apache Calcite SQL planner"
    }
  }
]