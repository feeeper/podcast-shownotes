[
  {
    "segment_id": "881a7d20-4ed6-4ee4-88b3-9b88a02206dd",
    "episode_id": "f5644dd0-4d15-4648-9af3-7a5a51ca6912",
    "episode_number": 383,
    "segment_number": 2,
    "text": "А у меня всегда проблемы с кепками, потому что у меня голова большая по периметру, и не всякая кепка налезает. Вот, и я прям специально зашел на зону и нашел себе такую большую-большую кепку, беленькую, сеточку, чтобы летом не было жарко. Кстати, у нас прям наступило лето, у нас на этой неделе первого раза было плюс двадцать. Сейчас за окном совсем не плюс двадцать, и такой пробирающий лекастей, ледяный ветер, но тем не менее. Не только ли всякая кепка налезет Саше на голову, и не только всякий сможет секволтно траст. Но это можно. И я тут на неделе наткнулся на просто потрясающую... То есть налетели мы на это давно, но как это... Я на этой неделе зарепортил в Апстрим фреймворка, которым мы пользуемся, и там было время посидеть, бэктрейсы сделать. Дальше там уже разработчики фреймворка начали копать и нашли интересное. То есть тут конечно замешан некоторые unsafe, потому что работа с выгрузкой... То есть DLopen, аналог DLopen в Rust, значит тот вызов в библиотеке стандартной, которая делает DLopen в Rust, насколько я понимаю, он unsafe. Но падает после этого уже save код. Почему так происходит? Вы можете писать на любом языке программирования, но если вы сделали DLclose, а у вас все еще есть какой-то код, который будет вызван по адресам, которые вы только что размапили, вы упадете. И дело в том, что более новой версии GLC, у них есть специальный кулбэк, которым пользуется в частности стандартная библиотека Rust, где можно понарезать, понарезать зарегистрировать деструктуру объектов, ну или drop trade соответственно, в случае Rust. А старый GLC просто так, такого не позволял. Вот, и новый GLC, если там кто-то зарегистрирован, он не будет как бы делать DLclose до конца. Во всяком случае пока кто-то зарегистрирован. А старый просто честно делает DLclose. И вот мы когда тестировали, пытались собраться на системе, которая CentOS 7, там довольно старый GLC, и вот мы на это налетали, потому что, в общем, да, это такой маленький, забавный факт. Погоди. То есть сейчас новый GLC, если я делаю DLclose, он неизвестно, когда мне закроют по-настоящему это DLclose. Да, если у тебя есть какие-то, то есть он не в любом случае, это не безусловно происходит, это происходит с языками вроде с плюс плюсы Rust, где есть нечто похожее на деструктуры. И если runtime дергает за кулбэки, которые предоставляет GLC, да. Я на самом деле нахожу это как бы самое плохое в этом поведении, что оно зависит от версии GLC. То есть я бы, наверное, был бы ok с любым из вариантов этого поведения, если бы он, как бы, если бы оно всегда было так. А то у тебя получается код на Rust и как бы Sound, но только если у тебя GLC старше какой-то версии. И вот это уже как бы вот как бы то, почему я притащил, что как это... ваш чудесный язык, который призван к давать статические гарантии, одна из его концептов такая, что значит все что он сейв, мы завернем и сделаем сейв. Но когда вы заворачивали, вы сделали предположение как бы о чем-то, и это предположение оказывается в старых версиях не работает, но вы не протестировали на старых версиях. Но это же можно спокойно на уровне компилятора определить. Ну то есть во время линковки ты смотришь на версию библиотеки, какая у тебя есть, и можешь выдавать предупреждения какие-нибудь. Да, наверное, но понимаешь, как бы... На них кто на них не смотрит? То дело даже не в этом. У тебя сама, то есть как бы то, что представляет стандартная библиотека, насколько я понимаю, оно уровня типа unsafe. А то, кто потом оборачивал, видимо не очень сильно задумался над этим. Над тем, как DL Close отработает в разных версиях. Если честно, знаешь, я бы, наверное, как вот мое личное какое-то такое мировое ощущение, я бы, наверное, просто не стал делать DL Close, пока я вообще со всеми объектами не закончу работу. Тут, как бы в коде, если я правильно помню код, я очень... Это не мой код, даже не на наша команда, я плохо его помню. Происходит копирование, и я так понимаю, что объекты... Человек, который писал код, так понимаю, что он подумал, что объекты, которые принадлежали вот той библиотеке, они...",
    "result": {
      "query": "Rust DLopen unsafe GLC version issue"
    }
  }
]