[
  {
    "segment_id": "c7c27350-fd93-45db-9cc1-b4252a7d688b",
    "episode_id": "76f3ac89-3c21-4b0f-94c6-b36736d11f7a",
    "episode_number": 45,
    "segment_number": 5,
    "text": "Блин, глупости же. Я все-таки здесь на стороне Гугла, вы меня не переубедите, потому что они, это их дело, кого они как берут, и требовать к себе особого отношения. Я думаю, что это не их дел. Я думаю, что у них есть перегибание палок на местах. То есть, в любом случае, каждый человек индивидуален, и всех мерить под одну губинку нельзя. Должительно они всем дают это бинарное дерево, и то, что там, не знаю, у них... Вот это глупо. Почему? Потому что если к ним придет Ларри Пейдж и скажет, я хочу устроиться в Гугл, а ему скажут, а перед ней как дерево, да? Нет ведь, наверное? Или если к ним... Ну, я имею в виду, что есть люди, и есть люди. Понимаешь, еще такой момент. Тут они, конечно, берут очень высококвалифицированных людей, а потом садят их за нудные, неинтересные проекты. И это я неоднократно слышала от гуглеров, и да, такая проблема есть. И люди приходят, делают свою неинтересную работу, потому что они оверквалифицированы для этого. Это много где написано, это, в общем-то, не секрет. И люди живут тем, что вот у меня есть 20% проект, который я могу делать в свое удовольствие, да, там может быть какой-то rocket science или что-нибудь более интересное, но в большинстве своем гуглеры очень многие занимаются обычной неинтересной работой. Ну, рутина. Просто у нас в профессии вы все прекрасно понимаете, много таких вещей, и кому-то нужно это делать так или иначе. В Гугле, не в Гугле. Задачи ведь такие есть. И просто... Мы берем всех очень крутых. А ты посади такого человека, он будет заниматься и он будет просто сидеть и чахнуть. Ну, у них позиция такая, что им лучше взять меньше высокоуровневых специалистов, чем взять хотя бы одного низкоуровневого. Они убежают в людях вот это желание. То есть, они слишком, скажем, квалифицированы для такой обычной работы. Ну и что теперь, брать низкоквалифицированных, чтобы они там портили и все, что ли? Нет, я здесь согласен, что... Я считаю, что это же очень многое из среды замесит. То есть, они берут такого, скажем, середняка, который хорошо это умеет делать. Хороший середняк, согласен. Но не низкий плюс. Нет, я же не говорю про идиотов, индусов, которые вообще ничего не понимают и копипастят код. Нет, мы говорим про обычного, скажем, разработчика, который умеет хорошо выполнять свою работу. И ему, в общем-то, это интересно. Я думаю, таких берут. А если он деревьев не умеет переворачивать и пошел лесом? Значит, его не возьмут. Но он умеет хорошо там клепать эти формочки, он отлично это понимает. Они найдут другого середнячка, который умеет переворачивать деревья. Они не будут искать именно человека, который вот крутой. Куча середнячков умеет деревья переворачивать. Теперь понятно, что нужно читать перед собеседованием в Google. Зато, Вань, далеко не всякая куча середнячков умеет оценить, сколько шариков влезет в самолет. А они это перестали уже делать. Я тоже неоднократно слышал о том, что у меня несколько друзей, которые проходили стажировку в Google и пытались работать, что если тебе не повезло с проектом, то они тебе набирают по общему отбору, который очень высокую планку задает. Потом для тебя совершеннейшая лотерея куда тебя занесет. Если тебе не очень повезло с этой лотереей, то ты будешь довольно неинтересную жизнь вести. Я вам расскажу историю из реальной жизни. У нас в компании есть документы, в котором описано, как надо брать людей, кого брать, кого не брать. Но там недословно, что если человек не ответил на это, то не берите. Но там одно из первых правил. Лучше не взять человека, если вы сомневаетесь, нужен или не нужен. Брать человека нужно... Там сказано так, что вы должны не искать причины, чтобы брать или не брать человека, а вы должны постоянно сомневаться и есть презумпция виновности. То есть, если хоть одна есть надежда, что этот человек не очень хорош, его брать нельзя. Вот такой стандарт. Я думаю, что он в Гугле намного строже, чем в средней компании типа нашей. По размеру я имею в виду. Я предлагаю перейти уже к темам слушателей. Давайте. Я сейчас это буду открывать. У нас каждый раз, когда переходим к темам слушателей, всегда так, что я говорю, давайте сейчас, подождите, они у меня загрузятся. И создается впечатление, что у нас особо тормозной сайт, который 15 минут загружает темы слушателей. Хорошо. Задает вопрос Алексей Лисиум. Привет, Лёша. Я-то знаю этого человека. Он спрашивает про то, что нужно изучать для того, чтобы разобраться в теме потоковой обработки данных. Что почитать, что посмотреть на этот счёт. Ну, я даже не знаю, что тут советовать. Вот те лекции, то, что я давала, сегодня говорила, так что можно это посмотреть. А по потоковой обработке данных, я бы посоветовала чего-нибудь взять реальное, потрогать что-то такое и с этим поиграться. И быстро встаёт хорошее понимание, что что-то такое, как с этим жить. Я бы сказала, возьмите тот же Шторм, разверните и поиграйте с этим. Есть примеры всяких топологий для Шторма, и можно это развернуть без проблем, поиграться, покрутить, повертеть. Есть книжки по Шторму, которые описывают на различные топологии, различные подходы к решению типовых задач. Там задачи машинного обучения, задачи классификации, как это решается. Так что я попробую. У меня где-то были ссылки на такие книжки. Что можете сказать по поводу Spring HD, Xd? Я посмотрела, штука интересная, в том плане, что по сути она умеет генерировать, решает проблему лямбда-архитектуры, она умеет генерировать как джобы, так и стримовую обработку. Я, правда, не пробовала это запускать. Посмотрела там очень много документации. И вот, на этом всё. Я не пробовала, не знаю. У вас есть что-нибудь, что я буду сказать на этот счёт? И тишина. Нет. Пошли дальше. Я вообще не понимаю, о чём речь. Какие-то стримы, какие-то спринги. Что происходит? Окей, идём дальше. Влад АБЦ пред... Блин, я сегодня не могу говорить. Советует нам представляться в подкасте с фамилиями. А то Вася, Петя, таких много. Страна должна знать своих героев. Что вы скажете? Паспорт показывать. Даже не про что Вася, Петя. Это Вася, Петя из подкаста. Я против. Я не хочу, чтобы меня слишком широко узнавали. Я летать своё не очень охотно палю на всяких конференциях. А вы ещё фамилию в каждом выпуске с ума сошли. Гуглиться начали, да. Ну, и, в общем-то, я считаю, что мы даём нужную информацию о себе в ссылках. И тот, кто хочет, тот будет указывать. Не хочет – не указывать. Всё просто. Каждый пишет о себе, что хочет. По этой же причине у нас нет там, странички с рожами всех ведущих. Их разыскивает полиция. И... Следующий вопрос. Что касается ОРМ-ов. Какие у нас отношения у нас к ОРМ-ам? Потому что избитая тема – она больная. И можно порассуждать на эту тему? Что вы скажете насчёт ОРМ-ов? Я думаю, она слишком большая, чтобы сейчас это обсуждать. Короче, да. Мне кажется, что зачем-то типа сликаю будущее. И там, не знаю, есть, например, для эрланговской виртуальной машины, не для эрланга, для эликсира, и астекта. И вот этим полиция гораздо удобнее и приятнее, чем всеми этими дурацкими ОРМ-ами, которые у тебя за спиной, за кулисами делают небедную херню. То есть для меня главное отличие, что у тебя отдельное построение запроса, пусть даже не средствами и скрепления, а средствами на библиотеке. И отдельное его выполнение. Для меня это просто самая критичная штука, потому что во-первых, это позволяет выполнять тогда, когда надо, и столько раз, сколько надо. И с таким базом сходить, сколько надо. А во-вторых, потому что это как это... Первое, что хотел сказать, что позволяет сходить с таком как есть, чтобы сходить к какому надо. А второе, что хотел сказать, позволяет сходить в общем, когда надо. А не когда пожелают ОРМ. Ну да, и данные будут загружены сразу для всего запроса, который ты построила. А не так, что там лениво, когда в какой-то момент что-то еще доедет откуда-то. Я в последнее время к такой ОРМ совсем плохо отношусь. Я вообще их давно уже не использовала, нет необходимости. Мне нравится идея библиотек. То есть если мы берем какую-то библиотечку, которая нам облегчает работу, например с реализационными базами, она за тебя будет все, что нужно закрывать и дает тебе какой-то приятный API и ты с ним работаешь. Я вспоминаю Skylight GDBC. Вот у нас, кстати, есть слушатель, который советует его. Эту библиотеку мы активно используем и в общем-то мне нравится. Хотя есть моменты, когда вот сейчас нужно делать довольно нетипичное использование SQL. Там нужно хитро распараллелить, потом собрать, потом что-то еще сделать и только потом закоммитить. И тогда становится довольно трудно это делать с какими-то библиотеками. Я даже не представляю, как это делать с ОРМ. И я за то, чтобы давать мне самые низкоуровневые рычажки, я сама разберусь как с этими рычажками обойтись. Я про ОРМ хочу сказать, что... Чего? Слик смотрела? Я смотрела на него только так поверхностно, я его ни разу не пробовала. Просто для меня это как раз... Я очень часто в пику термину ОРМ использую термин RRM. Потому что никакого маппингового объекта там не происходит. Маппинг объекта мне, например, очень не нравится. Мне довольно удобно работать. Мне нравился Spring. Как же он назывался? Там, темплейты. И ты с темплейтом очень комфортно работаешь. Вот такого плана это идеальный вариант. Не низкоуровневый, как GDBC, а как нужно. Хотя по производительности, конечно, заметно. Делали мы когда-то тесты и было видно на графике, что он всё время добавляет некоторый overhead. Он создаёт свои объекты и видно, что мы задавали объектов, потом они удалились. И вот такие. Это было заметно. Когда мы брали и записали на Plain GDBC, было заметно по тому, что мы не плодим кучу объектов. Я хочу сказать про ORM. Во-первых, мы их уже обсуждали, я это точно помню. И поиск по сайту по слову slick найдёт правильный выпуск. Есть такая странная вещь, что я каждый раз прихожу в новый проект, и в каждом новом проекте всегда есть самописный ORM. И самописный ORM это всегда проблема. Не пишите своих ORM. Если вам кажется, что это хорошая мысль, вы ошибаетесь. Писать свои ORM – это плохая идея. Никогда так не делайте. Никогда. То же самое с DSL. Ну, DSL бывают разные. Нет, свои DSL – это ещё большее зло, чем ORM. Саша, это хуже. Поварют разные. Ты мне дашь сказать? Я лучше свой ORM, чем DSL. Хорошо, Света, ты права. Ещё я считаю, что... Подожди, нет, Света не права. DSL бывают разные. Серьёзно. Почему меня сегодня все обижают в этом подкасте? Я просто пример приведу. Вот то, что я говорил про... Погоди, я ещё не обижен. Да-да-да, давай, Вань, ты меня обижаешь. Тот пример, который я говорил про футуры, то, что там есть футуры с юнитом внутри, футуры с болиным внутри и так далее. Это на самом деле очень маленький DSL. Но это просто, не знаю, типа 5 или 10 методов в одном пакете. Там как бы DSL-ности такой особой нет. То есть написать можно очень по-разному. Ну, я бы... Говори, пардон. Ну, это лично моё мнение. Но в целом я согласен, что если можно не писать, DSL лучше не писать. И последнее, что я хотел сказать, что там, где в той области, где я занят, там всякие highload, web и вот это всё, там, как правило, DSL не особо полезен, потому что тебе написать, описать схему и написать парочку функций, типа создать пользователя и удалить пользователя, по времени занимает примерно одинаково. А поскольку это типа highload, ты всё равно не будешь заморачиваться насчёт транзакции и всего остального, и тебе проще вот так. Без ORM. Света? Я думаю, Ваня сейчас будет говорить. Я к тому, что ты привёл пример какой-то типичный класс с какими-то утилитными методами. Но я бы не называла это DSL. Я бы пример из другой жизни привёл. Ну, как бы из предыдущей работы. Или типа того. Вот есть у тебя класс, офигенный, огромный кластер с кучей-кучей всякого железа. Тебе нужно определить, какое железо мониторить. Ты это определяешь какими-то стандартными средствами, замучаешься. А если у тебя есть специальный DSL, ты это определяешь в пару строчек. Ну почему сразу DSL? Сделайте нормальный API для этого всего. Нужно файл конфигурации писать. Ну хорошо, опиши файл конфигурации. Чем тебе JSON нравится? Чем тебе там... Я говорю, тем, что ты убьёшься JSON писать. В этом кластере сотни мелких железок, которые нужно все замониторить. Гораздо удобнее написать DSL, который будет определённым образом матчиться за автодискавленное по SNMP оборудование и добавлять его по какому-то шаблону, который описывается этим специальным DSL. И ещё специальный DSL через то же самое место позволяет правила описывать тоже матч, то что нашлось выше по тексту. То есть там был такой, не знаю... Что-то среднее между прологом даже и не знаю чем. Приходит к вам на проект новый человек. Это вообще делается нанаружи. Я тебе хуже скажу, это вообще штука, которая должна была отдаваться наружу. Понимаешь, как вас ненавидели люди. Сколько ненависти на вас выливалось. Ну, там ненависть была, но была совершенно по другому поводу. И я хочу тебе уверить, что, во-первых, в любой сетевой железке тоже есть свой собственный конфигурационный DSL. И админам не привыкать изучать очередной DSL, потому что конфигурация у каждой сложной софтины или сложной железки какая-нибудь своя собственная. Это раз. Во-вторых, между... А давайте мы сейчас возьмём JSON, мы пишем вообще всё, что у нас есть в кластере, давайте мы... Изобретём свой DSL. Две строчки опишем матчинг этого всего. Извините, но инженеры, которые с этим работали, один раз примерно понял, как это работает, а дальше ты конфиг для кластеров пишешь за пару минут, от пары минут до получаса, против того, что каждый раз начинаешь какими-то тулами генерировать этот JSON, и потом у каждого инженера тулы разные, и потом, когда какой-то другой инженер приходит и делает сконфигурированный кластер, он не может понять, чем твой предыдущий инженер всё это фигнёвое наставил. Почему бы тебе вместо того, чтобы создавать свой DSL, не дать инструмент, который умеет генерировать этот JSON, и ты говоришь... DSL это и был инструмент, который генерировал конфигурацию для системы. Блин, я тебе пытаюсь... Точно так же, как и трифты, например. Генерят тебе классы. Например. У меня в своё время было очень сильное желание написать DSL-чик, у нас было очень много однотипных REST-сервисов, и нужно было написать, вот буквально ты даёшь список полей, которые у тебя есть в табличке, и там типы этих полей, и может быть ещё там парочка свойств такого рода, и ты на выходе получаешь обёртку к Postgres с REST-интерфейсом. И тут появляется ещё один сервис, который чуть-чуть другой, и всё это летит к чертям. Не знаю, мы в итоге не написали. Это жизнь. Потому что это в жизни так всегда бывает. Вот у тебя ты создал такой прекрасный свой DSL, который работает для всех случаев, которые ты думал, а потом появляется ещё парочка, которые, блин, ну да, не предусмотрели, но надо это поменять. И получается какая-то гора костырей вечных. А потом человек, который это придумывал, перешёл на другой проект, уволился, ещё что-нибудь с ним случилось, и потом оставайся и поддерживай эту хрень, написанную кем-то. Я понимаю, это всё так и есть. Я просто считаю, что тема халеварная насчёт DSL-а. Давайте Ваня и Гена скажут про ОРМ, и дальше пойдём. Да, есть ещё худшая вещь DSL для ОРМа. Например, HSQL для HydroLate. В каком-то роде это тоже DSL. Но на тему ОРМов. Я очень много работаю с ОРМами в данный момент, и могу сказать, что я очень много плююсь. То есть претензии, в принципе, такие же, и я солидарен с предыдущими ораторами. То есть когда нужно сделать огромнейший запрос, который занимает прямо смоделировать его, то есть какие-то релейшеншипы между объектами сложные сделать, постоянно проходится какой-то момент, когда ты начинаешь просто бороться против ОРМа. То есть, условно говоря, большую часть времени обходить какие-то интересные корнер-кейсы этого ОРМа. Так что SQL Builder – это наше всё, можно сказать. А ещё в мире Clojure есть такой аскетичный подход часто, как описание SQL-файла. Использование просто чистого SQL. Есть удобные обёртки, которые позволяют изъять один, используется большой файл, в котором есть несколько SQL-запросов. Соответственно, обёртка, которая позволяет легко этот SQL-запрос вынуть, подставить параметры и, соответственно, им воспользоваться.",
    "result": {
      "error": "API request failed: Error code: 400 - {'error': 'Trying to keep the first 4738 tokens when context the overflows. However, the model is loaded with context length of only 4096 tokens, which is not enough. Try to load the model with a larger context length, or provide a shorter input'}",
      "stack_trace": "Traceback (most recent call last):\n  File \"/home/andrei/Projects/podcast-shownotes/scripts/build_search_eval_dataset.py\", line 157, in generate_search_query\n    response = await self.client.chat.completions.create(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/resources/chat/completions/completions.py\", line 1927, in create\n    return await self._post(\n           ^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1767, in post\n    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1461, in request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1562, in _request\n    raise self._make_status_error_from_response(err.response) from None\nopenai.BadRequestError: Error code: 400 - {'error': 'Trying to keep the first 4738 tokens when context the overflows. However, the model is loaded with context length of only 4096 tokens, which is not enough. Try to load the model with a larger context length, or provide a shorter input'}\n"
    }
  }
]