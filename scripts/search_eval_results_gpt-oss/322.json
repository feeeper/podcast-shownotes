[
  {
    "segment_id": "df1fda27-389d-4eed-bdcb-93534da186d8",
    "episode_id": "3e78c7a4-c623-4c6e-af25-0e9d18fbe557",
    "episode_number": 322,
    "segment_number": 9,
    "text": "Второй подход называется либо Детродский, либо Чикагский, либо его еще называют классическим подходом. И тот подход, который был до того, как была изобретена, так сказать, лондонская школа. То есть там, где вы не используете МОКи, а просто по старинке передаете на вход вашим объектам какие-то другие объекты, и потом проверяете либо изменившиеся состояния этих объектов, либо возвращаемые ими значения. То есть вот это разница основная между лондонской и классической школой. Это классическая школа юнитестирования. И они в том числе различаются в том, что из себя представляет определение юнитеста. Вот, например, лондонская школа, там, где активно используются МОКи, она пропагандирует описание юнитеста как теста, который тестирует одну небольшую часть кода. Как правило, это один класс, если вы работаете с ООП, языком программирования. И здесь минус такого подхода в том, что вы начинаете переиспользовать МОКи. То есть используете их там, где их использовать не нужно, только для того, чтобы отделить поведение одного класса от другого класса. То есть лондонская школа пропагандирует, что если у вас есть зависимость какая-то у вашего класса, и она является изменяемой, то есть ее можно поменять, то она должна заменяться на МОК. То есть, например, если у вас, допустим, есть класс «Юзер», у него есть две зависимости. Одна — это класс «Компани» компания, и второе, это, не знаю, там число, какое-нибудь 5 передается. Вот это число 5 заменять на МОК не нужно, потому что эта зависимость неизменяемая. Но объект «Компани» компанию заменять на МОК нужно, потому что она является изменяемой. Это в целом то, как лондонская школа юнитестирования рекомендует подходить к юнитестированию. То есть заменять все изменяемые зависимости на МОКи. При этом классическая школа юнитестирования рекомендует не настолько широко использование МОКов, она рекомендует заменять на МОКи только вне процессной зависимости. Если мы возьмем изменяемые зависимости и поделим их на вне процессной и внутри процессной, то классическая школа будет говорить о том, что нам нужно заменять на МОКи только вне процессной зависимости. То есть те, например, как база данных, LuckyMoney, messageBash и так далее. То есть тут классическая школа радует за то, чтобы использовать МОКи меньше, чем лондонская школа. Но при этом обе школы, на мой взгляд, не верны в подходах к макированию, потому что обе они пропагандируют использование МОКов слишком сильно там, где их использовать не нужно. И в книге я постарался это описать более подробно, но если вкратце, то должны разделить вне процессные изменяемые зависимости на еще два потипа. Первый – это управляемые зависимости, второй – это неуправляемые зависимости. Управляемые зависимости – это те зависимости, к которым имеют доступ только ваше приложение. Например, у базы данных, которые не имеют доступа в другие приложения, будет в этом случае управляемая зависимостью, допустим файловую систему, потому что к вашей файловой системе, как правило, не имеют доступа в другие приложения. Это тоже будет управляемой зависимостью. При этом какая-нибудь message-base или SMTP-server – это будет неуправляемой зависимостью, потому что к ним имеет доступ не только ваше приложение, но и другие приложения. И мочить, макировать можно только неуправляемой зависимости. Управляемые зависимости – то есть те зависимости вне процессной зависимости, к которым имеют доступ только ваше приложение, и их макировать нужно. И почему так? Потому что если мы возьмем то, как эволюционирует приложение, там работая бок о бок с друг с другом, то основным принципом такой эволюции является поддержка обратной совместимости. То есть вы не можете поменять ваше приложение таким образом, чтобы оно сломало совместимость с другими приложениями, которые зависят от вашего приложения. К примеру, если ваше приложение посылает какие-то месседжи на message-base, то независимо от того, как вы будете рефакторить ваше приложение, оно должно продолжать посылать эти месседжи с той же структурой, с тем же форматом, в котором оно делало это раньше. Потому что иначе те приложения, которые зависят от этих сообщений, они просто перестанут понимать эти сообщения и поломаются. То есть обратная совместимость вашего приложения с другими приложениями должна соблюдаться всегда, потому что вы не можете продеплоить ваше приложение с другими приложениями одновременно. Потому что у других приложений может быть другой цикл development, а он может разрабатываться другими командами, либо вообще вы не можете иметь к ним доступа. А если вы, допустим, выставляете какой-то API наружу, то ваши клиенты будут общить какие-то клиенты не внутри вашей компании, а извне вашей компании, и вы не можете никак на них повлиять. И для обратной совместимости, для того чтобы поддерживать обратную совместимость, Moki как раз очень хорошо подходит. Потому что они позволяют вам зацементировать то, как ваше приложение работает с другими приложениями. То есть оно позволяет вам установить контракт взаимодействия между вашим приложением и другими приложениями. Но при этом вы не должны устанавливать этот контракт, не должны цементировать эту связь между вашим приложением и управляемыми зависимостими, такими как база данных. Потому что вы можете диплоить ваше приложение одновременно с этой базой данных, и у вас нет нужды проверять, поддерживать обратную совместимость с этой базой данных. То есть такая база данных будет дали имплементации с точки зрения ваших клиентов, клиентов вашего приложения, они будут знать, как именно вы работаете с этой базой данных. И поэтому проверять коммуникации между вашим приложением и этой базой данных тоже не нужно, потому что это будет приводить также к хрупким тестам. Точно так же, как если бы вы маркировали взаимодействие между классом UiCompany, также и маркирование взаимодействия между вашим контролером и базой данных также будет приводить к хрупким тестам. Потому что если вы добавите новое параметры в какую-нибудь хранимую процедуру, либо разделите вашу табличку в вашей табличке колонку Name, допустим на две колонки FirstName и LastName, вы не хотите, чтобы у вас тесты при этом падали, если у вас при этом все работает, просто потому что вы поменяли взаимодействие между вашим приложением и базой данных. Вот, и в этом разница. Вопрос. Интерфейс работает с внешними приложениями тоже может меняться? Да, если он меняется, он может... Это же API по сути. То есть цементировать API это точно так же проблема, когда ты начинаешь работать над API, над его изменением, над введением новых версий, каких-то необязательных полей дополнительно. Да, но оно может меняться только так, чтобы поддерживалась обратная совместимость. Если у вас меняется интерфейс, как вы интервьюете какой-то брейкен ченж, то вы должны вводить новую версию этого API, при этом делать так, чтобы старая версия работала так же, как раньше. Да, да, логично, да. Да, и поэтому это вход на выход, соответственно, вы тоже, в принципе, можете делать так же, то есть вы можете делать messages в версии 2, но при этом должны также и в версии 1 тоже продолжать посылать сообщения, потому что иначе у вас старые, те приложения, которые нагорируются на ваши приложения, они перестанут их понимать. То есть тут нужно всегда поддерживать структуру входящих контрактов, датоконтрактов и выходных датоконтрактов. И для этого как раз Moki очень хороши. Ну, Moki хороши не для входящих, не для входных взаимодействий, а для выходных, в первую очередь. То есть когда вы, ваше приложение посылает какие-то запросы к внешним приложениям, таким как MessageBus, ну либо просто к внешним API, допустим. Вот, например, там другой пример, не MessageBus, а, допустим, какой-нибудь PaymentProcessor, вы хотите, чтобы ваше приложение посылало в этот PaymentProcessor ровно такой же запрос, как он посылал раньше, независимо от того, какой рефакторинг вы проведете. Таким образом вы будете знать, что, допустим, если вы потестируете use case там, покупки ордера, заказы ордера, то и там сумма при этом та же самая, то у вас отправится на PaymentProcessor ровно та сумма, ровно того же юзера, как и до этого. Вот, этому вы можете рефакторить на вашу доменную модель как угодно. Это не должно влиять на этот факт, что само взаимодействие между вашим приложением и внешним приложением остается одинаковым, одним и тем же. То есть, основная разница между теми зависимостими, для которых Moki можно прийти, и теми зависимостими, для которых Moki нельзя проверять, это вот то, являются ли они доступными извне. Если они являются доступными извне, то это будет неуправляемая зависимость, и для таких зависимости мы должны использовать Moki, потому что Moki, они хороши корресс тем, что они позволяют установить, зацементировать взаимодействие между вашим приложением и другими приложениями. Но это свойство Moki, оно идет во вред вашим тестам, если вы их применяете для любых других зависимостей, в том числе и для базы данных. И это одно из самых противоречивых утверждений в книге, это как раз то, что макировать базу данных не нужно. Оно как раз вызывает довольно много холиваров в индустрии. Тут я рекомендую смотреть на эту базу данных с точки зрения, как обычная коллекция в ТВ. Потому что вы же когда сохраняете что-нибудь в памяти, вы не проверяете, что вы вызвали на каком-то дикшнере такой-то метод, add new item to dictionary, допустим, хэштаблиц. Вы проверяете уже конечный состав хэштаблиц, что у вас в ней сохранился какой-то элемент, при этом неважно каким образом это было сделано. Также из базы данных, вам главное, что в этой базе данных у вас сохранилось конечное состояние вашей системы после того, как вы прогнали какой-то use case. Каким образом это было сделано для вас неважно. Поэтому вот это каким образом, то есть как именно ваша система работает с этой базой данных, вы не должны проверять муками. Потому что иначе, если вы поменяете это взаимодействие, то у вас это будет приводить к ложным срабатываниям. Это было такое большое описание. Я, кстати, хочу сказать, что я не видел не так много на практике попыток всунуть мок базы данных, если честно. У меня такое постоянно, потому что если работать в Javi, Kotlin либо в C-Sharp, есть там customer repository, у него есть либо iCustomer repository, у него есть там какой-то customer repository implementation, то очень часто от этой customer repository мочится и вместо самой customer repository передается мук на этой customer repository. И потом уже проявляется вызов метода coin-safe либо GET, либо что-то еще. Это стало менее нужно с появлением, как ни странно, докера, потому что сейчас... Я не знаю за все языки, я знаю, что в Go есть удобный интерфейс к докеру, где ты просто говоришь, подними мне пасгресс, потом ты запускаешь свое приложение с соединующим конфигом и просто дергаешь его в ручки. Потому что, в принципе, можно сделать это играционный тест, принципизировав нужные классы. И это просто у всех работает. Я могу это на маке запустить, я могу это на сяе запустить. А токер помогает очень сильно с индукционными тестами, это да. И можно исполнять от моков. Я не то чтобы беззубно против моков басданах, но обычно это не так хорошо работает, потому что либо это какая-то хитрая выдуманная реализация, которая работает немножко не так, как наш любимый пасгресс, либо там у него под капотом вообще SQLite, который работает совершенно не так. Просто если приложение предназначено для работы на пасгрессе, то тестируйте на пасгрессе, а не на моке, который пытается его изобразить. Ты сейчас говоришь про пейковые басданах, например, те же самые SQLite. Это немножко другое. Например, in-memory database. Они часто тоже используются вместо настоящих басданах для того, чтобы ускорить тесты, либо там изолировать это.",
    "result": {
      "query": "unit testing mocking best practices"
    }
  }
]