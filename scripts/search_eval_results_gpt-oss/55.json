[
  {
    "segment_id": "8ddb8dc5-037e-467a-8bce-a17a8ef426fe",
    "episode_id": "52a101b4-3780-4ff0-8a10-6d9a9458c81a",
    "episode_number": 55,
    "segment_number": 6,
    "text": "— Запомним, запомним. Арсений, ты нам хотел что-то рассказать про зоопарк языков для шейдеров, что-то такое? — Ну вот я вам сейчас рассказал про зоопарк API, да. Там есть еще одна проблема. Я вот говорил вначале, что чем дальше, тем более программируемое GPU. То есть вот сейчас на GPU можно писать код, который делает очень... вещи очень близкие к тому, который можно делать на обычном центральном процессоре. Наверняка там на слуху у всех когда-то была NVIDIA CUDA, где можно писать код, который похож на C-код, и запускать его на GPU. OpenCL более позднее развитие. Соответственно, чем дальше, тем больше интересно запускать код на GPU. Есть компании, которые используют это в очевидных целях. Там есть Photoshop, хочется фильтры запускать на GPU. Это понятная проблема. Есть компании, в которых есть, например, поиск, типа как Google. Я не знаю, Google конкретно, наверное, тоже исследует этот вопрос. И хочется какие-то кусочки поиска, поискового движка запускать на GPU, потому что быстрее. То есть чем дальше, тем больше GPU может вещи, которые... Можно писать настоящие программы. Turing Complete, все дела. Естественно, для этого нужен язык программирования. И трагедия заключается в том, что в типичной игре кода про... Код всей игры, там он, например, написан на C++ почти всегда, его там очень много. Но даже кода шейдеров, это вот эти программы, которые можно запускать на GPU, его там сотни килобайт условно. То есть в зависимости от игры, легко там может быть мегабайт шейдерного кода. Это код примерно как C++, как C, C++. Трагедия заключается в том, что, естественно, при многообразии API, даже до вот этих всех новых был уже OpenGL и Direct3D, и там на консолях свои. Естественно, что не может быть так, что один язык программирования. Это как бы на x86 все там писали на C или на Python. И не было бы никаких там Ruby, Perl, Erlang, Go, Rust и так далее, и так далее, и так далее. Вот. И вот вы пишете игру, и представьте себе, что у вас есть вот эти там, условно давайте, полмегабайта кода, которые надо бы написать на двух языках программирования. Ну, просто потому, что на одном API можно использовать только один, а на другом только другой. Ну, это так достаточно печальное значит, печальная ситуация. На сегодняшний день мы обсудили несколько API. В DirectX 12 один шейдерный язык, HLSL High Level Shader Language. Во Vulkan как бы шейдерного языка нет, но есть там bytecode, в котором есть компиляторы из GLSL, это OpenGL Shader Language, то есть тот, который был в VGL. И отличилась Apple, они выпустили Metal, и я не знаю, очень странное решение, самое странное во всем Metal, вместо того, чтобы взять один из двух канонических языков написания шейдеров HLSL и GLSL, они сделали свой. Они взяли C++ 11, и его немножко доработали, и там отрезали кусочки, которые не могут работать на GPU, добавили кусочки, которые нужны, чтобы писать код шейдеров, и получился такой типа гибрид C++ 11 и кода завод шейдерного языка, который, естественно, работает только на одной платформе, ну, точнее, только на одном API. А делать с этим что? Использовать готовые движки? Вот, как с этим жить? Надо понимать, у готовых движков есть точно такая же проблема, потому что, ну, нету совсем магического решения. Значит, текущий стандарт в индустрии примерно следующий. Вы выбираете один язык, который для вас самый интересный. Типично это HLSL, то есть из Direct3D, в основном потому что на консолях только он. Плюс-минус. То есть, типа там, на всех консолях, вот я работал, да, на Xbox 360, на PS3, сейчас есть PS4 и Xbox One, значит, насколько я понимаю, на всех четырех условно HLSL или HLSL-подобный язык. То есть вы пишете шейдерный код на HLSL, а дальше он почти сразу работает вот на всех API консольных. Проблема с OpenGL, OpenGL это в основном либо Mac, либо Linux, либо мобильники. Там OpenGL, там другой язык. Соответственно, вы пишете компилятор, Transpiler это называется обычно, то есть вы берете HLSL-код, пишете к парсеру. Почему пишете парсер к HLSL-коду? Потому что у Microsoft нет open-source парсера, вообще весь компилятор, который есть у Microsoft, естественно, который обрабатывает HLSL-код on closed-source, нет open-source парсера, поэтому пишете свой, естественно. И я знаю в индустрии типа там 4-5 мне кажется разных, вот в разных компаниях написали, один из них open-source, но он, там очень плохой код, его очень сложно расширять, и поэтому люди, которые начинают, они вот смотрят на него, это единственная open-source опция, они смотрят на код, им нужно его расширять, потому что он там нефтифичи поддерживает, они говорят, блин, чем, короче, эту фигню использовать, давайте свое напишем. Вот. Ну вот, парсите HLSL, а дальше генерируете GLSL код на выходе, GLSL это тоже высокоуровневый язык, соответственно, ну, вы берете там цикл, у вас есть в HLSL, вот вы его там переписываете на GLSL автоматически компилятором. И трагедия заключается в том, что, во-первых, это достаточно такой странный... Ну, обычно компиляторы, да... понятно, когда компилятор берет высокоуровневый язык и приводит в нижний воскоуровневый язык, это логично. Вот когда компилятор берет высокоуровневый язык и приводит в другой высокоуровневый язык, а потом есть драйвер, графический драйвер, который берет его и уже комплирует во что-нибудь осмышленное, это достаточно печально. Ну и главная проблема, конечно, что их вот там 5 условно, И, наверное, больше я про пять знаю, поскольку только один open source, наверняка их больше. И еще надо понять, что вот у вас есть полмегабайта шейдерного кода, но это важные полмегабайта, то есть вот если их убрать, то у вас игра вообще не может рисоваться, если вы...",
    "result": {
      "query": "GPU shader programming language challenges"
    }
  }
]