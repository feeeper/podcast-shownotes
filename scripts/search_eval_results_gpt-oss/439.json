[
  {
    "segment_id": "412e4b44-b58d-431c-88ba-6c885fcb4d32",
    "episode_id": "12179b91-7df6-4eec-962d-35dc59c2359a",
    "episode_number": 439,
    "segment_number": 4,
    "text": "Это все входные данные, которые влияют на выход компилятора. То, что выдает компилятор, все факторы, которые существуют в окружении, это релевантные входные данные. Они делятся на две категории. Одна из них преднамеренные, запланированные релевантные данные, а другая — это нечаянные данные. И в запланированной категории там очевидные вещи, такие как версия компилятора, версия исходного кода, который вы собираете. Ну и в общем, все. А вот куча остальных параметров, таких как архитектура вашего текущего процессора, на котором вы собираете, архитектура процессора, на котором, возможно, был собран компилятор, версия динамического линковщика, версия операционной системы, версия C-компилятора на этой системе, текущая дата-время, текущее имя юзера, его по ID-шник или еще что-нибудь в этом духе. Все вот эти вещи, они на самом деле так или иначе имеют шанс просочиться в ваш бинарник, и при их перемене, соответственно, бинарный результат компиляции станет другой, и верифицировать идентичность билда станет проблематичным. Собственно, почему это важно было для команды Go? Для команды Go это было важно, что они хотят, чтобы бинарные версии тулчейна, которые они публикуют у себя на сайте, были легко верифицируемы любыми сторонними пользователями, а также чтобы Go мог сам себя бутстрапить. Также верифицируем образом. Я, наверное, попущу детали того, как конкретно Go тулчейн бутстрапится, но идея состоит в том, что у них в дистрибутиве есть некоторый бутстрап тулчейн, который пресобран, и с его помощью они собирают текущую версию тулчейна три раза, и таким образом, если сборка полностью воспроизводимая, то второй и третий результат сборки должны быть идентичны с точностью добита. Вот. Соответственно, интересно было посмотреть, какие усилия команде Go пришлось предпринять, чтобы добиться идеальной воспроизводимости. В частности, то, чего они хотели добиться, это чтобы воспроизводимость единственными релевантными входными данными были, собственно, версия тулчейна и исходные тексты. Вот. Опять же, я не стану перечислять все, что они делали, поскольку это довольно длинный текст, но перечислю некоторые интересные моменты. Во-первых, у них была проблема зависимости от тулчейна C, который был установлен на машине сборки. Почему это проблема? Потому что существует больше одного компилятора C, и они ведут себя по-разному. Более того, один и тот же компилятор, в том смысле, что один и тот же тип компилятора может вести себя по-разному на разных площадках. И это не только для Windows и для Linux. Это не то, чтобы совсем разные вещи, но они могут иметь свои особенности. Вот. А почему Go зависел от компилятора C, казалось бы, хотя он сам написан на Go? А потому что стандартный пакет библиотеки Net зависел от компилятора C, потому что он зависел от C-шных библиотек операционной системы. Поскольку правильное разрешение доменных имен сделать нативно, не обращаясь к библиотекам операционной системы, практически невозможно. Просто потому что разные системы делают это по-разному, они могут быть очень сильно по-разному сконфигурированы. И, в общем, единственный надежный способ это просто позвать стандартную библиотеку, которая имеется. И, в общем, это очень важно на текущей машине. Вот. И изначально пакет Net использовал C-Go, чтобы прилинковаться к стандартной C-шной библиотеке и использовать ее функции для разрешения доменных имен. Что сделали разработчики Go? Они переписали этот пакет таким образом, что под macOS и Windows он динамически загружает, DLL-ку, и вызывает эти функции, но не используя языка C. То есть они просто это переписали на сисколах и ассемблерных вставках, насколько я понимаю. Вот. Таким образом, на этих двух платформах все получается просто. И это работает, потому что гарантированно библиотеки на разных инсталляциях macOS будут одни и те же. То есть macOS шипится с конкретными DLL-ками для работы с сетью. Это не так хорошо работает на Unix, потому что на Unix есть более одной реализации стандартной библиотеки C. И что они сделали в этом случае? Это они по умолчанию стали собирать сам тулчейн... Точнее, нет. Они сделали две вещи. Во-первых, они... Во-вторых, они сделали две вещи. Они автоматически стали выключать CGO для сборки пакета .NET, если C-тулчейн не установлен. А во-вторых, они выкинули предкомпилированную версию этого пакета из дистрибутива, таким образом уменьшив размер дистрибутива и избавившись от нужды верифицировать совпадение этого самого бинарного пакета. То есть теперь, когда вы ставите GO, вам приезжает... Стандартная библиотека просто в виде исходников, и вы ее соберете первый раз, когда вы что-то компилируете. Вот. Кроме того, в версии 1.21 они сделали изменения так, что сам тулчейн GO теперь под... С операционными системами собирает без CGO по умолчанию. Вот. И таким образом он перестает зависеть от... C-тулчейна. Также им пришлось сделать некоторые дополнительные реверансы, чтобы перестать зависеть... от динамического линковщика по всем тем же причинам. И... Что еще? Другой... Другая интересная проблема это, что... папка, в которой вы изначально собираете свою программу, она тоже попадает в ваш бинарник через отладочные символы. Поэтому, чтобы пользователи GO-тулчейна могли воспроизвести идентичную сборку в любой другой папке, они и добавили специальный флаг, который кидывает префикс пути к дереву исходников компилятора из бинарников. Таким образом, если вы выкинете этот префикс и у себя, то у вас получатся идентичные бинарники. Вот. Там более простые фиксы типа нормализации слэшей под Windows и Unix, чтобы они все были forward-slash, а не платформозависимой. Интересный момент был с ARM-ами. По историческим причинам, по умолчанию... Даже так. У ARM-а есть две версии архитектуры. В некоторых версиях у них нет аппаратной поддержки операций с плавающей точкой, поэтому она эмулируется софтверно. А в более новых архитектурах такая поддержка есть. И по историческим причинам компилятор Go решал, будет ли он использовать аппарат, будет ли он выдавать код с аппаратной или софтверной поддержкой в момент сборки тулчей на Go на какой платформе он собирался. При этом, если вы кросс-компилируете компилятор Go под ARM на не ARM-системе, допустим, на Intel, то он по умолчанию консервативно подразумевал софтовую реализацию плавающих чисел. А если вы компилируете на ARM, то он смотрит, поддерживает ли ваш текущий процессор аппаратную плавающую число, и в зависимости от этого он компилирует с тем или иным флагом. Что они поменяли? Они поменяли так, что теперь всегда он по умолчанию использует аппаратную реализацию плавающих чисел, за исключением тех ситуаций, когда вы собираете на таком старом ARM, на котором ее нет. И что это дает? Это дает то, что кросс-компиляция тулчейна на не ARM-архитектуре дает такой же результат, какой и дает компиляция Go тулчейна на любой современной ARM-архитектуре. Малинки в большинстве мобильных процессоров и все такое. Вот. Отдельную кучу... Погоди, я не понял. То есть они собирают всегда в предположении, что все возможные... вся возможная функциональность есть, то есть как бы на новые ARM рассчитывая, но если ее нет, то оно не упадет или упадет? И надо будет пересобирать? Или у него есть там backup версии, он на лету определяет, если в архитектуре эти инструкции и будет запускать другую, более медленную версию? Это хороший вопрос. Насколько я понимаю, если ты собираешь компилятор с расчетом на аппаратное использование числа с плавающей точкой, то бинарники, скомпилированные этим компилятором, не запустятся на старых ARM-ах, у которых аппаратной поддержки нет. Поэтому, если ты знаешь, что ты будешь работать на таком старом ARM-е, тебе придется пересобрать тулчейн под конкретно ту архитектуру, передав ему параметры конфигурации. Но по умолчанию теперь он всегда использует аппаратную реализацию флоутов. Просто я бы сделал еще и поддержку этих каких-нибудь медленных дополнительных оптов, сделать динамическую проверку. Я на самом деле тоже задумался, почему они не решили выбирать использовать аппаратную поддержку или софтовую поддержку в аутпутах компилятора в рантаймент, то есть когда вы вызываете компилятор. Они об этом не говорят. Но я подозреваю, что отчасти еще дело в том, что если ты таргетишь платформу без поддержки, то тебе и компилятор тоже нужно собирать без поддержки флоутов. То есть тебе все равно нужно знать на этапе, когда ты компилируешь компилятор. Ну и возможно есть какие-то еще исторические причины. Надо сказать, что с линковщиком они как раз поступили именно таким образом. Они теперь, когда ты вызываешь свою компиляцию, тогда они смотрят, какой у тебя линковщик, точнее какой у тебя путь к линковщику и его используют при компиляции. Но при этом они не при этом раньше они смотрели на путь линковщика при сборе компилятора и после этого компилятор всегда использовал тот самый путь линковщика. Вот.",
    "result": {
      "query": "Go reproducible builds challenges"
    }
  }
]