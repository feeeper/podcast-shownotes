[
  {
    "segment_id": "9881f17d-18ec-40a7-a6de-ae6bf035273e",
    "episode_id": "d5035d65-88bd-476b-8d60-71c7be88f7a8",
    "episode_number": 140,
    "segment_number": 6,
    "text": "Вот. То есть jigsaw в этом смысле, в каком смысле он такой? Инфраструктурный проект. То есть у него есть и внутренние какие-то бонусы для разработки самого jdk, но есть и внешний бонус, потому что он дает возможность сделать вот подобного рода новые оптимизации снаружи, потому что он по сути вводит в как-то опциональную стадию линковки всего-всего этого мира в один большой jimage. Это то, что я понимаю, то, что я касался jigsaw. Я как-то там только со свечкой стоял, поэтому не могу поручиться за то, что я понимаю все правильно целиком. Такой вопрос. Сейчас как бы его сформулировать. Вот допустим, кто-то из наших слушателей хочет стать контрибютером в OpenJDK, ну это же открытый проект. Насколько оттуда вообще реально прийти вот так снаружи, или нужно обязательно работать в компании, и если тем или иным путем можно прийти, то с чего начать? Да, значит, надо отдать должное компании сам Microsystems и тоже компании Oracle. Правила, которые сформулированы для OpenJDK, они на самом деле в большой мере вендор-агностик. То есть там нет особенной заточки на конкретной компании. То есть если ты контрибютер не ассоциирован с какой-то компанией, просто тебе нравится по вечерам хатчить OpenJDK, то там есть довольно простой процесс, каким образом можно получить разные роли в проекте. То есть там, например, для того, чтобы получить лычку Author, которая дает тебе, например, доступ к бактрекеру, тебе там нужно всего сделать 2 Contribution в OpenJDK. Причем Contribution, что такое Contribution, это такой субъективный вопрос. Например, в онлайнер, в документации это Contribution или нет? То есть там обычно есть какой-то такой обтекаемая серая зона. Но если у тебя есть конкретные кодовые улучшения, ты их делаешь постоянно. И даже если там несколько сложных улучшений или много маленьких улучшений, то ты в итоге получаешь там первую свою лычку Author. После того, как ты сделал больше Contribution, ты получаешь лычку Committer. Ты получаешь возможность коммитить прямо в OpenJDK кодовую базу. Сколько таких людей всего? Ну, порядок. Достаточно много, там есть сотни, десятки. Сотни, да, я бы сказал. Постоянных коммиттеров, я бы сказал, меньше сотни, но вообще, если посмотреть на OpenJDK цензус, там есть такая страничка, в которой описаны, кто эти люди и какими ролями они обладают в проекте. То там можно увидеть, что достаточно много людей. Конечно, большая часть этих людей из компаний Sun Microsystems и Oracle теперь. Ну, просто потому, что Oracle вливает туда тьму-тьмущую инженерных ресурсов. То есть он финансирует огромную девелоперскую организацию, которая работает над этим проектом. Поэтому может казаться, что в OpenJDK доминируется Oracle, но она доминируется, как доминируется любой другой опенсорсный проект. Если у тебя есть дофига контрибьюторов из твоей компании, ты, значит, контролируешь этот проект, очевидным образом. Другие компании, такие как Red Hat, например, SAP, кто угодно еще, Google, IBM и так далее, они туда приходят тоже наваливать своих контрибьюторов как раз для того, чтобы тоже получить часть контроля над этим проектом. Там есть достаточно много людей, которые не афилированы ни с какой большой компанией, а просто контрибьютят и обладают большими статусами, просто безбомберных кратическим соображениям, которые выписаны в правилах OpenJDK. Тут не надо себя обманывать только в том, что OpenJDK — это непростой проект. То есть критерии качества, которые предъявляются, скажем, к патчам, они существенно выше, чем критерии качества к какому-нибудь опенсорсному проекту, у которого там три звездочки на GitHub. Это скорее уровень такого Linux kernel, GCC, Glibc. Не то что там все сложные баги, которые ты можешь править, но обычно стандартные качества там сильно повышены. Есть как бы обходной путь. Обходной путь состоит в чем? Кроме самой OpenJDK, вернее, кроме самой виртуальной машины из стандартной библиотеки, которая является как бы подставкой JDK, есть посторонние проекты. Например, есть OpenJDK CodeCodyTools, такой большой проект, в котором есть проекты типа jmhub, jcstress, joel, jtrec и прочее. То есть это пулы, которые обслуживают OpenJDK, которые в сборку OpenJDK не входят, но они в составе этого мегапроекта. На них распространяются те же самые правила. Туда, как правило, контрибьюшены гораздо проще влить, потому что стандартные качества там ниже, поскольку это не тот продукт, который ты релизишь на миллиард инсталляций. Но это дает возможность быстро получить доступ к бактрекеру на запись, вырастет сейс как коммиттер и так далее. Кстати, было много сказано про стандартные качества, а вот, собственно, как это выглядит в случае с JVM, как она тестируется, как она проверяется, как патчи проверяются. Есть ли рассылка, есть ли issue tracker и так далее. Ищуе трекер есть, bugs.openjdk. java.net огромный. Там очень много ishuев унаследовано еще из старых сановых бактрекеров. Туда наваливаются постоянно куча багов, и фифи там трекаются, и прочее, прочее. Вот, допустим, с точки зрения новичка, рассмотрим процесс, да, и хочется протолкнуть патч, его надо отправить в какой-то mailing-лист, и что с ним дальше будет, и так далее. Да, есть целая страничка, называется OpenJDK Contribute, там прямо описан подробный процесс, что, типа, если ты хочешь законтрибьютить, ты не знаешь, что начать, идешь в багтрекер, выбираешь свой любимый баг, пишешь к нему патч, берешь соответствующий mailing-лист, и приходишь туда и пишешь, я, Вася Пупкин из Древнего Дюкина, очень люблю разрабатывать OpenJDK, вот мой патч для такого-то ishuя. Если этот ishu нормально, это означает, что тогда с той стороны к тебе приходит инженер и говорит, окей, чувак, у тебя, поскольку статуса пока никакого нет, спасибо за патч, мы его залили вот так-то, и тебе ставится где-нибудь плюс один. Ты приходишь второй раз, тебе ставится еще раз плюс один, третий, четвертый, и ты получаешь дальше илычки, илычки, илычки, илычки, и в итоге начинаешь все больше и больше приобретать самостоятельность в этом проекте. Вот такой примерно процесс. Опять же, о наболевшем. Надо думать, OpenJDK такой сложный проект, как люди не сходят с ума его разрабатывая, там, очень доходчивый комментарий, или он не такой прям выпиюще сложный, как кажется, или как это происходит? Я вот, честно говоря, не очень уверен, что люди не сходят с ума. Мне кажется, что многие люди, которые много занимались вообще подобного рода проектами, и это не только OpenJDK, но и какие-нибудь там компиляторные, толчейные и прочие, они на самом деле все уже поехавшие, просто они как-то хорошо социализированы. Вот я, например, не уверен, что я не сумасшедший после всего того, что я тут сделал в OpenJDK. Это... там есть, понимаешь, несколько вещей. Как и во многих больших проектах, там есть сложные вещи, которые нужно делать, которые требуют залазения своими руками во все части рантайма, например. А есть простые вещи, которые реально очевидные баги, которым просто никто не занимался, потому что на это нужно время, а времени мало обычно. Обычно начинающие начинают вот именно с таких маленьких-маленьких ишуев. Говорят, а вот здесь неаккуратненько, здесь можно пофиксить, а здесь неаккуратненько можно пофиксить, а вот здесь вот этот метод можно по-другому написать, а вот здесь можно вот так отрефакторить вот этот класс, а вот тут можно вот этот пэкэдж вообще выкинуть или свести его к трем пэкэджам. Ну вот такой элеватор получается, что ты начинаешь с маленького, поскольку потихоньку как-то раскручиваешь связи в этом продукте, ты получаешь возможность делать все больше и больше изменений, потому что ты больше и больше продуктов понимаешь. В итоге ты дорастаешь до понимания всего продукта целиком и можешь делать фичи, которые делают изменения прямо во всех частях рантайма. Сразу вопрос. Отношение к рефакторингам и вот такого рода вещам, оно как бы нормальное? Или тебе пишут ответ, что типа ну да, этот метод, ну не метод, хорошо, это процедура усиливает на тысячу срок, можно было бы конечно разбить на две, как в твоем патче, но мы не видим мотивации этого делать. Ну честно говоря, я не видел, чтобы патчи отклоняли из соображений... Ну из соображений простое. Сейчас кто-то возможно работает над патчем в этом месте, а ты своим рефакторингом ему помешаешь, и толку от этого рефакторинга как-то немного. А, нет, такое бывает, но это обычно заканчивается следующим. Тебе говорят, чувак, мы знаем, что Гоша Кораблев работает над патчем в этой же области, пойди пожалуйста с ним поговори, пусть он твой патч зальет к себе, ну как бы ты скоординируетесь вот так. То есть это в этом смысле open source, пожалуйста работайте вместе. Такого, чтобы OpenJDK отклонили патч, ну просто потому что, а зачем менять этот код? Ну если это изменение улучшает читаемость, то это очень хорошо, потому что улучшая читаемость, значит меньше там вероятность того, что ты сделаешь какой-нибудь трудноуловимый баг. В PostgreSQL такие патчи, как правило, не принимают, как раз из двух соображений, что возможно там будут конфликты в патчах, и вторая проблема, что возможно будут фикситься баги, которые будут бэкпортиться в разные версии. И если ты вот там например в 9.6 отрифачил, а в 9.5 оно не отрифачено, то как бы будет трудно бэкпортировать. Это конечно да, это интересные соображения, но тут есть очень простой такой лайфсайкл о том, что собственно мажорный релиз, когда ты выпускаешь, он будет отличаться от предыдущего мажорного релиза. В какой-то момент ты перестаешь поддерживать мажорные релизы там N-катой версии, например. Поэтому вопросы бэкпортинга конечно встают, но на них ты тоже смотришь как бы с прищуром ленинским. Если ты понимаешь, что бэкпорт будет усложнен, ну и ладно. Это не повод для того, чтобы не рефакторить конкретный метод, потому что иначе эта логика приводит к тому, что ты не можешь рефакторить вообще, если ты все время печешься только о том, чтобы была возможность бэкпорта. Ты отчетливо себе представляешь, что многие изменения, многие рефакторинги ты не будешь бэкпортить. Точка. Ты будешь бэкпортить только критические изменения. И ты будешь ожидать от пользователей, ты будешь своим лайфсайклом своего продукта пинать пользователей на то, чтобы они пользовались более старшими версиями. И все. Вот примерно такой подход. То есть, скажем, перенести там какие-нибудь, переименовать какой-нибудь класс, это не является такой внутренней проблемой сильно. Ну да, тебе придется, если ты будешь бэкпортить какие-нибудь критические изменения в этом фиксе, немножко попотеть, чтобы его вставить в нужное место в предыдущей версии. Окей. Но это не означает, что ты не переименовываешь класс, если он устраняет какой-нибудь класс ошибок, да, или предохраняет от какого-нибудь класса ошибок, потому что класс неправильно был назван, например. Вот. Это нормальная ситуация. Ну, кстати, ты упомянул, что начинается еще меньше переходить по большей долге, пока не узнаешь, что проект это все. Это, в принципе, довольно классическое. Многие так и делают, многие так и советуют. Тем не менее, JVM, в отличие от того же Postgres, это проект, который наружу особо не торчит. Ну, то есть, он наружу торчит своей стандартной библиотекой. Однако он внутри устроен очень нетривиально. Есть ли какая-то документация хотя бы для разработчиков, как вы передаете знания, как это внутри устроено и почему оно так устроено? На деле, если смотреть на многие... Вернее, так. Большая часть виртуальных машин на самом деле друг на друга похожа. То есть, в принципе, концептуальная компоновка виртуальных машин, вне зависимости от целевого языка, от целевой платформы, она на самом деле более-менее равномерна между реализациями. Поэтому в крупную клетку для того, чтобы понять, как устроен рантайм. Ну, там, если ты хочешь узнать, как устроен ГЦ, ты открываешь учебник по ГЦ и, в общем, читаешь примерно архитектуру. И можешь даже соотнести архитектуру из учебника с архитектурой, которая в коде написана. Если ты хочешь узнать, как компилятор написан, то у тебя есть классические труды и текстбуки, прямо в которых описаны структуры этих компиляторов. Либо это статьи или диссеры людей, которые писали этот компилятор, в котором описаны базовые идеи и подходы. Во многих нетривиальных местах просто есть очень большие лыжи комментариев, которые описывают рациональность, почему сделаны именно так. И эти комментарии дописываются с истории багов, которые были вызваны или исправлены этим изменением и так далее. Ты можешь пойти в багтрекер, найти ссылки на эти баги, найти тестовые кейсы, которые пофейлились. По ссылкам из этих багов ты можешь найти обсуждения на мейлинг-листах, которые описывали эти проблемы и так далее. То есть в принципе, если тебе приходится заниматься археологией, то там ссылочки-то провязаны друг между другом. Ты можешь найти концы, почему сделано было именно так. Это особенной проблемой не составляет. А я вот всё-таки задумался, что как же так, если сотни коммитеров, а кто в какой момент принимает такое волевое решение, что всё, мы релизим Java 9, у нас там фич фриз и так далее? Ну, это интересный вопрос. То есть в принципе, есть GCP, который обсуждает, что является стандартом Java, и что туда входит и так далее. И этот GCP вообще в нём участвуют компании. Это консорциум компаний, которые определяют, что есть стандарт, а что нет стандарта. Понятно, что в этом полумеритократическом процессе в основном компании, которые делают фичи, они определяют, в какой релиз они войдут. Успеют они сделать конкретному релизу или нет. Во многом сейчас, поскольку Oracle доминирует под JDK, чисто по количеству инженеров, это во многом решает Oracle. Что он говорит, что, чуваки, мы считаем, что roadmap для JDK 9 должен выглядеть вот так, вот такие-то джепы затаргетчены на Java 9 и должны быть выполнены там. Это не обязательно все оракловые джепы, это могут быть и джепы других людей. То есть оно примерно на таком уровне происходит.",
    "result": {
      "query": "contributing to OpenJDK process"
    }
  }
]