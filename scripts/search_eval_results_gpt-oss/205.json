[
  {
    "segment_id": "72629922-5d7e-4031-ab05-9a452d4e2504",
    "episode_id": "b4a2a9e5-1c51-4ae2-b00f-361c242ba013",
    "episode_number": 205,
    "segment_number": 2,
    "text": "Можно было бы пройти мимо, но он решил, что это вроде как его непосредственная работа, и он начал исследовать эту проблему чуть более детально. И в результате получилась такая детективная история. Первое, что он сделал, это включил трассировку всех ивентов в хроме. И что забавно, я не знал о таком софте, есть для Windows специальная программа, которая открывает интерфейс, в который хром может сливать все свои ивенты, которых достаточно много, они с большой часто идут. И вот эта прога через специальное API в сервисе в памяти коллекционирует эти ивенты, потом их складывает на диск. То есть идея в том, чтобы на диск обращаться редко, ты можешь набрать несколько гигабайтов таких трасс и скинуть их на диск потом. И файлики, которые получаются, они подходят для от перформанса аналайзеров разных. Соответственно, он записал такую активность, у него получилось это воспроизвести, и ничего особенного там не увидел. То есть нигде CPU, например, usage не становится высоким, ничего там необычного особенно нет. Следующее, что он сделал, включил Keylogger, то есть он набирает письмо и он решил матчить вот эту трассировку с его набором текста. В итоге вот так у него получилось найти момент в этих трассах, где хром ничего не делал. И там была как раз особенность в том, что не высокий CPU usage был, а его вообще не было. То есть на этих графиках, вот в его статье, в блоге видно прям такой провал активности. Дальше, что он сделал, он начал смотреть бэктрейсы в этот момент. И в этот момент видно, что хром пытается лоцировать память, причем, как потом выяснится, именно экзекютабл фигмента памяти. А ему это не получается, ему это не удается в том плане, что он висит просто на локе. То есть он пытается захватить лок, но не может. Вот у него там было 400 стэктрейсов за эти несколько секунд, пока хром не мог рендериться. И все 400 раз он не смог взять. Дальше он начал записывать всю систему и увидел, что есть у него такой Windows VWMI процесс, который израилит 100% CPU, но у него как бы еще... Если я встрянусь в вопрос, может кто-нибудь объяснить, что такое Windows, вот этот вот процесс? Да, могу. Я специально посмотрел. В общем, VWMI, это специальная такая подсистема скриптованная, он дальше пишет, что у них в гугле, вот все компы их рабочие, тестировщиков, они несколько раз в день проходят сканирование на какие-то метрики. И оказалось, что VWMI, это такое типа окружение, ну в общем, это экзекьютор такой скриптового язычка, и скрипт, который был запущен, он сканировал всю память. То есть он идет по списку открытых процессов и смотрит, сколько аллокаций есть, какие блоки зааллоцированы. Вот именно вот этот процесс брал лог, который не мог Chrome получить. В общем, я ответил на этот вопрос, что такое VWMI. В общем, это некоторая скриптовая штука для Windows, которая в нормальной инсталляции у вас ничего такого запущенного не должно быть. Но по-хорошему, даже если она запущенная, и у вас какие-то скрипты, вот он дальше пишет, что стригерить на обычной этой системе можно, запустив диагностику, вот он там пишет, каким способом в Windows можно ее запустить, и вот будет примерно то же самое, что у него и от вас производится. Вот, то есть на чем я остановился, что он видит, что вот этот WMI-процесс сканирует виртуальную память Chrome, пытается получить статистику по аллокациям, и вот он все время берет лог, и вот тут классический такой log starvation или priority inversion, что вот этот WMI-процесс, он берет лог, освобождает его, в общем, что шедулер будет Chrome в те моменты, когда лог занят, и когда лог отпущен, ничего не происходит. А напомни, речь идет про лог, про который операционная система знает. Это лог именно операционки, то есть в этих бэктрейсах он видит, у него подгружены символы ядра, и вот у него Chrome просит типа allocate памяти, которую он собирается сделать executable, и там дальше видно такой стек, который уходит уже в ядро, что они дерутся за лог в локаторе. А, но операционная система его будет, она не знает, что он собирается взять этот лог. Да, да, ну то есть это обычные логи, которые нечестные, то есть это такой лог как лог. Вот, но это не то, что это, это еще далеко до самой проблемы, то есть это один из симптомов. В итоге он посмотрел на этот лог Starvation и решил, не воспроизведется ли у него с его скриптами такое же. В итоге он сам написал сканер памяти, который то же самое делает, но при сканировании каких-то других процессов, которые примерно такое же количество памяти аллоцировали, ничего не происходит. А вот когда Chrome сканирует, то начинает, во-первых, его сканер 100% в CPU сжать, во-вторых, Chrome начинает лагать, и непонятно, что происходит. А сканер это через виндовый API, он запрашивает, какие локации есть в процессе, непрерывные. И можно посмотреть в винде, что на результат выхлопа этого сканера вроде не особо много, то есть какой-то сильной фрагментации памяти он там не видит. Дальше он взял такую виндовую Toolz VM Map, которая распечатывает адресное пространство, ну больше статистики об адресном пространстве выдает, и увидел там одну из локаций на 2 терабайта. И вот тут он вспомнил, что он о чем-то похожем читал, что в винду, начиная с 8.1, завезли рандомизацию адресов, что-то типа, по-моему, в OpenBSD сейчас также сделано, а SLR, адрес Space Load Randomization. В винде это функционал называется Control Flow Guard, и вот в винде 8.1 они поменяли максимально возможную память процесса с 16 терабайт на честные 256 терабайт, и заодно еще занесли вот эту рандомизацию памяти для executable страниц. Я только должен тебя чуть-чуть дополнить, не знаю насчет виндового механизма, а SLR он есть не только в BSD системах, это давно уже механизм Linux. А, в Linux, ну окей, я просто точно помню, что я про BSD читал, и также они мапят на большой размер памяти. Я один раз увидел у себя в EdgeTop в списке процессов использования ресурсов под 2 терабайта, сначала порадовался, откуда у меня столько памяти, потом очень удивился, что вроде бы не было, потом да, это всякие новые модные защиты. Ну вот. Это было давно. Ну ок, значит все завезли, винда тоже старается не отставать. И вот, это 2 терабайта, но 2 терабайта это не аллокация, вернее как, это аллокация, но она естественно не вся использована, и именно вот в этой 2 терабайтной, в 2 терабайтном куске там страниц много. То есть если, like, там десятки тысяч страниц были у самого Хрома, той памяти, которой он пользуется, то еще вот тоже десятки тысяч были в этой Control Flow Cloud Area. Соответственно, дальше он попробовал уже воспроизвести это и без Хрома, тоже написал программу, которая аллокирует кусочки памяти, делает их экзекьютабл, это важно, потому что вот этот механизм включается только на экзекьютабл страницах. И у него получилось это воспроизвести, в итоге оказывается, что Windows не освобождает информацию об аллокациях в этой зоне, пока их не станет очень много. И в итоге он там пробовал неделю растить себе вот эту зону, и она у него вырастает до нескольких гигабайт, но все равно не освобождается, то есть там, ну, можно сказать, такой, типа, memory leak внутри операционки. Хотя, на самом деле, там есть какой-то размер, после которого она вся выкидывается, но он очень большой. В итоге, возвращаясь к Хрому, оказалось, что Gmail для offline режима использует веб-боркеры, которые просыпаются раз в пару минут, каждый веб-боркер, когда просыпается, инициализирует EvoScript, Engine v8, вот, этот v8.git компилирует тот код, который у него есть, создает новую страничку в памяти, делает ее экзекьютабл. Прости, я тебя чуть-чуть прервал, у тебя что-то трется о микрофон. Может быть, да, извиняюсь. Вот это вот. Это я руками тут вожу в воздухе. Ты потеряешь микрофон? Потираю воздух, а микрофон был рядом. Ну вот, и в общем, v8.git компиляция создает экзекьютабл страницы новые, каждый раз новые при каждом запуске, и вот так вот все это начинает очень медленно иногда работать, когда кто-то тебя сканирует. Соответственно, Chrome у себя исправил, они впилили кэшик таких страниц, и Windows в новых версиях, они тоже исправили это, и теперь так эта память не растет такими ужасными темпами. Вот, в общем, такая история о дебаге. Интересно, сколько еще софта на этом налетало? Ну, я не думаю, что это такая специфическая штука, то есть, в целом, я думаю, что в программе аллоцировать экзекьютабл куски памяти, это не самая стандартная вещь. То есть, если ты не делаешь что-то типа Gita, то даже, ну, то есть, либо ты вирус, либо ты GIT делаешь. Вот, может, еще что-то есть. То есть, это аффективно весь JVM и сам .NET и все, что на нем работает? А, ну, кстати, да, да. Если с этой точки зрения, то, наверное, много софта. Ну, и кто-то должен сканировать обязательно тебя, чтобы вызвать log starvation, чтобы твоя программа не могла зааллоцировать этот кусок. Да, дела. Вопросы, дополнения, кто-нибудь? Соображения? Ну, я, конечно, могу потянуть тему, спросив, а сталкивался ли ты с чем-то таким в Postgres, может быть, не конкретно с этой проблемой, а вообще с log starvation. Ну, вообще, с кучей похожих проблем сталкивался. С log starvation есть, ну, это частая проблема в базах данных, когда вот у тебя процесс или тред, который владеет локом, его шедулер выгрузил, и у тебя много других процессов, он все остальные будет, они пробуждаются, видят, что ресурс занят, уходят, а тот, кто его держит, он на самом деле, там, до него не доходит шедулер. И вот один из способов, как это можно преодолеть, это юзать что-то более близкое к операционке. То есть, например, в одном проекте помогла замена локов на осимофоры, то есть там были самодельные локи сделаны на атомиках, а о осимофорах вроде как шедулер Linux знает, и вот тогда это помогло. Еще похожая проблема была, когда у меня на Mac SE неправильно написанная программа, которая дергала постоянно, на неблокирующем сокете постоянно дергала ресив из-за ошибки. То есть вот создается там busy loop, который постоянно пытается из сокета вычитать, неважно, есть там данные или нет, вот он трется. Окей. Создает busy loop, который постоянно пытается вычитать, и от этого у меня переставало на Mac работать очень много софта, и самое обидное, что переставало работать дебаггер. В общем, эта прога, которая была важной, она была запущена на лупбэк интерфейсе, и из-за вот этого постоянного опроса ресива, она, в общем, весь лупбэк интерфейс переставал работать. А макосный дебаггер, у него единственный интерфейс, по которому он коннектится, то есть ты лупбэк пишешь в консольке, и он через лупбэк пытается приконектиться к лупбэк серверу. А весь лупбэк интерфейс не работает, при этом другие интерфейсы работают. У меня на работе стоит рядом ноут и еще один компьютер, и я просто заходил с другого компьютера на свой лупбэк сервер, чтобы подебажить, чтобы понять, что это такое. И тут очень помогали символы ядра, в итоге выяснилось, что это... Ну в общем, что вроде как все и нормально, просто не надо так делать. Но было забавно, это тоже зависит от версии. В каких-то более свежих апдейтах OSX это починили.",
    "result": {
      "query": "Chrome memory allocation log starvation debugging"
    }
  }
]