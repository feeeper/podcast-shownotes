[
  {
    "segment_id": "59ff0775-ad7f-4066-bed0-84c17defde45",
    "episode_id": "0b5b6a61-296d-4023-928b-7b721820454a",
    "episode_number": 223,
    "segment_number": 2,
    "text": "подходит, да и для интеграционных, наверное, можно делать лучше. Собственно, я не знаю, как бы к этому лучше перейти, в общем посыл такой, что обычно нам депенды нужны, когда мы хотим тестировать какой-то IOS с внешним миром. И мокать, в принципе, в некоторых случаях вариант, то есть если мы знаем, что какой-то endpoint отдаёт просто всегда какой-то похожий набор данных, если мы тестируем просто поведение на конкретном наборе данных, можно действительно не к настоящему сервису ходить, а мокнуть это, ну как бы тем, что нам нужно. Но это не всегда хорошо, особенно если мы пытаемся тестировать какие-то внешние API, там тот же самый, я не знаю, интеграция с Facebook каким-нибудь или с Google, или с Twitter, неважно с чем, тогда начинаются проблемы, что если мы это замокаем, они поменяют поведение, то мы не знаем, что наш код сломался, ну или узнаем, но поздно. В принципе, хороший способ в таких случаях это там брать и прям к ним ходить под каким-нибудь специальным тест-юзером, многие из этих публичных API позволяют иметь тестового юзера. Ну или ещё вариант просто банально ходить, если такой-то ваш сервис, точно так же свои сервисы писать с такой же идеей, что у них есть какие-то специальные юзеры, которые к ним ходят из тестов, тогда ваши тесты без отдельного, без того, чтобы разворачивать специальное окружение под них, могут работать с какими-то такими реальными источниками данных или реальными другими сервисами, без необходимости разворачивать каждый раз какие-то сложные интеграционные конструкции. Ну и опять же, в принципе, нужно, видимо, как-то пытаться разделять, зачем мы это IEO делаем, то есть там довольно тонкая грань проходит, и там даже, если я правильно помню, автор сама не даёт точного ответа, где у нас, как бы, когда мы будем пытаться мокать, когда не будем, то есть, наверное, там грань проходит где-то между того, что если это IEO какое-то смысловое, то есть нам нужно, то есть смысл этого сервиса – это ходить в какой-то другой сервис и там из него получить A, B, C, что-то с ними сделать или там вернуть наружу. Вот в таком случае нам нужно максимально приблизить вот этот вот тест к тому, что он реально ходит в какой-то другой сервис. То есть, как бы не мокать ту цепочку дипендов, которая является основой бизнес-логики. С другой стороны, если у нас есть какая-то штука, которая просто такой, не знаю, нам конфиг, например, отдаёт, это в принципе можно и замокать. Видимо, какой-то такой подход. Ну и в принципе, что то, что раньше было юнит-тестами, оно начинает быть похоже немножко на такие почти интеграционные тесты, которые не мокают всё, а оставляют некоторые вещи пойти наружу. В принципе, конкретно вот эту штуку я делал и раньше. Я как-то тоже всегда считал, что какой смысл мокать ответы из HTTP, потому что мы тогда, получается, или реализацию HTTP клиента начинаем тестировать, или вообще какую-то свою фантазию во внешнем дипенде тестируем, а не то, что реально происходит. Соответственно, интеграционные тесты тогда становятся чем-то интересным. Они получаются, мы как бы делаем или canary deploy, или deploy в какой-то специальный environment, и там, получается, валидируем. Какие-то там, не знаю, exploration, performance и так далее, может в принципе даже уходить на production. Мы просто выкатываем на очень маленький процент production на что-то экспериментальное, но достаточно стабильное, представили мы себя, показавшее на предыдущих этапах. И смотрим, насколько оно себя ведет. Это нам очень сильно помогает наши инженерные усилия как бы держать в разумных рамках, не пытаться всё вообще возможное протестировать до того, как оно подойдет на production. Как-то так вот я понял статью и в принципе, наверное, согласен и в принципе, наверное, буду пытаться следовать и не пытаться больше запекнуть половину production в токер комп. Мысли, комментарии? Ну, единственный комментарий, это, наверное, еще отдельное приклад, когда версии разных микросервисов по-разному меняются, когда их разные люди делают. То есть тут, наверное, люди очень радуются, когда у них монорепы, потому что тогда у тебя есть какая-то ревизия, которая означает состояние всего, включая там паст данных и так дальше. Ну да, с другой стороны, непонятно, как ты должен диплоить всё одновременно получается, потому что ты можешь диплоить, окей, у тебя есть монорепы, ты с диплоем на версию сервиса, а он вдруг перестал работать, потому что зависимость ещё не обновилась. То есть как вы относитесь к тому, чтобы тестировать и писать ваши тесты не напротив микросервисов, которые вы тут же рядом поднимаете, а напротив версии, которые вы, например, задиплоили уже на staging или даже на production? Ну, это примерно об этом и речь в статье, чтобы тестировать, чтобы внешние депенды просто были в обозначенном месте и тесты гонялись напротив них. То есть, в принципе, это означает, что у тебя тест, ты не можешь локально запустить тест, ты готов оффлайн. У тебя CI не может запустить тест, если у него есть какие-то ограничения по системам взаимодействия. Ну, я бы так сказал, что всегда можно делать подмножество тестов, которые будут работать локально, если ты офлайн. То есть я обычно такие тесты, которые ходят наружу, зачем-то прям совсем наружу, я их обычно флагаю, как делающий какое-то специальное I.O. наружу, и там на моём лаптопе они не бегают. Если я хочу их прогнать, я специально флагом указываю, что хочу их прогнать. Ну, а на CI их можно... Я бы сказал, что по умолчанию CI можно читать, что ему доступно внешнее окружение, свой лаптоп, ну как хотите, так и делайте. Мне кажется, это в принципе выход. Да, это не значит, что нужно делать I.O. налево и направо и по любому поводу его совершать. Мне лично кажется, что делать I.O. налево и направо по любому поводу и его совершать, если честно. И переставать это делать, это становится проблемой, когда оно становится слишком хрупко или слишком долго и так далее, потому что, ну вот опять же, я согласен полностью, что не нужно там особо ничего мокать по возможности, и по возможности означает, что в 99% случаев ничего не нужно мокать. Сейчас всё довольно легко поднять лакать, если хочется. Я на самом деле ещё пришёл к такой вещи, что я отделяю, например, отдельно у меня есть тесты на, ну скажем, условный, условная платформа F. Вот у меня есть клиент к платформе F, который там для специального подмножества был написан ручками, потому что because reasons. Так лучше работает, к сожалению. И вот оно входит реально вот в тесты в API и честно всё делает. То есть и после этого этот же клиент умеет вызываться не реально наружу, а просто в какую-то функцию, которая пересылает внутри релонговые ноды сообщения. Ну и соответственно, у меня есть маленький кусочек, который делает реально I.O., а всё остальное работает ну как бы со специальным как раз таким оком, который уже просто возвращает то, что мне нужно в тесте. Потому что, во-первых, довольно сложно заставить как-то API-шку третьего, 35-я API-шку ломаться, когда тебе нужно, например.",
    "result": {
      "query": "integration testing vs mocking"
    }
  }
]