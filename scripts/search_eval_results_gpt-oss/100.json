[
  {
    "segment_id": "b1130503-ae72-422c-b490-7c8eaaa197cb",
    "episode_id": "b56c9502-785b-423d-acaf-179b09422762",
    "episode_number": 100,
    "segment_number": 3,
    "text": "А реально из того, что я видел, есть такая Blockade штучка, которая умеет моргать докерами, то есть ты там создаёшь такой файлик с описанием, очень похожий на нативный докерный, и после этого у тебя появляется такой API к нему, и ты можешь там сказать, выключи, добавь задержку, через IPROW2 работают, и они хотят ещё добавить, поменяй время. И кроме этого я больше ничего особенного не видел. Так что можно было прямо взять, написать тест, который ты там сделаешь, или make check, или кнопочку нажмёшь, или ещё что-то, и он бы поднял тебя где-то там, либо в контейнере, либо на сервачках ноды, и начал моргать ими. Ну смотри, во-первых, ещё есть такой интересный куфок Jebson, называется Knozos, который смотрит на записанные истории, пытается понять, есть ли там артефакты нарушения лионизируемости. Во-вторых, мой любимый property-based testing, который опять-таки, ну то есть тебе, конечно же, нужен какой-то framework типа того же, типа прямо до этого блокейда, но при помощи property-based тестов можно генерировать как бы всякие ситуации, и твоё ожидание от этой ситуации, например, лионизируемость сохраняется, или там какое-то другое свойство, которое ты хочешь проверить, сохраняется. И вот так вот насиловать, при том, ну как бы у нас не было необходимости блокейд делать, я вам про это рассказывал как-то раз в других выпусках, что на предыдущей работе, когда мы делали распредельную там time-серии с бэш-данных, у нас была необходимость сделать довольно развесистую логику запрашивания данных с кластером, и соответственно там, этот координатор запроса, он должен был переживать, если большой-большой запрос, как бы опламывать запрос, если там на какую-то ноду данные еще не доехали, потому что она была мертва в это время, ну, как-то не хочется, и терять, как бы не отдавать данные тоже не хочется, поэтому там этот координатор запроса, он ходил по всем нодам, по которым могут быть данные, и старался давать максимально полный ответ, вот старался отдать. Вот, и чтобы протестировать, что это хорошо работает, и больше того, потом еще прооптимизировать, у нас как раз, то есть поскольку это писалось на Erlang, нам даже блокейд был не нужен, потому что можно было просто на уровень общения встать, то есть мы общались не напрямую, пидом посылали, а у нас была небольшая своя внутренняя абстракция, просто можно было ей сказать, что у нас теряется общение, и при помощи этого мы навернули тест, то есть мы замокали, написали такие искусственные vnodes, которые отвечали, что мы им скажем, вот это дальше генератор обломов, и дальше, собственно, реальный координатор запроса, и мы считаем, что при таких-то проблемах в сети, при таких-то данных на узлах, мы ожидаем такой-то ответ. И потом, даже первая реализация, которая была нетривиальна, она имела не маля пару багов, потом мы ее прооптимизировали, и вот Property начал находить кейс, который нужно было порядка, он, по каким-то, несколько десятков тысяч итераций проходил, только тогда он напарывался на этот баг внесенной оптимизацией, которому нужно было порядка, не знаю, 10 шагов, чтобы встать в такую ситуацию, которая там появлялась. И это довольно здорово. То есть это не то, чтобы это не магическая кнопка сделала, не зашибись, но property-based и похожие там всякие файзинги и прочие такие штуки, это отличный способ найти edge-кейсы, про которые очень тяжело подумать человеческой головой, скажем так. Ну, согласен, да. Но здесь с моками это очень удобно, когда ты и пишешь, когда она активно развивается. Вот был такой баг как раз в сериалайзе был Postgres, который вот производился, если ты там засетапишь такой нормальный сервакс с кучей ядер, поставишь еще два рядом, будут генерировать запрос, и тогда через там несколько часов срабатывало редкий REST condition, и этот баг там пытались найти год, ну то есть",
    "result": {
      "query": "property based testing Erlang distributed systems"
    }
  }
]