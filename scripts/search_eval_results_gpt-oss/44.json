[
  {
    "segment_id": "9e4c4ff6-7792-4b9a-84ec-0a5cc9fe8e12",
    "episode_id": "ec106bb6-8c89-49ca-91dc-a865e19ffb99",
    "episode_number": 44,
    "segment_number": 2,
    "text": "к другу. Я не писал ни одного продакшн-проекта на функциональном языке, хотя и мне было бы, конечно, интересно это сделать. В основном мое применение функциональчины в применении к продакшн-проектам ограничивалось инструментами, которые называются time plotters. Это инструменты для визуализации всяких графиков по временным рядам. Я их использовал для того, чтобы рисовать, что происходит с моими кластерами обработки данных и так далее. То есть я беру лог, написанный моим кластером, и, значит, прогоняю его через мой инструмент с помощью однострочника и получаю красивую картинку. Вот эти инструменты написаны на Haskell. В принципе, писать их было очень весело и пользоваться тоже. Так что, под этим случаем, разрекламирую их. Пользуйтесь, пожалуйста, тоже. Мне кажется, они хорошие. Вот я помню, когда-то в свое время, это было года два назад уже, когда я была в Штатах, я общалась с гуглерами. У нас были завтраки с гуглерами, ланчи с гуглерами. И я у них все время спрашивала, расскажите, как вы относитесь вообще к скале и к другим функциональным языкам. И что я услышала, у них такое было очень скептическое мнение по поводу вот этого всего. И таких, знаешь, вот этих хипстерских всех технологий, там всякие MongoDB и прочие вещи. Они очень скептически к этому всему относились. И так, ну, у нас есть C++, у нас есть Java, у нас все так здорово, и вообще это не нужно. Просто это звучало довольно странно, на мой взгляд. Тебе в твоей профессиональной жизни нет такого ощущения, что хочется чего-то такого нового попробовать, что вот сейчас на пике популярности? Да, значит, по поводу скептического отношения к функциональным языкам и прочим хипстерским технологиям, у меня, должен сказать, когда я начал писать DataFlow, у него весь бакент написан на C++, и в конце произошла некоторая переоценка ценностей того, чего мне хочется видеть в языке программирования. И, например, некоторые аспекты Haskell'а и даже той же Java я совершенно разлюбил и очень полюбился C++. Значит, сейчас расскажу, почему. Я понял, что мне совершенно не нравятся эксепшены, и мне хочется явной обработки ошибок. То есть, если функция может как-то ошибиться, то она возвращает либо значение, либо ошибку. И хочется, чтобы в коде было явно написано, что с этой ошибкой дальше делать. Это же Erlang. Окей, значит, этот аспект Erlang мне тоже нравится. В этом смысле он сделан правильно. Мне совершенно не нравится ленивость теперь, потому что она скрывает, в какой момент в программе может произойти что-то тяжелое и интересное. То есть, когда вы пишете большую, какую-то сложную высокопроизводительную систему, от которой требуется предсказуемость и возможность отладить, что именно пошло не так, если что-то пошло не так, то неявная обработка ошибок и ленивость и прочие такие вещи оказываются очень не в тему. И код с ними писать было приятно, но когда код сломался, то отлаживать его становится совершенно неприятно. Вот, значит, этого всего в C++ нет, и в гугле используется такой стиль C++, при котором большинство его недостатков как-то отходят на второй план. Например, ну, понятно, эксепшены мы не используем. Есть обширные внутренние библиотеки для всяческих целей. Есть распределенная, клаудная, детерминированная полностью билд-система, то есть никакого dependency-хел нет и в помине. Она, кстати говоря, вышла в open-source и называется Bazel. И есть некоторые инструменты, которых нету, инструменты отладки, которых нету ни в одном другом известном языке программирования, кроме Go, а именно ThreadSanitizer. Это такой инструмент, который позволяет детектировать многопоточные гонки. Например, если у вас одна нить в программе выделила память, другая в нее записала, а третья прочитала, и они не были в достаточной степени синхронизированы с помощью mutex, например, то в рантайме вы получите warning о том, что такая-то область памяти была создана таким-то stacktrace, прочитана таким-то stacktrace, записана таким-то stacktrace, нитки были созданы таким-то stacktrace и так далее. И, в общем, этот инструмент настолько полезен, что, например, мне страшно писать многопоточные программы на той же Java теперь, потому что для Java такого инструмента нет. И, кроме того, я считаю, что люди, которые не пользуются этим инструментом в C++, он open-source и публично доступен, и вы можете воспользоваться им просто передав фактически флаг командной строки компилятору Clang. Вот люди, которые им не пользуются, мне кажется, это также безответственно, как, например, отвечать в ворнинге компилятора или не писать юнит-тесты. Даже более безответственно, потому что, чтобы писать юнит-тесты, по крайней мере, нужно прикладывать усилия, а чтобы использовать этот инструмент — нет. Две ремарки. Я хочу заметить, что ты пишешь на C++ в одной из, так скажем, команд самых светлых умов в индустрии. Я думаю, это тоже стоит учитывать, когда ты хвалишь C++? Да, это, конечно, стоит учитывать. Вообще в Гугле очень серьезная культура отношения к качеству кода, по крайней мере, в нашей команде тех, с которыми я взаимодействовал. Код проходит тщательное ревью. Для того, чтобы закоммитить код на каком-то языке программирования, нужно либо самому иметь такой флажок, который говорит, что ты знаком с тем, как на нем в Гугле правильно пишут, либо чтобы твой код заапрувил кто-то, кто имеет такой флажок. И в результате, в общем-то, код получается очень высококачественный. Не говоря уже о культуре тестирования. Несколько лет назад в Гугле было намного меньше и было много нетестированного кода, но сейчас это как бы де-факто стандарт — иметь все покрытым тестами с высоким coverage. И в результате, в общем-то, большинство проблем, связанных с C++ и с разными способами выстрелить себе в ногу в нем, просто оказываются мифами. Тут просто не случается. И потом попросить инструмент за тебя перебрать все возможные, точнее, не все возможные, а какое-то достаточно большое количество вариантов скедулинга тредов и посмотреть, выполняется ли твой вариант. И для Erlang такие штуки, их, по-моему, даже две. Одна open-source называется Conqueror, вторая, собственно, платная называется Pulse, и ей, например, пользуется Bashor. Да, вот этого, конечно, не хватает. То есть без такой мощной системы типа как Haskell или Scala написать такую лзу трудно. Ну, для Erlang написали, возможно, конечно. Но да, этого не хватает. То есть приходится отделываться юнит-тестами. Вот, Джонни, ты немножко рассказал про культуру код-ревью в Гугле. А можешь немного подробнее про вот эту систему с флажками и что это такое, и как у вас вот код попадает из вашего environment в production? Значит, процесс, как он попадает в production — это отдельный процесс, это процесс релизов. Касаемо флажка, значит, флажок называется readability. Смысл в том, что если, например, у меня есть C++ readability, то я имею право комитить код на C++, получив просто approval владельцев проекта. Если же у меня такого флажка нет, то мне понадобится еще approval кого-то, у кого есть этот readability. Значит, readability получается так, что в какой-то момент, если я считаю, что я написал что-то достаточно большое и интересное, я это отправляю на ревью, так называемый readability reviewer. Он смотрит, хорошо ли я все написал, делает комментарии какие-то, и если он в итоге удовлетворен, то считается, что и я после этого умею правильно писать на C++. Или там на Java, на Go и так далее. Вот так работает этот флажок. Я ответил на твой вопрос или ты хочешь, чтобы я еще что-то покрыл? Ну, в целом да. У меня коверзный вопрос. И я пойму, если ты не хочешь мне его отвечать. Если сравнивать культуру разработки в Гугле и в некоторых других компаниях, ну там, на Я начинающихся, то ты можешь какой-то анализ провести? Ну, в Яндексе, по-моему, эта культура отличается от команды к команде. Например, в поиске, когда я там работал, код ревью вроде бы было обязательным, а там, где я работал, в Яндекс. Маркете не было. Ну, качество кода было, конечно, похуже, но, с другой стороны, части системы, которые мы писали, были не настолько критичными. В общем, я не могу сказать, что я безоговорочно рекомендую любой компании так делать, но просто у нас получается, что для тех проектов, которые мы пишем, это хорошо работает. Я не знаю, насколько этот опыт обобщается на других. В сети ОПОДКАД, недавно тоже был гость из Гугла, и он рассказывал про какие-то специальные способы отслеживания того, что ты не пишешь дуалирующийся код, который уже написан другой командой. Там, библиотеки какие-то общие и так далее. Вы какую-нибудь подобную метрику, ты можешь вообще что-нибудь про это рассказать и какой-нибудь пример привести, может быть? Слушай, если честно, я не знаю, о чем говорил ваш гость. Внутри есть такое большое движение за качество кода, и это люди, которые в основном, большинство из них, наверное, просто в свободное время помогают этому движению и пишут какие-то тулы или как-то анализируют код и делают какие-то интересные выводы из него, или делают какие-то рефакторинги в масштабах всей базы кода Гугла, например, удаляют использование каких-то устаревших API. Но вполне возможно, что там есть и такой тул, про который говорил твой гость, но я лично им не пользовался. Нет, это был не наш гость, это был такой подкаст CTO Cast, и в последнем выпуске у них в гостях был Игорь Маханек. И он рассказал про такую очень интересную вещь, что, например, в Гугле есть команда А и команда Б, и обе команды делают какой-то очень похожий инструмент, что-нибудь вроде библиотеки, ну, очень похожую функциональность. И, например, если команда А говорит, что, ну, в принципе, мы заканчиваем свою разработку, сворачиваем, мы решили использовать инструмент командой Б разработанной, то им за это даже дают какие-то там привилегии и вообще все всячески радуются, что вот, ребята, вы молодцы, что прекратили разрабатывать свое и решили пользоваться чужим, потому что это эффективнее и вообще это лучше в рамках компании, потому что меньше там средств расходуется на изобретение тех же велосипедов. Вот, соответственно, был вопрос, а как их вообще-то отслеживать, то есть должна быть какая-то общая база всех проектов, библиотек, либо еще каким-то образом. Но, понимаешь, если брать даже, я могу судить по своей компании, и так или иначе в каждой команде возникают какие-то похожие задачи, и чтобы вот так всех обобщить библиотеки, вообще, так говоря, очень большая объемная задача, потому что зачастую удобнее брать что-то, ну, да, мы делаем какие-то похожие вещи, но заканчиваем под конкретно свои нужды, и получается это такой хороший тул, который хорошо работает для нас. А не факт, что он будет работать хорошо для других, и скорее всего, для других придется его переделывать, обобщать, выходить на новый уровень абстракции. Здесь много учененцев возникает. Ну, что я могу сказать? Значит, какие-то базы проектов и библиотек, конечно, есть. Я бы сказал, что все-таки основной способ выяснить, есть ли что-то, что ты хочешь написать, это просто поискать по интернету по каким-то связанным с этим ключевым словам, и, скорее всего, ты это найдешь. Следующий шаг — поискать в кодсерче, и тоже, скорее всего, ты это найдешь. Но, несмотря на это, конечно, многие задачи решены по несколько раз из-за слегка различающихся нужд или из-за того, что одна команда не хочет в случае чего блокироваться на другую команду, если понадобится что-то пофиксить. Но в целом, конечно, все понимают, что избыток велосипедов — это плохо, и периодически пытаются избавляться от каких-то систем, которые стали строго хуже какой-то другой системы. Я помню, у нас гость был, который рассказывал, что в Амазоне, например, как такую проблему решили, они сказали, что до тех пор, пока у нас не будет порядка 20 повторяющихся библиотек, до тех пор мы не будем их объединять, и пускай они себе там живут и здравствуют, ну, там, скажем, похожего функционала как у кого-то библиотеки, абсолютно идентичные. Но, скажем, тоже такое довольно интересное решение. Я, правда, не помню, где это я слышала. Слушай, это очень интересно, особенно учитывая, что у Амазона такой фокус на service-oriented architecture, казалось бы, там приюзать должно быть проще, потому что все-таки это форсирует... Ну, там, либо каких-то систем мониторингов, либо еще что-то, ну, какие-то, скажем, похожие вещи, например, одной команде нужно мониторинг сделать, второй нужно делать мониторинг, и да, у них есть какие-то там свои одинаковые наработки, но нет, мы их не будем загонять в одну инфраструктуру, потому что, ну, пока что нет смысла, потому что их там не так уж и много повторяющихся элементов. Ну, в общем, мне несколько странно это слышать, особенно в таком масштабе, что пока не будет 20 повторений, и мы ничего не обобщаем. Я бы не сказал, что в Гугле заставляют переходить на общие решения, но, по крайней мере, когда становится понятно, что куча команд разработала общее решение, то обычно это хорошая мотивация, чтобы какие-то люди собрались вместе и сказали, давайте мы напишем все как следует, и они обычно при этом действительно пишут это как следует. Например, в Гугле масса систем, которые используются всем продакшеном, там, мониторинг, система мониторинга общая и крайне мощная, тот же кластер менеджмент, хранение файлов, хранение, то есть, нет нескольких видов баз для разных целей, тот же Bigtable, который недавно вышел в виде клаудного продукта, Spanner, это SQL база с георепликацией и так далее. То есть, такой инфраструктуры в Гугле много, она общая, ее все во все используют, но есть некоторые вещи, которые переизобретены по несколько раз, например, там одних только глобальных очередей задач, наверное, штук 5 разных, и там, может быть, 2-3 из них очень активно используются.",
    "result": {
      "query": "Google code review culture C++ readability flag"
    }
  }
]