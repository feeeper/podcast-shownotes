[
  {
    "segment_id": "dd14c59f-30c9-4601-b2d4-965be0bc4b98",
    "episode_id": "37979056-870c-4f2a-93df-79b1eab9fd6e",
    "episode_number": 111,
    "segment_number": 11,
    "text": "Хочу. Но как я сказал, у меня как бы жизненные обстоятельства, они подпалкивают меня в сторону C, при том чистой оси. И как бы у меня нет особого выбора. Я, возможно, даже когда-нибудь протащу Rust, но на самом деле, в данном случае, то есть, я могу даже пояснить, не вдаваясь в детали, есть некоторые проекты, у которых уже есть, там, не знаю, например, тот же самый Erlang. Некоторые API для FFI и чего-то там не было. Иногда подобные API, они уже содержат в себе некоторое количество магических макросов, которые написаны на C. Это C-шные макросы. И это всегда отдельная боль. Эти макросы, как бы как-то эмулировать их работу в том же самом Rust, потому что в Rust нет Define'а никого. Тебе нужно каждый раз, что там от версии к версии, вот этот Define меняется в разных всех, может быть, не меняется, может, не значительно, с ним что-то может произойти в заголовочном файле того, для чего ты пишешь плагин. А тебе нужно, соответственно, в твоем Rust-овом маппере каждый раз это как-то поддерживать. И это не очень приятная ситуация. Да, наверное, можно вставить основную логику на Rust, а потом на C. Наверное, так можно делать, но, в общем, я не уверен, что это в целом как бы принтабельная идея. То есть у меня был отдельный Rust-условник. Подожди, Боря. У меня был отдельный свой header-файл, в котором я импортил тот header-файл, который для того языка, который мне был нужен. И я просто вот те макросы, которые я использовал, я их экспортил как C-шные функции в Rust. Соответственно, когда я камин писал на Rust, у меня были бандинги в мой файл, а не в тот. Соответственно, в этом случае получалось, что вот этот файл — это одно место, где вот у меня есть вот эта прослойка между тем IPM, который предоставляет язык, и тем IPM, который я конфигурирую в Rust. Вопросы из серии кто own-ит, какие там ресурсы и все такое прочее, они уже на Rust-стороне описывались системой типа. То есть вот это была штука. Неудобно тем, что тебе нужен Rust-компайлер. Соответственно, везде, где ты этот код собираешь, тебе он там нужен. Это бывает неудобно. Ну да, на фирме в этом плане интереснее, потому что он позволяет только на девелопермашине все это делать. Я на самом деле поиграю с Rust, это был мой следующий пункт в списке, чтобы оценить трудозатраты в принципе втаскивания в Rust подобный проект.",
    "result": {
      "query": "Rust FFI C macros challenges"
    }
  }
]