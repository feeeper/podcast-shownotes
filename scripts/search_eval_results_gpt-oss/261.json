[
  {
    "segment_id": "d8a57f00-a830-4d66-b6bf-a45f3ce937bc",
    "episode_id": "e8e19618-fbac-4ff1-b61b-4eff5cd47d71",
    "episode_number": 261,
    "segment_number": 5,
    "text": "Ну вот у нас go-плагины как-то так используются, потому что есть кусок системы, который по-хорошему должен быть компилен в приложении, но он пишется под задачу, под клиента, поэтому туда нужно загружать разные куски кода и проверять, что они не могут из своих песочниц сделать всякую фигню. Вот. И сейчас это делается как раз через механизм плагинов, и это не очень хорошо работает, опять же, смотри выше, потому что они, например, невыгружаемые. Ну и последние три строчки, чтобы как раз Ваню поджарить, я на Lion's Terror предложил, что миру пора сделать новый объектный файл и формат, и что они могут быть как раз теми, кто его предложит. Ведь вообще эти форматы были созданы в 80-е годы, и с тех пор первыми сильными есть. Ради этого я, в принципе, и хотел бы, чтобы они занимались подобной ерундой. Для справки, да, вот этот человек, который это предложил, Иоанн Ван Стейлер, это один из мейнтенеров ГЦЦ, автор Gold Linker в ГЦЦ и так далее. То есть он про линкеры довольно много чего знает. Gold топчик. Можно вопрос? Во-первых, вот этот документ имеет какой статус? Что это такое? Это публичный пропозал. Чтобы сделать публичный пропозал, что надо сделать? Не знаю. На самом деле, все, что надо сделать, это его написать и публиковать. Или я не понял твой вопрос? Фактически, я вижу, что в четвертой строчке ссылка goldlink.org slash s slash better linker. То есть ссылка на этот документ ведет с goldlink.org. На самом деле, это урл получить такую короткую ссылку не очень сложно. Если это что-то связанное с ГО, и это не инициатива одного человека, есть механизм, можно попросить этот урл, что-то на к тебе его сделать. Что будет дальше происходить с этим документом? То есть, к примеру, я написал еще подобный документ. Что будет происходить с моим документом? И как на примере, что будет происходить с этим документом? Во-первых, первый этап пропозала, не первый этап, это уже, наверное, относительно продвинутый этап, но факт в том, что его написали, провели эксперимент и сделали обсуждение. Обсуждение конкретно этого пропозала, я думаю, не суперактивное, потому что требует очень таких специфических знаний. Обратный байкшейдинг. Тут обсуждают атомную электростанцию, очень много, немного специалистов понимает о электростанциях атомных, поэтому я думаю, его просто примут и дальше селонку начнут делать. То есть пропозалы в ГО обычно кто хочет, кто написал пропозал, тот и делает. Вот эти люди постепенно, я думаю, будут делать, но это едва ли очень быстрый процесс. Я полагаю, что процесс чрезвычайно долгий и в первую очередь потому, что он требует изменений не только линкера, но и компилятора, но и того, что хранится в объектных файлах, соответственно, передается от компилятора линкеру, и взаимодействие, способ взаимодействия у них, и соответственно у меня вопрос из-за этого. Возвращаемся снова к ГО-2. Фактически новый объектный файл обозначает, что версии будут несовместимы между собой. Напомни, пожалуйста, что у нас там с совместимостью версий в ГО? Вот это наброс. Ну, вообще, мне кажется, немножко странный наброс, если честно. Это не наброс, а вопрос. Во-первых, представь себя, что если бы это были разные проекты, да, линкер был в одном проекте, компилятор в другом, они бы такого вообще не смогли сделать. Поэтому как раз это плюс того, что они все, целиком все поддерживают. Линкер, компилятор они делают сами. Извини, пожалуйста, первое правило троллинга — всем говорить, что ты очень серьезен и не тролляшь. Вот. Во-вторых, в ГО сейчас нету АБИ стабильного, да? То есть, на самом деле, там есть пропозал про то, что давайте документироваем АБИ, но есть контрпропозал, давайте сменим АБИ, а потом его документируем и сделаем стабильным. То есть, гарантия стабильности ГО лежит на уровне исходных кодов, но не языка. Помимо этого, типа, есть механизмы для указания версии языка, мы его как-то обсуждали в одном из выпусков, там, когда вы код в модулях, типа, есть специальный дилетив, который указывает версию языка. И эта штука язык на язык вообще не влияет. Она влияет на формат файлов, на кэш, ну, то есть, все придется кодировать, да. Но с языком это не так и связано. А если учесть, что в последней версии ГО выпилили бинарные пакеты, которые без исходников, то проблемы, в общем, нет. Тем временем, в чате слушатель, наш постоянный слушатель Ник Линкер искрометно шутит на тему, что не надо меня переписывать и вот всякое такое. Полчаса по этой теме еще что-то осталось? Не знаю, я... Да, боже мой. Но вот я подозреваю, что на самом деле, это немногим слушателям интересно, поэтому я хотел бы ее попутать. Да как не интересно? Вообще, самое интересное сегодня. Переписать Линкер для того, чтобы Линкер быстрее работал и перетащить кучу всего в компилятор. Такой объем большой работы. Если честно... Мы уже выяснили, что Ник Линкер работает хорошо. Если честно, мне кажется, что они должны сделать версию ГО 3 и вот это сделать там в ГО 3. А зачем? Почему? Ну, я имею в виду не с точки зрения того, что несовместимо, а что, как бы, вот ГО 2 когда появится, еще лет через 10 появится ГО 3 вот с этими оптимизациями. Слушай, ну, ты имеешь в виду, что лучшим занялись чем не полезно, да? Вот, да-да-да-да. У меня такой вопрос. Я смотрю номерка тикетов в ГО Ленге, я вижу, что здесь уже давно перешли за 20 тысяч. Я прям уверен, что из этих 30 тысяч есть какие-то тикеты, которые чрезвычайно полезны сообществу и любому большому проекту. Переписывать Линкер, который вместо 5 секунд будет работать 2 секунды, ну мне кажется, оно такая глупость, что я даже не знаю. Смотрел, по-моему, это было то ли в день радио, то ли о чём говорят мужчины, вот это про найти пуговицу. Знаешь прикол? Нет, нет. Ну там контекст примерно такой, что к нам едет генерал, он там придёт и устроит нам всем разнос, что мы будем с этим сделать? Я знаю, что мужики, давайте найдём пуговицу. У меня вот пержак, от него пуговица оторвалась, она где-то тут валяется, давайте мы её найдём. Это что, какая пуговица? Тут к нам сейчас генерал придёт, вообще при чём тут пуговица? Ну вот смотри, ты с генералом что-нибудь сделать можешь? Нет. А пуговицу мы найти можем. Ну то же самое с Линкером, вот там сообщество хочет всяких странных, каких-то непонятных вещей, которые сложные, нужно думать, а вот Линкер, переписать это реально. Мне кажется, логика скорее обратной должна быть, то есть люди, которые будут работать под Линкером не будут там искалять баги в документации, то есть есть какое-то ненужное количество тикетов, которые про документацию, это просто разные люди с этим занимаются. И люди из сообщества, им гораздо проще пойти и поправить документацию, чем пойти и поправить Линкер. Поэтому это очень специализированное знание, и им занимаются специализированные люди. Прямо сейчас полезу в гитхак и посмотрю, какие топовые ищи висят на язык. На самом деле, в защиту года надо сказать, что баги, которые действительно критичны и в нем своевременно скрывают, тут, например, недавно это наша следующая тема, репортили баг на то, что в Go 1.13 можно как-то отправить стандартную библиотеку языка в бесконечный цикл, если сделать лукап неудачного IP-адреса. В вышлиссах можно почитать, как это произошло, какие были DNS-записи, я, честно говоря, особо не понял, но там типа был PTR на что-то, и можно уйти в цикл. Так что, ну вот, как бы был серьезный баг, закрыли. Я подозреваю, что многие баги, которые висят в вышли трекере Go, они не супер критичны. Черт, извини, я не могу сдержаться. Я отсортировал по количеству комментариев, вы меня не поверите. Вот. Теперь мы понимаем, почему у Postgres нет вышли трекера. Вот именно поэтому. Я тут тоже посмотрел, отсортировал по эмоджи, на первом генерике, к слову, там про Go 2 и генерики, там же пропозывал про генерики есть, и вообще, говоря, их активно пилят. Так что, глядишь, мы генерики скоро получим. Причем раньше, чем обработку ошибок продвинутых, как тут выяснилось. Самое интересное, что на втором месте это сделать файзинг First Class Citizen. И пропозывал, в принципе, принят, но вот это тот же тот самый случай, когда не хватает людей, которые этим занимаются. То есть им реально занимается там полтора человека, и из них один уже над Go активно не работает. Поэтому, вот, например. Но с другой стороны появилось там, почти новомерно появилось пару стартапов, которые делают файзинг для вас в облаке постоянно. И оба используют GoFuzz, оба используют Go по этому вещам, что они как-то скооперируются и сделают что-то с этим. На третьем месте суммтип и DiscriminateUnions. В общем, да, все как мы любим. А где уже есть генерики и много других полезных вещей, нормальный менеджер пакетов, например, это в языке NIM. И не многие знают, эта новость как-то не была широко освещена, что недавно состоялся релиз NIM 1.0. Было это 23 сентября. И 1.0 означает, что они обязуются не ломать обратную совместимость. То есть это я не пересказываю с описания Go 1.0, это вот у них на сайте реально написано, что язык теперь считается stable за исключением некоторых экспериментальных вещей, которые прям помечены как экспериментально. Стоит напомнить, чем интересен язык NIM, потому что я, во-первых, узнал, что некоторые люди про него вообще не слышали. В разговорах это выяснилось. Во-вторых, я уже сам как бы немножко, когда читал эту новость, я уже подзабыл, потому что NIM я трогал в далёком 2015 году, когда это ещё не было мейнстримом. Вот, и если коротко, он похож на нормальный ESEA с генериками, с нормальными типами и внезапным метапрограммированием. Либо можно о нём думать как о компилируемом Python'е, опять же, с нормальными типами, который не падает после получаса работы с «Ой, чувак, а такой функции, которую ты вызываешь, как бы не объявлено? У тебя опечатка в названии». То есть он не имеет легковесных процессов, как в OO, но у него с процессами тоже интересно сделано. У него создание трэда, при создании трэда он на самом деле не выделяется из операционной системы, он берётся из пулы трэдов, поэтому если его приложение часто создаёт и удаляет трэды, то это достаточно дешёвая операция. Что ещё интересно? Сборка мусора. В НИМ так называемый в Real-Time куча побита на кусочки, каждый трэд имеет свою маленькую кучку, и в ней сборка мусора осуществляется преимущественно подсчётом ссылок, с точностью до оптимизации, что вот эту переменную можно положить на стэке, плюс в НИМ есть ручное управление памятью, поэтому если вы видите, что там приложение травматизировало ГЦ, вы в принципе можете управлять памятью вручную, что тоже не бесполезно. Я не знаю, как сейчас с этим обстоят дела, но в своё время они обещали шареные кучи между несколькими трэдами. Вот имеет смысл посмотреть, как оно сейчас в этом плане обстоят дела. Но в целом посыл такой, что в НИМ не может возникать такой долгий, в принципе не может возникать стаб за ворлд, он всегда что-то полезное делает. Но цена за это, что если ты не управляешь памятью вручную, то копирование объектов будет дорогой между трэдами. — Если не так, спрашивают, это конкурент Erlang-у Гои Хасклю? — Нет, нет, я это определенно не воспринимаю как конкурент Erlang-у Гои Хасклю, то есть языки, они делаются для своих задач, и когда вы решаете задачу, нужно понять, какой инструмент для этого хорошо подходит, какая база данных хорошо подходит, и какой язык. НИМ, он не совсем для тех задач, для которых Гои и Erlang скорее всего не Хасклю, Хасклю из-за того, что я знаю, он круто подходит для всяких парсеров, компиляторов, всякого такого, в принципе в нём и легковесные процессы, как в Гои и Erlang, о чём тоже немногие знают, но я не знаю про много проектов, которые использовали Хасклю именно по этой причине. То есть реально НИМ — это скорее конкурент C и конкурент Python, то есть если ты начинаешь, ну, как бы проекты на Python, они обычно начинаются как маленькие скриптики, где как бы названная проблема про то, что у тебя в runtime типы не сошлись или в runtime оказалось, что функция не объявлена и интерпретатор падает, вот эти проблемы, они поначалу не возникают, но они начинают возникать уже потом, когда проект немножко разрастается. И Python, он, например, не предлагает легковесных трэдов, он не очень хорошо подходит для такого серьёзного сервер-сайта, то есть как бы интернет-магазинчик, не знаю, блогжики, что-то такое писать на нём вполне можно, и мы помним, что например… Вот ты сейчас зря питанистов обидел, там же есть часто синк встроенный в язык, и он даже работает почти так же, как не знаю, то есть он не просто как раньше торнадо был, он там же сейчас вот прям синк, который выглядит как не знаю, как yield, даже нет, в общем, оно сейчас выглядит так, что даже можно писать код как будто в один поток. Я помню, Ваня рассказывал, как сходил на доклад, как с этим работать, и Вань какой-то сделал вывод. Никогда! Никогда больше не трогать. Ну потому что это был типа часовой доклад про то, как не пристрелить себе ногу там 15 способами. Даже делая следующую документацию. Вот, ну то есть серьёзно, это вот это не как в ГО, в ГО ты вот просто создаёшь гаррутину, тебе по большому счёту не нужно много про что думать, ну с точки до того, что не наплоди их там 15 миллионов, а по большому счёту ты просто сделал гаррутину, и голова не болит. И СИПа возможности не вызывай. Чего не вызывай? СИП. СИП, да-да-да. Вот, о, кстати, про вызов СИПа хорошо, что ты вспомнил, ним он поскольку не даёт вот всякого такого рантайма с легковесными трэдами, ну смотри выше, их создавать дёшево, то он хорошо взаимодействует с СИПа, на самом деле одна из его сильных фичей заявленных, вот, то есть как бы код СИПа линкуется и вызывается легко и приятно. Я почему говорю, что он больше как бы как замена СИПа, как замена Питона, потому что он ну вот, трэды, вот это вот всё, я не хочу повторяться. Вот, как замена Питона, потому что типа вот это вот всё, как замена СИПа, потому что ты имеешь существенно меньше шансов случайно не так сложить указатели и обратиться к куску памяти в JLibC и после получаса работы твоё приложение упадёт с непонятной ошибкой. Ну вот, то есть он просто более безопасен. Вот, и если просто посмотреть, опять же вот мы часто забываем про то, что программирование бывает разное, задачи бывают разные, вот представьте, что вы пишете какой-то софт для роутеров или для какого-то МБТ, то есть как бы системы, у которых сильно порезаны ресурсы, вот туда вообще туда не надо. На СИИ можно, но на СИИ писать ну, можно найти языки, на которых писать приятнее, чем на СИИ. И вот НИМ – это такой язык, который тебе сделает достаточно эффективную, легковесную программу для твоего роутера, и при этом ты будешь писать, как на Питоне с ТИПами. Что ещё? У него есть интересные всякие фичи про систему эффектов, то есть можно сказать, что вот эта функция, она, например, никогда не бросает исключений, она никогда не создаёт сайд-эффектов и всякого такого. Плюс к этому у него есть интересный механизм, что когда у тебя программа собрана с дебаг-флагами, то рантайм делает кучу всяких проверок и перепроверок, что ты не вышел за границу массивов и всякое такое, но потом, когда ты собираешь релиз, сборка, у тебя все эти проверки уходят и код работает сильно быстрее, чем дебажная сборка, но понятно, что всё-таки она может упасть в рантайме, но тем не менее фича занятная. Что ещё? Мне вот сейчас по-быстрому нормальный менеджер пакетов называется Nimble, и там централизованные репозитории с пакетами, с нормальными версионерами, в общем, всё как у нормальных людей. И самое главное, этой фичи нет ни в одном другом языке, которую я знаю, это вот самая важная фича в NIMB. Если ты в коде напишешь табуляцию, код не скомпильится, это вот я считаю самое главное, что есть в NIMB. Молодцы. А NIMB-формата там есть тоже? Что есть? NIMB-формата. Ну, я не разобрал, ты говоришь загадками. NIMB-формата. Это хороший вопрос. Вкратце я не знаю, но в последнее время вот по опыту использования всяких GoFMAT, AltOp8, вот этой всей истории, я не то чтобы был сильно убеждён в полезности этих инструментов, то есть обычно это выглядит так, что, ну, во-первых, твоя IDE, она всё равно немножко иначе форматирует, вот чуть-чуть, но иначе, поэтому вот если ты пишешь в Vim, а человек… А кейс валил, это я. Да, да, да, то есть я пишу там на питоне в Vim, а все коллеги пишут в GoLandy через плагин питонячий, и да, я сейчас пойду и пять человек буду убеждать, чтобы они выкинули свою IDE и пересели на Vim. Ну или выкинь себя. Либо можно сказать, что вся эта история про FMAT, она, может быть, была не так уж хороша, в конце концов, если у тебя проблемы с пробелами, версус табуляции у тебя не возникает в ними, а всё остальное, ну, как бы, а что ты ещё хочешь форматировать, вот всякая фигня типа, а у тебя после запятой пробелы нет, вот я это никогда не считал огромной проблемой, поэтому, ну, то есть… Слушай, а мне очень нравится, как в Go сделано, вот прям очень. Я считаю, что GoFMAT это одно из самых классных изобретений языка Go. Нет, он же там табуляции ставит. Без разницы, что он ставит, главное, что он всё это делает в одном стиле везде. Ну, как я AutoPep8, но смотри выше у тебя… Нет, не как AutoPep8, AutoPep8 это расширение над языком, которое давайте-ка мы все введём там, а если не введём, то… А это тулчейн, который внутри языка скрыт, и если ты хочешь пользоваться языком, ты должен пользоваться этим тулчейном. Вообще ни разу. Но мне ничто не мешает написать программу на Go, ни через какой FMAT не прогонять её, что я никогда и не делаю, и всё отлично скомпилируется. Ну, вообще, скомпилируется-то да, но факт в том, что вся экосистема, вся культура работает против тебя. То есть ты пишешь программу, ты её сохраняешь, она у тебя автоматически хроматируется. Для того, чтобы это отключить, тебе нужно это идти и специально отключать. Кем сохраняется, куда сохраняется VM? Ну, фимплагин VMA для Go, который у тебя стоит, Go-шный плагин для VMA. Чего у меня стоит? Ну, ты к VMу можешь поставить плагин, который работает с Go. Или я могу этого не делать. А можешь программу через карту писать, но большинство так не делает. Ну, в смысле, у меня реально нет ни одного плагина для VMA. Я не знаю, как ты живёшь, если честно. Я им всегда любил за то, что он расширяется. Я превосходно живой, вот прикинь, я в VMA локально пишу, у меня всё работает. Я потом по SSH куда-то захожу, у меня работает всё точно так же, как локально. Я живу вообще идеально. Ну, там же не комплешн, не навигация, ничего. Всё там есть. И комплешн, и навигация. Ну, комплешн там получается просто такой, как бы по словам, а не умный. Нет, ну, если мы говорим про серьёзный крупный код, то я его просто в Гулэнде пишу, а всякий, ну, VMA, он для скриптиков или небольших программ. Ну, нет, если мы говорим про большой проект, над которым 15 человек работают, то в VMA его писать, конечно, убьёшься. Понятно, можно я пишу? Я в Гнедск в VMA пишу. Ну, я в принципе тоже на Ирланге в VMA писал, но там немножко другая история, там просто все в VMA писали, потому что ничего лучше для Ирланга. Все в Emax писали? Нет, нет. Ну, в целом, не знаю, в экзанто, последний раз, где мы с тобой работали с Ирлангом, там был борьба с Толи, где был Emax. Только мы с тобой двое были очерепенцы с VMA. Давай не так радикально скажем, что в зависимости от конкретной команды, конкретного подпроекта, люди сидели на VMA или на Emax. Окей, возможно. Ну, короче, там были задроты, вот. Извините, ребят, я вас очень люблю. Много пальцев, много рук, я Emaxовый паук. С моей стороны это всё, что я хотел рассказать про ним. Я очень рад реализу 1.0, я собираюсь его, если время найду, потрогать, в каком он сейчас состоянии, может быть, пописать какие-то подпроекты. Если есть какие-то комментарии со стороны уважаемых соведущих, я Да. Можешь посоветовать подпроекты для Нима? У меня в своё время был пост в блоге, он сейчас один из самых популярных, самых читаемых, вот как бы список подпроектов для изучения нового языка. Я могу тебе скинуть. Нет, подожди, вот чтобы Ним прям своими сильными сторонами играл, прошивку для роутера писать? Нет, зачем? Ну в смысле, вот ты берёшь всё, для чего ты используешь питон, и перестаёшь использовать питон и используешь Ним. А я не использую питон. Ну, руби, или что там у тебя? Я руби тоже не использую. Башня. Руби давно заменил на эликсир. Ну вот, выкидываешь свой эликсир и используешь. Ты понял. Ну это же, что-то прям даже не знаю. Не знаю, как прокомментировать ваше заявление. Ну вообще, для чего можно попробовать? Не сетевой стер писать? Какие-то приложения мелкие, которые вокруг каких-то своих мейкфайлов? Ну давай для начала определимся. Мы говорим про написание код ката, так называемых, или решение чего-то более-менее прикладного? Не знаю, мне просто хочется узнать, где его можно было бы применить, где он показал бы свои сильные стороны, как сказал Валера. Для любого случая расскажи. Какой-нибудь парочку примеров, да, и мне хватит. Ну, это просто немножко индивидуально. У меня, например, часто возникает задача типа пройтись по каким-то сайтам, пропаршить html регулярками, да, я паршу html регулярками, мне наплевать, что вы об этом думаете. Потом как-то это все сагрегировать и вывести отчет. Или построить какие-то графики. Или, например, на питоне я в свое время писал программки, которые я увлеченный радиолюбитель, мне хотелось построить карту, где такими линиями показано, с кем я проводил радиосвязи, чтобы оценить как далеко какая антенна стреляет и так далее. В принципе, все это можно делать на НИМе. Вот ты сидишь, ты понимаешь, что тебе нужно решить какую-то задачу программерскую, берешь и решаешь на НИМе. Для меня это как-то так работает. Но если тебе прям задача не так не подворачивается, ну перепиши движок devzen.ru на НИМ. Ну, кстати, вот еще один пример генерации статистических сайтов, то, где тебе не нужны легковесные треды и так далее. Спасибо. Я с вашего позволения все-таки пролинкую этот пост, как бы не в целях самопиара, а потому что вдруг кому-то реально будет интересно. Да-да-да. Леша тактично отмалчивается, а у нас так нельзя. Ты одобряешь или осуждаешь? Мне все равно. Константин Егупов в комментариях написал, что НИМ — это прямой конкурент ГО, а ты говоришь, тебе все равно. И Rust, и еще Java. Я, кстати, согласен насчет Rust и Java, насчет ГО немножко под вопросом. Почему? Ну ты вот говоришь... Как у тебя и Rust, и Java оказались одновременно конкурентами? Мне вот тяжело это представить. Нет, в смысле, они между собой не конкуренты, это просто ГО, в смысле, НИМ конкурирует с какой-то частью юзкейсов, которые можно решить как с помощью Rust, так и с помощью НИМа. И аналогично с Java. Ну, я так рассуждаю. Если взять множество задач, которые решаются Java или Rust, то я... Ну, там с точностью до, понаписано, 100-500 человек, там миллион вакансий и всякое такое. Вот если на этого секундочку забить, я не вижу причин, почему придумать задачу, которую можно было бы легко решить на Java, и она будет хуже решаться на НИМе, например. Но в то же время я могу придумать задачи, которые будут хорошо решаться на ГО и менее хорошо на НИМе. Мы тут как раз рассуждали про то, что в питании никогда не нужно использовать sink-await, но, в общем, здесь на самом деле то же самое. await, wait-for... В смысле, они есть, да? Ты это имеешь в виду? Ну, я просто пошел читать всякие примерные коды на НИМе, чтобы хоть немного понять, что это такое. В общем, да, await активно использовать. Ну, нет, он... Наверное, он есть, но тебя никто не заставляет им пользоваться, как же... То же так же, как и в питании. Ты можешь написать код без единого await. Окей, ладно, поверьте на слово. Нет, ну... Как мне сделать http-запрос получить результат без await? Ну, там, типа, создать http-клиент и сходить и заблокироваться, и дождаться результата. Ну, вот я и смотрю вопрос результат, ну, я сходил в документацию на http-клиент, здесь прямо написано import, создать клиент, client-content-url, а потом await на результат. Ну, я не могу прокомментировать, потому что не знаю, на какую документацию ты смотришь, к какому клиенту, я довольно уверен, что к нему их может быть больше одного. Ну, если он top-person в библиотеке. Ну, я не настолько эксперт. Давай так, мой ответ я не знаю. По моим представлениям, в NIME код по дефолту должен выглядеть вот примерно как питаняч или джарный такой блокирующий код. Вполне может быть, что стандартный клиент, он по каким-то причинам сделан как-то иначе с футурами или с чем-то еще. В чате, секундочку, в чате Константин Ягупов... А, нет, простите, не клинкер спрашивает, есть ли GC у NIME. У NIME, у него смешанный подход, он может использовать GC, а может использовать управление памятью вручную. Вот это к вопросу, почему конкурент или не конкурент разным. Я думаю, мы на этой теме подзадержались. И я передаю слово Валериям, который нам расскажет про релиз PostgreSQL 12. Вот тему добавил, ты отдуваться в ней, ну как же так? Ты в ней отметился, а я много говорил. Ах вот как. Я поддержу, не беспокойся, я только отдышусь. А то знаешь, опять начнется вот это, Саша делал микрофон. Ну что ж, ну попробуем, давай не гарантирую. В общем, дело такое, с релиза PostgreSQL 12 он зарелизался, по-моему, вчера или позавчера днем, чуть ли не вчера днем, мне кажется. И, в общем, самый, наверное, крупный такой крупный вещенок, который я лично ждал, во всяком случае, это JIT, он пока очень ограниченный. Извини, пожалуйста, можно? Он появился в 11? Что? Можно, на секундочку, я тебя прерву. Просто Леша жирный тролль, потому что он показывает ссылку на документацию к стандартному HTTP клиенту, и там два примера, NewHTTPClient и блокирующий вызов GetContent, и NewAsyncHTTPClient и AwaitGetContent. Ну как бы, Леша, я не заметил. Ты будешь ржать, но я реально не заметил. Ладно, окей. Просто для справки есть два варианта. Можно сделать синхронный вызов, можно асинхронный. Извини, пожалуйста, Валер, JIT и PostgreSQL. Вот, здесь они его расширили, углубили и добавили в это все. Раньше он только в WorkClose сработал. И был включен не по дефолту. Сейчас он включен по дефолту. И теперь он еще работает в агрегатах и еще в некоторых местах.",
    "result": {
      "error": "API request failed: Error code: 400 - {'error': 'Trying to keep the first 7631 tokens when context the overflows. However, the model is loaded with context length of only 4096 tokens, which is not enough. Try to load the model with a larger context length, or provide a shorter input'}",
      "stack_trace": "Traceback (most recent call last):\n  File \"/home/andrei/Projects/podcast-shownotes/scripts/build_search_eval_dataset.py\", line 157, in generate_search_query\n    response = await self.client.chat.completions.create(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/resources/chat/completions/completions.py\", line 1927, in create\n    return await self._post(\n           ^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1767, in post\n    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1461, in request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1562, in _request\n    raise self._make_status_error_from_response(err.response) from None\nopenai.BadRequestError: Error code: 400 - {'error': 'Trying to keep the first 7631 tokens when context the overflows. However, the model is loaded with context length of only 4096 tokens, which is not enough. Try to load the model with a larger context length, or provide a shorter input'}\n"
    }
  }
]