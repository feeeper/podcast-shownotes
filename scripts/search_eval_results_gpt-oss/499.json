[
  {
    "segment_id": "295573b8-66a5-420d-8590-1be6b78a91c3",
    "episode_id": "2fe43cfa-a5ca-4dc0-b40b-f195c26865c9",
    "episode_number": 499,
    "segment_number": 6,
    "text": "хорошо тема эта навеяна постом в блоге раса кокса который известен своей работой над языком Го. Но прежде чем я займусь темой, я наверное задам такой наводящий вопрос возникала ли у вас такая ситуация в программировании, когда у вас есть некая функция сложная и у вас есть два юнит теста для этой функции. Один проходит другой не проходит и в общем-то не очень понятно где баг, потому что там какая-то сложная математика например. Вот как вы обычно подходите к такому вопросу чтобы выяснить а где пошло что-то не так что менял тесты функцию или то есть я написал новый тест поменял функции ну вот другой пример Представь себе, что допустим ты пишешь длинную математику, ты написал функцию, вот как ты понимаешь она должна работать, потом ты написал тесты, один тест проходит как положено, а другой тест не проходит значит где-то у тебя баг что-то вот ты написал не так но ты не не знаешь типа почему в чем в чем разница почему один работает другой нет инженерные ответы или как часто происходит на практике ну вот как ты как ты бы делал сессию на работе такая ситуация? Я вначале поскольку ты наименее энергозатратная я просто пойду заварю себе кофе потом вернусь и еще раз посмотрю на свой код иногда это очень хорошо помогает Потому что ты глазами посмотрел и так бьешься по лбу бок блять да точно более инженерный вариант если вот предыдущий вариант ты там не знаю не помог ты уже выпил три чашки кофе больше кофеина нельзя пить днем и вообще принципе за день не стоит столько кофеина выхлебывать а как-то нужно не знаю дальше зарплату получать то берется пишется ну как это условно говоря в данном случае 3 тест вообще говоря N плюс первый тест и в пределе это дает нам фазинг или property base тестирование то есть каким-то образом сформировать такой эксперимент который даст нам хорошее покрытие Это отвечает на твои вопросы? Да, это отвечает. Проперти бейс тест это сразу как бы возможно по воробьям из пушки, но увеличивать покрытие и тестировать гипотезы ну как бы в целом вообще про любую отладку. Слушай я всегда отлаживаюсь печатями я добавляю везде принтов и поехали запускай один тест запускай один А вот Ваня это мой человек потому что Валера он интеллектуальный интеллект он интеллектуальный я тоже принтами отлаживаюсь просто не знаю как это очень очень легко когда у тебя она у тебя есть юниты я хочу немножко набросить я когда был маленький я только принтами отлаживался и вообще короче все остальное для слабаков, хотя тесты я и писал. Но что-то чем больше живу, тем больше оказываюсь в ситуациях, когда то что я хочу отладить принтами хрен отладишь. Ну типа оно или многопоточное или там по дороге ещё кто-нибудь насрет логами, так что свои принты не найдёшь. В общем давненько мне не получалось удачно принтами отлаживаться. Ещё бывает так, что факт того, что ты отлаживаешься принтами убирает бак. Это все справедливо. В общем, я думаю, что то, что мы обсудили, это похоже на правду то, как большая часть нормальных инженеров это делает. Я обычно расставляю принты до того, как я включаю мозг, мозг идет в следующую очередь. Но в целом это все хорошие, валидные, проверенные временем техники. Однако оказывается есть еще один интересный прием, который можно использовать, который как расставить принты только лучше. Идея в чем, мы берем многие языки в данной статье используется пример го, но практически все современные языки так или иначе умеют замерять test coverage. То есть, грубо говоря, какие строки были выполнены в течение теста, а какие нет. Идея состоит в следующем: вы запускаете сначала ваш проходящий тест кейс, а потом ломающийся тест кейс и для каждого отдельно записываете профиль кавередж. А потом вы делаете div этих профилей если у вас текст что вы потом Я что-то не понял! Ага! Так еще раз мы прогоняем обычный тест записываем профиль Да вот ты записываешь coverage profile А прогоняем сломавшийся тест, тоже записываем Coverage profile. И потом пишем профили. Ты записал два профиля и у тебя просто типа есть файлы, в которых написано какие строчки исполнились. Вот, поскольку твоя задача понять, что пошло не так во втором тесте, ты можешь сделать диф этих профилей и посмотреть какие строчки выполнялись в одном тесте, но не в другом. И это сильно сузит у тебя диапазон поиска, где у тебя может быть проблема в твоём Ты переврэйки диапазон поиска, где тебе надо поставить принтвы. Грубо говоря, да. Ну либо ты уже потом вот как раз, когда у тебя уже поменьше кода, на который надо смотреть, ты на него посмотрел и пошёл заваривать кофе. Это тоже вариант. Ну в общем основная идея здесь в том, что вместо того, чтобы пытаться внимательно пролистать кучу кода, ты можешь очень быстро сузить диапазон кода, на который тебе нужно смотреть, и какие-то критические условия, которые нужно внимательно обдумать, просто сравнив два трейса исполнения и добиться этого можно простым способом, когда ты берешь записываешь два code coverage прогона одного и другого теста и просто сравнивай их потом. Если формат этого coverage в каком-то относительно простом текстовом формате, то его можно тупо дифом задефать и потом отрендерить как в тот же coverage profile. Я не буду вдаваться в детали, кому это интересно могут посмотреть в статье, но там в статье буквально тебе дают команды, которые нужно сделать, включая div и все, чтобы это вот работало с профилями, которые go записывает. Вот собственно статья довольно небольшая и тема не очень большая, поэтому сама идея мне показалась очень прикольной, потому что это вот знаешь, мой подход был бы это пойти расставить тысячу принтов и посмотреть какие принты выполняются, какие принты не выполняются, и потом начать бинарным поиском как-то сужать это дело. А тут можно просто сразу скипнуть, потому что компьютеры делают скучную часть работы за нас. Мне кажется, это очень круто.",
    "result": {
      "query": "debug failing unit test coverage diff"
    }
  }
]