[
  {
    "segment_id": "36b7775b-e4e3-4d2e-99ef-386b8d8bd970",
    "episode_id": "9e0613ee-9b18-4f1d-aa68-bec8a6ffdf04",
    "episode_number": 389,
    "segment_number": 3,
    "text": "Спасибо. Дальше, чему научился Саша, поскажешь? Я научился тому, что телеграмму очень сильно пережимает фоточки, если их пересылать наивным способом. Фоточка. Да, да, да. Но оказывается... Мы тут играли в увлекательную игру, называется «Нейди-кота на фотографии». И эта игра вызвала затруднения. Оказалось, потому что фоточка переслала очень пережатой, и на ней просто кота реально не было видно. Оказывается, в телеграмме есть альтернативный режим. Посылать как файл. Я не помню, где он спрятан в интерфейсе, но его достаточно легко найти. Так что, если вы шлёте фотографию чего-то, где нужно разглядеть мелкие детали или мелкие животных, то знаете, что такая фича есть. Я про неё даже не догадывался. Её легко найти, если вы профессиональный пользователь современных интерфейсов. Но эта манера прятать кнопки за хавером, чего-нибудь и прочее такое, конечно, бе. Я тем временем расскажу, чему я научился. Или... Да, Ваня потом пусть будет, раз я ж рот открыл. Я совершенно случайно для себя узнал, что в «Возгрессе» есть такая функция, которая называется PG Extension Update Path. Смысл в чём? Если вы пишете своё расширение, и в расширениях «Возгресса» там могут быть такие скрипты миграции. И у вас могут быть... Грубо говоря, вы можете написать... У вас есть, например, есть версия 1, версия 1.1 и версия 2. И, например, вы можете иметь путь миграции прямой из 1 в 2, а можете иметь путь миграции 1.0.1.1.2. В смысле, 1.0.1.1.2. Когда вы... Если у вас поставлено.. . Вы можете и такой- и такой путь заиметь. «Возгресс» обычно автоматически сам выбирает путь из доступных. Но если вам почему-то нужно на их все посмотреть, например, потому что мы хотим их протестировать, вот есть такая чудесная функция, которая вам покажет, какие пути существуют. Удобненько. Он показывает прям все или кратчайшие? По-моему, прям все, судя по тому, что я вижу. Я вижу Source, Target и пути для них. То есть он предлагает тебе для каждой пары из версии в версию... В версию он находит один путь? Да, наверное, да. Наверное, не совсем всевозможные. Но тут еще я смотрю, конкретно об этом примере, я не уверен, что это, по-моему, есть всевозможные. А, слушай, да, тут прям документатор написан, что он типа да, из версии в версию, из каждой версии в каждую версию, и это будет тот путь, который выберет Alter Extension Update. Так что да, это не совсем все доступные, это те, которые «Возгресс» реально пойдет. Ну, удобно, да, хорошо. Если вы хотите что-то потестировать, это именно то, что вам нужно, потому что это именно те пути, которыми оно пойдет. Еще занимательный факт про версии в «Возгрессе», если меня не подводит «Склероз», «Возгресс» в принципе нет разницы, что вы там напишете 1.3, 1.8, то есть для него это просто строка, и вы можете релизить там 1.49, следом за 1.67. В «Возгресс» нет особой разницы. Насколько я помню. Слушай, нет, подожди, когда ты ставишь, он всегда ставит самую новую версию. А, ну, возможно, он ставит ту, которая в экстаншене написана, просто да. Наверное, да, наверное, ему правда пофиг. Ну, как бы, а с чего бы ему вообще беспокоиться об этом? С того, что, например, по-хорошему надо ходить, в обратную сторону, наверное, не всегда должно быть возможно, с другой стороны, типа вот тут есть такие пути из версии 1.3 в версии 1.0. У тебя эти пути, они появляются, когда разработчик явно написал Update Script. Если ты написал вот прям руками Downgrade Script, почему бы «Возгресс» тебе запрещать им пользоваться? Ну, наоборот, алло. Все обсудили, я могу уже свое. А мое это Kubernetes. И внезапно оказалось, что я не знал такой важной вещи в работе с метками. Как вы знаете, в Kubernetes есть метки. Они установлены на подах. И вы можете сказать, дай-ка мне все поды, у которых есть метка, не знаю, клиенты из, не знаю, Новой Зеландии. И у вас есть клиент-метка, значение которой равняется Новой Зеландии, не знаю, Европа, Австралия или еще что-нибудь такое. И вы можете спокойно там получить этот список подов. И я всегда его использовал только для срока для сравнения. То есть дай мне все, что ключ равняется такой это значение. Оказывается, что я совсем слабо использовал эту функциональность, потому что есть два типа операции с метками во время сравнения. Можно сравнивать на равенство, как я делал. Но, кстати, можно сравнить на неравенство. Для меня это бесполезная вещь, потому что обычно если с неравенством сравниваешь, там будет куча вылазить тебе, но все равно. А есть еще на работу с сетами. То есть как бы есть набор меток, которые ты хочешь, ты можешь сказать дай мне все из этого набора. Ну, например, там тип ноды чтобы был и frontend и backend. Или там тип ноды и перечислить все типы. И можно объединять эти запросы в одном, потому что все условия, которые вы перечислить через запятую, они будут как бы с логическим и связаны. И можно сделать оказывается из этого очень не стандартные запросы. Довольно большое количество use-case у меня лично открывается. Ну, там в качестве примеров в документации говорится, что партийцы это клиенты A, клиенты B и environment это не равняется qA. То есть через запятую перечисляйте, и это прям классно. Классно, я не знал этой функциональности и на этой неделе увидел и удивился, что я как-то ее пропустил. Я ссылку на документацию приложил, так что поглядите. Ну что, я думаю это все по поводу на эту тему. Я может быть отключился, Ваня про друзей рассказал? Про гусей рассказал и про плесень. Я отключался, простите. И так, новые друзья Вани мы узнали, кто они. Следующая тема это про базы данных. Новые друзья Саши. Новые друзья Саши. Деревья. Деревья новые друзья Саши. Да, в вашу любимую рубрика под названием Саша решил немножечко подтянуть свои знания о обучении бдрвьев. Седьмая лекция из серии CMU Intro to database systems посвящена бдрвям. Как обычно не пересказ, поскольку ну, мы тут серьезный подкаст, и все знают, как устроено бдрвя. Вот поэтому я выписываю только что-то, что мне показалось интересным, или что-то, что мало известно, таковы роды вещи. Вот, доклад говорит, что бдрвья это одновременно и семейство алгоритмов, и прям есть конкретно B3, right? B3. Алгоритм в 1972 году его придумали, но на практике он, как правило, не используется. На практике используется вариация названием B плюс деревья. Отличие в том, что B плюс дерево хранит значение только в листьях. B дерево хранит значение и в листьях, и в узлах, и в корнях, вроде бы. Вот, другие вариации. Это B star деревья, еще есть FD деревья и BW деревья. FD деревья и BW деревья они хорошо описаны в книжке Database Internals, автора Алекс Петров. Я уверен, мы упоминали эту книжку больше одного раза в этом подкасте. Не так часто как книжку с кабанчиком, но тем не менее. И я прониковал ее в шелнотах. Если вам будет интересно узнать, чем FD деревья отличаются от B star деревьев, насколько мне известно, на практике все не парятся, используют B плюс деревья. Ну, с некоторыми разными вариациями. Например, Postgres вроде бы не умеет схлопывать узлы, в смысле уменьшать вложенность. То есть, наращивать можно, а схлопывать только если ты перестроишь индекс. Но я сейчас по памяти говорю, это не точно. Рекомендуется книжка в этом закладе, называется Modern B3 Technics, автор Goets Graefe. Я не уверен, как это произносится. Ее можно купить в формате PDF за 150 долларов, или очень легко найти цифровую копию для ознакомительного чтения. Также найдете ссылки в шелнотах. Занимательный факт, не существует, ну или по крайней мере никто из знакомой докладчиков не смог назвать пейпер, который описывает B плюс деревья. То есть, как бы вот B плюс деревья есть, а кто конкретно их изобрел, в каком пейпере они описаны, не очень понятно. Ну, потому что 50 лет прошло, почти, и как-то эту информацию успело потеряться. Также никто не знает, что означает B в названии B деревья или B плюс деревья. Ну, как бы есть версии, что это, ну кто-то расшифрует это как bush, кто-то расшифрует как balanced, но что точно означает B, не знает никто. Вот, что еще? Ну, в целом, если вы не очень знакомы с этой структурой данных, или, может быть, забыли ее, то в докладе там хорошо объясняется, как происходит вставка, удаление, поиска, все это очень подробно. Вот, из вещей, которые я не очень понял, я, может быть, уставший смотрел, может быть, мы вот сейчас вспомним, утверждается, что когда у тебя в B плюс деревья попадаются элементы с одинаковым ключом, это проблема, потому что свойство B деревьев такое, что вот у тебя есть узел, в нем массив элементов, и должно выполняться условие, что вот в самом узелом под деревья у тебя все элементы строго меньше, не меньше, или обравно, вот прям строго меньше первого, ну или нулевого, элемента массива в узле. Потом, если мы смотрим следующую ссылку, то там строго меньше второго элемента в массиве, и так далее. И это проблема, когда у тебя попадаются одинаковые элементы, потому что представляете, да, себе B дерева, ну, простите, я в подкасте объясню, как могу, у тебя, когда ты много одинаковых элементов B дерева засунул, у тебя появляется узел, в котором сказано, что вот в самом-самом левом поддею у тебя все элементы, которые строго меньше, не при разночении A, а потом получается в следующий элемент ты снова должен записать, что у тебя вот все элементы строго меньше A, но это достаточно глупо, потому что ты сказал, что все, что меньше A, находится левее первого элемента. Я не совсем уловил, а что мешает делать меньше либо равно, то ли при этом теряется что-то из свойства с забалансированности дерева, или поиск становится не O от log N, но докладчик, он приводит там несколько решений этой проблемы. Одно из решений заключается в том, чтобы в листях значениями ты можешь к нему применять... Саша, ты пропадал. Хорошо, на каком месте я пропадал? Сейчас, я... Что-то сказало значениями, кажется, я пропадал. Чтобы в листях со значениями потом было пауза. Хорошо, давайте я с основной начну. Мы пытаемся решить проблему, мы записываем много одинаковых значений в обе дерева. Все значения хранятся в листях. Вот если у тебя листовой элемент переполнился одинаковыми значениями, одна из стратегий заключается в том, чтобы прилинковать к нему еще один узел, еще один leaf nodes. Это называется overflow leaf nodes. И этим ты решаешь эту проблему, если все одинаковые значения будут в один лист, который как резиновый растет постоянно. Но зато в нормальных узлах, которые не листовые, ты можешь уже нормально выполнить свойства, что все, что меньше х находится левее. Потому что они все попадут в один листовой элемент. Но это достаточно сложно реализуется и поддерживается, потому что по индексам можно конкурентно ходить. И пока ты по ним ходишь, ищешь, тебе нужно в дерево вставлять значения. Это достаточно сложная реализация, но тем не менее теоретически она есть. Другое решение заключается в том, чтобы к ключам добавить какой-то уникальный ID, потому что у тебя есть значение, которое куда-то ссылается в индексе. В позграсте это называется item pointer, это номер страницы и слот внутри этой страницы. И ты можешь сказать, что ты не индексируешь не просто поле X, а ты индексируешь пару X и вот этот item pointer гарантированно уникальный, и он все равно хранится в B дереве, правильно? Поэтому ты можешь сказать, что это все твое значение, и этим ты решаешь проблему уникальных элементов. Да, нет. Решаешь проблему повторяющихся элементов. И вроде как тебе не нужно лишнюю память потреблять, сколько item pointer ты все равно хранишь в индексе. Вот. Повторюсь, я не очень понял, почему должно быть именно строго меньше, и честно говоря, мне было лень думать, потому что я смотрел это вечером. Ну а если кто-то готов слет ответить или прийти в комментарии и пояснить, было бы здорово. Вот. У меня по этой теме все. Я точно не помню, почему это важно, но вот чисто на скидку, если у тебя есть, если у тебя нет повторяющихся ключей, то получается, если ты нашел ключ, который однозначно ну то есть либо равен, ты можешь точно делать выводы о том, что находится слева текущего ключа, а что находится справа текущего ключа. Например, ты нашел нужный ключ тебе, а если у тебя могут быть равны, тебе может быть надо идти влево еще бесконечное количество ключей. Ну, конечное, но в смысле вплоть до полного списка. Я думаю, тут есть какой-то ограниченный случай, например, когда тебе нужно разбить узел на несколько, и у тебя возникает вопрос, а что добавлять влево, что вправо. Или наоборот, когда ты схлопаешь, но это достаточно неочевидно, я так слету не могу сказать, что мешает добавлять по уменьшению либо равно. Но я думаю, если достаточно долго над этим медитировать, то, наверное, ответ найдется. Но, повторюсь, мне было как-то не настолько интересно, но если вам интересно, вот вам интересная задачка для медитации. Что мешает в ВБ деревья класть не так. Ходить в дочерние узлы не по условию меньше, а по условию меньше либо равно. У меня по этой теме все.",
    "result": {
      "query": "telegram photo send file mode"
    }
  }
]