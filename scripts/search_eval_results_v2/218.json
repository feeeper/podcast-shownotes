[
  {
    "segment_id": "024ccf4b-f7f7-44de-b5a4-4b62892794c0",
    "episode_id": "17efc184-7508-48a0-b736-57091831c631",
    "episode_number": 218,
    "segment_number": 9,
    "text": "как бы изменения, это свойства системы, то есть рейт работает за одну секунду, и соответственно, вы не поймёте, что происходит. Здесь начинают помогать гистограммы, но к сожалению, гистограммы довольно сложно доставлять, и NodeExporter по умолчанию не доставляет гистограммы, он использует только каунтеры. Вот, и… что там дальше-то было? Сейчас, секундочку, я пытаюсь приближаться по статье, вспомнить. Да, и соответственно, чаще всего, мало того, что вам надо посмотреть на показания, которые как-то ваша бизнес-логика определяет, что происходит в вашей системе, сколько человек пришло и так далее, какие-то определенные запросы в вашу систему. Бывает полезно узнать, что происходит в вашей системе с точки зрения самой операционной системы, что она сама о себе думает. То есть показания какие-то, которые можно вытащить об I.O. происходящем в вашей системе, о каких-то счётчиках внутри ядра. И для того, чтобы это работало, вы должны понимать, что как бы это же вы снимаете с реального продакшена, и это, во-первых, должно быть очень быстро, во-вторых, оно не должно создавать никаких проблем для вашего сервиса, который работает в продакшене. Это должно быть удобно, универсально и работать прямо из коробки для того, чтобы вы запустили новую машину и не надо с ней колдовать два часа для того, чтобы там эти графики появлялись. Ну то есть довольно много требований к системе, и здесь получается, что не так это много универсальных способов, чтобы это сделать, и EBPF, он как бы подходит. Теоретически EBPF – это система, которая работает внутри ядра, и она позволяет в безопасном режиме запускать, как это, фактически binary, то есть как бы предскомпилированные программы в каком-то сэндбоксе внутри ядра, и поэтому вы можете вычислять какие-то большие важные для вас метрики. С одной стороны, это будет быстро, с другой стороны, вы этим сами управляете, и все это хорошо. И для того, чтобы это было удобно, они как раз и сделали систему, которая из EBPF экспортирует в Prometheus, и они приводили некоторые примеры, когда это бывает очень полезно. Ну, например, у них была какая-то проблема в системе с тем, что размеры файлов, количество файлов, количество обращений в кэш, директория файловой системы, ударение в L3, CPU кэш, то есть они разбирают прям реальные юзкейсы из своей практики, когда только знание о том, что происходит в операционной системе, помогало им обнаружить проблему. С точки зрения их бизнес-логики, то есть когда вы разрабатываете какую-то бизнес-логику, вы не предполагаете, что это может настолько сильно перезагрузить вашу систему, что по показателям бизнес-логики все ок, но почему-то ничего не работает, и больше 100% цепи занято, хотя должно быть 5-6%, судя по текущей статистике использования. И только знание о том, куда посмотреть в системе и введение графиков системы прямо в реальном времени помогает очень быстро на лету понять проблему. К примеру, у них есть система, которая показывает… Так, сейчас я пытаюсь найти этот пример, секундочку. К примеру, у вас происходит какая-то… Как это называется-то? То есть у вас получилась ошибка в вашем коде, происходит… А, нет-нет-нет, я уже забыл, это было очень давно, когда я читал эту статью, не буду приводить примера. Они пытались понять в некоторых случаях, почему тормозит система с точки зрения ядра, и они написали функцию, которая периодически с каким-то интервалом смотрит в какой функции прямо сейчас происходит обработка, и фактически строили вот этот Flame Graph, но только для работающей системы продакшен на лету и с гораздо худшим качеством. То есть они это не делали постоянно, а скажем, каждую миллисекунду, грубо говоря. И они прямо написали интерфейс, они написали код, с помощью которого это можно определить, простейший код вида определения функции, в которой сейчас происходит обработка, потом мы это хэшируем, каким-то образом выдаем наружу, а из-за того, что ядро одно и то же везде используют, мы потом можем по таблице хэш и определить, где мы были в настоящий момент, и нарисовать какой-то график. Но там все это в виде кода и с комментарием, поэтому все становится понятно, я просто сейчас уже, у меня выветрилось из головы, читал давно. И довольно удобно определить и понять. В целом, общий вывод этой статьи такой, что из непонятного и далекого инструмента, который вы слышите на конференции и ходите посмотреть, что такое за диковины звери, а давайте мы попробуем его использовать для решения наших проблем, он превращается в довольно универсальную систему, которую вы можете прямо из коробки поставить и запустить для каких-то основных метрик, которые могут вам, возможно, понадобиться. Из-за того, что эти метрики очень дешевые в использовании, из-за того, что это прямо из коробки должно работать, это не в теории. Я сам не пробовал, но здесь как бы ничего не намекает, что здесь где-то есть сложности. Получается, что вы это прямо сразу получаете у себя в примитивосе и можете настраивать какие-то алерты или по крайней мере смотреть, что происходит на ваших серверах. Я считаю, что это вообще очень удобная штука, я прямо нам уже подкинул эту идею и мы, возможно, это будем примонтировать скоро. Как-то так. Вопросы? Я что-то вас всех утомил, похоже, вы уснули. Ну это просто пересказ доклада. Вот мы так второй раз сказали, как не знаю, что не надо доклада, пересказ взял и пересказ доклада. Это не доклад, это статья. И я прямо очень рекомендую заинтересоваться всем тем, кто следит за своими системами и хочет понимать проблемы в продакшене на лету. Я считаю, что это прямо не может не заинтересовать вас. Вот вы, Валера, вы используете EBPF, показатели метрики где-нибудь для отслеживания состояния системы?",
    "result": {
      "query": "EBPF системные метрики Prometheus"
    }
  }
]