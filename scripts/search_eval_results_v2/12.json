[
  {
    "segment_id": "90d43199-96d3-4689-9716-dac15a9c5bf9",
    "episode_id": "27288c90-9c96-4610-b676-ff008c33c2b1",
    "episode_number": 12,
    "segment_number": 4,
    "text": "Ты не забываешь, Вань, что это динамически типизированный язык. Здесь можно Transducers применить хоть к списку, хоть к каналу, хоть к сокету, почему угодно. Там очень интересная колбаса, когда это все выложилось, куча народу начало бегать и говорить, да, это уже было, это называется так. Потом им приходят и говорят, нет, это не то, потому что то-то там. И в общем есть сотни гипотез на Hacker News трейде, что такое Transducers. Они все не очень соответствуют истине. Есть пост Understanding Transducers Through Types, то есть попытаемся разобраться с Transducers через типы, где на Haskell'е пытаются вывести сигнатуру типов для Transducers. Там не очень получается, ну то есть наполовину как-то получается, в принципе. Там какой-то Type 2 полиморфизм врывается вообще в дискуссию. Вот такая вот вещь. Мне поначалу напомнило больше всего карьерование, но после своего объяснения я понимаю, что это не совсем оно. Да, причем очень много это напоминает, но везде получается, что это не совсем оно. В линзе кому-то напоминает, что-то еще напоминает, вот это все не совсем оно. Давай дальше, к следующему вопросу перейдем. Я не знаю, кто его добавил, тот какой-то анонимный источник. Ну да, в смысле анонимный источник? Это ты же добавил тоже. Нет-нет-нет. Ты написал, объясни нормально, что такое Clojure и Clojure Script. А, может и не ты написал. Да нет, это все Саша написал под разными аккаунтами. Ну, значит я уже запамятовал, просто я был слишком упорот, как свет у меня спалил. Продолжая тему Clojure, у Clojure есть диалект, называется Clojure Script. Это когда ты пишешь Clojure код, он компилируется в JavaScript и исполняется в браузере. Это подмножество, но это даже не подмножество, а другая, немножко, почти Clojure, но с нюансами. Завязанные на браузере и особенности браузера. Короче, ты можешь писать на Clojure и запускать это в браузере, и в браузере работает все, что ты хочешь от Clojure. Всякие персистентные структуры данных работают, умытабельность, функциональное программирование, модули и все на свете. Это сделано достаточно грамотно, он компилируется в JavaScript, причем JavaScript такой машинный, который умеет обрабатываться гугловым компилятором JavaScript, который оптимизирует и минифицирует. Получается очень на выходе компактный, минимальный JavaScript, насколько это возможно, только с теми вещами, которые ты реально используешь. И все работает, есть source map, можно дебажить прямо в браузере. Ниакого подвоха нет, в библиотеке interop JavaScript, можно дергать том, можно дергать библиотеки JavaScript, jQuery, React, что хочешь. Красота, чтобы писать JavaScript приложения в браузере, это прекрасное решение. Изначально концепция у них была такая, что назревает эпоха приложений в браузере, веб-сайты все научились делать, JavaScript хватает, а сложных приложений не умеют. Нужен нормальный язык, на JavaScript очень трудно делать большие приложения, нужно решение, которое бы концептуальные проблемы решало. Клоджскрипт предлагает такие решения. Плюс сам язык намного лучше, у него нет bad parts, частей стандарта, которые запутаны, нелогичные, семантика поправлена кое-где. Это про то, что такое клоджскрипт. И почему это круто, и спасение. Притекающая сюда тема, это соответственно, чем это хорошо, про спасение фронт-энда. Ты недавно сделал пост у себя в ЖЖ. Да, я примерно уже рассказал. С точки зрения UI ты мало чего рассказал. Да, концепции поддерживаются, а почему с точки зрения UI это намного легче станет? Ты на JavaScript писал? Ну, немножко писал. Есть еще вопрос? Я немножко писал на JavaScript, немножко на клоджскрипте, я не понял разницы, если честно. Ладно, так, сейчас. JavaScript как язык у него есть, во-первых, это довольно старый, он давно создавался, и у него есть очень много проблем. Но он стоит в каждом браузере. И более-менее браузеры достигли понимания, когда они все одинаково интерпретируют. Короче, это общий язык для всех, кто хочет запускаться в браузер. Соответственно, это и блессинг, и проблема. Нужно как-то жить с JavaScript, но с самим JavaScript пользоваться невозможно, потому что у него очень много всякой хрени. Он очень медленно развивается. Это старый язык, в котором ничего нет, никаких приятных синтексов, нифига нет. Его, опять же, не очень оптимально исполняется. Чтобы JavaScript нормально исполнялся, его нужно писать в полумашиновом режиме, вставляя всякие аннотации для компиляторов, которые в Chrome, Safari, Firefox будут эти аннотации понимать и оптимизировать код. Когда ты пишешь на языке руками, ты пишешь такой код, из которого компилятор не может понять, что его можно исполнить эффективно. А вот если ты его правильно пишешь, его можно будет исполнить эффективно. Ты сейчас повторяешь то же самое, что и до этого сказал. Я с тобой здесь полностью согласен. Я имею в виду, с точки зрения крупных систем построения, когда у тебя большая логика, получается, тебе ClojureScript дает спасение, потому что у тебя куча новых функций, которые в новых языках появляются, а в JavaScript появиться не могут по определению. Меня больше интересует с точки зрения, когда у тебя не логика вида, но более прикладное программирование. Когда ты хочешь маленький свой сайтик написать с маленьким бложиком и так далее. ClojureScript тоже поможет, хотя у тебя 20 строчек будет. Стоит ли тебе учить ClojureScript, если у тебя не будет большой разветвленной логики, а будет что-то маленькое, и тебе, возможно, больше придется потратить времени на изучение ClojureScript, чем оно даст плюсов? Тут два момента. На самом деле, маленькие проекты все равно, чем писать. Ты не почувствуешь боли JavaScript, если ты будешь писать маленький проект, скорее всего. Во-первых, маленькие проекты превращаются в большие рано или поздно. Во-вторых, большие тоже надо как-то писать. Я не пытаюсь убедить, что ClojureScript нужно учить, чтобы писать 20 строчек. Я это делаю, потому что я его уже знаю. Мне проще на ClojureScript накидать, потому что на JavaScript я буду дольше комбинировать, комбинировать underscore с чем-то, чтобы сделать map, filter, reduce, чем я на ClojureScript это сделал. Естественно, если ты уже знаешь JavaScript, делаешь что-то небольшое, никаких проблем ты не испытаешь. А на больших проектах все те плюсы, которые дает функциональное программирование, иммутабельность, плюсы, которые дают пресетентные структуры данных, когда ты можешь иммутабельные данные, copy on write менять, делать это эффективно и переиспользовать потом. Когда ты не боишься, что в одном месте кода данные поменяются, и это испортит другое место кода, которое не ждали, что объект, который они передали функцию, поменяется. Вот такие вещи. Неймспейсы, нормальная организация кода. Такого плана вещи нет. Есть нормальные мапы, у которых ключи могут быть произвольными объектами, а не так, как в JavaScript, где ты не можешь ключ, называющийся конструктор, положить в мапу, потому что это зарезервированное поле. Я люблю просто эту часть JavaScript. Такого плана вещи. У меня где-то был список того, что хорошо в JavaScript, но я сейчас, может быть, что-то пропустил. В принципе, писать на нормальном языке большой проект, структурировать его гораздо проще, чем на JavaScript. Александр Петров спрашивает про проект PassibleDB. Что это вообще? Так. Окей. PassibleDB, да. Есть такая база данных для Clojure, Datomic. Она такая нетрадиционная, очень сильно нетрадиционная. Она иммутабельная, то есть там вся история изменений хранится, это может катиться к любой версии данной, к версии базы и делать по этой версии, допустим, запросы. Есть версия Datomic для браузера, такая немножко ограниченная, и in-memory, но в принципе версия. Называется DataScript, это то, что я делал на библиотеку. Идея такая, чтобы, когда у тебя есть веб-страничка, ты мог на веб-страничке хранить, стоять не как попало в переменных и не пойми чем, а завести базу данных и хранить, стоять в базе данных. Для приложений, которые показывают структурированную информацию, таблицы, тишис, списки, это очень удобно. И я потихоньку пиарю свой проект. А PassibleDB это комбинация того и другого, то есть они взяли мой DataScript, и если я правильно понял, насколько я смог понять, потому что у них есть на GitHub, они берут DataScript и сохраняют его в ResyncDB базу. Смысл в том, что DataScript это база данных, которая работает на клиенте, в браузере, у нее нет персистентности. Персистентность оставлена за скобками, ты как хочешь, так ее и делай. Потому что у разных приложений разная идея о том, как им нужно это делать. Поэтому я никакого решения не предлагаю. Соответственно эти ребята, я так понял, просто прикрутили к DataScript персистентность. Получилось open-source, персистентный, почти что датомик. Вот такая концепция. Я так понял, там довольно мало кода, и все, что она делает, это просто берет всю базу данных и сохраняет ее в ResyncDB. А потом достает. Может быть я, конечно, что-то проглядел. Но приятно, что мой проект что-то пытается в нем делать. Тот же Александр Петров интересуется про ClojureScript на Nashorn. Nashorn, если не изменяй склероз, это JavaScript под JVM, да? Да. Вот, допустим, PassiveLDB, про который мы говорили, он как раз таким образом и сделан. Или не таким, примерно таким образом сделан. Они взяли ClojureScript проект мой и запускают его на сервере. С помощью то ли Node.js, то ли Nashorn. Смысл в том, что у нас есть ClojureScript, он компилируется в JavaScript, а JavaScript можно запускать и на сервере. Круг замкнулся, мы сначала писали на сервере, потом писали в браузере, а потом пишем на JavaScript на сервере. На том самом плохом языке, который никто в здравом уме не хочет использовать, сейчас все кинулись писать на нем и на сервере тоже. Есть такая штука, что можно на ClojureScript писать и запускать то, что ты на нем написал на сервере с помощью JavaScript Engine. Обычно это V8, есть Lighttable, это такая IDE для Clojure, написанная на ClojureScript полностью, но она работает у тебя на компьютере, то есть на сервере. Она написана на ClojureScript и запускается на Node. js. Плюсы этого в том, что у них есть веб-интерфейс и сервер-интерфейс, они написаны на одном языке на ClojureScript. И плюсы в том, что стартап тайм быстрее, чем у JVM-овской Clojure. Соответственно, у нас Horn, я так понимаю, дает примерно все те же плюсы. Единственное, что он запускается внутри JVM, так что мне не очень понятно, в чем прикол. Насколько я понимаю, прикольно использовать Horn внутри JVM, когда ты гоняешь во время разработки теста. То есть тебе ClojureScript, чтобы протестировать, тебе нужен JavaScript Environment, ты можешь его в виде Java объекта создать и туда загнать то, что ты сделал. Такое использование, мне кажется, скорее всего, наиболее популярным станет для него. Не-не-не, подожди, ты же можешь взять ClojureScript, скомпилить его в JavaScript, а потом использовать его как какой-нибудь embedded язык для твоей приложенки, как скриптовый язык для твоего приложения. Или я чего-то не догоняю? Ну, можешь так делать, да. Ну, как бы... Ну, да, можешь. Насколько я понимаю, JavaScript под JVM используют либо для написания каких-то тестов, либо для вот такого embedded языка. Может, еще есть какие-то use cases, но я так слету не могу придумать. Ну, наверное, можно, да. Ну, хорошо. Тот же Александр Петров спрашивает про обертки для React.js. Да, обертки для React.js. Смысл примерно такой. Есть такая библиотека React, это классная библиотека для того, чтобы писать WebUI, которая как раз сильно облегчает разработку WebUI. Она появилась недавно, но там такой взрывной у нее рост популярности, потому что это очень классная концепция. Она стоит в том, что каждый кадр мы вычисляем все том дерева с нуля. То есть у нас есть данные, и мы говорим, что нам сейчас рисовать, а давай весь граф дома, который нам надо рисовать, и вычислим. Это очень удобно, потому что это позволяет не морочиться с модификацией дома. Типа, вот здесь кликнули на кнопочку, нам нужно найти объект по идишнику такому-то и сделать ему display height. А мы просто все перерисовываем. То есть у нас есть исходные данные, мы все перерисовываем. Достижение React в том, что они придумали, как это сделать эффективно. И не настоящий дом используют, а виртуальный JavaScript объект. А так, концепция известная, ее используют в играх. То есть в играх каждый кадр это перерисовка всех треугольников заново. Там нет каких-то stateful треугольников, на которые решаются клики или еще что-то. И это все работает, это все работает супер классно, это работает в мобилках и везде. Такую библиотеку нельзя было обойти в Clojure-сообществе. Для Clojure Script появились адаптации. Самая простая адаптация этого, это наверное, QuestChant. Это очень простая концепция. Примерно так, как я описал, они просто говорят, что данные, которые мы рисуем, иммутабельны. То есть это любая Clojure-ская структура данных иммутабельна. И, собственно, напишите функцию, которая из данных x рисует дерево, дом, объект. И все, ваше приложение готово. И все, они больше ничего не делают. Это очень простой проект, буквально 20 строчек осмысленных кода. Но это все прекрасно работает. Если вы можете таким образом структурировать свои данные, то оно будет работать для вас. Дальше идет Reagent. Reagent немножко похитрее. Когда рендеришь дом-дерево, в каждом узле... Каждый узел зависит от каких-то данных. Соответственно, Reagent вешает листерны на эти данные. И когда ты меняешь эти данные, он перерисовывает только те компоненты, которые слушают нужные данные. Это, наверное, будет работать в каких-то случаях быстрее, потому что только части этого дом-дерева перевычисляются. Но у них там своя реализация этих объектов, которые можно менять. У них там свое какое-то макро-программирование. Я не знаю, в принципе, я уверен, что это все работает. Но по моему опыту разница, мне кажется, не очень большая. Короче, перерисовать все дом-дерево или только кусочки, это не сильно большая разница. Ну, зависит от того, как вы с данными работаете. Короче, если вы можете структурировать свои данные, как много разных атомов, и связи между ними, привязать компоненты к ним, то у вас это будет лучше работать и быстрее. Проще, наверное, будет написать на Reagent. Наконец, есть OMM. Это библиотека от монтейнера кружескрипта Дэвида Нолана. OMM это такая штука, она продает немножко больше, чем просто биндинг к React. Она продает еще свой подход к стейт-менеджменту. Она говорит, что весь ваш стейт должен быть одна хеш-мапа, глубоко вложенная. И, соответственно, ваше дом-дерево должно раскидываться по кусочкам этой хеш-мапы. И там они реализуют ререндеринг на основе React по частям этой хеш-мапы и дерева дома. Это, по-моему, наиболее популярная библиотека для биндингов к кружескрипту React. Но, на мой взгляд, она немножко излишне переусложнена. Там очень много хитростей и таких попыток сделать магией и прозрачно. С другой стороны, там очень много неявных правил, типа, что вот эту функцию можно вызвать здесь, нельзя здесь. Не очень много документации по этому поводу. В ней нужно очень хитро разобраться и очень легко запутаться. И вот это такого плана вещь. Тем не менее, она популярная. И там же Александр спрашивал про то, что я использую в своих проектах. Я пробовал использовать OM, у меня с этим не очень сложилось. И я перешел на Question, а потом, когда я начал писать над создателем скрипта своим проектом, мне даже Question не очень подошел. Короче, я пока использую голый React, я перерисовываю все. Все эти три проекта, они на самом деле про то, что давайте возьмем React, как он есть, и немножко его соптимизируем в той части, чтобы нам не все дерево всегда перерисовывали. У меня хорошо работает пока подход, давайте все дерево перерисовываю. Но когда он перестанет работать, надо будет думать, как его соптимизировать. Что с этим делать? Ты заодно ответил еще на парочку вопросов, не останавливаясь. Очень здорово, спасибо. Давай следующий. Спрашивают про Clojure Web Security. Да. Clojure Web Security, user science fiction. Это вопрос, вызван тем, что был такой доклад, очень мощный и запоминающийся, где чувак говорит, что в Clojure Security очень плохо. Для веб-приложений на Clojure у них уровень security, один из худших, который он видел, он security expert, и что это примерно уровня PHP, причем PHP без фреймворка вообще. То есть, когда ты все на PHP сам как-то сделал, вот у Clojure приложения примерно такой уровень security. Вопрос в том, стало ли что-то лучше с тех пор. Я на самом деле не очень в курсе, я такие классические веб-приложения не писал на Clojure. Я не думаю, что сильно стало лучше, по крайней мере ничего громкого я не слышал, что бы происходило на эту тему. А если посмотреть сам доклад, то понятно, что чувак сам про это говорит, что проблема не с тем, что Clojure фундаментально не подходит к тому, чтобы делать секьюрные приложения. Подходит, конечно. Проблема с тем, что люди собирают неправильно. В Clojure есть такая культура, что мы не любим фреймворки, мы любим библиотеки. То есть, нам не нужно что-то цельное, которое будет говорить нам, как организовать код. Дайте нам библиотеки, которые каждая делает какую-то функцию, а я потом сам решу, как их скомбинировать. Это очень классный подход, он очень здорово работает, он мне глубоко симпатичен, но у него есть именно для веб-приложений один минус, что ты не... вся ответственность на тебе. Если ты не знаешь, что ты делаешь, ты сделаешь кучу проблем, потому что ты не учел, что вот эти две вещи можно только так комбинировать, а про третью вещь, которую нужно обязательно использовать, ты вообще не знал. Ну так во всем выбежит. Нет. И, собственно, есть веб-фреймворки, они хотя бы частично решают эту проблему. То есть такие вещи, как Django или Rails, это фреймворк, который тебе дает все готовое, и ты можешь менять чуть-чуть. Соответственно, они решают эту проблему, во-первых, потому что у них то, что нужно, уже есть, в стандартной поставке просто включено уже. Во-вторых, оно настроено на те параметры, которые по дефолту, скорее всего, наиболее оптимальные и безопасные. Если у тебя что-то с ними не работает, то ты поменяешь их в ту сторону, куда тебе нужно, но ты будешь знать, что ты отступаешь от безопасного дефолта, когда меняешь. И третий момент, связанный тоже с тем, что есть фреймворки, на самом деле, это такой образовательный момент. То есть проблема с безопасностью не в том, что ее сложно сделать, а в том, что люди просто не знают, как ее делать. И фреймворки на самом деле решают во многом именно образовательную проблему. То есть, допустим, ты смотришь, что там вообще есть, и учишься, как делать веб-приложения, и с какими проблемами ты, возможно, столкнешься, и как с ними бороться. И ты учишься, глядя на сам код, глядя на документацию, глядя на документацию в основном тоже. И это тебе позволяет вырасти. То есть, допустим, у Django есть прекрасная документация по этому фреймворку, и в ней это не документация уровня, типа «этот метод делает то-то». Это почти что как книга. То есть ты ее можешь читать и узнавать о веб-приложениях и о том, как их строить. Я когда работал с Django, я впечатлился, и с тех пор приобрел точку зрения, что сгенерированная документация, она недостаточно хороша. Документация должна быть написана специально, и последовательно, и как-то добавлять больше информации, чем просто комментарий к каждому методу. И, собственно, на самом деле, чтобы ситуацию исправить, достаточно просто научить людей делать веб-приложения секьюрно. Достаточно написать блог-пост, вот как сделать веб-приложение секьюрно, и разобрать основные проблемы. Как сделать форму логина, какие вещи не забыть. Чуть ли не чек-листа, может быть, было бы достаточно. Но, к сожалению, никто этого не сделал. Научить людей делать секьюрные веб-приложения? За столько лет этого никто не преуспел с этим в PHP, а ты говоришь, что сейчас в Clojure один пост все изменит? Мне непонятно, почему я не преуспел. Мне кажется, это такой топик, у него понятна тема, круг вопросов, понятны решения. И вообще загадка, почему нет. Сам доклад, который говоришь, что секьюрити хреново в Clojure, он как раз частично решает эту проблему. Он обращает внимание людей на проблемы, которые есть. Ты берешь этот доклад, берешь список проблем и смотришь, чтобы у тебя их не было в приложении. Все, вперед. В таком духе, мне кажется, надо продолжать. Джон Мостовой обеспокоен скоростью загрузки Clojure приложений под Android. Ничего не будет. Clojure грузится очень медленно. На Android она очень медленно, опять же, тоже грузится. Она особенно медленно грузится. И когда первые разы пробовали ее запускать на Android, она вылетала по таймауту, потому что за 30 секунд не успевала загрузиться. Что-то такое. Не знаю, будет ли решено это как-то или нет. Какие-то оптимизации в 1.7, по-моему, должны по скорости загрузки быть. Они будут для JVM Clojure. Скорее всего, не будет специальных заточек под Android. И, скорее всего, это будет недостаточно хорошо все равно. Решение состоит в том, чтобы писать на Clojure скрипте и запускать их в каком-то JavaScript environment в приложении. Фонгэп или еще что-то. Такой подход работает. Есть iPhone-приложение, написанное на Clojure скрипте. И Android, наверное, приложение тоже есть. Такое чувство, что под Android все-таки нельзя писать ни на чем, кроме Java чистой. Потому что на Scala не одобряют, на Clojure ругают. Не нужно писать ни на чем. Нужно писать на Java скрипте и все. Я не понимаю, зачем телефоны придумали свои языки, а не делают нормальный JavaScript. Все бы уже были счастливы. Или C++, как в Ubuntu Touch. Да. Особенно Никита был бы счастлив писать на Clojure скрипте, и оказалось бы, что это под все мобильники. Ну, так можно делать, но как бы... Там есть преседание, да. Почему-то этот путь немножко запрещен. Немножко запрещенным, считаю. Ну, не то, что запрещенным. Этот путь специально не оптимизируют. В iPhone ты запускаешь PhoneGap, но ты запускаешь его вместе с самостоятельно собранным JavaScript, в котором нет JIT-компиляции, и он работает медленнее, чем в Safari, допустим.",
    "result": {
      "query": "лучшие библиотеки ClojureScript React"
    }
  }
]