[
  {
    "segment_id": "217a9ed7-cbfa-4078-b856-98d0d4d78061",
    "episode_id": "725625c8-76d3-45f2-ba81-d38202043394",
    "episode_number": 121,
    "segment_number": 9,
    "text": "ETS-ка там типа Ordered Set, который имеет на себе один здоровенный лог, и он, то есть, как бы даже если там, хоть заставься врать Concurrency True на таком типе ETS-ке, она из-за того, что Ordered, она не может быть True Concurrent, поэтому все операции с ней, ну, как бы если у нас есть хотя бы одна запись, она будет вставать, ставить в ожидание всех остальных. Поэтому G-Proc, он на самом деле скейлится где-то, наверное, до сотен тысяч, ну, со скрипом уже, дальше сотен тысяч, ну, то есть они, конечно, в оригинальном пейпере говорили, что вот у нас там прям сотен тысяч процессов зареганных в одном регистре. Они при этом в оригинальном пейпере говорили, что у нас там сотни-сотни тысяч, вот по моему опыту, когда у нас есть G-Proc, под которым нужно стартовать сто тысяч процессов разом, это примерно его предел. Потому что уже на сто тысяч процессов, которые стартуют и регистрируются в G-Proc, у нас нода может так призадуматься, и вот как бы пока все эти ребята не стартовают и не зарегаются. И это не круто. Неизвестно в регистре, если лучше или нет. Вот как раз я к этому и веду, я в код еще не смотрел, ребята утверждают, что он, во-первых, вы можете стартовать в независимый регистр, у вас нет одного мега G-Proc, а у вас независимый регистр для того, что вам нужно. Это первый документ. И если я правильно понимаю, даже внутри регистр, он как-то внутри сделан более умно, и он скейлится по ядрам, то есть там как вот есть такая библиотека от BASHO, side job. Вот там ETS-ки по числу скейдлеров сделаны. И, соответственно, worker сделан тоже по числу скейдлеров. И, в общем, там так сделано, что в первую очередь пытается библиотека работать с ETS-кой, которая для ее скейдлера, поэтому контеншона нет гарантированно, и только если с той ETS-кой у нее не получается, она уже лезет в другие ETS-ки, потенциально вызывая контеншон. Соответственно, когда у вас всего много происходит, скорее всего, каждая ETS-ка забита, и до контеншона дело не доходит. Если происходит мало всего, то посылать в другую ETS-ку не так страшно, потому что, ну, все равно, когда происходит мало, поэтому даже контеншон, если будет, он будет не такой страшный. Вот. Здесь, насколько я понимаю, похожий подход использован. Но я цифр не видел вообще никаких. Я имею в виду утверждений каких-то, что вот мы работаем больше, чем на сотни тысяч. Ну, смотри, я еще раз говорю, я тоже не тестировал, несмотря на то, что в код никаких утверждений не вижу, но просто тот подход, который они описывают, он должен скейлиться лучше, чем то, что я видел в Jproc'е. Ну, Jproc я видел своими глазами много раз. Слушай, а вообще у меня вызывают сомнения, а точно тебе надо сотни тысяч процессов? Ну, вот у меня было предложение, где у тебя на каждой энтите чего-то составался процесс. И это довольно типичный релаксовый подход. И вот знаешь, 100 тысяч пользователей на машину или 100 тысяч финансовых инструментов на машину, это на самом деле не так много. Особенно если это не финансовые инструменты, а пользователи, то там 100 тысяч на машину, это на самом деле не много. Это, ну, сильнее, меньше, чем у тебя, может быть, пользователей всего онлайн одновременно. Мне ли тебе рассказывать, ты работал в одной интересной компании? Это все понятно. Я к тому, что получается, что у тебя один инструмент влияет на выбор архитектуры, а возможно, что должно быть наоборот, выбор архитектуры. Не понял, почему это? Ну, к тому, что вот я решил сделать так, теперь я Jproc использовать не могу. Ну, подожди, нет, как бы, ты решил сделать так, ты написал процесс режиссера, который решает его задачу. У нас было всегда так. Мы просто заканчивали тем, что мы писали кастомный процесс режиссер. А, ну, я понял. А здесь они как бы делают библиотеку, которая помогает. Да, да. Мне просто не нужно писать очередной кусок, который я писал в каждом проекте, мне не нужно писать. Ну, то есть, при том, Jproc позволял не писать в каждом проекте, потому что библиотека все-таки есть. Но каждый раз, когда ты его скейлишь, проект до какого-то размера, все, приходит как бы пушной зверек к Jproc и нужно, привет, в общем. При том, что процесс режиссер, у него есть еще особенности того, как его нужно писать иногда, потому что иногда нужны гарантии, типа, что процесс не должен быть виден до того, как он реально стартанул и инициализировался. И это дает еще больше интересных эффектов. Там нужно мощно писать еще некоторые вещи. Вот. Еще нам завезли синтекс-калоринг. Опять-таки, мелкие приятности. Каждый раз, когда какой-то талочный вывод пишешь, нужно было как-то там заморочиться, помнить эти коды, которые нужно вывести, чтобы был какой-то калоринг. Вот. Завезли, чтобы стандартному библиотеку немножко удобств в этом поводу. Продолжают улучшать тип календаря. Опять-таки, то, за что иерланг все пинают, там ужасная работа со временем. В Elixir все сильно лучше. Еще изначально сделали, то есть, больше не нужно, если что-то есть в дипендах, больше не нужно это дополнительно прописывать, как дипенд приложения, потому что там в иерланге приложений в одном ноде может быть много. Библиотека зачастую является еще и приложением, которое крутится внутри иерланговой ноды. И приложения между собой могут быть дипенды, это, собственно, какой-то библиотек. Зачастую они совершенно одинаковые. И часто приходится заниматься фигней из-за того, что мы добавили дипенды в себе, потом нам нужно эти дипенды прописать себе в зависимости от какого-то приложения в рантайме. Вот этой фигней в Elixir заниматься больше не нужно. Это мелочь, но это мелочь показывает, что это... Ну, как бы, ей неприятно заниматься. Да. Я продолжаю тему того, что в Elixir эргономику полномерно релиз за релизом делают лучше. А Sync Stream, расскажи. Да, вот, собственно, а это уже теперь как бы про другое. Это уже практически не имеет отношения к коду, который... Ну, то есть, это, в принципе, имеет, я такое видел в паре проектах, но то, что же реже приходится писать постоянно самому, это вещь, которая уже идет на немножко другой уровень. Это удобный примитив из-за того, что если у нас есть какая-то коллекция, которую мы хотим как-то прососать через себя, вот, в какой-нибудь акке у нас есть совершенно безумный акка-стрим, с которой там просто блять, ака на все случаи жизни. Насколько я знаю, в мире Elixir там тоже есть шевеление по этому поводу, там на конференциях они по этому поводу пару раз говорили, но пока они пошли скромнее, они добавили ровно пока две функции, три функции в стандартную библиотеку, которые позволяют коллекцию распространять на... обработку коллекции распространять на как это... с ограниченной конкуренцией, то есть не запускать там по процессу на каждый элемент коллекции, как это делается в простом случае, а им там какой-то bounded concurrency запустить, с каким-то хорошими, приятными обработчиками, которые вам нужны. И что в этом интересного, кроме всего прочего, оно... то есть в Elixir, в частности, среди таких маленьких эргономических улучшений, еще с первой версии, и даже до версии 1.0, уже были в стандартной библиотеке стримы, то бишь ленивые коллекции. Вот то, чего в Erlang'е каждый раз... еще одна вещь, которую я видел в поменьшем ряду местах, написанную с нуля. Здесь она в языке, и она в стандартной библиотеке, и вот эта абстракция, она строится поверх нее, то бишь у вас вот эта вот обработка асинхронная в куче воркеров и так далее, она наружу торчит просто как ленивая коллекция. И это просто с точки зрения эргономики просто бесподобно. Вот вы вставляете, вам нужно какую-то обработку сделать, сделать хорошо параллельный по числу ядер у вас в машине, и чтобы оно при этом имело... вместо того, чтобы писать какую-то сложную пойду, которую раньше вам пришлось писать самому, у вас теперь есть один простой вызов, который это сделает за вас, а наружу оно при этом будет продолжать торчать как коллекция, которую можно продолжать применять в операции коллекции. Я просто в восторге. То есть я не знаю, мне это, скорее всего, ближе к десяти проектах не пригодится. Но вот те пару раз, когда в жизни это было нужно, этого очень не хватало. Да вообще вот эти все, как это, пайпы и стримы с пайпами, и все это вместе настолько улучшает удобство написания, то есть вместо каких-то, я не знаю, больших лапшообразных кодов ты пишешь там три строчки и все отлично. А здесь еще интерфейсы. У этого есть и обратная сторона, потому что я вот, знаешь, я смотрю на свой же код эликсири, я понимаю, что человек, который пришел из Ирланда, ему уже и дематический эликсир, я уже просто на эликсире прописал какое-то время, я уже выучился, я уже пишу и дематический эликсир, этого не замечаю, но при этом я стараюсь на кого-нибудь писать, и такой вот эзотерикой стараюсь не заниматься, тем не менее. Человеку, который пришел со страны или пришедшему из Ирланды, когда он смотрит на код в эликсировске, ему многие вещи могут быть непонятны, то есть что вообще здесь происходит. И это немножко нехорошо. В другой момент люди, приходящие из других культур, поскольку в языке есть макросы, люди, приходящие из культур, где принято заниматься метапрограммированием, они могут, то есть я наблюдал и в библиотеках, которые на GitHub можно найти еще в нескольких местах, что люди, которые приходят из культур, где принято заниматься метапрограммированием, начинают заниматься метапрограммированием, даже если это не нужно совсем. Я ненавижу макросы. Я бы не сказал, что ненавижу, что я их ненавижу, потому что без макросов у нас бы не было такой замечательной вещи, как это, например. Но с другой стороны, вот в том же самом фениксе, я понимаю, зачем это сделано, но я не одобряю там прям в болванке приложение. Есть такие штуки, которые тебе делают стандартную вьюху, стандартный контроллер, стандартную модель, и это макросы, которые в ваш модуль насовывают всякого. И вот это уже такая вещь, на которую я уже поглядываю искренне. То есть понятно, что там очень маленький понятный макрос. Он не делает совсем уж какой-то непонятной магии. Он в принципе делает написание кода меньше. Но блин, это болванка приложения. Что в болванке приложения в принципе мешает? Не знаю, в общем. Наверное, конечно, он делает... новый контроллер позволяет создавать с меньшим количеством кода. Но в общем... Я парочку раз уже боролся с ними. Я имею в виду, когда оно делает немножко не то, что я хочу, и всик, что-то попадает. Ну да, потом начинается, что тебе на самом деле нужно контроллеры типа А, контроллеры типа Б, или там вьюхи типа А, типа Б, и тебе нужно либо этих макросов 10 написать, либо просто выкинуть эти макросы и все, что нужно тащить во вьюху, тащить во вьюху руками. В общем-то. Я уверен, они это исправят в 1.5. Это, нет, знаешь, вот этот подход с макросами, мне кажется, никто никогда не будет исправить, потому что направлено на то, чтобы стартовать проекты быстро. А масштабироваться потом ну нужно просто с умом. Масштабироваться тебе нужно с умом, этого никто не отменял. Давайте пройдемся по конференциям и постараемся на этом не акцентироваться, потому что слушатели много раз просили этого не делать. Так, и я расскажу, вот пройдет позитив хакдэйс, это будет не скоро, 23-24 мая, уже началась продажа билетов, до 13 февраля билет стоит 7400 рублей, потом будет сильно дороже, чуть ли там не в 2 раза.",
    "result": {
      "query": "Elixir concurrency scaling solutions"
    }
  }
]