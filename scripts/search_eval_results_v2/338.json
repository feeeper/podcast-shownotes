[
  {
    "segment_id": "e9a39307-2541-48a2-a63b-7dc4fcbc39ff",
    "episode_id": "2e9de864-85fb-4771-b448-5d5299a05e4b",
    "episode_number": 338,
    "segment_number": 3,
    "text": "По поводу того, какие, ну можем, в принципе, про микросервисы поговорить, либо можем поговорить больше про такие практические вещи, которые связаны с моделированием конкретным. Ну давай вначале про практику, потому что все-таки Ваня попросил, вернемся к этому, а то мы убежали. Я думаю, это нечестно, мой вопрос был раньше. А я для слушателей волнуюсь. По поводу критерийств, это просто, на самом деле, проще немножко, наверное, рассказать. Давайте, наверное, тогда с них начнем. В DDD само по себе не говорит о том, что нужно все держать в монолите и в одном месте. Разбиение на приложение, оно присутствует в DDD тоже. Оно выглядит как, ну вот в терме на DDD, это выглядит как, сама практика называется bounded-контекст, то есть ограниченные контексты по-русски. И эти ограниченные контексты включают в себя доменную логику, относящуюся к какому-то поддомену вашего приложения. То есть, если у вас, допустим, есть какая-то, ну опять же, если пример с CRM-кой приводить, то, допустим, вы можете разбить эту CRM-ку на поддомены, то есть подзадачи. Первое это, допустим, бухгалтерия, второе это учет пользователей, там, юзер-мейнджмент, допустим, и третье, там, четвертое и так далее. Вот, и для этих поддоменов, подзадач, выделяется отдельный bounded-контекст, то есть, отдельная область в вашем приложении, которая ограничена от остальных областей, которые занимается только этой одной подзадачей. И делается это, ну опять же, по той же причине, почему мы делаем микрофервис, для того, чтобы уменьшить сложность вашего приложения. Потому что, если вы будете все делать в одном… Что-то вроде вложенного DDD. Ну, можно сказать, да. Да, и тут возникает вопрос, как как раз эти ограниченные контексты взаимодействуют, ну, во-первых, между собой, а, вторых, с микросервисами. Между собой эти ограниченные контексты взаимодействуют так, что, ну, вот у вас есть, допустим, два контекста, допустим, sales-контекст и support-контекст. Sales-контекст у вас занимается продажей вашего софта пользователем, support-контекст занимается поддержкой ваших пользователей после того, как вы использовали этот софт. И может быть так, что у обоих этих bounded-контекстов есть одинаковая сущность, то есть, в том, что в этих… То есть, в таких bounded-контекстах могут быть пересечения, и это вполне нормально. Но то есть, тут разница в том, что эти контексты смотрят на этих … ну, допустим, в sales-контесте есть customer и в support-контесте есть customer. И это нормально потому, что эти bounded-контексты смотрят на этих кастомеров с разных точек зрения. То есть, sales-контекст смотрит на кастомеров с точки зрения того, как продать, как сделать продажу этому кастомеру, и он уже смотрит на этого кастомера с точки зрения того, как сделать жизнь этого кастомера лучше при использовании нашего софта. И, то есть, тут физически это может выглядеть так, что у вас это может находиться в одном монолите, то есть приложение может быть одно, просто у вас логическим образом разбита ваша логика на несколько bounded-контекстов, либо это может быть так, что вы разносите сами bounded-контексты на разные приложения. И вот тут как раз у нас получается микросервисная архитектура. И тут опять же возникает вопрос, насколько большими нужно делать эти микросервисы. Есть разные подходы к этому. Один подход – это можно сделать один микросервис на один bounded-контекст. Второй подход – это можно сделать разбиение более мелким. К примеру, в DDD есть такой паттерн, как агрегат. Можем о нем чуть попозже поговорить. Если вкратце, то это агрегация, то есть группа каких-то сущностей, которые между собой взаимосвязаны. И так как они между собой взаимосвязаны, проще становится работать с этой группой сущностей как с единым целым, то есть с агрегатом. Допустим, если у вас у кастомера есть какие-то адреса, что там еще может быть? Допустим, лог транзакции или еще что-то. Или там billing-адреса тоже. Вот эти все три сущности – customer, его адреса, его billing-адреса, то есть billing-info, кредитные карточки. Их проще всего держать как один агрегат в разных приложениях. Так что тут я просто привожу как пример. И в коде у вас будет такой логический boundary для этого агрегата. И некоторые еще говорят о том, что нужно не только делать в коде логический boundary для агрегатов, но и микросервису нужно строить так, чтобы каждый микросервис отвечал за один агрегат. Мое личное мнение, что такое слишком мелкое разделение – оно чревато. Слишком большим overhead при поддержке микросервисов. И лучше делать, по умолчанию, по крайней мере, лучше делать микросервисы больше. То есть такой хороший raw thumb – это один bounded context на один микросервис. Если уже потом этот микросервис или bounded context разрастается слишком большим, то там уже можно вынести из этого микросервиса другие микросервисы. Разделять микросервисы, как правило, всегда проще, чем объединять микросервисы либо менять границы между имеющимися микросервисами. Потому что, на мой взгляд, две таких самых больших ошибки при проективной микросервисов – это слишком раннее введение микросервисов, когда вы еще не знаете, какие точные boundary у вас будут в вашем приложении. А, вторых, делать их слишком мелкими. Это приводит к тому, что потом у вас возникает слишком большой overhead, и с микросервисом становится очень сложно работать. А ты упомянул, что очень сложно потом менять границы микросервисов. А можно ли поподробнее об этом поговорить? Потому что, мне кажется, у очень многих приложений сейчас такая ситуация. То есть, кто-то спроектировал, потом прошло время, все поменялось, и мы хотим поменять эти границы. Как к такой проблеме подходить, и как это лучше решать? Да, ну, пример такой проблемы, допустим, если вы смоделировали два микросервиса, и, допустим, тот же самый Sales и Support, и поместили, допустим, тикет, допустим, открытый ИШЮ для кастомера в Sales контекст, а не в Support контекст. Вот здесь возникает проблема в том, что тикет, по смыслу, должен принадлежать Support контексту, а не Sales контексту, и нужно как-то работать в Support контексте с этими тикетами. То есть, Support контекст, получается, Support микросервис должен делать каждый раз, запрашивать информацию об этом тикете в Sales контекст, и дальше уже работать с этой информацией. Как именно, во-первых, проще всего таких случаев избегать путем того, что не нужно сразу делать микросервисы прямо в первую версию вашего приложения. Сейчас я вспомню автора. Не помню имя автора, но вот он писал в блоге у Мартина Фаулера про микросервисы, и он как раз там тоже писал про то, что лучше всего делать микросервисы во второй версии вашего приложения, потому что вы уже будете знать точно, какие баундрес у вас должны быть в приложении, и вам будет намного проще делать разбиение, чем когда вы делаете это с нуля. Вот когда вы пишете это с нуля... Хороший совет только, никогда не наступай. Эх, в практике это редко. Потому что всегда нужно фичекатить новые вещи и рефакторить, переписывать на вторую версию, никто никогда не дает времени. Ну, тут не обязательно это прям как четкая вторая версия. Тут можете просто начать с того, что у вас все находится в аналите, допустим, пока еще логика не очень большая, и по мере того, как эта логика разрастается, вы можете уже выделять эти разные части этого микросервиса в свои микросервисы. Потому что там уже восстановится понятно, как именно связаны между собой сущности внутри этого микросервиса. Т.е. тут такой принцип должен быть, loose coupling между микросервисами и tight caucasian внутри микросервисов. И вот это говорит о том, что сущности внутри микросервиса должны тесно коммуницировать сущности, будут между собой коммуницировать тесно, какие будут слабо зависимы друг на друге. И у вас это понимание возникает по мере того, как вы начинаете разрабатывать эти микросервисы. И там уже, как я говорю, там уже будет более понятно, какие границы нужно выделить, делать для ваших микросервисов. Так, а как мы решим такую проблему? Точно вот у нас есть какие-то сервисы, может не микросервисы, просто два сервиса, и мы хотим поменять границу между ними. Как нам подойти к такой проблеме? Да, это хороший вопрос. Тут нужно делать миграцию. Миграция будет, как правило, стоять из нескольких шагов. Т.е. у вас, допустим, если вы хотите вынести тот же самый тикет, допустим, из sales микросервиса контекста в support контекст. В первой версии, в текущей ситуации у вас этот тикет будет находиться в sales микросервисе. Т.е. у него будет своя база данных, эти тикеты будут находиться в базе данных этого микросервиса, и к ним можно будет обращаться, у него будет какой-то API у того микросервиса, который будет позволять выбирать данные по этим тикетам другим микросервисам. Первый шаг здесь будет такой, что, во-первых, вам нужно сделать... Миграция может стоять из нескольких шагов. Вам нужно, во-первых, убедиться, что обратная совместимость у вас работает. Т.е. скорее всего, это будет выглядеть так, что вы, допустим, новые тикеты начнете заводить в новом микросервисе с дублированием в старом микросервисе. Т.е. они у вас будут заводиться и там, и там, но при этом в старом микросервисе эти тикеты будут доступны только для чтения, а в новом микросервисе они уже будут доступны и для чтения, и для редактирования. И по мере того, как у вас клиенты этого микросервиса переходят на другой микросервис, т.е. они уже начинают обращаться за этими тикетами в Salesforce, в Support Microservice, там уже по мере этого уже можно будет отключать все больше и больше функциональностей по отношению к тикетам в Salesforce Microservice. И в итоге, когда уже все клиенты перешли на Support Microservice, там уже можно будет удалить эти данные из Salesforce Microservice и работать только в Support Microservice. Такой сложный процесс здесь. Главное это поддерживать обратную совместимость. А у тебя были такие ситуации с практикой?",
    "result": {
      "query": "изменение границ микросервисов"
    }
  }
]