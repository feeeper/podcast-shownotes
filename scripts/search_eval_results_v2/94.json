[
  {
    "segment_id": "62affabe-0aa4-480d-9d17-8936ca9c4429",
    "episode_id": "53fc2050-51d4-4466-b8be-5e6c031265aa",
    "episode_number": 94,
    "segment_number": 4,
    "text": "Он говорит, что это все далеко не так, что компилятор – это ваш лучший помощник и друг, он вам вообще в любой ситуации поможет, и все вот эту сложную логику, которую он сперва написал наивно, он потом показывал, что переписывать на зависимых типах становится очень просто, то есть ты в любой точке можешь посмотреть в репле, что к чему, какие типы здесь будут, как это правильно нужно написать, и если что, компилятор тебе подскажет, что скорее всего ты имел в виду другое, потому что здесь размерности не совпадают, а там совпадают, и все такое. Короче, вообще здорово, огонь. У меня вопрос возник, ты приводил в пример ситуацию с умножением двух матриц, правильно? Да. И о том, что зависимые типы могут здесь помочь. Да. И в противном случае, если матрицы умножатся, будет неправильный результат. Они не умножатся. Ну вот именно, то есть они же не умножатся, матрицы должны быть согласованными, чтобы они могли быть умноженными. Да, в compile-тайме или в run-тайме, это ошибка будет найдена, но вот в чем разница. Я, например, очень поддерживаю автора, по-моему, он выбрал очень хороший пример, я действительно видел эти проблемы конкретно на многослойных нейронных сетях, когда уже можно запутаться в том, из чего состоят слои, какие они имеют размеры, и когда мы пытаемся собрать и заставить все это работать, многие ошибки действительно могутся на run-тайме, причем что самое больное, они могут сыпаться на низком уровне, и откуда развернуть их и понять, какую конкретно строчку нужно исправить, это процесс, который еще требует умственного напряжения, достаточно значительного. А по поводу умножения матриц, у меня есть шикарнейшая моя давняя история, что я в свое время, по-моему, несколько десятков часов провел в поисках баги, которое заключалось в том, что я неправильно перемножил матрицы в одном месте, поставил их в неправильном порядке. Вот-вот, и он как раз и говорит, что компилятор должен защищать от того, что ты поменял местами два аргумента, и ты не должен об этом совершенно думать, то есть ты должен знать, что я умножаю здесь две матрицы, а компилятор должен подсказать, какие, и как ты их должен поставить, в каком порядке. А не увеличивает ли это время компиляции настолько, что это становится неэффективно? Я думаю, что оно увеличивает время компиляции, но у тебя спор, она инкрементальная, не забывай. Ну и там на пакетике можно нарезать, ну ты же на скале пишешь. Ещё очень чёткий домен у автора, jle.aim. Валера, почему ты молча осуждаешь эту тему? Я не осуждаю, я просто не считаю себя достаточно следующим. Да, но ты мог похвалить Хаскель, то, что он запрещает плохие практики, и они должны быть сложны. Ну тут спорно, понимаешь, с одной стороны язык и так такой, что отпугивает новичков, а тут у него ещё втащили того, чтобы ещё больше их отпугивать. Вот, кстати, автор про это говорит в самом начале, если честно, я здесь с ним не согласен. Для новичков есть питом, в чём проблема? Вот он как раз говорит, что зависимые типы считаются такой большой сложностью, что как бы никому они не нужны и так далее. Я хочу здесь показать, что они очень-очень сильно помогают разработчику, и я хочу видеть, что в дальнейшем зависимые типы будут проходиться на начальном, на бегиннер уровне для всех хаскелистов. И я понимаю, что если вот такое надо будет объяснять для бегиннер уровня хаскелистов, вообще ноль человек будет в сообществе Хас. Ну вот как-то да, и мне всегда казалось, что вот есть Идрис, вот там пусть будут здоровские зависимые типы, я буду на него поглядывать и дальше идти работать на рубе, Ирлангом. Да, но в Идрисе нет потока. Ну как бы вот как раз, чтобы он там развивался, чтобы втащили потоки, вот это всё. Я скорее... Ну вот его развили, получился хаскель. Ну нет, ну то есть... Смотри, он строгий, с зависимыми типами, что тебе не нравится? Только мне не нравится, что... Идрис как Идрис. В общем, ну то есть, не знаю, то есть с моей точки зрения всё сильно зависит от того, насколько это станет мейнстримом, и насколько это избавит Хаскеля от судьбы мейнстримом. Никогда не станет, мы же себя понимаем. Нет, ну то есть в смысле мейнстримом внутри Хаскеля. То есть если это встанет мейнстримом внутри Хаскеля, Хаскель вообще, ну как вот уже вышевозвучно, потеряет любую, какой-либо трекшн среди новичков. Ну реально, вот я начинаю понимать, я начинаю читать вот эту статью, в которой он делает арифметику над кайндами, то есть это не то, как ты считаешь твою программу и как идёт в выполнение, да, а то, как ты типы твоих аргументов, арифметика над типами твоих аргументов. То есть это, ну это вот, то есть как бы вот если для кого-то сложны указатели, то это указатели над указателями, то есть концепции над концепцией. Я считаю, что это очень сильно усложняет вход вообще в эту область. Я думаю, это не сложнее, чем макросовлистка, ну как бы код над кодом. Арифметика на типах, в чём проблема? Я, например, здесь, глядя на это, воспринимаю, может быть, Haskell как такого передовика, который выбивается вперёд, показывая остальным, как можно делать. Станет это модным или не очень, это непонятно, но вот если откатиться назад о тех вещах, которые есть в Haskell, или, допустим, поговорить о Type классах, когда я знакомился с, вот обычно о своей теме, с новой фичей, предложенной в C++, концепты, ну она была предложена давно, но попытка её ввести в стандарт была недавно. Когда я читал, что такое концепты C++, вот у меня прям такая мощная аналогия проводилась с Type классами в Haskell. Они и в каком-то мере призваны одну и ту же проблему решить, и в чём-то подходы у них, казалось бы, общие. Может быть, Haskell и на примере зависимых типов покажет, как надо, и за ним просто потом, через 10-20 лет, подтянутся другие языки. А мой плавный переход никто не понял, да, про плохие практики? Ну так, Саша, про плохие практики расскажешь нам, или кто-то ещё прочитал всё-таки этот комментарий? Я комментарий читал, но я так... Ты знаешь, я заметил, что это вообще добавили такие в темы слушателей к правильному номеру выпуска, поэтому давайте потом. Не, ну давайте, раз мы начали, давайте сейчас обсудим, почему бы и нет. Анатолий Прилудский добавляет нам ссылку на статью Worst Practices Should Be Hard. Кабреля Гонзалеса, которую мы уже не раз обсуждали. Да, широчайшее известно в очень узких кругах. Ну, TLDR такое, что есть, ну, как бы издалека начиная, там, язык X, язык Y, да, и так далее, но концовка такая, что вот вы на питоне можете быстро наговнякать, но вы потом утомитесь это поддерживать, там, в течение 20 лет, например. Вот на Haskell вам будет тяжело стартануть проект, но зато потом 20 лет вы будете его без проблем поддерживать. Всё почему? Потому что на питоне ты можешь делать плохие практики, передавать аргументы разных типов, можешь, там, Валер, как там это называется, ну вот то, что ты не любишь врубя. Monkey-patching? Да, точно, вот это вот, ну, плохое практику. Ну и всякие другие. А, ну, изменяемые состояния, ну и всё как обычно. А в Haskell нельзя, такие дела. Ну, то есть я по большому счёту согласен с этой статьёй, с чем я не согласен, что иногда вот нужно, ну вот как наш гость делает, ресёрч, да, например, там, ну ты код написал, его сравнительно немного, его нужно писать быстро и быстро увидеть результат. Вот, мне кажется, на Haskell вот делать то, чем гость занимается, не получится. Гость, ты согласен или нет? Не получится, почему? Подожди, продолжим. Дело привычия. Я думаю, что, ну, сколько бы сложная технология ни была, ввязав соответствующую границу сложности, можно на ней работать с такой же скоростью, как на более простых. Если есть все инструменты необходимые, ты знаешь их опции, знаешь их команды, то есть ты с этим работаешь долго. Если тебе нужно начать с нуля, ты не знаешь этой технологии, ну, конечно, и тебе нужен быстрый результат. Ну, конечно, технологии типа Haskell'а надо сначала потратить время на изучение, потом только получить результат. Ну, вот у меня скорость разработки на Haskell'е никогда не была, там, скажем, хотя бы в два раза медленнее, чем на Python'е. То есть она всегда существенно меньше. Потому что на Python'е, ну, как-то просто, ты, не знаю, половину решения нашел на Stack Overflow, потом там написал код, там ввел пару глобальных перемен, все здорово, все замечательно. Ну, понятно, что скрипт там небольшой типа, строк на 100, на 200, а на Haskell'е так сложно сделать. Да потому что мы пишем редко на Haskell'е. Писали бы часто, каждый день понемножечку, и я думаю, все подобные скрипты писались бы с такой же скоростью. Я вот брошусь с другой стороны, я вот очень много пишу на Erlang'е, но, собственно, я тут не один много пишу, или пока не писал на Erlang'е, или к Siri, и у меня такая вот гипотеза, что, на самом деле, все дело даже не в систематипах, а в конкретной особенности систематипов, а именно саптайпинга. То есть как только есть саптайпинг, сразу писать и поддерживать становится резко сложнее. Я тебя расстрою в Haskell'е саптайпингом. Где там саптайпинг? В исключениях. Ну, это не считается. С чего бы? С того, что ты исключение... я в своем коде исключения писал примерно не разу. Они могут вылетать, но ты их не пишешь. И тебе не приходится... то есть у тебя нет такого, что у тебя, короче, есть какой-то объект, ну то есть какая-то хрень, ты через нее, через точку вызываешь какую-то хрень, окей, ты даже нашел тип этого объекта, пошел в него, а там эта хрень не объявлена. Ты такой, а где же она? И потом увидишь, что там на самом деле он наследует кого-то, а он его потом еще откуда-то наследует, и вот это все, и вот это раскручиваешь, раскручиваешь, раскручиваешь, и на самом деле все дело в себе, да, в саптайпинге, мне кажется. Особенно большая проблема это саптайпинг плюс полиморфизм параметрический, и вот тут уже начинается полная ваканалия и прочая скала. Так вот, у тебя, ну даже не привязанно к исключениям, есть экзистенциальные типы, в сущности саптайпинг. Вот с этим я согласен, да. Ну вот, они есть. Ну ты знаешь, что такое саптайпинг с ограниченным уроном, или ты не согласишься с этим? Я соглашусь с тем, что нормальных интерфейсов из коробки нет, мне рассказывали, как их сделать, но я уже забыл, то есть ты не можешь вот этот саптайп как бы привести к интерфейсу, а потом гонять по коду вот чистый интерфейс без типа, ну, по крайней мере, сделать это просто. Нет, подожди, интерфейс это не самое страшное, собственно интерфейс, typeclass это не самое страшное, что может случиться. Проблема, когда у тебя есть ровно один уровень, это не страшно, то есть случиться с интерфейсом, у тебя всегда ровно один уровень. Ну ладно, хотя вру. Ну, короче так, у тебя реализация всегда ровно в одном месте, так ведь? Допустим, примем за рабочую теорию. А ты говоришь про то, когда ты переопределяешь метод, да? Да-да-да, вот про всякую такую петрушку, когда непонятно откуда это дерьмо приехало и почему оно тут. А хуже всего, когда у тебя, знаешь, есть одновременный миксин и саптайпинг, то есть, не знаю, типичный рубик класс, он там от кого-нибудь наследует, а еще включает в себя пару модулей, и пытаться понять откуда оно приехало очень тяжело. Особенно, то есть, ну, в Scala это решает тем, что там есть система типов, ты в идее нажимаешь command и на имя метода, и он тебе покажет откуда он мог приехать. В случае, там, не знаю, с Ruby, я не знаю, может RubyMine это умеет делать, интеллижерский, но в целом там проблема в том, что язык динамический, и понять откуда оно в динамике приехало, даже если нет подкипачинга, тяжело. Вот поэтому, да, повторюсь, в себе децаптапинг. А у меня вот есть вопрос к общему. Может быть я давно не спарил на хаскере, но правда ли для того, чтобы написать скрипт в 100 строчек, нужно использовать вот всю мощь? Допустим, зависимых типов и всю мощь, которую с тобой приносит хаскер, нельзя обойтись его меньшим подмножеством? Тебе не нужно использовать всю мощь, чтобы писать 100 строк на хаскере. Ну, то есть, никто тебя не заставляет весть тюма. Ну и скрипты на хаскере писать, это сомнительная идея. Почему? Почему? Ну, мне кажется, есть более подходящие языки для именно скриптов. Почему? Типа того же питона. Интерпретируемые, не компилируемые. Так ведь хаскер — это же правильный питон. Слишком правильный для скриптов. Не, ну ты хаскер тоже можешь на лету, в смысле, ранг хаскер какой-нибудь использовать. Ну, так, знаешь, это сложно. Почему? Ну, тебе нужно устанавливать тот же хаскер на машины. Как раз наоборот. Тебе нужно устанавливать питон, а на хаскере скомпилировать бинарно чексоверить. Шах и мат, питонисты. И потом перекомпилировать каждый раз, когда тебе нужно что-то поменять маленькое. А ты прям постоянно скрипты меняешь? Ну, довольно часто. Так вот, в чём твоя ошибка? Надо выкидывать и писать заново? Отличная идея. Ну там всего остался строк. Даша, а ты с лучшим не путаешь с первым? Нет, нет, я так не думаю. В общем, на хаскере можно писать скрипты, и некоторые так и делают, и ты в скриптах можешь какие-то хитрые штуки делать. Если надо. Если не надо, будешь пользоваться базовым. Basic Haskell. Ну, для меня это очень сомнительное удовольствие. Скрипты писать на хаскере я, честно говоря, не вижу в этом какого-то смысла. Не знаю, на том же Go можно писать скрипт, если вы хотите именно бинарный чек. Ладно, а что ещё? Сомнительное удовольствие или несомнительное? Так это Conan. Правда, Павел? Здесь я могу сказать несколько слов. Можно сказать, прорекламировать или поделиться опытом использования системы dependency-менеджера для C++, которая называется Conan.io. Вот я часто видел такую большую проблему в мире C++. Проблема работы с зависимостями. В отличие от, допустим, того же RastasCargo или Node.js NPM, C++ как-то исторически не сложилось единого стандартизованного способа решать эту большую проблему. Поэтому всё это привело к созданию фактически всегда отсутствующих велосипедов. Я таких скриптов на Python, на Perl, на других языках видел очень много, которые читают какие-то файлики, где описаны зависимости, идут куда-то на сервер, выкачивают эти зависимости, как-то их распаковывают, подключают, собирают. В общем, решают достаточно сложную проблему, которая, на мой взгляд, почти всегда является одним из главных стопоров в быстрой разработке на языках типа C++. Потому что когда вам нужно быстренько написать скрипт, который лезет куда-то по сети, качает картинку и вам её реализирует, если у вас в стандартной библиотеке нет функции для того, чтобы слазить по сети, нет в стандартной библиотеке функции отрисовать картинку, всегда приходится какие-то зависимости подключать. В мире C++ это традиционно делалось достаточно сложно. Были способы, но они почти никогда не были переносимы между разными платформами. И вот Conan предложил один из таких способов. Это, кстати, уже второй запуск. Первый назывался bCode. Эд одного и того же автора. Проект, который bCode, он не удался. А, я помню, что мы его упоминали, я ещё как-то троллился, типа давайте посмотрим, как он поживёт. Ага, загнулся. Теперь, Валер, ты можешь делать ставки на второй проект, работать над ошибками. Насколько долго существует этот? Постойте, мы все знаем, чтобы проект удался, надо сделать его хотя бы три раза. Тогда можно будет посмотреть, может быть, на третью версию, но пока кажется, что работа над ошибками проведена правильно. В частности, первая была главная решена проблема, любой желающий может поставить к себе сервер. И у себя абсолютно локально поднимать свои пакеты, управлять, не обязательно используя какое-то большое централизованное хранилище. Всё это доступно. То и другое, кстати, что забавно написано. Так, Гойз, ты пропадаешь снова так часто, что тебя невозможно понять. Вынужден отобрать у себя слово и передать его свету. А у нас осталась тема, я обещала в прошлом выпуске посмотреть и дочитать рассказ инженеров Линкедына про их объектное хранилище, которое называется Амбри. Так вот, я таки дочитала эту статью, и моё заключение, что это очень тяжело написанная статья, ну, сложным языком, она тяжело зашла. Из интересного, что можно сказать, они делали занятную штуку с cross-data-центром, как это на русском сказать, с репликацией между центровой, и при этом они никак не объясняют, как это сделано. Они сказали, что мы используем алгоритмы, мы используем некоторые оптимизации, но никакой конкретики. Вопрос. Вот я свету не слышу. Что-то начинает... Свет, мы тебя вообще не слышали. Ещё раз, а сейчас меня слышите? Сейчас слышим, но ты тоже как-то прегреваешься. Интересно. Тебя Паша загрязил. У меня все, кроме Вани, пропадают. Включай, Саш, ну да. Ну, сейчас слышно. Вот это тоже пропадало. Ну, сейчас все нормально. Я думаю, с сервером что-то. Продолжай, пожалуйста. Хорошо. На чём я остановилась? Напомните мне, пожалуйста. Я могу сначала? Тяжело написанная. А, хорошо. Да, статья написана очень тяжелым языком, и очень сложно воспринимать её. Вот. Собственно, интересно из этой статьи. Их хранилище, оно умеет делать репликацию междуцентровую. При этом они не говорят совершенно, как это делают. Они сказали, что мы используем некоторые алгоритмы и некоторые оптимизации. Ну, круто, а что конкретно, ничего не сказано. Дальше. У них была проблема с предыдущей системой. С самого начала у меня был некоторый алгоритм, и я его придерживался. Плюс один. Почему вообще они пришли к новой системе, написали Umbri? У них предыдущая система базировалась на реалиционной базе данных Oracle, и были сложности с хранением картинок, ну, медиафайлов. У них были очень большие медиафайлы и очень много маленьких медиафайлов. И при этом каждому медиафайлу они хранили какую-то метаинформацию. И весь этот overhead, который был для маленьких картинок, это было большой проблемой для них, и они решили, давайте от этого избавимся. И они от этого избавились, но снова не написали, как они это в итоге сделали. То есть какие архитектурные решения они приняли. Они сказали, у нас есть датаноды, которые хранят данные. А как конкретно эту проблему решили, ничего не сказано. Из интересного в этой статье я увидела, что у LinkedIn, оказывается, есть свой аналог Джепсона. Внезапно. И они этот аналог Джепсона используют для тестирования вот этой вот Umbri и для Kafka в том числе. А tool этот называется CMURK. Он тоже open-source. И по сути это такая имплементация HealthMonkey. То есть она в принципе может быть использована для чего-то другого. И я на неё сейчас внимательно смотрю, просто интересно сравнить её с Джепсоном. Выглядит довольно интересно. В целом, если хотите подробнее ознакомиться, можете почитать статью, но она очень странно написана. Вопросы, возражения, пожелания? Чтобы инженеры не писали таких неполных статей. Давайте, да, пожелания LinkedIn, пишите лучше статьи. Дальше снова моя тема. Ей! Ладно. Печальная карьера. Печальная карьера. Я думаю, наши слушатели меня забросают за такую тему. Они просили нас не говорить про стартапы и про всё связанное с этим направлением. Ну простите. Разве что, серьезно? Ну по крайней мере пару раз я такие комментарии видела. Не видел. Ну ладно, продолжай. Мне кажется стартапы это всегда бесконечно интересно. Это даже еще интереснее, чем игра. Чем фрейдблей. Да-да-да. Суждение конференции. И постгресс, Саша. Докер-докер. Недавно увидела статью про печальную карьеру. В статье навеяна недавней Олимпиадой по программированию, на которой Россия выступила просто шикарно. Первые пять мест России. И это великолепный результат. И немножко было рассказано про то, куда идут ребята, не работавшие, а ребята, которые участвовали в таких Олимпиадах, и куда они идут работать. И главная идея этой статьи, что печальная карьера, это когда эти олимпиадники идут работать в большую корпорацию типа Яндекса, Гугла, Фейсбука. Они просто там растворяются, вот это очень хорошее слово, именно растворяются, и перестают, не знаю, заниматься тем, что их, скажем, заряжает и дает энергию куда-то двигаться и что-то делать. Просто если сравнить олимпиадное программирование и работу в большой компании, где вы просто там маленький-маленький винтик, и вас могут в принципе легко заменить каким-то другим маленьким винтиком, то это не самое интересное развитие карьеры. И автор статьи здесь говорит, что давайте-ка, ну, его бизнес такой, что он придумывает по факту какую-то идею, либо просто идею, какую-то проблему, и говорит олимпиадникам, вот давайте-ка вы решите эту проблему. Олимпиадники научены опытом решать какие-то сложные задачи, им это интересно, и они начинают эту задачу решать. И в принципе они задачу эту решают. И в итоге формируется компания. И компания, которая занимается решением крутой проблемы, и в итоге эту компанию либо покупает другая большая компания, либо они дальше развиваются как индивидуальный стартап. И идея такая, что давайте-ка вы, олимпиадники, будете создавать свои компании вместо работы на большие корпорации. Мне просто интересно послушать ваше мнение по этому поводу, и что вы скажете. Жить на что? Вот такой из института крутой олимпиадник сделал компанию. Смотри, обычно, если мы говорим про стартапы, стартапы, чтобы им жить, особенно первое время, они поднимают какие-то инвестиции. И если проблема действительно сложная, и они показывают, что проблема нуждается в решении, то, как правило, инвесторы могут, ну, если ты покажешь правильный бизнес-план, а с ними как раз-таки работает бизнес-человек, он может делать правильные бумаги, и сказать под правильным углом это инвестору. И, как правило, инвесторы готовы в это вкладывать деньги, и на это ты будешь жить, на это ты можешь очень даже хорошо жить. Да, но вот ты как инвестор дашь вот этому прыщавому 20-летнему парню или девушке? Ты не даешь ему. Вот этот вот человек, автор статьи, это его бизнес, вообще в принципе его бизнес, он создает вот такие компании, он знает, он занимается бизнесом, а эти ребята решают проблемы, они не говорят с инвесторами, они не общаются, не пичат, он это все делает. И поэтому эта идея работает. Подожди, ты только что сказала, что олимпиадники должны создавать свои компании. Да, это их компании, но он, по сути, их представляет. А чем это отличается от пойти работать в Яндекс. Надежда и создавать Яндекс? Ну, тем, что в итоге ты оказываешься сетевого, то есть тебе помогают все это дело забутстрапить. Того человека, который тебе помогает все это забутстрапить, у него есть уже достаточно хорошая сеть контактов, по которым он может найти людей, которым это интересно, он же тебе научит как-то презентовать. В принципе, это довольно здорово. Я, правда, считаю, что все равно некоторый опыт работы в крупном бизнесе, особенно как раз типа Яндекса, хороший тем, что, во-первых, хотя конкретно Яндекс, может быть, не лучший пример, потому что там инженеру бизнес-процессы, скорее всего, не видны вообще, пока есть из тех людей, которых я знаю. Но как минимум можно научиться... Ну, кстати, да, конкретно Яндекс, наверное, совсем плохая компания, потому что если ты ведешь работу с инженером, ты не прям сурового продакшена особо не видишь, ты только код пишешь. А, продакшен, все продакшен-блоги собирают потом опсы и тебя бьют потом за это. В общем, я считаю, что после универа хорошо поработать где-то, где можно собрать шишек работой с большим продакшеном, и вот после этого идти делать свою компанию. Мне кажется, это так. Вот тоже я очень присуе, это очень хороший аргумент. В большой компании имеет смысл работать так же, потому что ты видишь процессы, ты смотришь, как они устроены внутри, и ты можешь видеть какие-то недочеты, и ты в этом всем участвуешь. Но мой аргумент как раз в том, что это как раз нужно не в большую компанию, а в среднюю, потому что в большой компании процессы уже не видны. Я имею в виду процессы, ты даже в большой компании, где-то там маленький винтик, ты видишь эти бизнес-процессы, ты проходишь через... Да вот нет! Нет, ты проходишь через эти бизнес-процессы, я имею в виду не то, как зарабатывают в компании деньги, как это внутри устроено, там ты пришел в HR-отдел, потом тебя передали в другую HR, которая занимается чем-то еще. Это тоже бизнес-процессы внутри компании. Вот, про что я говорю, эти моменты, то есть как с тобой там разговаривают, делать тебе какой-то перформанс, ревью, как с тобой, как ты общаешься с тестировщиками, как ты общаешься там с опсами, это тоже все бизнес-процессы внутри компании. Это тоже очень полезно посмотреть, и особенно если вы собираетесь создавать свою компанию, это очень хорошо иметь опыт именно работы в большой, и желательно очень большой корпорации, чтобы дальше понимать, куда вы хотите двигаться, куда вы можете прийти, куда вы не хотите приходить. Но в целом мне посыл статьи очень понравился, особенно сейчас, в моем текущем состоянии. Я хочу поддержать Свету и Валеру и добавить еще вот какой момент. Если мы говорим про опыт рядного программирования, там обычно есть очень четко и точно поставленная задача, которой в реальных проблемах ее нужно сначала еще дойти до этого. Вряд ли у людей, которые только имеют опыт работы с Олимпиадами, у них куда-то умение превратить какую-то проблему реальных людей в конкретную алгоритмическую задачу. Так вот Света же с этого начала, там есть некоторые человеча, которые, во-первых, отвечают за бустераппинг бизнеса, а во-вторых, он приносит им идею. То есть такой очень удобный дядя на самом деле. Ну обычно как раз таки есть проблема всех технических людей. Мы научены решать проблемы, возможно не самым эффективным образом, но в принципе мы можем решать проблемы, но мы не знаем, какую проблему решить, как вообще эту проблему технологическую применить для людей, для того, чтобы люди могли этим пользоваться и дальше на этом построить какой-то свой бизнес, например. Нас этому даже нигде не учат, а более того, это наша особенность. Я вот заметила, сравнивая с ребятами из европейских университетов, у них есть какие-то курсы, где они пытаются как-то креативно представлять результаты своей работы и как-то вот к этому подталкивают. У нас же система такая, что вот ты инженер, и вот у вас есть госты, и будь добр по этим гостам сделай чертежи, подготовь конструкторскую документацию, и это вот твои результаты работы. Тебе не нужно думать над тем, как это представить красиво, интересно, чтобы это было занятно. И вот у нас, да, хорошая база техническая, да, хорошая математическая база, но мы не умеем делать там хорошие презентации, мы не умеем, мы не можем... Вот у нас инженеры, они решают именно технические проблемы, а не проблемы людей. Вот в этом я вижу особенности. Мы получаемся хорошими исполнителями, но не хорошими... Но не теми, кто придумывает задачи и их решает. Мы не те, кто ставим задачи. Эта разница чувствуется, кстати. Вот. Я на этом закончила. Если у кого-то есть по этой теме что-то добавить, то пожалуйста. А мы переходим тогда к вакансиям. У нас вакансия бэкэнд-разработчика, и, наверное, это Валера принес, либо... Да, это я принес. В общем, тут у нас есть вакансия, то есть если вы хотите подписать на Эликсири, то представляете, Эликсири, это даже не только Эрланг, это прям вот новейший, моднейший Эликсир. Также вы не боитесь, ну, или вас еще не тошнит этот рельс, ну и в принципе, перспективы вас прелишает Эрланг. Вас ждут в компании Quattro Pro. И... да, стратеги технологии, собственно, Эликсир, Эрланг, желательно Феникс. Ну, или как бы если вы знаете Руби, то... Если вы знаете рельсы, то Феникс для вас не будет чем-то новым, это будут такие более правильные рельсы. Ну, дальше все-таки у них Postgres, Kafka, Redis, Docker, то-то-все. В общем-то, типичное дальше описание профессии современного бэкэнд-разработчика. А в PC лежит программирование на Элисире, нет? Нет, нет, нет, там требуемый опыт вполне себе знаешь, мне кажется тут... Да это не типично, это довольно грамотная вакансия. Окей, ну да, в общем-то тут вплоть до одного года опыта вообще работы с чем-либо-то ни было, и бесконечно огромная зарплата на вилку, и подозреваемая вакансия такая, что тут этой вакансией пытаются покрыть и юниор, и сеньоров, судя по зарплате на вилке. Ну да, зарплата от ничего, да очень много. Да, поэтому вы туда, если вдруг вас интересует список перечисленных слов, стукайтесь, вот, и на этом... А что за компания такая, чем она вообще занимается? Я честно говоря не знаю, меня в Рлангочатике русском попросили попиарить, у меня есть подозрение, что кто эти ребята, но я не буду его озвучивать. Мне кажется, они не найдут человека с сознанием Элисира, ну в смысле, это не так работает, ты сначала находишь работу, а потом там на мессе учишь Элисир.",
    "result": {
      "query": "Haskell dependent types discussion"
    }
  }
]