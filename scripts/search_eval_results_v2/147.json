[
  {
    "segment_id": "d6689b47-f33a-4484-8b24-67abc2865a5c",
    "episode_id": "4ee71028-bb7a-47fa-9822-1563cb0207ed",
    "episode_number": 147,
    "segment_number": 9,
    "text": "И они показывают дальше, что есть ещё три области, в которых RAST очень может сильно помочь. Это, во-первых, изоляция, анализы, то есть изоляция с точки зрения проблем в модулях, то есть вы можете разделить вашу программу на модули и изолировать проблемы в разных модулях, изолировать использование данных в разных модулях, то есть как процессы в Unix-системах, они практически независимы друг между другом, и вы специально говорите, когда им надо обменяться данными или взаимодействием каким-то, а во всех остальных случаях вы не можете ни залезть, ни проконтролировать, ничего сделать не можете. Во-вторых, это анализы, которые с помощью вот этих вот линейных типов очень сильно упрощены по сравнению с остальными системами. И в-третьих, автоматизация. И дальше они, значит, пошли по каждому из трёх пунктов отдельно рассказывать. Во-первых, изоляция. Они говорят, что большинство современных изоляций, которые присутствуют на рынке, которые позволяют изолировать программы, изолировать данные, они либо на уровне железа, что сложно, либо на уровне программы, тогда они сильно замедляют программу, потому что надо в рантайме делать какие-то сложные вычисления. Поэтому требования производительности. Чаще всего у вас есть ещё, если вы, скажем, делаете изолированные два между собой модулей, вы не можете пересылать сами данные или ссылки на данные между модулями, потому что в этом случае у вас модули одновременно имеют доступ к записи в одну и ту же памяти. Поэтому чаще всего эти системы реализуются через копирование, то есть вы обязаны копировать память между... Когда посылаете данные в другой модуль, вы должны копировать, для того чтобы они не могли одновременно писать. А RAST со своими системами типов и владения позволяют делать zero copy изоляцию, и это гарантирует компилятор на уровне компиляции, а не в рантайме. Они показали, как можно строить подобную библиотеку на RAST с помощью Software Fault Isolation библиотеки, они её реализовали, простейшая библиотека. Эта библиотека экспортирует два типа данных, это защищённый домены, то есть protection domains, и удалённые ссылки. То есть вот эти защищённые домены, они изолируются друг от друга, между собой они пересылают данные, которые либо ты навсегда отдаёшь владение, либо ты даёшь только ссылку на чтение, и поэтому фактически они практически независимы между собой, и это компилятор тебя гарантирует. Если ты хочешь передать данные для того, чтобы и ты, и другой сторонник мог читать, они делают вот этот специальный тип данных, это ссылочный тип данных, и владение остаётся в твоём домене, а туда ты только позволяешь запись делать. И с помощью этого получается, что у тебя данные как-то моделизируются, получается, и у тебя безопасность получается более высокая, которая гарантируется, и приложение становится более устойчивым и безопасным. При этом они сделали оценку оверхеда на примере программы, которая получает сетевой трафик, и натравливают систему фильтров на этот сетевой трафик. Они не показывали, какие фильтры, потому что смысла не имеет, то есть они сделали набор из пустых фильтров, которые не делают ничего, просто в модуль заходит данное и выходит из данной с каким-то ответом, там рандомным, нерандомным, без разницы. И они брали пустой список фильтров, а потом добавляли некоторые фильтры, которые не делают ничего, но и, соответственно, замеряли разницу в производительности. То есть оверхед на то, что у тебя будет присутствовать эта система фильтров, не на сами фильтры. И они получали, что у них, во-первых, это константное время, то есть оно не увеличивается в зависимости от количества фильтров, оно увеличивается, ну, в общем, там получают, что есть, они взяли несколько готовых реализаций, которые уже сейчас присутствуют на рынке и позволяют сделать то же самое, и во всех реализациях, для всех реализаций они значительно выигрывали по скорости, и они говорят, что у нас почти нулевой оверхед. Данные можете посмотреть в бумаге, если хотите. Во-вторых, анализы, анализ information flow control, они позволяют отслеживать проход информации, который является важной, и в том числе разбивать информацию по каким-то меткам на ту, которой можно доверять, которая сгенерирована самой системой, и ту, которая приходит от клиента, и которой нельзя, соответственно, доверять. Эти анализы делаются с помощью системы макросов, сураста, то есть каким-то образом, я не вдавался в подробности, вы делаете метки в тех местах, в которых приходят внешние данные, и потом по коду программы, соответственно, сама программа, сам компилятор у вас делает анализ, и в результате вы получаете какую-то абстрактную программу, которая уже содержит, куда какие метки пошли, куда какие данные пришли, и вы можете натравливать внешний верификатор. Они внешний верификатор использовали какой-то плагин к внешнему верификатору SMAC, и он на примере вот как раз вот этой простейшей системы, они не говорят, что это у них хорошая система получилась, они просто показывают возможность реализуемость данной затеи, и они показывали, что можно детектировать проблемы в каких-то простейших программах вида, есть некоторые примеры у них прямо в paper. И третья, самая интересная, на мой взгляд, вещь – это автоматизация. Они говорят, что большинство современных систем при необходимости какого-то снапшоттинга, то есть когда вам нужны транзакции, когда вам нужны checkpoint, replication, нужно делать снапшоттинг, а снапшоттинг чаще всего это включает в себя какие-то перемещения данных. И при этом, чем больше у вас ссылок в этих данных, тем больше у вас проверок по этим ссылкам, вам нужно пробегать, смотреть, были там, не были, какой-то garbage collection или еще что-нибудь такое. И это все очень сильно усложняет автоматизацию, то есть вы получаете либо плохие результаты, когда вы просто пренебрегаете частью анализа, либо все это становится чрезвычайно сложно. В Rust же все получается много проще, получается, что любая ссылка у вас контролируется компилятором, она либо принадлежит здесь, либо не принадлежит, и либо у нее есть доступ на запись, либо у нее нет доступа на запись, и только на чтение. Это значительно упрощает все вот эти подобные автоматизации. И авторы построили автоматическую библиотеку для чекпоинтов, так и назвали ее Checkpointing Library, которая использует специальный интерфейс Checkpointable. Этот интерфейс они написали для каких-то простейших типов, а в дальнейшем для всех более сложных имплементаций он делается автоматически. И соответственно, компилятор генерирует сам реализацию для более сложных типов, которые состоят из более простых скалярных величин. И это позволяет очень дешево делать чекпоинты. Эту библиотеку они, соответственно, открыли, она, говорит, тоже простейшая, но это показывает основной вектор движения, куда можно дальше двигаться. И с помощью вот этих трех направлений они делают вывод, что системное программирование на раз значительно облегчено по сравнению с C, и что всем пора переходить на RAS вместо C.",
    "result": {
      "query": "Rust isolation analysis automation"
    }
  }
]