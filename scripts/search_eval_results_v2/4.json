[
  {
    "segment_id": "b1e99b93-acc2-45f4-aad8-1e54d0204cd3",
    "episode_id": "7f8b0a4e-15c8-48e4-9822-16cb37dc2b53",
    "episode_number": 4,
    "segment_number": 4,
    "text": "А вот, Вань, ты хотел нам еще какую-то статью подкинуть. Эта статья относится к сюда же. То есть в рамках этого... В рамках этой идеи того, что нужно постоянно смотреть, не копипастишь ли ты какой-то код, есть отличная статья про то, как один из программистов, Уби Дахам, по-моему, его зовут, он написал интересную вещь. Он говорит, что я настолько... Как бы это сказать? Настолько хорошо пытался заиспользовать вот эту идею переиспользования кода, настолько все пытался сильно вынести в библиотеке, что сделал это слишком хорошо. И та вещь, когда у меня было несколько компонентов полностью разделенных и независимых друг от дружки, я сделал их зависимыми через какие-то библиотеки, и теперь у меня код стал намного сложнее и хуже. И он из-за этого говорит, что, ребята, опасайтесь чрезмерного усердия в этом вопросе. Опасайтесь переиспользования кода точно так же, как опасаетесь копипаста. Надо исходить за латой середину. Следует отметить, что человек, как он пишет в этой статье, он только закончил свое образование, и вот такой свежий выпустился. Он хочет использовать все то, чем мы его научили. Он пришел на реальный проект, а в реальной жизни не всегда все так, как учили. И он пытался сделать как можно лучше, получилось, как всегда, и поэтому ему сказали, что ну-ка, исправляй это все. В принципе, правильно сказали, потому что очень часто получается ситуация, когда есть какая-то похожая функциональность у совершенно разных несвязанных между собой модулей. Ну вот так получилось, что она похожа, так получилось, что на данный момент это одно и то же. Но на практике нельзя никаким образом это объединять, выносить в библиотеки, потому что это разные логические структуры. Если вынести в общую библиотеку, то ты делаешь зависимость. Это уже нужно поддерживать, и это раз. И два, нужно писать всегда больше тестов на библиотеку, которая общая, потому что может быть много всяких тонких моментов, если она используется много где. Хотя, с другой стороны, тоже хорошо. Написали один раз библиотеку, ее прокастировали хорошенько, все ее используют, и все понятно. Тут еще одно усложнение, еще одна библиотечка, от которой происходит зависимость, интеграционные тесты, бла-бла-бла. Тут надо всегда искать, всегда понимать плюсы того, что ты делаешь. Вынес в библиотеку, видите плюсы и минусы. Золотую середину нужно искать, как всегда. Я думаю, такие вещи с опытом приходят, и потом начинаешь понимать, где лучше вынести, где лучше оставить, это только опыт. Да, да, да. Вот касательно опыта, давай расскажи нам, как ты получала свой опыт на скала Дейс. На самом деле, я только скажу просто два слова, что это давно уже выложили, но чтобы посмотреть доклады, нужно было время. Извини, Свет, я в очередной который раз уже тебя перебиваю. Да ничего, собственно, где-то чуть больше недели назад в Минске был первый метап сообщества, оно так и называлось, мета-сообщество функциональных программистов. И поскольку у нас сообщества довольно маленькие, есть отдельно стоящие F-Sharp, есть отдельно стоящие Scala, Erlang даже такие у нас есть, но они маленькие, поэтому решили их объединить и сделали такое большое собрание, где выступали два докладчика, они рассказывали, как съездили на скала Дейс в Берлине. Они рассказали про доклады, что было, что было интересно, куда движется скала. Я там была на этом метапе, мне некоторые доклады очень понравились, я решила их посмотреть, потому что все доклады уже выложили, напарились, и ссылка будет в шоу-нотах. Расскажу про два из них, которые мне больше всего зацепили. Первый, который мне понравился, это АКК-HTTP, опять же, потому что тема близкая ко мне, и раньше в АКК-е не было никакого модуля, который работает с HTTP, была библиотека, написанная на Scala, называлась она Spray, но я как-то с ней не работала. Была у меня задача, чтобы написать REST какой-то, и на тот момент в модуле, который работает с клиентской частью, не было никакой АКК-и, она работала на NETI. Я написала REST поверх NETI, это довольно было легко и приятно сделало, но смотрю, оба-на, появилась в АКК-е такая штука. Интересно. Я посмотрела, к чему оно все идет, они, по сути, переработали Spray, точнее, перерабатывают Spray, полностью его переделывают, поэтому будут некоторые изменения в API, и собираются внести Spray в виде модуля АКК-HTTP в конечную поставку АКК-и. Но, собственно, в чем это хорошо, потому что, наконец-то, появится такой модуль, но там тоже есть некоторые проблемы, которые пытались, в которых есть Spray, потому что, если у нас есть какой-то узел, к которому приходит очень много данных, порядка несколько гигабайт, то оно начинает педалить, они пытались это решить, в докладе об этом рассказывалось, но как-то они все-таки это решают, и пока что есть только бета, еще они не советуют использовать это в реальности, но штука интересная. Они эту стабильную АКК-у еще не включили, насколько я понимаю. Еще не включили, это только то, что будет. Есть такой подкаст, называется ScalaVax, там в последнем выпуске, номер 19, было интервью с чуваком из тех, которые пилят АКК-у, и там можно интересно послушать, в том числе про АКК-а, HTTP, про Spray. Если вам эта тема интересна, ссылка будет в шоу-ноутах. Спасибо, интересная инфа. И второй доклад, который мне понравился, это про то, как человек ускорил работу скаловских коллекций в 30-40 раз. Как это так получилось? Собственно, идея в чем? Было два примера. Пример простейший, да нельзя. У нас есть массив интов, и нужно посчитать среднее этого массива, среднее значение. Пример, работающий на Java, в котором написана самая простая и типичная реализация. У нас есть какой-то цикл, который складывается, и дальше делим на количество элементов. Есть такая же штука, написанная на скале. На скале это OneLiner, и используется функция reduce. И в чем проблема? На скале это работает в 32,5 раза медленнее. Вопрос, почему? Идея в том, что начали разбираться, что происходит в Java, что происходит в скале. В Java по сути выполняется один, то есть просто overhead идет только на сложение. В скале же всегда есть проблема, называется boxing, unboxing, и вот это все очень много времени берет. И человек, который делал доклад, он рассказал, каким образом это сделал. Он написал в библиотеку, он Scalablitz называется. И по факту получилось ускорение порядка, по сути для некоторых случаев, порядка такого же, как у Java, а для других вариантов порядка на 40% лучше. Собственно, что они сделали? Они добавили макросы. Во время компиляции используются макросы, они меняют байт-код, и благодаря этому у нас работа с коллекциями происходит намного быстрее. Собственно, минусы этого решения тоже очевидны, в том, что код генерен, и он, как правило, хуже, его хуже дебажить. Стектрейсы тоже тяжелее понимать. Все-таки оно чуть-чуть работает медленнее, чем Java. И это все происходит во время компиляции, и все-таки это занимает некоторое время. И далее, не для всех случаев это работает. Это работает хорошо для интов, это для тех вариантов, когда нам нужно на боксинг и анбоксинг стратить много времени, а на непосредственную логику мало, как было со сложением. А для ситуации, когда мы работаем со ссылками, то этот оверхед будет маленький по сравнению с тем, что нам нужно сделать. Поэтому это будет не так заметно. Но штука интересная. Вопрос, однако, заключается в том, насколько это на практике вообще кого-то волнует, потому что, по сути, чуваки взяли микробенчмарк и его заоптимизили. То есть это здорово, что там какой-то цикл стал в 30 раз быстрее, но если это в 30 раз медленнее, было 2 миллисекунды, и оно выполняется раз в день, то может оно особо никого не беспокоило. Ну, смотри, если есть какая-то задача, которая чисто вычислительная, это тоже вопрос, с какого ты будешь это на скале писать. Ну, допустим, ты пишешь это на скале, и да, тебе это поможет. А самое интересное, что нужно в коде исправить, чтобы это работало. По сути, нужно писать только блок Optimize, и все, оно работает в 30 раз быстрее. Магия. Но это все библиотечка, правильно? Да, эта библиотечка, она, возможно, когда-нибудь станет частью скала, но на данный момент это библиотека, которая отдельно стоящая. Угу. Мне все же кажется, что ребята могли бы потратить свое время с большим толком, потому что чем хороша скала, даже если ты столкнулся с какими-то адовыми тормозами, ты берешь и пишешь один класс на чистой Java, без всякого, как он там, боксинга-анбоксинга, на, как они там правильно называются, нативные типы или... Ну, когда ты просто пишешь int через класс. Да, эти примитивные. Примитивные, да, не нативные, примитивные. На примитивных типах все, что угодно пишешь, у тебя получается Java. Ну, да, согласна, но смотри, это же по сути работа какая-то магистерская, либо PHD, я считаю, это довольно интересная штука. А, нет, ну, с теоретической точки зрения, конечно. Смотри, это реально интересно заниматься такого рода вещами, то есть написал вот такую библиотеку, ну, это здорово, чем какую-то там еще одну систему документа оборота писать в качестве там диссертации. Это здорово. А что еще здорово, это язык Kotlin и компания JetBrains, которая с недавних пор, по крайней мере, я так понял, это пока не официально, но в социальных сеточках, вот, например, Илья Рыженков, надеюсь, я правильно поставил удаление, пишет, что они в Kotlin ищут себе новых коллег, которые для Kotlin будут разрабатывать, ну, типа инфраструктуру, то есть писать какие-то библиотечки, писать, я не знаю, там, отладчики, инструментарий, такого рода вещи. Честно говоря, если бы я был, если бы я что-то понимал в Java, то я бы вот прям с радостью прям пошел бы на эту должность, мне кажется, это замечательно. Ты как считаешь, Свет? По-моему, шикарно. Это вообще здорово. То есть я бы такое рассмотрела обязательно. Ваня, а ты бы пошел писать в Kotlin? Я мечтаю об этом очень давно, но как-то времени не хватает. А кто вообще, ну, так смотрел его близко, потому что я смотрел его далеко в общих чертах. У нас на All Camp в этом году, на летней Ульяновской конференции на пляже приезжал рассказчик, который пишет на Kotlin, так что я видел одного человека, который пишет на Kotlin. Еще когда-то в свое время, когда я решала задачки на топкодере, и я видела решение на Kotlin. То есть там можно посмотреть свое решение, выложить, посмотреть решение других, и думаю, оба, ну интересно, что это. Смотрю Kotlin, здорово. Ну, если по-простому, то это как бы такая менее задротская скала. Но мне интересно, вот у них там есть лямбдочки, есть у них там паттерн-матчинг, такие вещи? Ну, я думаю, такие уже должны быть. Я не смотрел. А вот зато ты смотрел что-то другое. Да, давайте я расскажу новую тему. Я нашел ссылку, которая довольно интересная тема. Ребята сделали введение в криптоанализ и всю теорию в криптотеорию, только не со стороны теории, как это сделано на Круссере, например, а со стороны практики. Они так и говорят примерно, что их ресурс посвящен тому, чтобы вы полностью погрузились в криптоанализ, в всю эту теорию, но только со стороны написания реальных прикладных задач. И эти два курса дополняют друг дружку, и они их рекомендуют делать вместе. Грубо говоря, у вас есть список задач, которые необходимо решать, от простых к сложным. То есть сейчас уже выпущено 6 задач, они обещают их увеличить до 8. И каждая следующая задача, она в том числе основывается на теории из предыдущего анализа, и вы должны писать какие-то программки, которые будут те задачи, которые они ставят, решать и исполнять на любом интересном для вас языке. Мне кажется, что это очень интересная вещь, называется она Matasana. Mata – это kill, sana – это healthy. Это с испанского языка. То есть нечто странное, убивающее здоровье. Убивающее здоровым образом. Здоровым образом, отлично. И в целом такая интересная вещь. Я бы с удовольствием поучаствовал, если найду время, я поучаствую. Пишите, делайте, погружайтесь в эту теорию, если вам она еще не знакома. Мне кажется, очень замечательный способ. Чем больше будет таких соревнований, состязаний, тем интереснее. Кстати, вспомнила про соревнования. Совсем недавно, буквально вчера, или позавчера, был Google Code Jam финал, и белорус Геннадий Короткевич выиграл. Может быть, вы слышали? Да, я слышал. А я не слышал, расскажи мне. Наверняка ты слышал про такие соревнования по программированию топ-кода, Code Jam и прочие планы. Гена, он у нас вообще белорус, он сам из Гомеля. Он еще в школьные годы участвовал с ребятами постарше, выигрывал на Республике олимпиады по программированию, потом международные. И в Google Code Jam он не мог участвовать из-за возраста. Ему не было 18 лет, насколько я помню, и он не мог участвовать. Но при этом он брал все международные награды. И вот сейчас, в первый раз, когда он участвовал как полноправный участник, он победил. Что следовало ожидать. Он очень молодой, а сколько ему сейчас? 18 как раз? 19. Молодец, отлично. То есть, с самого детства его учили, его родители программисты работают в университете. Благодаря этому человек с самого раннего детства приучалик решать задачкам. И вот такой эффект получается. Ну, вообще здорово быть олимпиадником, потому что тебя после такого возьмут куда угодно и будешь заниматься чем-то интересным. Мне кажется, после такого уровня найти действительно интересную задачу будет достаточно сложно. Вы понимаете, надеюсь, что все эти олимпиады очень далеки от программирования? Я прекрасно понимаю, я сама в этом участвовала. Я, правда, сначала по математике, потом и в программировании была. И да, эти задачки далеки, но они заставляют думать. И это так прекрасно развивает способности к мышлению, к решению задач. Олимпиадное программирование, оно, конечно, не похоже на решение реальных индустриальных, как это будет по-русски, промышленных задач. Но я говорил не о том, что это тебе какой-то крутой опыт дает, а о том, что тебя возьмут куда угодно, потом тебя, конечно, переучат делать вещи правильно. Вот-вот, то есть ты учился, учился, а потом тебя все равно переучат. Ну ладно. Я предлагаю перейти к следующей теме. Я только хотел уточнить по предыдущей. То есть там на курсе реально тебе объясняют, что там вот это дифференциальный криптоанализ, там на каком-нибудь простеньком алгоритме, условно говоря, простеньком. Все так? Нет. На курсе дают тебе задачу, а дальше ты внедряешься сам и ищи теорию сам. А, ну, окей. А хоть ссылки дают какие-нибудь, куда копать? Да, конечно, конечно. То есть как бы они, у них идея-то в чем? Тебе ставят задачу, то есть какое-то минимальное объяснение, что это за задачи они дают, а в дальнейшем ты должен сам найти информацию, ну как в реальном мире, то есть тебе ставят, как в промышленном программировании, как мы только что говорили. А слушай, а критерий завершенности задач есть какой-то входной-выходной параметр, либо как? Слушай, вот это я не знаю. То есть я думаю, что есть какие-то тесты, но как они реализованы на сервер-сайте, или ты сам можешь их погонять, вот этого я не знаю. А потом прохождение какое-то показывается? Прохождение ты имеешь в виду что? Ну, правильное решение с объяснением. Да, да, да. Я так понимаю, что возможно сейчас этого нет, но они хотят это сделать. Хотя, может быть, они сейчас уже это пояснили, просто я на оригинальном сайте не вижу ссылок пока.",
    "result": {
      "query": "матасана задачи криптоанализ"
    }
  }
]