[
  {
    "segment_id": "c0525410-5ccc-4a18-94f4-179b178b4c9d",
    "episode_id": "c8bbde55-3719-4c4e-9075-be6ee2edfa4d",
    "episode_number": 82,
    "segment_number": 5,
    "text": "С другой стороны, у Rust zero-sized runtime, и это компилированный язык, хотя получается, что из-за того, что он компилируемый на каждую платформу, он менее портабельный, но из-за того, что он используется для LVM, получается, что сложность добавления архитектур, она минимальна. Плюс вот как раз он в конце затрагивает, что сложность Rust, она вот в его концепциях lifetime и ownership, получается, что это и одновременно очень большая помощь, и одновременно очень большая головная боль. То есть до тех пор, пока вы не разобрались, вы будете бороться с компилятором, но когда вы скомпилировали код, получается, что чаще всего он запускается. Он говорит, что он подобное наслаждение от кода получал только в Haskell и в Acaml, в том плане, что если код скомпилировался, скорее всего, он работает. Но при этом Haskell и Acaml гораздо более сложные высокоуровневые языки, и Rust в этом смысле проще. Вот это только секция runtime, а там таких секций порядка 4-5. Это краткие выдержки, вот как-то так. Я не согласен с тем, что Acaml сложнее Rust. Ну, я тоже, наверное, не согласен с тем, что Acaml сложнее Rust. Acaml относительно простой язык, у них тоже недавно была гелиоса, и тема была в выпуске, я видел, но куда-то она пропала. А её никто не прочитал, то есть я лично… Я прочитал тему. Он не сказал, что она сложнее, я, может быть, неправильно выразился, он сказал, что он более высокоуровневый. А, это да. То есть с помощью Rust ты можешь писать очень сильно приближенный к машине, а всё-таки Acaml, он что-то генерирует, и то, что он генерирует, ты мало можешь контролировать временами. Тему про Acaml я могу найти, если надо. Да не надо. В общем, любители Acaml, вышел новый Acaml, в нём всё хорошо, всё замечательно, и они готовятся к тому, чтобы их garbage collector стал multi-core, для этого они сделали какие-то первые изменения, но часть работы не была закончена во время к релизу, поэтому он отложился ещё на один релиз, но в принципе все так и ждали, что так и случится. Поэтому, в общем, икуем. И интересно, что новости о релизе Acaml явилась на сайте Jane Street, а не на сайте самого Acaml в первую очередь. То есть было пост из серии «Ой, мы релизнулись», написали ребята из Jane Street. Jane Street Capital – это компания, которая занимается high frequency trading, и задолго до того, как всякие Acaml, Haskell и вот эти функциональные языки стали в мире HST популярными, они первыми начали это использовать, и для них это было довольно-таки долго конкурентным преимуществом. Но фактически это единственные пользователи Acaml, поэтому они у себя в блоге пишут. Ну, наверное, кто-то ещё им пользуется, я знаю, что у нас в Orly было много пользователей Acaml в какой-то момент, но я сейчас не знаю. Мы писали на Acaml довольно большие куски кода. В Facebook тоже есть кусочек кода на Acaml, на нём написан проверяющих типов для JavaScript, который называется float, то есть он поддерживает то, что называется gradual typing, то есть в каких-то местах можно ставить аннотации о том, например, какого типа параметра мы ждём, какого типа результат мы получаем, и, соответственно, там, где эти типы стоят, он может проверить вывод типов и попытаться сказать, есть ли у тебя ошибки типизации или нет. Инструмент написан на Acaml, исторически так сложилось у них, и в результате получается, что как бы есть билды под OS X и под Linux, а вот билды под Windows собирает односторонняя команда, и они немножко запаздывают, и получается, что многие новые в плюшки не попадают туда вовремя. Слушай, мы эту тему затрагивали где-то с полгода, может быть, назад, да? Да, наверное. А с тех пор появились какие-то новые блокпосты про это? Я просто не видел нигде в новостях. Если найдёшь, ссылок накидай, ладно? Окей, на самом деле получается, что есть два больших проекта, которые этим занимаются, это вот этот Flow от Facebook и TypeScript от Microsoft, и они как бы двигаются с одной стороны в Ноздре в Ноздрю, и некоторые фичи просто друг у друга перетягивают, например, в последнем TypeScript появились вот эти StringUnionTypes, я не знаю, как это точно назвать, но когда ты говоришь, что это строка, и она имеет там одно из перечисленных, допустим, трёх или четырёх значений.",
    "result": {
      "query": "Acaml vs Rust complexity"
    }
  }
]