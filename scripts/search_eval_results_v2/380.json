[
  {
    "segment_id": "8bfc4e39-19f1-4447-969e-4e8b3b0a3ce1",
    "episode_id": "c430da95-fd3c-4d2d-bfcc-1d7cf330135e",
    "episode_number": 380,
    "segment_number": 4,
    "text": "Вот, называйте вашу систему нормально. Вот. Андрес Фрейнд сейчас работает в Microsoft, и он занимается PostgreSQL лет 15. И сейчас он особенно интересуется задачей, вопросом добавлением асинхронного IEW в асинхронного и директ IEW в PostgreSQL. У него соответствующий патч висит на Комитфесте, и разорватывает он его с, он сообщает, что он будет работать в 2019-го года. Ну, для контекста, в мире PostgreSQL 2-3 года разрабатывать патч такого уровня, это нормальная история. Значит, о чем он говорит? Ну, сначала он рассказывает про то, что, ну, как вообще сейчас устроен IEW в PostgreSQL, и что с ним не так? PostgreSQL использует buffer от IEW, то есть у тебя есть страницы, любые таблицы хранятся в виде страницы по 8 килобайт по умолчанию, у тебя индексы хранятся в страницах, и rate of headlock, он тоже пишется страницами. Я, должен сказать, не очень внимательно смотрел, как устроена rate of headlock, там не 8 килобайтные вроде страницы, но тоже какие-то такие единицы. Вот. И когда вот в PostgreSQL просто решал на этапе, на каком-то из этапов корректирования системы, когда принимался дизайнерское решение, было сказано, что buffer от IEW это плохая идея. И, ну, это вообще в мире баз данных аксионов. Вот. Почему это плохая идея? Во-первых, у тебя появляется... Ну, подожди, buffer от IEW не совсем это. Ну, то, что ты назвал, просто что в PostgreSQL есть страницы, ты не объяснил, что такое buffer от IEW. Ну, хорошо, давай, вперед. Ну, buffer от IEW, это, собственно, то, как мы обычно используем read-write, когда у нас как бы мы делаем системный вызов, говорим, ядру, дай мне вот это или запиши вон туда, и оно через свои внутренние буферы в ядре это делает. И, соответственно, у ядра могут быть кэши файловой системы, это плюс и минус, потому что, если у вас что-то в кэше, оно будет быстро, если чего-то в кэше нет, оно будет медленно, но если там мы, например, просто читаем файл подряд, то оно будет быстрее, потому что система будет делать prefetch. А что вы с Сашей судя по заметкам дальше потом скажете? То же самое с записи, оно по волночанию запишет буферы, и просто пока вы там их в синг не скажете, оно в этих буферах там возможно останется, оно не совсем обязательно поедет сразу на диск. Плюс в том, что с этим гораздо проще работать, чем с с ногами и другими API, минус в том, что это как бы не прозрачно совершенно, то есть вы что-то записали не как оно записалось, это непредсказуемый перфоманс, потому что вы должны угадать, что у вас в кэше, и вы должны вести себя так, чтобы где-то могло предсказать, что вам там на prefetch-ить. Еще это сис колы, собственно говоря, сис колы не бесплатные, если вам нужно много и часто за них тергать, вы просто на этом будете производительность терять. Ну и собственно потом, когда вы это прочитали или записали, вы как бы, поскольку вы не можете, вы не имеете доступа к никаким кэшам в ядре, то, что вы прочитали, вы положили куда-то еще потом в свою память, что-то с этим делаете. И соответственно, данные в памяти хранятся два раза, один раз в ваших выделенных, вместо в вашем приложении, куда вы читали, и второй раз они лежат в кэше ядра. Все верно, ты все рассказал, то есть подведем итог. Недостатки. Это двойное кэширование в кэше файловой системы в памяти и в самом приложении, которое реализует свою логику кэширования в случае с Postgres. Это не для всех приложений, справедливо некоторые свои кэши не держат. И да, системные вызовы не бесплатные, имеют не очень много расходов, особенно когда ты их делаешь много. В случае с Windows сообщает Endress, это особенно дорого, а ее очень сильно не оптимизирован по сравнению с Linux, например. Но он также отмечает, что он давно в последний раз активно работал с Windows, поэтому эти данные могли немного устареть. Возникает тогда вопрос, а почему, если у Bicare это ее такие недостатки, почему в Postgres он используется? Ну то есть несколько причин. Во-первых, над Postgres работали относительно немного людей и команда маленькая, поэтому поддерживать что-то более сложное, это дополнительная нагрузка, нужны дополнительные ресурсы. Сейчас над Postgres работает больше людей, чем работало 15 лет назад, но тогда это было прям актуальной проблемой. Другая причина, которую отмечает докладчик, это некоторые архитектурные решения, которые были приняты, например, то, что Postgres использует process-based архитектуру. Я вот так вот прям слет не могу сказать, дело в том, что я не очень знаком с терфейсом всяких асинхронных IE, с интерфейсами разных асинхронных IE, объясни в чем здесь влияние. Дело не в том, что если я правильно понимаю, там проблема просто то, что оно не факт, что не на каждой операционной системе Direct IE может быть удобно асинхронным, или что-то такое, там какая-то такая история, и тебе нужно соответственно делать какой-то отдельный поток, который отвечает за ввод-вывод, и ты не можешь в Postgres взять отдельный поток, который отвечает за ввод-вывод, или тебе нужно будет делать отдельный процесс, общаться с ним через какой-то shared memory и PPC, и это будет скорее всего неоправданно долго и сложно, и плохо работать. Я понял. То есть это такая история, я не уверен на 100%, но да. Стоит в том, что одна из самых больших проблем в принципе всем, кроме Buffered IE, что оно на каждой операционной системе какое-то свое уникальное, и построить какую-то абстракцию, которая бы хорошо работала универсально, это прям задача. Где-то в этот момент докладчик он декомпозирует, скажем так, проблему с Buffered IE, то, что у тебя как альтернатива есть Direct IE, когда ты входишь в... когда у тебя не задействовано какое-либо кэширование со стороны файловой системы, но вот чистая Direct IE не дает существенных преимуществ, потому что у тебя... если он последовательный, у тебя и ты, например, делаешь три чтения, то как у тебя выглядит последнее три чтения, ты делаешь там первый Direct IE, сходил в OS, OS сходил в диск, напрямую без кэшей, получил результат, поработал тебе результат. Ты делаешь так три раза, и у тебя на все эти три вызова у тебя большое latency. Поэтому Direct IE он осмысленен, когда у тебя есть также асинхронное с IE, синхронное, потому что ты можешь все свои три операции, чтения или записи послать бачом, бачами получить ответ, и у тебя latency уменьшается. То есть Direct IE без асинхронного с IE он имеет мало смысла. Но с асинхронным с IE проблема, что он платформа зависимый, на разной степени хорошести работает, и API некоторых платформ по сути делают интерфейс с POSGIS бессмысленным. В этом месте он еще вспоминает, что есть POSIX, IE, но он бесконечно сломан. Он бесконечно сломан по части, потому что он потом дальше по тексту говорит, что они в итоге все равно на него полагаются, только на тех операционных системах, где он менее сломан, где он основной вариант асинхронного IE. Например, на MacOS и FreeBSD они будут использованы по ZXO, потому что там это основной и нормально поддерживаемый, а типа на Linux он настолько бесконечно сломан, что теряет данные. То есть он неудобный или какой-то неправильный. А на Linux он еще и реализован так, что его добавили для галочки, что мы поддерживаем, но он в некоторых случаях работает некорректно.",
    "result": {
      "query": "PostgreSQL Direct IO async support"
    }
  }
]