[
  {
    "segment_id": "7799956d-1520-47fd-88d6-73d96387445a",
    "episode_id": "8e0547fc-0387-4213-ab82-868852218892",
    "episode_number": 27,
    "segment_number": 6,
    "text": "Вот. Версии Db сделали абсолютно офигительную вещь. У них уже довольно давно был changes fit, но они теперь сделали так, что changes в их API можно присобачить почти к любому запросу. То есть как это выглядит? Мы говорим там, хочу, значит, вот выбрать по такому-то индексу, вот такой-то order by, такой-то limit, и значит, дай-ка мне на этот сразу еще и changes fit. Первым ответом приходит текущий snapshot, т.е. текущий ответ, дальше приходят дельты к этому. То есть, говорится, что для такой-то записи в пришедшем первом ответе, точнее, в текущем состоянии пришедшего, нужно такую-то запись заменить на такую-то. То есть, типа, запись с таким-то ID-шником, то есть, представляем, что нам первый ответ пришел, как какая-то, не знаю, грубо говоря, хэштабличка, потому что база работает с режиссером на самом деле. Дальше нам приходят в стриме данные, типа, что данный объект по такому-то ключу нужно заменить на объект по такому-то ключу. То есть, мы, грубо говоря, любой запрос, уже отсортированный, оторделенный и так далее, можем просто напрямую дисплей, например, в браузер, если мы в браузер это делаем. Ну, на самом деле, понятно, что придется какой-то клиент написать, но тем не менее. И больше того, поскольку у нас данные могут поступать очень быстро, и мы, возможно, не хотим пользователю показывать данные за скоростью 100-500 миллионов раз в секунду на летнему страничку, потому что мы изнасилуем его браузер, там есть еще одна фича, связанная с этим changes.feed, можно сказать, что уважаемые базы данных, пожалуйста, мерджим мне там изменения в пределах, например, секунды, и база не будет посылать обновления чаще, чем раз в секунду, то есть она будет присылать советскими батчиками. А там на стороне базы ни во что не упрется? Ну, они говорят, что они ориентируются на масштаб, не, там, нескольких десятков узлов, там, 2-3 десятка узлов, и они говорят, что они тестировали, вроде все хорошо работает, то есть, они пока IP с join не сделали публичным, то есть, это пока не работает в билде не публичным, но они на тем работают, чтобы join тоже нормально с этим работали, все остальные типы запросов говорят, что работает, работает нормально. Ну, я, в принципе, представляю себе, как это можно сделать, и я думаю, что тут не должно быть, то есть, всего кроме join не должно быть скалобиэти проблем. Прикольно. То есть, как бы представь, на самом деле, что ты поставил поверх такого фида, такой небольшой маленький Spark кластер, и через него пропускаешь вот это все. Ну, то есть, очень грубо говоря, ты можешь себе так представить, на самом-то деле. Просто тут-то сделали за тебя, и это все, как бы, абстракция предоставляемой базы данных. Ну, подожди, ты вроде, если я тебя правильно понял, я могу подписаться на все события в базе? Можешь, но ты ведь как бы... Да, ты можешь подписаться на все события в базе, но тогда тебе придется, как я говорю, построить какой-то свой кластер, который будет из этого фида изменений строить нужный тебе вьюхе, а так ты просишь вьюху и апдейт к ней. Ну, окей, тогда ладно. Потому что я так понял из твоего рассказа, что на один запрос я могу получить какие-то апдейты. Ну да, да, ты просишь запросом, просишь какую-то вьюху. То есть, например, хочу данные по такому-то индексу, так-то их отордерить, так-то их фильтровать, такой-то лимит на них, типа мне нужно топ-50, например. И дальше ты будешь получать апдейты к полученному ответу. Прикольно. Что еще прикольно, Олег? Ты нам что-то хотел о пиве поведать? Да, я хотел бы вернуться к теме Фосдема. Если хотя бы не для докладов, то стоит съездить в Бельгию хотя бы из-за пива. Многие, я знаю, знают про немецкое пиво и чешское, и оба хорошо славятся. Ну, как житель Германии, я могу сказать, что я немецкое пиво пить не могу. Но бельгийское того стоит, чтобы его попробовать. Ну, во-первых, немножко цитируя Википедию, в Бельгии примерно производится около 900 разных марок пива, некоторым из них по 500 лет. То есть в прошлом в Бельгии было как минимум один сорт пива на церковь. То есть каждая церковь делала свой сорт пива. Какие милые монахи. Ну, как бы оттуда все пошло. Каждая пивоварня имела свой сорт, свои источники воды, своего пивовара. То есть для каждого пива своя форма стакана. Это очень интересно. То есть тебе не могут принести, то есть не как в Германии, приносят пиво все в одном типе стакана. Тут для каждого пива свой стакан, чтобы он по-разному действует, там запах и вкус и все такое. Пиво крепкое. 7-10 градусов. Или как здесь говорят процентов алкоголя. То есть побалдеет, дает хорошо, но очень вкусное. Мой фаворит это бельгийский эльпальм шпициале. Приятно янтарного цвета и на вкус немного сладкий и пряный, потому что варится с пряностями. Я еще добавил линк на Википедию. Очень интересно почитать. Если поедете на Фостэм, хотя бы только из-за этого, чтобы попить вкусного пива. На самом деле я просто могу сказать, что если вам вдруг нечего делать, просто езжайте в Брюгги, особенно если вам вдруг повезет попасть в рождественскую сказку, когда там все снежочек и подрождество. Правда вы рискуете там заполучить очень много народу, но вообще Бельгия и в частности Брюгги, это прям такая как будто заснята рождественская, то есть материализована рождественская сказка с очень вкусным всем под шоколадом и пивом. Ну как-то так. Ну а если вы очень домашний котик, то даже в Москве в принципе есть пивные бары, которые специализируются на таком импортном пиве. Так что в принципе их можно найти. В любом случае стоит попробовать. Ну я так понимаю, Валер, ты настаиваешь на том, чтобы была раскрыта тема Netflix? Да, я читал статью и я ей очень заинтересовался. Я хочу от вас, от кого-то, кто это читал, что-то услышать, чтобы понять для себя, я это правда хочу почитать, она большая, или и брать по всем ссылкам, или я могу это скинуть. Во-первых, она не большая. Со ссылками большая. Во-вторых, кстати, примерно о том, что есть такая компания Netflix, им нужно находить аномалии в поведении системы. То есть им нужно знать в каком она состоянии. Либо все ок, либо что-то пошло в криф и в коз. Для этого они выработали несколько подходов. Подход номер первый, это то, что они называют SPS. Не уверен, как оно правильно расшифровывается. Тут где-то, кстати, написано, но я уже забыл и не могу найти. Но суть очень простая. Она же широко используется много где еще. Это когда, представь себе, у тебя есть график за предыдущий день. Например, число запросов по времени в суток. Ты рядом с этим графиком рисуешь другой график. Это сегодняшнее число запросов по времени в суток. И если они у тебя более-менее похожи, ты понимаешь, что все хорошо. Если они вдруг резко расходятся, то видимо что-то не так. Это как-то ничего нового. Они не придумали ничего нового в этом плане. Пока нет, да. Но это просто хорошая методика, которая себя зарекомендовала. И которую они используют чуть ли не до сих пор. Далее. Тупой подход, который они называют Static Threshold. То есть ты задаешь какой-то порог. И если у тебя метрика вышла с айвопредела выше-ниже, то понятно, да, все плохо. Например, время обработки запроса должно быть не больше 300 миллисекунд. Если больше, значит где-то что-то тупит. Тоже пока ничего неинтересного. Дальше. С этого момента становится интереснее. Бегущая средняя. Как она? Экспоненциальная бегущая средняя. Я, по-моему, в предыдущем выпуске рассказывал о том, как можно подстраивать KPST Units в DynamoDB. В том методе, который я рассказывал, там используется похожий подход. Смысл в том, что у тебя есть какая-то метрика, она колеблется. То есть, например, тоже число запросов в секунду там вверх-вниз. Такая шероховатая кривая получается. EMA позволяет ее сгладить. И, соответственно, эту EMA, к ней можно еще какие-то пороги прикрутить. Например, текущее число запросов к базе данных плюс кое-како процентов. И, понятно, да? Поставлять такие KPST Units как вариант. Или считать, что если у тебя что-то выскочило за эти пределы, то это какая-то аномалия. Такого рода вещи. Далее. Они в своем блоге описывают двойное экспоненциальное сглаживание. Я не понял. Экспоненциальное сглаживание. А дальше как они эти данные анализируют? Они же, я так понимаю, хотят автоматом матчить. С матчингом в предыдущем дне и матчингом по статическому треш-холду, понятно. А экспоненциальное сглаживание, что они потом отклонение от сглаженной линии считают? Или что они считают признаком чего-то плохого? Тут довольно размахчато написано об этом. Я смотрю, как на их сайте, что они ищут много разработчиков на air. А там уже все эти библиотеки уже есть переиспользованы. Понятно. То есть, они, видимо, не очень пишут об этом. Окей. Далее они пишут про двойное экспоненциальное сглаживание и о том, что оно вроде как всегда... То есть, я так понял из этой статьи, что они пытались при помощи этого двойного экспоненциального сглаживания установить нижний порог. Потому что это двойное экспоненциальное сглаживание, оно всегда отстает от твоего текущего значения. Оно всегда меньше, но не намного. И вот если у тебя вдруг твоя текущая метрика резко упала ниже вот этой вычисленной метрики, которая двойное экспоненциальное сглаживание, то значит у тебя что-то сломалось. Но плохая новость в том, что она довольно долго восстанавливается после того, как система придет в норму. Поэтому тоже такой странный подход. Ну вот. По-моему это все, что было интересно в этой статье. То есть у них основная задача была это как-то автоматически определить верхние пороги и нижние пороги. И если что-то вышло из коридора, то сказать, что все плохо, все сломалось. Понятно. Спасибо. Ну вообще очень интересно. Это стандартный подход. Если что-то вышло из-за каких-то пределов, то мы будем нотификацию присылать. Нет, ну вот это, понимаешь, вот то, что ты говоришь про что-то вышло из-за каких-то пределов, да, это звучит очень просто, но ведь всегда интересно узнать на конкретной практике, какие пределы, как они нашли. Смотри, я к тому, что ничего нового не произошло. Хотелось услышать что-то такое вау, они придумали какой-то новый подход проживной. Нет, в смысле, я как раз понимал, что они просто какой-то существующий подход как-то адаптировали и мне... Алло. Алло. Вы у меня пропали. Нет, это Валер отвалился, у него там точечки побежали. Давайте перейдем к темы слушателей. Давайте. На самом деле их не так много. Один из наших слушателей, Фогоферс, спрашивает, расскажите об алгоритмах, о распределенных алгоритмах, которые вы используете, реально используете, Raft, Gossip и так далее. Ну, Raft я не то, что прямо использую, но по нему есть отличный сайт, ссылку на который я добавляю шоу-ноты, там есть пейпер и там прям все очень здорово описано. И я когда-то в Твиттер постила ссылку с гифками, как работает Paxos. Я думаю, я могу найти и добавить. Ну, я могу сказать, что я Paxos реализовал, но игрушечный, на самом деле, по большей части. Че еще? Gossip каждый день на работе. Много раз своими добра. Всячески, ну, как бы, в общем-то весь реаккор. Понятное дело, что реаккор я не писал, но активно вонзался в это все. И в любом случае, когда делается что-то поверх этого дела, нужно понимать, где какие гарантии, где можно что-то сделать, где нельзя что-то сделать. Совершенно классические всякие репликации тоже каждый день на работе. То есть, ну, нужно, грубо говоря, если есть какой-то стейт, который меняется, нужно его среплицировать на какую-то другую машину. Тоже там классические подходы, типа заведем какой-нибудь оплок, будем его по секвенсам отдавать дальше или что-нибудь еще в этом духе. Либо если это какая-то консистентная репликация, нужно понимать, где что, когда форвардить, какие запросы, как это все взаимодействует с тем, как реактор перемещает данные по кластеру и так далее. Что там еще? Ну, да, в общем-то, консистент хешинг тоже каждый день много и часто. Ну и вообще все DHT подходы. Плюс один за госеб, плюс один за репликацию. И читайте документацию по АК-кластер, она классная. И у меня в блоге время от времени появляются статьи про АК-кластер. Там вот то, с чем я реально сталкиваюсь. Там не сами алгоритмы, там скорее уже готовые. Но тоже интересно. Ну и есть, на самом деле, книжка, которую я всегда каждый раз советую приответить на такие вопросы. Есть такая, видимо, еще раз представляем ссылку. Такая мини-обзорная статья по таким наиболее основным понятиям в распределенных вычислениях. Ну и ее всегда хорошо прочитать и понимать, о чем речь. Ну и, кстати говоря, по поводу алгоритмов, это не то, чтобы алгоритм распределенной системы. Это такой алгоритм, который всегда рано или поздно всплывает как вспомогательный. Ну вот векторные часы просто во все поля. Ну и, соответственно, CRDT тоже во все поля, поскольку у нас API-система. Слушатель Жек Гебонс просит порекламировать, попиарить группу любителей FP в Новосибирске. Рекламируем. Ребята, группа FP в Новосибирске, с ней ваши волосы станут гладкими и шелковистыми. Приходите в темы к выпуску 27 и там найдите комментарии Жека Гебонса. И присоединяйтесь к группе. Так, далее, далее. Слушатель Берник сообщает, что вышла ScalaJS 0.6.0. Она разрабатывалась 2 года и стала совсем-совсем стейбл. То есть до этого считалась как бы экспериментал, а теперь она как бы стейбл. Ну, не знаю, прям все очень радуются этой новости. Прям буквально вообще все. Я ее даже добавлял в темы, но просто мы по времени немного не укладываемся. Я, честно говоря, не вижу, что тут можно сказать. Да, ScalaJS офигительно. Используйте все ScalaJS. Светлана? Я бы сказала, что используйте ее, но я сама ее не пробовала. Не могу рекомендовать то, что не использовала. Ну вот, но остальные вопросы слушателей как-то не очень вдохновляют. Ну, можно поднять холиварный вопрос тут от слушателя Алексея Фомкина. Станет ли функционаличным мейнстримом? Мы хотим это обсуждать. Ну, у нас сегодня не было ни одного холивара на самом деле. Но с другой стороны, у нас сейчас оно и не будет, потому что мне кажется, мы все на одной стороне силы. Я считаю, оно уже давно мейнстрим. Ну, то есть, как бы да, там совершенно Эльджер Кагибон совершенно верно замечает, что линк это типичнейшая эмманада. Она уже давно в C-шарпе. Один из самых интеркрайзнейших языков, которые есть. Есть более интеркрайзная только Ява, но в нее уже пришли лямбдачки, все, закругляемся, спор окончен. Ну, то есть, оно не вошло в мейнстрим как единственная парадигма, она вошла как дополнение, как в скале FP и OP. И вообще, я пишу на скале, я уже не вижу особых различий, я просто пишу на как бы и на том, и на другом. Там разница очень тонкая, буквально в том, что вот у тебя есть опшонал, у него есть сам, есть нан, и разница между FP и OP в том, что является ли сам самостоятельным типом или не является самостоятельным типом. То есть, там разница минимальная, поэтому как бы нет особого смысла. Ну, все-таки, то, о чем ты говоришь, больше про виды типизации, чем про FP или OP. Я скорее вижу разницу в том, что FP, почему программирование функциональное, потому что там объект, который оперирует функция. То есть, чтобы в Java что-то параметризовать, чистой Java, в которой еще старой не было лямбд, нужно сделать класс, который сгенерирует класс, который сгенерирует класс, ну, это просто синтаксически очень тяжеловесная конструкция, хотя по смыслу будет отражать то же самое, что замыкание. Замыкание, или на лямбдочке делают, очень быстро и просто. И поэтому в FP, поскольку во всех FP языках очень просто оперировать с функциями, там есть некоторый багаж подходов к тому, как дизайнить API из своих библиотек, из своего кода. Вернуть функцию из другой функции, это нормально, или принять функцию, сделать что-то из нее, вернуть другую функцию, тоже нормально. То есть, мы хотим одной функции вернуть другую функцию, ну пожалуйста, там можно писать пара строчек, и это очень активно много где применяется. А в случае с OP, возможности стараются избегать такого, потому что иерархия класса возрастает, и без того немаленькая. И приняты немножко другие подходы, и некоторые ограничения обходят всякими паттернами. Обратите, кстати, внимание, что когда Java самая первая релизилась, это что такое было? Это такой а-ля C++ с автоматической сборкой мусора, грубо говоря. Но GC у нас откуда пришел? Из Lisp. То есть это уже было привнесение элементов FP. Потом Lisp, он у тебя не говорит о том, что все данные должны быть мутабельны, он говорит тебе, что можно и так, и так. Ну, собственно, как и в Java. То есть Java это такой, условно говоря, Lisp с немножко другим синтеписом и без макросов. Ну, на самом деле, в Java дрались и Aberon, насколько я слышал, из cool story разных. Но, как бы, да, и Aberon, и Java тоже в норме заимствовали из еще более ранних языковых общественностей, из Lisp. Ну, то есть идеи, они как бы так берутся, хорошие практики, и намешиваются. Ну, то есть вообще, как бы, да, любая практическая программа, даже на чисто функциональном языке Haskell, будет содержать в себе 2-3 парадигмы, на самом деле. И на этой радостной ноте, я думаю, пора закругляться. Вы как считаете, друзья? Ну, не знаю, можно... А, вот, нужно еще одну совершенно необходимую вещь сказать. Говори. Да. Вот, я уже в прошлом подкасте озвучивал, но сейчас наконец появилась ссылка на вакансию в отличной компании Xanth, которая очень классная, и в ней все хорошо. Честно-честно, без подвоха, ищет Erlang-программиста, который был бы заинтересован в разработке системы хранения и агрегации временных рядов. Мы это делаем поверх React, ну, то есть, знание React по этому приветствуется, но не то, чтобы это прям супер необходимо в случае, чего научим. Главное, понимать, что происходит. Ну, и React, React-Core, кишки React, вот это все. Уникальная возможность поковыряться во всем. Ну, то есть, если вам интересно все эти чудесные алгоритмы, на которые вы облизываетесь и не знаете, а где же там практики применяют, ну, Paxos'а у нас нет нигде, потому что, по крайней мере, пока. Потому что там у нас API-стайл системы, и нам пока не очень это было нужно. Но, что касается, раз все как CRDT, и Gossip, и React-Core, и API-систем, ну, это как раз сюда.",
    "result": {
      "query": "распределенные алгоритмы в практике"
    }
  }
]