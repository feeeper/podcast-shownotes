[
  {
    "segment_id": "485e4fd5-c982-46b5-b44a-a2107d012392",
    "episode_id": "238e04da-da20-4232-ba7d-4c8c6b7ee1f9",
    "episode_number": 103,
    "segment_number": 12,
    "text": "Дальше на этот хип могут указать произвольное количество индексов. И primary key в этом плане – это обычный индекс. И... Это ведет к тому, что если у нас tuple с данными меняется, и на него указывают очень много индексов, то нам, скорее всего, придется перестраивать все индексы, потому что им теперь нужно указывать на новое место в хипе дисковом. В Postgres, на самом деле, насколько я знаю, опять-таки, мне очень интересно было бы услышать от Саши подробности, есть некоторые оптимизации по этому поводу, что, мол, если одна и та же строчка меняется часто в пределах там одного блока, то там вроде как не будет полного переписывания, перекидывания указателей. Если у тебя не поменялся тот элемент, по которому построен индекс, то используешь... Ну, то есть, понимаешь, да? У тебя tuple поменялся, но то, что ты индексировал все поля, они остались прежним предом. Да, и tuple поменялся внутри одного пейджа, да? Правильно? По-моему, так, да. То у тебя используется механизм ход, то, что действительно индекс не переостраивается. Вот. Но дело в том, что конкретно в их случае, а, конкретно в случае, так называемом, скиммалес, это обертка у фруктмастикуля, ну и, видимо, раньше Postgres, они имеют порядка 12 индексов на строчку, то есть у них так получается, что у них всегда что-нибудь, какой-нибудь индекс задевается. При том, что индексы для чтения используются нечасто, то есть как бы в Postgres индексы работают гораздо более эффективно, чем... в смысле, там меньше косвенных переходов, чем в том же MySQL, потому что в MySQL там, как это, там есть одна большая, то есть primary key плюс данные это такой как бы clustered index большой, и все остальные индексы, они просто такие бы деревья, которые ключ в виде всех полей, которые проиндексированы, в значении это просто указатель на как бы вот primary key и индекс. Понятное дело, что для записи это немножко приятнее, для чтения это дает лишний прыг, который можно было бы избежать. В Postgres этих лишних прыгов нет. Больше того, что еще в Postgres хорошо, архитектура Postgres, она позволяет таким образом строить всякие интересные индексы, то есть в Postgres есть gin индексы, есть водка индексы, есть GIS индексы, в MySQL это ничем не пахнет, просто потому что там архитектура такая, там сложнее это сделать. Вот. Как бы да. И из-за этого же, из-за того, что они натыкаются на тот точкейс, когда Postgres не может оптимизировать переписывание индексов, они напаруются на то, что у них в итоге очень высокий proliferation, поскольку репликация в Postgres самая рабочая до сих пор физическая, то есть когда просто транзакционный журнал перекидывается с машины на машину и при этом в него попадают, понятное дело, абсолютно все изменения данных, которые были на диске мастера, понятное дело, что если они напарываются на патологический кейс, который пишет много данных, понятное дело, что в репликацию-то, к сожалению, тоже попадает. По поводу плохого отношения на реплики, если я верно понял, там ситуация такая, что если у нас есть много читающих транзакций, которые надолго блокируют кто-то на реплике, то раньше был только вариант с тем, чтобы временно не читать из мастера, что в итоге приводило к тому, что физическая репликация немножко вставала колу. Сейчас есть механизм фидбэка, который позволяет мастеру, который говорит мастеру, что эй, вот там на реплике до сих пор кто-то читает, видит такую-то версию таблицы, поэтому, пожалуйста, если ты будешь делать это временно автовакуум, пожалуйста, не трогай такую-то версию. Сейчас это уже исправлено. По поводу апгрейдов, я думаю, Саша интереснее расскажет, чем я. Я Postgres не апгрейдил давно, и я не знаю, как сейчас дела обстоят. Я хотел бы вообще в целом про эту статью сказать. Сейчас Uber валит с Postgres на MySQL. В комментариях справили, заметили, что в 2019 году они валили наоборот с MySQL на Postgres, так что, как это сказать, они не консистентны, что ли, в этом смысле, все время валят куда-то. По поводу бультов, которые они там отметили, вот честно скажу, от меня, конечно, все ожидают реакцию, что нет, это все неправда. Да, у Postgres у него есть определенные недостатки. Мне эта статья, она очень напомнила, что чуваков сначала заставили свалить на MySQL, потому что пришла команда, которая написала им на MySQL на S систему, которая им там все решает. Скиманис. Да, да, да. А потом они уже под это нашли причины, почему они валят. Например, ты говоришь про... Я начну сначала с простого. Традиционно там приводится автовакуум, да, все пинают Postgres за автовакуум. Действительно, в MySQL его нет, но зато у тебя данные по диску разбросаны как попало. Это означает, что у тебя на практике почти любое обращение к диску, оно приводит к случайному чтению из разных мест. Подожди, подожди. Извини, мне как раз сказалось, что как раз в InnoDB, не в MySQL, а именно в InnoDB, мне как раз сказалось, что там кластеризованный, по крайней мере, primary index, он кластеризованный, и там как раз строчки подряд лежат. Не про index. Про что? Про heap. Так в MySQL же как раз нет хипа вроде как. Ну, хрен знает. Возможно, мне нужно освежить свои знания MySQL. Вот, насчет обновления, да, давай к нему перейдем. Ну, во-первых, из того, что я знаю, у тебя вот есть один шарт, ты действительно не можешь у него, например, сначала обновить мастер, потом обновить реплики, тебе нужно обновлять сразу все, если ты используешь stream replication. Но из того, что я знаю, это типа какие-то секунды простоя, ну, типа минуты в худшем случае. Как часто ты обновляешь по взрослым? Типа раз в пару лет у тебя один реплика-сет, там будет минуты не работать, ну, то есть это для Uber действительно прям такая большая проблема, или скорее надуманная. Для большинства твоих проектов это вообще не проблема. Плюс к этому на самом деле у тебя есть логическая репликация, которая по Г-логику, она немного такая нестабильная, экспериментальная, но по большому счету работает. То есть она просто новая, и в ней можно поймать новые баги, это правда. Если тебе нужна стабильная логическая репликация, пожалуйста, возьми тот же Слонни, например, или забыл, как там называется, то, что чуваки из Skype запили в свое время. То есть это вполне в продакшене крутится и работает. Вот. Что еще они там приводили, я, честно говоря, уже смутно припоминаю, потому что давно это прочитал. Ну, то есть там какой-то баг они называли, там знаешь, из-за разряда, но мы сидим на 9.2, мы понимаем, что это там типа версия пятилетней давности, и сейчас там 9.5 вышел, получается там скорее четырехлетней давности, да? Вот. Но мы все равно будем ругать 9.2 за то, какой он есть. Ну, окей. Ну, то есть как-то так. То есть найти там причины свалить с одного на другое, да, всегда можно. То есть они изначально валили на подвес, потому что в MySQL не было вот GIN индексов, да, вот всего, что им нужно. То есть у них основной риск – это вот найти, где сейчас находится пользователь, найти таксистов, которые находятся рядом с ним, и быстренько там предложить этим таксистам забрать этого пользователя, да, потому что ему нужно куда-то уехать. Ну, то есть согласитесь, да, это вот основное, что делает Uber. Сейчас они говорят то, что им на самом деле это не нужно, и они валят на MySQL, где этого нет от слова совсем. Ну, хорошо. То есть получается, раньше они про свои причины что, врали, или у них нет таких причин? Нет, мне кажется, они просто некоторое время назад, мне кажется, они уперлись в то, с какой скоростью работают GIN в Postgres, и в итоге они там, я не знаю, не помню точно причину, но помню, где-то видел статью, что они, по сути, замену GIN индексов написали в виде какой-то отдельной системы, которая вот занимается этим матчингом, и оно у них больше, вроде как, не в базе. Могу ошибаться. Помню, я видел такую статью, где вот что-то подобное описывало. И, как следствие, им это теперь не очень нужно, и им теперь важнее иметь storage, который под их паттерны записи лучше подходит. Тогда, мне кажется, несколько странно вообще использовать MySQL, ну, взяли бы, то, аля Кассандру, например, но они взяли и запилили свой распределенный MySQL зачем-то. Ну, тут мне тоже не очень понятно, то есть нужно смотреть, что у них там, это, с кем аля сумеет, что не умеет, потому что если у них там есть какие-то селекции, то есть судя по тому, что у них 12 индексов на строчку, у них, видимо, есть какие-то селекты, которые в Кассандре было бы сложно сделать, это вот моё такое подозрение. Вот, ну, в общем и целом, как бы, ну, ребята выбирают инструменты, которые им удобны, молодцы, нельзя их за это осуждать. Ну, кстати, я хочу заметить, что повторюсь, что даже если вам пофиг на то, почему Uber с чему-то на что-то пришёл, просто из как-то, из интереса к тому, как работают внутри всевозможные базы данных, там в плане того, где индексы устроены, как они, что такое кластеризованный и не кластеризованный индекс, я вот рекомендую посмотреть как раз на эту статью и на ссылку вот из useindex.luc, потому что там опять-таки есть дальше ссылки по этой ссылке, и в общем там можно довольно хорошо пополнить свой багаж знаний о том, как базы данных внутри устроены, если вам даже не интересно конкретно про Uber. А вот Ване, Свете, нечего про это сказать? Не знаю. Мне как-то странно вообще всё это видеть. Почему тебе странно? Ну, потому что теоретически команда, которая переводила с MySqueen должны были оценить это всё заранее, и, видимо, они этого не сделали. Ну, во-первых, команда меняется, смотри, это же быстрорастущий сетап, опять-таки вот по одной из ссылок, которую я там залинковал, человек верно говорит, что когда ты так быстро растёшь, у тебя, ты занимаешь очень много людей, у тебя average qualification людей падает, тебе становится проще и быстрее менять технологии, чем доучивать",
    "result": {
      "query": "Postgres vs MySQL index architecture"
    }
  }
]