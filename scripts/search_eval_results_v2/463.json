[
  {
    "segment_id": "9a318f74-84d4-4364-b3bd-70aa43697fb6",
    "episode_id": "7083d4cf-c1e4-4e57-b8ff-0b9c3ece234b",
    "episode_number": 463,
    "segment_number": 7,
    "text": "Еще есть то, что вообще никак не решает Abit'ом, но что можно докинуть библиотеками, что вы могли бы ожидать в другом, в кавычках, движке. Потому что движок, ну будем считать, что это tool kit для создания игр. То есть какой-то набор, с помощью которого можно создавать игры. Есть у нас библиотека, даже несколько библиотек для составления интерфейсов. Это тоже чаще всего code-first, но некоторые это где мы layout описываем через код. Например, в Qt так можно делать, хотя некоторые могут использовать графический редактор layout, но не суть. И некоторые поддерживают, например, загрузку через, условно по-моему, через HTML некоторые умеют импортировать layout. Таблицек, которые я использую, нет, но тем не менее, UI можно создавать довольно хорошо. Менеджер загрузчика ресурсов, я уже говорил. Есть всякие отдельные библиотеки, несколько разных для математики, то есть ничего для векторной математики, для матриц, веб-энжини нет. Ну вернее, там есть для своих нужд, когда нужно отрендерить что-то, там есть трансформация, но не для общего назначения, то есть для своей игры это сложновато будет использовать. Поиска пути веб-энжини нет, но есть несколько библиотек довольно хороших. Обработка ввода веб-энжини на уровне очень примитивном, это значит, что если вы хотите проверить кнопку, вы пишете в коде if, какая-то клавиша нажата, какая-то клавиша, например, enter, но есть тут проблема. У вас одно и то же действие может быть затригерено разными кнопками. Например, не знаю, на клавиатуре это escape, на геймпаде это кнопка back, на тачклине это что-то еще, свайп влево, например. И вам придется писать в коде if и через или все перечислять. Это не очень хороший способ, и вот, например, в Godot и во многих других движках есть система, которая позволяет определить ввод ввода веб-энжини на абстрактного, и у него есть connection с разными input вводами. То есть у вас в данном случае было бы три способа активировать этот action. И вот для этого тоже библиотеки есть, то есть не стоит использовать то, что есть прямо в веб-энжине, но он дает вот этот базовый низкого уровня API, поверх которого создана библиотека для того, чтобы хорошо обрабатывать ввод для кроссплотворных игр, которые в том числе могут работать с геймпадами, клавиатурой и так далее. Есть всякие production-ready штуки, вроде bindings для Steamworks. Я вот в Steam релизился, никаких проблем особо не было, у меня даже на Steam Deck все работает ожидаемо, то есть там клавиатуру можно вызвать, экранную, системную и все такое. Есть библиотеки для кроссплатформной работы с сейвами. Это может показаться странным, потому что если вы делаете игру, то скорее всего вы знаете, где вы храните сейвы. Но это не совсем так. Если делаете десктопную игру, то да, скорее всего это просто запись в файл, но Abit Engine поддерживает веб, это через вас им делается, то есть в браузере вы в файл просто не пойдете уже. Уже какой-нибудь OS write файл не заработает. На каких-нибудь Android просто в write файл тоже не получится, потому что там есть только определенный путь, где приложения могут писать. И подобные такие нюансы связаны именно с кроссплатформенностью. Вот библиотека, из которой это все инкапсулирует. Это аналог юзер двоеточия слэш-слэш из Godot. То есть Godot это в движке самом есть, а здесь это библиотекой можно накинуть. И даже, как я уже говорил, есть экзотика вроде проигрывания модульной музыки прямо из игры. То есть это все вот это, то, что можно сказать, что в каком-нибудь Godot есть из коробки, здесь оно есть в библиотеке, и есть список Awesome Abit Engine, где как раз такой довольно большой список этих библиотек. И вы это все себе складываете, и у вас получается более функциональный движок. То есть я никому не рекомендую использовать Abit Engine как есть. Это довольно больно и непродуктивно. Но если взять набор вот этих библиотек, которые за последние несколько лет довольно сильно лучше стали, их стало больше, банально, то получается совсем другой экспириенс. Есть некоторые другие проблемы, о них мы можем потом поговорить, но в целом, вот если бы я говорил, что такое Abit Engine, то это очень минималистичный движок. Потом мы накидываем это в библиотеки, берем внешние редакторы уровней, используем внешние редакторы для графики, типа Asprite или GIMP, и получаем в совокупности очень кастомизируемый экспириенс для создания игр. Я могу назвать плюс того, что это написано на Go. Это, наверное, тоже не сразу в глаза бросается, но представьте себе вот эту магию, что у вас в код движка есть простой GoToDefinition, просто кликая в IDE-шке. То есть вы вызываете какие-то функции движка, а это просто библиотека, которую вы импортировали в свой Go-проект. И если там есть какие-то баги, может даже pull-request выслать, потому что вы Go-программист, вы скорее всего там разбираетесь. Или, например, форкнуть что-то, поправить и использовать форк какое-то время. Это довольно большой контроль. И очень удобно, когда можно вглубь прыгать и прям дебажить один и тот же язык. Здесь, получается, нет разрыва между скриптами и движком. Обычно это... А, вот о чем я хотел спросить. Обычно это не так. Вот, например, в каком-нибудь Unity, то код пишется на C-sharp, который... Я не эксперт по Unity, но насколько мне рассказывали, он потом в плюсы конвертится. Но неважно. Сам движок написан не на C-sharp. И получается, что если ты вызываешь какую-то функцию, скорее всего, в лучшем случае там будет какой-то stub, файл. Ты прыгаешь, ты видишь сигнатуру, комментарий, но кода ты не видишь, он написан на другом языке. И это так довольно часто, потому что игры могут писаться, например, на Lua, и очень редко, когда сам движок написан на Lua. У Godot там есть GDScript. На самом деле движок написан на плюсах. Ты можешь использовать C-sharp, но у тебя просто будет виртуальный машина внутри движка, сам движок опять же на плюсах. И получается, ты всегда работаешь с биндингами на том уровне, когда ты прыгаешь куда-то, но вглубь ты не попадаешь. Ты не можешь вот так сквозную профилировать и дебажить. Опять же, профилировать прямо одно удовольствие, потому что у тебя в профиле будет и движок явно размечен, и твоя игра. Никакого дополнительного тулинга делать не надо. Обычно в IDE для разработки игр есть какой-то свой профайлер, который поймет, что есть какая-то часть движка, есть часть игры. Вот эти две разные сущности. Здесь можно все с точностью профилировать и дебажить без дополнительных тулингов. Прям дефолтное все, гошное, работает. Это довольно большой плюс. Это снижает порог входа. Согласен. Кстати, о снижении порога входа. С какой стороны лучше заходить в движок с официального сайта? Сомневаюсь, что есть книги, но вдруг. И как ты оцениваешь кривизну обучения и ее крутизму? У меня есть ощущение, что сейчас пока какая-то странная ситуация сообщественная, что движок, насколько я вижу, очень популярен в Японии, потому что автор движка из Японии. Там в Японии даже конференция есть по этому движку крупная, достаточно, ну, как понять крупная? Ну, если есть конференция по движку, то я считаю, это успех. В других странах этого нет. И получается, что вне Японии я бы сказал, что все довольно тихо, то есть есть активность. Мы пытаемся активными участниками как-то это продвигать. Сообщество других движков, например, того же Bavy, я бы не сказал, что оно больше, оно просто более активное, и поэтому там с этим ситуация порогов входа проще, больше материалов. Здесь это не совсем так, поэтому недавно я сделал документ, я ссылку на него привел, там это прописано как Ableton slash ru в моем домене, и там есть как раз гайд нового разработчика игры Nogo, там есть много ссылок, много подсказок, как начать для разных стилей внедрения. Например, можно пойти, по экзамплу, по дипломам ходить, а можно какую-то свою игру создать, но подглядывать в другие игры, чтобы оттуда портировать идею в свою какую-то, например, игру. То есть я рекомендую вот этот документ на ознакомиться. Плюс я сейчас пишу что-то вроде серии статей для разработки относительно большой игры на Abit Engine как раз. И там сейчас две части, но скоро будет третья, и там я стараюсь сразу же затрагивать сложные проблемы, например, структуризация проекта. Потому что движок Abit вообще никак практически не говорит, что где класть и как структурировать код. Это может быть довольно важно, особенно для начинающих, потому что игры все-таки немножко другое приложение, не как какой-нибудь бэкэнд. Здесь не сразу может быть очевидно, как вообще обойти проблему того, что в год циклические зависимости в принципе запрещены. Если вы захотите, например, сделать так, что сцены находятся в разных пакетах, и из каждой сцены из этих двух можно туда-сюда попасть, они друг друга импортировать не могут. Здесь вот даже на таком месте могут возникать проблемы. Так что вот, рекомендую эту страницу и плюс статьи на хабре. Но ведь статьи больше никто не читает, а теперь надо делать видео на YouTube. Я подозреваю, TikTok надо будет записывать. Но я готов даже к худшему. То есть я статьи допишу, это скорее скрипт для видео. Я когда допишу статьи, буду делать видосики. Но до хореографии еще далеко. До хореографии... Ты не знаешь, какую музыку я слышал до этого подкаста. У меня было два часа на подготовку, и я полторы часа слушал музыку Caramel Danson, если ты знаешь ее. Нет, наверное. Ну, то есть я, может, знаю музыку, я скорее всего не знаю, что это так называется. Я, кстати, хотел описать то, что Go на самом деле не такой уж и плохой язык для разработки игр. Его обычно сравнивают с тем, что он хуже, чем плюсы какие-нибудь. Я, кстати, не согласен. Отличный же язык. Как язык, скорее, мне кажется, вопрос в осу стоит у Линга, чем в языке. На чем только игры так-то не разрабатывают. Вот у тебя достаточно взвешенное мнение, но чаще обычно каждый выбор языка, который не является Lua, C++, иногда C-sharp, возникает часто у людей вопрос. То есть почти любой язык будет медленнее, чем C++, почти любой язык будет менее знакомый для скриптеров, чем Lua, и почти любой не являющийся C-sharp не будет самым мейнстримовым для игр. Ну, я не знаю, в каком-нибудь инди-сегменте. Поэтому получается, что Go можно с разных сторон играть и вряд ли в какой-то стороне победит. Но в целом он неплохой кандидат. Это распространенное заблуждение, что у C++ быстрый язык, потому что он там на определенных задачах, на каких-то бенчмарках победил другие языки. Но если большой проект рассматривать, у тебя существенная часть накладных расходов на время исполнения приходится на сборку мусора. В C++ сборка мусора либо ручная, либо на счетчиках на смартпойнтерах. И это означает, что ты обходишь мертвые объекты, чтобы их удалить. Тогда как в Go, наоборот, у тебя сборщик мусора по принципу Mark and Sweep, и он обходит живые объекты, которых статистически меньше, чем мертвых. Ну, статистически у тебя образуется много объектов, которые живут мало времени. Ну, знаешь, тут начинается... Ты не в тетебре уходишь. Тут начинаются аргументы по тому, что ну, а как же симд, вот это вот все, это гораздо легко пишется, гораздо проще писать на плюсах, в этом вашем Go нет симда, если только компилятор его не вставит, или нужна сембер вручную как-то вставлять, вот это вот все. Ну, я про то, что вот я беру, как мне кажется, достаточно насущную проблему, и как бы вот у меня не возникает впечатления, что C++ в задачах, где создается много временных объектов, он будет быстрее Go. По-другому еще нужно это ответить. Тут смотри, в случае с играми тебе важно не типа не худшее время, даже не то, как у тебя алгоритм, какая у него типа симптотика, тебе важна предсказуемость, потому что у тебя в одинаковом, в каждом кадре должно совершаться одинаковое количество работы. Не должно быть так, что у тебя типа 30 кадров, у тебя, не знаю, 29 кадров у тебя, работа совершается типа меньше, она, а потом вся работа по сборке совершается в 30 кадре. Но это тоже очень губительно. Это популярный наезд на языки со сборкой мусора, и опять же, ну как бы это хорошо работает, если ты там первый год-два программируешь, а вообще это все решаемые проблемы тем же переиспользованием объектов. Ты их один раз заалацировал и переиспользуешь все, никакой сборки мусора. Да, согласен с этим. Я, собственно, потому что мы просто не в те дебри ушли, я хотел другую такой менее умозрительный пример привести. Есть такой типа популярный движок, который мы сегодня уже упоминали, Unreal Engine, на нем много игр сделано, и вот есть такая особенность.",
    "result": {
      "query": "Abit Engine плюсы и минусы"
    }
  }
]