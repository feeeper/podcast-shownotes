[
  {
    "segment_id": "ba00c328-4299-43f8-9220-d95f2bf7dd62",
    "episode_id": "b4a2a9e5-1c51-4ae2-b00f-361c242ba013",
    "episode_number": 205,
    "segment_number": 9,
    "text": "Я, кажется, уже постил свой доклад. То есть не помню, был ли в Дэкзене, я в Twitter что-то выкладывал. По-моему, это был как раз... А, может быть, это был Грит. Ну, они выкладывали, по-моему, только пару залов сразу же, а здесь уже со всех залов доступно совершенно бесплатно. Что еще совершенно бесплатно? Это задачка про пятно. Да, это такая короткая тема. Меня очень... Мне недавно рассказали задачку математическую, и она меня очень зацепила, и какое-то еще количество людей вокруг. Мы все долго ее пытались решить, и она действительно сложная, но что приятно, что для решения не нужно практически никакой математики знать. То есть вот буквально даже уметь складывать, умножать не нужно. То есть все там, сколько-то классов в школе и сколько-то курсов в институте, они не нужны для решения. Формулируется она так. У нас есть бесконечная прямоугольная сетка с фиксированным ходом сетки. Допустим, это 1 см. Такая вот бесконечная тетрадь в клетке. Мы рисуем пятно в произвольной форме, но площадью строго меньше 1 см2. И вот вопрос заключается в том, можно ли нарисовать это так? Можно ли всегда с двигами и поворотами этого пятна сделать так, чтобы это пятнышко не попадало ни в один из узлов сетки, в узловой сетке от пересечения? То есть еще раз, есть тетрадка в клетку, рисуем пятнышко, у которого площадь строго меньше площади 1 клеточки, но в произвольной форме пятной. Можно ли его так поворачивать и сдвигать, чтобы оно не пересеклось нигде с узлами сетки? И-и-и-и-и-и очень крутая задачка, очень красивое решение, которое не требует знания никакой математики, выходящей из-за первой класса. Звучит как вопрос для интервью. Один из моих коллег постоянно на интервью эту задачку спрашивает, и еще ни один человек ее не решил. Ну то есть он обычно предупреждает, что это не та задачка, которую нужно решить, или которую ожидается, что ее решат. Ее еще и да, вот, собственно. А зачем он это делает, я интересуюсь. Он просто ради... Просто тратит время и свое и кандидата, правильно? Да-да-да. Он как бы использует этот момент для того, ну, момент интервью для того, чтобы проверить свою... Самоутвердиться, да? Нет. Я же говорю, он предупреждает, что это не... Задачка не повлияет на решение интервью, он просто использует момент интервью для сравнения с человеком, чтобы свое долгоиграющее исследование того, кто умеет решать такие задачки, провести. Я бы так сформулировал. Я так понимаю, он присутствует в противоположном. Саша, говори, пожалуйста. Известно, что ведь у любой задачи есть пустое, понятное и неправильное решение. И если человек на интервью сразу же его отвечает, ну, это что-нибудь о нем может быть сказать. Он поищет другое, или еще что-нибудь такое. Я думал, ты скажешь, известно, что на интервью спрашивают то, что ты сам узнал неделю назад, и теперь как бы блечишь умом. Тебе, Стас, слово. Продолжай. Ну, собственно, я сформулировал задачу. Я не знаю, если я могу кому-нибудь прислать на следующее дельзено решение. Если кому-то интересно, то мы можем попробовать порисовать, порешать. Характерно, что я довольно уверен, что решал ее и успешно решил, но я уже напрочь забыл какое там решение. Ну, видимо, это была довольно бесполезной для меня информация. Ну, потому что, да, я про нее года полтора назад слышал. Саша? Нам нужно не просто сказать возможно или невозможно, а найти условия, при которых это возможно, или сказать, почему нет. Не, ну, есть же просто. Если это возможно, вернее, если это невозможно, то нужно сделать пример, то есть придумать конкретную форму пятна и доказать, что это невозможно. А если утверждение обратное, то нужно придумать алгоритм, как всегда сдвинуть сетку или пятно так, чтобы узлы сетки не попадали на пятно. Для любителей головоломок. А всякие вырожденные случаи рассматриваются? Ну, я думаю, скажем, что у нее гладкая дифференцируемая. Края у нее гладкие и дифференцируемые. Чтобы, да, не рассматривать случаи, когда она не является площадью. Ну, там, мера площади для нее очень странно определена. Нет, просто обычная там. То, что можно нарисовать рукой, рукой, а ручкой не отрывая руку от бумаги. Ну да, важно условие, что она без разрывов. Я думаю, с разрывами тоже, ну, все то же самое будет. Но в оригинальной постановке она односвязная. А к чему нельзя применить слово «односвязная»? Это к своим языкам программирования. Я бы даже сказал, что к чему нельзя применить математику? Это к программированию, но идут большие споры о том, что в основном в твиттерах может быть, в программировании-то есть математика. Вот. И иногда применять математику все-таки полезно. Потому что некоторые виды программирования, например, функциональные, ну, они к математике, да, относятся довольно близко. Вот. И у меня я не знаю, вопрос такой к окружающим. Если бы вы придумали идеальный язык, на какой другой он был бы сейчас похож? Вот, 2018 на момент выпуска. Ну, мой идеальный язык — это типа Акамла, только с легковестными процессами, я бы так описал. Ну, и с синтексисом поприятнее, типа Кокускала. Просто языку уже почти 50 лет скоро, и все очень любят просто брать его и делать так же. И тащить туда все вот эти вот штучки, все попроколы. Тут, наверное, я хотел бы сделать поправку, что, конечно же, спрашивается, про какую задачу речь. То есть я в голове держал задачу про backend, webcheck, возможно, какие-то базы данных. Ну, то есть речь не идёт про embedded, речь не идёт про не знаю, HDL, ну, то есть понимаю. Язык общего значения... Так, а что не так с текущими языками? Зачем им ещё один? Так не на чём писать, вообще не на чём. Действительно, мало языков, надо больше. Поэтому компания сделала... Негодяйцы ни на что. Да, мы себе сделали ещё вязанку языков, чтобы не писать с руками, про это даже было пару языков здесь. Вот, и у меня постоянно бомбит от того, какими мы же их сделали, почему они такие сишные, почему... Ведь мы же не хотим писать на C, на самом деле. Но, с другой стороны, есть люди, которые хотят писать на C, и им тоже надо как-то угодить. И вот это такая большая проблема, что непонятно, как её тащить дальше. Поэтому эксперименты продолжаются, и сейчас я делаю очередной язык, который будет лучше. Альтернатив. Вот, и я занимаюсь этим пока что в формате экспериментов, пытаюсь втащить туда по одной рюшечке за раз. Например, а давайте не будем делать синтаксическое дерево, давайте сделаем его наборным из разных кусочков. Или... А давайте не будем делать много разных синтаксических деревьев для разных фаз, для разных проходов компилятора, и сделаем всё в одном. По-разному его перекрашивая, нотируя и так далее. Вот, к счастью, я делаю это на Haskell, поэтому это чуть легче делать. Но я думаю, всякие аккомлисты тоже понимают радости разговоров долгих в бесед с компилятором. И... Одним из требований моих, одним из моих предпочтений является как раз возможность подобных бесед с компилятором. То есть, когда ты хочешь что-то выразить, и у тебя есть три типичных исхода, это ты начинаешь писать, и компилятор тебе говорит, что «я не понимаю, что ты имеешь в виду, уточни, мне твои утверждения кажутся весьма туманными». Что в принципе соответствует... Про что было сказано в прошлом веке товарищами Черчим, Ховардом и остальными про то, что утверждения соответствуют типам в языках программирования, утверждения в логике. И если ваши типы похожи на логику, как во всех нормальных языках должно было бы быть, то вы пишете какую-то фигню, если она не помещается в компилятор. И компилятор вам об этом говорит. Ты в начале говорил, что хочешь заменить синтетические деревья чем-то другим. А на что конкретно ты хочешь заменить? Я про это чуть-чуть попозже скажу. Это был один из экспериментов. Просто казалось бы, такая базовая штука и не очень понятно, но ее либо можно заменить чем-то взаимно однозначным, типа стековой машиной. Неужто монадой? Если стековой, то можно. Вот. И если тебе удалось рассказать компилятору, что все-таки ты от него хочешь сделать какое-то утверждение, выразимое в его системе типов и соответствующее какое-то там утверждение в логике, то теперь тебе нужно предоставить ему пруфы. И это еще может вылиться в пару недель переговоров, потому что пруфов может не быть. И тогда компилятор получится предоставить тебе противоречие как в предыдущей задаче про пятно. И тебе придется выбрасывать все и делать заново. Ну и в конце концов эта увенчается успехом, и тогда у вас будет какое-то выражение про вашу модель, про вашу систему, про вот это все. У вас будут пруфы, и наконец-то можно с этим будет что-то делать. Вот, и если компилятор вам в этом не помогает, если ваше вообще в принципе среда разработки в этом не помогает, там и с IDE, и с редактором, и без, или что-то еще, вот, то мне кажется, что это очень странный язык, и использовать его, пожалуйста, не стоит. Ну, потому что червата ошибками, это невыполненные варианты runtime, которые можно было бы проверить в compile-time, и и прочие-прочие-прочие ошибки, которые некоторые из них покрываются тестами, отлавливаются, некоторые нет, поэтому хороший язык, это который вас будет не просто бить по рукам, как делают плохие статические системы типов, но еще будет вас учить. Ну, а вот тогда такой вопрос, вот я, конечно, сварщик ненастоящий, но... Кто же? Я просто вот часто слышу эту дискуссию о типах, и о том, что мы можем много чего доказать в compile-time, но достаточно редко слышу обсуждения про лога и связанных с ним языков, то есть, а почему бы не пойти дальше и не сказать, что а зачем вообще писать алгоритм? Почему бы не на каком-то языке спецификации декларативном, не рассказать, что ты в принципе хочешь? То есть, ну, один из примеров этого, это SQL, он, конечно, очень domain-специфик, но ты пишешь, что ты хочешь получить, а не как ты хочешь получить, а дальше там среда сама пытается, она статистику ведет, пытается что-то для тебя сделать, и там какими-то хорошо, ну, по крайней мере, хорошо вылизанными алгоритмами, то есть, а почему вообще не перестать программировать, а просто я хочу этого, сделай мне компилятор. Да, это хорошая идея, и примерно этого я хотел, и примерно этого я хотел добиться. А я хочу сказать... А пиши это тоже, да? Да, отчасти первая попытка была, а сделай-ка мне компилятор, вот у меня есть какие-то выражения, вот у меня есть какие-то стейтменты, такая библиотечка, типа у меня есть литерал, строковые, числовые, у меня есть рекорды, у меня есть там списки, но нет нула, например, не хочу я в языке, а еще у меня есть стейтменты присвоения, объявления типа, и там какого-то там ввода-вывода, принт. Вот, и как бы так исхитриться, чтобы из этого всего можно было просто набирать такие наборчики, типа сделай сам компилятор, как приходишь в ресторан, мне, пожалуйста, двойной JSON с выражениями и типами, и написанными, пожалуйста. Вот. Ну, про сказать компилятору, сделай мне еще один компилятор, я вспоминаю такой вырожденный случай языка, который, если мне не изменяет память, назывался hcq, в нем собственно в этом языке есть три команды, h это распечатать hello world, c это сделать компилятор самого себя, и q это написать на вывод q, то есть сделать client. Мы еще сделали расширение, которое делало 99 бутылок. Ну, он явно на нить уже не полный. Хотя... Вот примерно как раз расширение компилятора до поддержки бутылок, это примерно то, чего мне и хотелось получить. То есть ты берешь, описываешь для маленького-маленького кусочка, там парсер, претти-принтер и его представление, и потом дальше во что-то перегоняешь. Вот, но со всем этим оказалось очень неудобно работать, и этот первый эксперимент был отброшен. Потом я попытался взять одно какое-то конкретное аст, и сказать, что не хочу его дублировать 10 тысяч раз на каждый проход компилятора, потому что их там несколько было. Это парсер, это какая-то услышка русской импорты, резолвинг, имён, вот это всё, потом typecheck, потом дальше там ещё что-то. Вот, я хотел сказать, что, пожалуйста, продолжай использовать вот то, что ты сейчас используешь, только дорисовывай туда то, что тебе нужно новое использовать. То есть, изначально от парсера там известен только какая-нибудь точка в файле, из которого это было распаршено, и потом ты туда дописываешь, что, а ещё, вот это выражение, оно такого-то типа, и потом это выражение, оно отрезовывается там ещё куда-нибудь, и потом всякий фолдинг, там константы, прочие штуки дальше, и компиляторы вольно использовать вот это аст для каких-то своих совершенно целей, как угодно. Использовать просто как записную книжку всё аст, без дополнительных усилий, без переписывания термов тысячу раз.",
    "result": {
      "query": "задача пятно бесконечная сетка"
    }
  }
]