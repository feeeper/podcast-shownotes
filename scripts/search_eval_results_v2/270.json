[
  {
    "segment_id": "edda7ba4-3e8b-4267-a954-8c05235a213b",
    "episode_id": "1c6ebcec-3146-452e-a5b3-acb09c6cb9f2",
    "episode_number": 270,
    "segment_number": 7,
    "text": "Нет, я говорю о том, что в случае параллельных транзакций клиент будет получать разный ответ от участников, который будет говорить о том, что ему надо дождаться реального ответа. То есть в твоей модели каждая нода все еще может говорить произвольно, по своему желанию, на любую транзакцию, припарит либо абортит? Именно так, то есть каждая нода может ответить отрицательным образом, но при этом клиент может сделать эту оптимизацию только в одном случае, когда он принимает одинаковые ответы. И эти ответы, если они одинаковые, если это ок, значит это действительно ок. Если же хотя бы один ответ отличается, это означает, что транзакция может поабортиться, а может и нет, а значит ему нужно ждать окончательного ответа. Такой выдающийся ответ. А клиент ждет отовсех или от майжорити? Для консенсуса использовать. Вообще говоря, мажорити уже не достаточно для такого рода взаимодействия. Можно опять же поговорить о том, что достаточно, в любом случае точно достаточно ответы от всех учеников. То есть они не должны быть все живы. Если хотя бы один из них не жив, то уже могут быть проблемы, потому что мажорити недостаточно. То есть ты требуешь perfect failure detector в своей системе, которая не может ошибаться, не ложно положительно, не ложно отрицательно, так что ли? В данном случае нет, потому что мне не важно, если ответа ноды упала, мне это не важно. Главное, что она не может изменить свое решение, если она восстанавливает свое состояние после восстановления. Как клиенту понять, вот клиент начал ждать от всех подтверждений, когда ему переставать ждать, какая-то нода ему не отвечает, вот как он определит, она упала, когда нам по таймауту? В данном случае клиент делает fallback на более длительное... То есть есть, так сказать, fast pass и slow pass. Fast pass – это когда есть ответ от всех участников, а за какой таймаут? Ты таймаут, что ли, вводишь? Нет, если у тебя есть ответы, то зачем тебе таймаут? Нет, а как мне отличить slow pass от когда мне считать, что кто-то мне не ответил? Через 300 миллисекунд, через 30? То есть, собственно, к чему? Обычно в таких алгоритмах мы ждем majority, и это ок, потому что мы не сильно волнуемся, кто упал, кто не упал, если упали все, то мы в любом случае, мы в любом случае не работаем. А если хоть в каком-то моменте мы начинаем ждать всех, то вопрос, когда переставать ждать всех, то есть когда мы считаем, что какая-то из ноды упала. Вопрос, понятно, еще раз, значит, есть fast pass и slow pass. Значит, если мы дождались ответов от всех участников, и эти ответы одинаковые, это fast pass. Если мы не дождались, секунду, если мы не дождались, например, мы можем дожидаться действительно в течение какого-то времени, например, одну секунду или 100 миллисекунд, это не важно. Если мы не дождались ответов, то, соответственно, мы переключаем в slow pass, но это не клиент на самом деле переключается, это вся логика, включая клиента. И, соответственно, мы тогда ждем действительно полноценный консенсус, который отказоустойчивый, который не требует доступа всех нод, но мы тогда должны ждать ответа от самой группы, то есть от самого шарда. Вот. И тогда число раундрипов начинает расти. Окей, я, кажется, понял, и все равно, мне кажется, здесь есть проблема. Вот. И сейчас, ну вот в терминах Paxos ты все-таки ждешь стейта, который называется accepted, а не decided в своем fast pass. И здесь... Давай я попробую описать ситуацию, в какой, мне кажется, здесь может произойти что-то не так. Вот, допустим, клиент разослал всем prepair, каждая нода заприпарила, и вот рассматриваем теперь последнюю. Последняя от всех успела собрать вот за там 100 миллисекунд подтверждение, и она закоммитила эту транзакцию, но сама не получила ответа. Ситуация 1. Она о своем prepair никому не рассказала. Это ситуация 1. А ситуация 2. Это точно такая же ситуация, где последняя нода заабортила, от всех приняла prepair, решила аборт, и никому об этом не рассказала, как бы ни о своем изначальном аборте, ни о том, что она заабортила. Вот с точки зрения остальных нод вообще нет никакого способа отличить одну ситуацию от другой, если мы не придумали. Так, во-первых, это уже вопрос несколько другого. Значит, ты писал, как мы делаем консенсус за 0 round-trips, при этом у нас еще нет двухвазного коммита. Нет, сейчас, я говорю, что вот из рассмотрения вот этой ситуации следует, что если у нас одна нода упала, то мы про эту транзакцию вообще никогда ничего не решим. То есть на оставшихся нодах нет достаточного количества информации, чтобы понять, что происходит. То есть у нас как бы fail tolerance 0 нод. Так, еще раз, сейчас я не говорил про двухвазный коммит и распределенную транзакцию. Сейчас я говорил только про, как сделать, как убыть консенсус, превратить из одного round-trip в эффективных 0 round-trip, в котором клиент может предугадывать будущее. Теперь мы можем поговорить о том, а как это использовать для двухвазного коммита, точнее, как все это сформировать в том, чтобы у нас получить суммарно 1 round-trip клиента, вот именно стартуя с самого клиента. Что мы делаем? Например, у нас есть 4 шарда. Вот у нас есть 4 шарда. В каждом шарде, каждый шард участвует в консенсус-группе, в которого 3 участника. В итоге у нас получается 12 разных участников. 4 шарда, в каждом по 3 консенсус-ноды. 12 участников. Что делает клиент? Клиент рассылает всем 12 участникам то, что он хочет сделать. При этом понятно, что шарду он шлет непосредственно то, что должен сделать этот шард. То есть он не шлет ему записи других участников, он просто шлет записи конкретно этому шарду, но при этом он шлет еще информацию о том, что есть другие шарды в рамках этой транзакции. И что он делает? Он дожидается ответов от всех 12 участников. Если хотя бы какой-то один участник упал, то есть он не ответил, то, соответственно, для этого шарда мы переключаемся в slow pass и, соответственно, мы проводим нормальный консенсус, смотрим, окей или не окей, и, соответственно, если все окей, значит собираем ответы. Таким образом мы получаем, что мы за один round trip, если все участники живы и все работают как надо, можем понять, будет ли окей и что вообще закоммитится и в какой порядок будет. То есть клиент это все узнает и, соответственно, если они разослали всю эту информацию и поняли, что да, вот такая у нас очередность происходит, они могут сделать это решение. Таким образом мы приходим к одному round trip, но это только в случае серьезных предположений о том, что все участники живы и нет конкурентных запросов, о чем, собственно, я в статье по-моему явно везде описывал. Могу я предположить подолгопаузе, чтобы тема себя исчерпала? Ну, я, собственно, не понял, как меняет то, что я сказал до этого, что если, вот так как ты описал, клиент отправил на все, на всех, на все ноды свою транзакцию и одна из групп, консенсус групп ее заабортила или заприпарила, но при этом сама успела собрать подтверждение это всех, но я, наверное, сейчас понимаю, да, то есть у тебя она целиком никогда не может упасть, потому что она забекаплена, поэтому у нее будет просто промоушен. Ок, я, наверное, тогда вот, вот, вот, что не понимаю, как получается, что клиент отправляет не на мастера, а сразу на всех участников консенсус группы, они обязаны приходить к одному и тому же решению или это вероятностная процедура? Как только у тебя есть, как только все участники согласились на это значение на этом шаге, они начинают делать консенсус, в котором у тебя нет лидера и, собственно, они договариваются и они приходят к одному и тому же, потому что у них пропозал один и тот же, можно показать, что если пропозал один и тот же, то консенсус вырождается, они не могут ничего другого предположить, кроме того, что у них есть, они обязаны прийти к этому значению. Собственно, вот ответ. Ну, я, наверное, понял, да. Да, спасибо. Вот, да, я отвечаю на вопрос, Саша, наверное, если у вас еще нет, больше нет вопросов, то у меня, наверное, не закончились. Ок, потому что я бы хотел послушать от Валеры про Space. На самом деле, тут какая-то микро-новость, там ее в тему слушателей принесли, вот это все, это просто как-то изображает одной строкой, вот такая вот фигня случилась на этой неделе, JetBrains выпустили свой собственный Атлас. Стас мьет. Стас, Стас! О, нет, он ушел, оставив микрофон, но вроде не шумно. Извини, парни. Очень обидно, что в Mumble нельзя просто замикать человека насильно, это бы нам очень помогало. Да, это классная фича, фича-реквест.",
    "result": {
      "query": "distributed consensus round trips"
    }
  }
]