[
  {
    "segment_id": "7be9af5e-eae2-4a5c-aee4-05a185beea0d",
    "episode_id": "6a7c0e85-1e66-48c4-8043-16b0aa31af9d",
    "episode_number": 246,
    "segment_number": 5,
    "text": "22 страницы, совершенно не сухого, наполненного кучей, я не знаю, литературного языка статья, в которой множество слов, которые совершенно не относятся никак к техническому английскому, и из-за этого становится ее читать сложно. И довольно литературные обороты, сравнения, гиперболы и так далее. Поэтому я не скажу, что мне было очень легко читать. С другой стороны, тема очень интересная, и тема про то, как автор воспринимает язык C и его восприятие языка C, я внезапно понял, что я согласен с ним. Но я совершенно не задумывался об этих вопросах до того, как прочитал. Многие воспринимают язык C, особенно в сравнении с другими языками, как вот давайте мы напишем свою программу на C, или мы, пожалуй, не будем писать свою программу на C, то есть рассматривать только с точки зрения написания своих собственных программ. По факту язык C это нечто большее. Это система, на которой зиждется современная IT. Потому что большая часть системного софта, если не вся, она пишется на C с той точки зрения, что у вас есть какие-то куски вашей системы, не знаю, операционная система, какие-то драйвера, какие-нибудь программы запускаемые, еще что-нибудь. Они фактически используют одно и то же оборудование, одну и ту же инфраструктуру. Но при этом у них нет никакой договоренности между собой об интерфейсах, у них нет никаких, я условно здесь говорю, на самом деле все это, конечно, есть на уровне A, B, A, B, но это как раз и показывает, что этот интерфейс был создан благодаря C, и только благодаря C он поддерживается в текущем состоянии, и поэтому наши программы продолжают работать. Поэтому автор выделяет два направления у языка C, это написание своих собственных программ, а во-вторых это коммуникативное направление, как он его называет, когда ты можешь связать вообще любую программу с любой другой программой фактически через память, потому что большинство общения, большинство обмена информацией и так далее нуждается в каком-то канале связи, и вот память выступает замечательным общим каналом связи. Неважно, как вы будете работать с этой памятью, как вы будете копировать каким-то образом, что-то пересылать, все равно вы как-то будете через эту память взаимодействовать. И с этой точки зрения C выступает в качестве уникального средства, когда ты можешь просто сказать, а вот здесь вот по смещению 22, 15, 68 у меня будет лежать кусок памяти, и нужно выполнить функцию, которая начнется со смещением 15 от начала, ну 15, конечно, не начнется, но 16 может начаться. И возьми этот кусок памяти, воспринимай его как функцию и начинай его выполнять. С этой точки зрения C, конечно же, небезопасный язык, когда многие говорят, сравнивают безопасность языков, но с другой стороны вы не сможете создать вот этот коммуникативный слой, имея полностью безопасное вычисление с доказательными системами и системой типов полноценной. Ну или сможете, но пока наука до этого еще не дошла, и таких систем пока не существует. И поэтому нельзя сравнивать безопасность C с другими языками, потому что чаще всего производительность вам не нужна, когда вы пишете на C. Здесь я так парочку абзацев или страниц даже потратил на то, чтобы он доказать, что на самом деле производительность не так важна. И я вас интересующихся отсылаю почитать эту статью. А важно именно либо простота, которая хуже воровства, либо коммуникативность. Очень много интересных моментов, связанных с безопасностью. Вообще вот здесь я хочу задать вопрос. Скажите мне, пожалуйста, что такое безопасный язык? По вашему мнению. Валер, что такое безопасный язык? Чтобы лапку себе было отстрелить сложновато. Ты можешь как-то более формально описать? Сори, у меня там грузовики за окном ездят, я окно закрыть не могу. У меня там в Берлине жарко. Вот, смотри. Формально, наверное, тяжело объяснить. Наверное, можно попробовать объяснить в таких терминах, которые были бы соотносимы с опытом использования этого безопасного языка. Мы берем, пишем какой-то код. И если у нас в коде появляется какая-то ошибка, которую, если бы мы были внимательны, мы бы не допустили. То есть оно не приводит к тому, что в нашем коде появляются, или с маленькой вероятностью приводит к тому, что в нашем коде появляются уязвимости, которые могут эксплуатировать внешние атакующие. Я могу описать, что такое для меня безопасный язык. Для меня безопасный язык это как го, в котором убрали эти бесполезные указатели. Особенно null-пойнтеры. Гос-мэйби, вот так вот. Но ты можешь формально дать? Куда формальней? Я не знаю, насколько правильно, но для меня это безопасность эквивалентно слова segmentation fault. Насколько это грамотный подход. То есть, по-моему, можно языки отсортировать по тому, насколько легко уронить программу с exception, который будет неперехвачен обработчиком исключений. Вот слушателям сразу вопрос вы немножко подумайте и сами скажите, что такое безопасность. Поставьте на паузу, если хотите. Автор дает следующий ответ. Во-первых, он говорит, что нет единого мнения, что такое безопасный язык, и поэтому спорить о безопасности языков вообще бесполезно. Мы сейчас обсудили, что есть три разных определения, они довольно сильно отличаются между собой. Он привел ссылки на несколько статей, в которых определяется безопасность. Он считает, что в принципе самыми важными являются два определения. И мне было прямо интересно почитать. Первое определение – это перехватывать ошибки или иметь возможность их перехватить удобно и быстро, сразу после того, как они появились, вместо того, чтобы это было неявно и с возможной поломкой программы позже. Первое определение безопасности. Второе определение безопасности – что поведение программы, любой программы на этом языке, может быть, легко понято и обработано в терминах семантики самого языка. В смысле, ты можешь на этом самом языке написать что-то для того, чтобы это было... Ну, как бы осуществлял разбор программы, и семантику можно было понять. Вот два определения, которые он рассматривает, он привел ссылки на статьи, где вы можете почитать больше про эти определения. И с точки зрения безопасности, он приходит к выводу, это выводы уже автора пошли дальше, что безопасность для многих обозначает правильную работу с памятью, с указателями и с ошибками, связанные с этими указателями и ошибками. И, соответственно, если у тебя происходит автоматическая работа с памятью, то есть у тебя есть garbage collector, у тебя есть какой-то вывод типов, у тебя есть автоматическая работа, сколько тебе нужно памяти для данного куска, то чаще всего все подобные языки называются безопасными. Здесь я машу двумя пальцами в кавычки, и вы их не видите. К сожалению, это автоматически означает, что язык C не может быть безопасным, потому что у него есть коммуникативный уровень и коммуникативное направление работы, где не может быть подобной безопасности для него. И получается, что если вы хотите создать, как это сказать, не то чтобы систему, а возможность создавать инфраструктуру, и возможность создавать систему на основе нашего железа, мы обязаны иметь небезопасный с этой точки зрения язык, который будет на нижайшем уровне связывать все работающие системы на компьютере. Я думаю, что вот это и есть главная идея всей статьи. И там есть много дополнительных идей, где он рассматривает, что такое и почему были введены undefined, unspecified, implementation specific, который в C часто ругается, он доказывает, что это было необходимо и по-другому было сделать нельзя. Он рассказывает про то, что безопасность на других уровнях добавить можно, но нужно очень много исследований, и по мне он не ответил на этот вопрос вообще, что там можно сделать с точки зрения безопасности. Но статья однозначно интересная, и для тех, кто интересуется языком C, я очень советую ее прочитать. Но сразу готовьтесь, она не техническая, это просто размышления автора на тему языка C. И спасибо большое, кто пнес, я очень благодарен. А что еще, возможно, написано на языке C? Ну вы что, специально ждете моего плавного перехода? Я уверен, что вы большие котятки и можете сами сделать плавный переход. Что еще может быть написано на языке C? Возможно, прошивка новых наручников Саши? Как если бы Валера был ведущим, и все ждали, когда он выберет следующую тему в самом деле. А то они не по порядку лежат. А то они, может быть, не по порядку лежат. Но это не наушники Саши, на самом деле, это наушники, которые Саше дали потрогать ненадолго, и Саша впечатлился, потому что на самом деле Саша обычно пользуется, помимо того, что он говорит о себе в третьем лице, обычно пользуется простыми наушниками, такими типа затычками, ну не считая одних аудиотехника, которые Валера мне одно время советовал, я даже не помню, что там за модель была, Валера, ты не помнишь? Твоя любимая. Техника, наверное, М50, я свои М50 продал уже, потому что они у меня стали старенькие и дряхленькие, и я их продал кому-то, кому они были нужнее, чем мне. У меня сейчас из проводных только мои Bowers & Wilkins, которые тоже ломаются, у них душка сломалась немножко металлическая в печали. Нет, у меня эти ушки всё ещё есть, они вполне себя живут, но в них достаточно плохо дышат ушки, и это меня печалит.",
    "result": {
      "query": "what makes secure programming languages"
    }
  }
]