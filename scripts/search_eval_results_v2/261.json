[
  {
    "segment_id": "61ee14bb-e889-40e6-bc2b-013c3a614516",
    "episode_id": "e8e19618-fbac-4ff1-b61b-4eff5cd47d71",
    "episode_number": 261,
    "segment_number": 2,
    "text": "А кто ещё котики, это разработчики… Подожди, подожди, подожди, я сейчас хочу остановить на секундочку. Я же правильно понимаю, что глич в прошлом выпуске подкаста мы не выяснили, с чем был связан? Ну звучало, как если бы там терялись пакеты, а потом в постобработке вырезались паузы, но да. Ну короче, мы за это извиняемся, но в общем мы не очень понимаем, что произошло, но мы постараемся, чтобы так больше не было. Ну по-моему звучало прикольно, вот я так представил, что у Валеры микрофон с магнитной лентой, и вот там что-то зажевало. Ну на самом деле я думаю, что возможно, потому что моя запись была с платформы Windows и мама была 1.3.0, возможно, с этим какая-то проблема, посмотрим. Ну так 1.3.0 это… Это очень новая версия. Да-да-да, у меня 1.2.19 сейчас. Ну да, в том надежности старее и надежнее. Ну как старее, я раньше под Linux когда сидел, там была более старая версия. Вот, но не важно. Вот, а что важно, что важно, это язык go-lang и его линкер. Валер, а напомни, какой у тебя микрофон, как он называется? Rod Wireless Go. Видишь, вот подвозка go. В общем, новость у нас о том, что go собирается переделать новый линкер когда-нибудь. Может быть, в ближайшее время, может быть, не очень. План уже написан, есть некий пропозл довольно большой про то, как сделать новый хороший линкер. Из того, что я понимаю, основная у них мотивация в том, что его автор ушел на пенсию, его автор это Кен Томпсон. Вот, и как следствие из того, что он был его автором, у линкера есть некие определенные проблемы с точки зрения кода, с точки зрения его структурируемости, с точки зрения его частоты. А если учесть, что он изначально был написан на C, потом автоматически транслирован в Go, то его потом довольно немного причесывали, то, конечно, не самая идиоматичная Go программа с некоторым количеством проблем. Вот, ну и поскольку майнтрейнера какое-то время уже не было, и он более-менее создавал проблемы, создавал проблемы с обчинением зад, создавал проблемы с подтверждением памяти. Можно я тебя буду перебивать? Надо. Отлично, что значит не было майнтрейнера? Ну, смотри, то есть как бы Go, несмотря на то, что там это Google и всё такое, команда разработки Go довольно небольшая в целом. Команда разработки там, например, рантайма, компилятора и так далее, она ещё более небольшая. По сути, Кент Томпсон написал линкер 1, да, но там частично использовался наработки линкера пом 9, по сути, он его написал 1 и ушёл на пенсию после этого. Вот, и, соответственно, получалось так, что линкер был плюс-минус неподдерживаемый, то есть у него не было выделено майнтрейнера. То есть если там в разных частях рантайма есть ответственные люди, гарантированно к ним привязаны, то линкер как бы такой очень оптималист. Но при этом баги-то фиксились и добавления делались, насколько я понял по тексту этого документа, причём добавления были очень большими, так что поменяли логику в некоторых местах. То есть отсутствие линкера не помешало развитию этого линкера, но помешало чему? Ну, развитие, как бы это одна часть, да, майнтрейнер это другая часть. То есть не было человека, который был способен сказать, что всё надо тут переделать, тут подставить, и по сути они его патчили и патчили, как могли, совместными усилиями. Но Зарялый узнал, что необходимость переписывать. Я немножко удивлён, что я узнал, что у ГО есть свой линкер, казалось бы, а чем не линкуется с существующими линкерами? То есть ты обж файлы нагенерил и линкуешь? Чем попало? Нет? Это не так работает? Ну, во-первых, у ГО свой объектный формат. То есть как бы у него, если ты пишешь. Да. Ну, я думаю, это вызывает вопросы. Я понял, его же, вот этот обж, его не в Гугле изобрели, всё правильно, да-да-да, нам нужен свой формат. Ну вообще его не в Гугле изобрели, его изобрели автор в план 9 до того, как ГО вообще появился на свете, если Ну, опять же, это во многом исторические причины, то есть изначально runtime toolchain ГО использовал toolchain план 9 просто потому, что его авторы были гораздо лучше с ним знакомы, они его, собственно, сами написали до этого, поэтому использовали то, что есть для Bootstrap, а дальше постепенно кусочки разные изменялись, там где-то можно, но всё равно линкер использовал свой собственный формат. То есть отчасти исторические причины. Собственно, есть там более реальные причины, потому что, ну, тут другая программа, немножко другая, есть некоторые особенности, и свой формат выходил лучше. Ну, в общем, этот документ, на самом деле, и описывает, какие тут плюсы есть, какие минусы, и как они хотят тоже это всё переделать. А можно дальше пока не уходить? Мне хочется какой-нибудь истории, если ты её знаешь. То есть всё Unix-сообщество фактически живёт на этом ELF — executable linkable формат, который не принят как стандарт, но он фактически используется как стандарт, там, не знаю, с давних-давних пор. Почему Go не подходит? Я могу одну причину назвать, простите, что за лёшек говорю, но как минимум, поскольку Go язык кроссплатформенный, то возникает проблема, что у тебя на разных платформах всё-таки разные форматы. Вот я говорил obj, obj, а ты назвал ELF, потому что, ну, как бы в Unix действительно ELF. При том, я не сильный эксперт, но я слышал, что ELF, и они немножко там разные в Mac'ах и в Linux'ах, например. Если тебе нужно собирать программу под разные платформы, то там, ну, представляешь, какие сложности по поддержке возникают. Отлично, то есть у какого-нибудь там, я не знаю, GCC, который кроссплатформенный, эта проблема не вызывает. У какого-нибудь LLVM эта проблема не вызывает. Я сейчас могу назвать ещё кучу компиляторов, у которых эта проблема не вызывает, а у Go эта проблема вызвала. Проблема возникает в том, чтобы генерировать под конкретную платформу объектные файлы. То есть как бы у тебя не проблема собрать, ну, слинковать не GCC, а CLAMP под разные платформы, разные объектные файлы, но тебе для этого сначала нужно сгенерировать объектные файлы, а ещё тебе нужно потащить CLAMP как зависимость. Ну, то есть я в целом могу понять. Да, я вот, если честно, не понимаю. То есть я за стандарты, которые приняты в сообществе, я за то, что этот стандарт будет развиваться. То есть если у GoLang была какая-то проблема с текущим стандартом, ну, блин, предложите какое-то изменение стандарта. Они вместо этого сказали, не, всё нафиг, мы знаем лучше, что надо делать, давайте мы сами напишем. А потом внезапно через 5 лет говорят, о, кстати, а что-то у нас линкер тормозит, потому что мы его сами написали для нашего собственного Ops-файла. Ой-ой-ой, как же так? Парни, во-первых, конечно, я не эксперт, но мне кажется, вы ещё менее эксперты, чем я. Я поэтому и задаю этот вопрос. То есть, во-первых, ELF это действительно executable формат, это формат для экзешников. Не-не-не, не только. Вот-вот-вот, сейчас ты немножечко не эксперт, ELF это формат, примерно, для всего, и для динамических библиотек, и для исполняемых файлов, и в том числе для того, что линкуется. И там и tooling прописан, и ABI прописан, там много чего прописано, это огромный стандарт. Но, кстати, это, возможно, одна из его проблем, что он такой формат для всего. Смотрите, ещё раз, то есть независимо от того, какие промежуточные форматы, то есть любой Ops, любой объектный формат может быть какой угодно. На выходе на Linux должен получиться ELF, потому что в нормальной ситуации ничего другого в Linux запустить не может, ну, типичный Linux. Зато на Mac OS, на Mac OS и ELF тоже нет. То есть там бинарно, в своём собственном формате, там Mac CO или как называется, там Mac O. Вот, и, соответственно, ELF там тоже не используется. Дальше всякие инструменты типа GCC и так далее, они поддерживают большой кучу форматов, но они как бы сильно-сильно большие по размеру. То есть я думаю, там, компилятор, не знаю, C в GCC, маленький кусочек GCC, больше, чем Go вместе с Netcube Library вообще всем. В том числе за счёт поддержки этих форматов. Вот, поэтому, да, объектный формат в Go свой, и сделаешь бинарный, конечно, там, на Linux ELF, на Mac и Mac OS, на Windows CPE и на следственных платформах как надо. Объектный формат свой. Вот, что касается, почему они изобрели свой и так далее. Опять же, вы говорите там Unix-like, и всё должно быть как на Unix, но, на самом деле, это не Unix-оперативная система, это другая оперативная. Это изначально был исследовательский проект, который появился после Unix, как бы, как следующая большая оперативная система после Unix. И они много там делали своего, там, не знаю, другой подход к файловой системе, другой подход к сети, даже подход, что не всё файл, а всё pipe, там, точнее, всё файловая система и так далее. Да, в том числе там полностью был свой туннель и свой формат. И поскольку эти же люди, собственно, этим занимались, они просто портировали Go, используя этот туннель. То есть, я не думаю, что здесь какая-то там тайна сговор, not invented hair синдром, Google, сейчас только прочая Google, здесь, мне кажется, появился очень поздно во всей этой картине. Но мне кажется, что ты не ответил на этот вопрос. То есть, чем не подошёл Ляйф, ты пока не ответил.",
    "result": {
      "query": "Go linker format issues"
    }
  }
]