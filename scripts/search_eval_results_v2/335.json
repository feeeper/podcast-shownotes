[
  {
    "segment_id": "ebeaf8e4-f45e-4e5f-9131-d121ee983726",
    "episode_id": "01cde138-e34e-400b-a839-0bfd4009109b",
    "episode_number": 335,
    "segment_number": 10,
    "text": "Она как бы настраивает на гораздо более конструктивное обсуждение, чем если я считаю, что было так, давайте делать, ну что, вот такой путь правильный, и я прав. Я пока искал КДПВ, вопросы с чата озвучили правильно? Да, уже даже ответили. Я это еще вспомнила, я когда-то слушала историю в какой-то подкасте, вот прям просто мне вспомнилось, был, есть компания Johnson & Johnson, американская, и у них был большой кризис, когда по-моему в детское питание то ли мышьяк попал, то ли еще что-то. То есть там было какая-то, ну очень большой скандал, когда несколько людей умерло из-за того, что вот что-то не так произошло в процессе изготовления их продукции. И это считается одним из классических примеров, как компания, когда прям очень сильно накосячила, как нужно исправляться. Я точно не помню, как это все было разрулено, я попробую найти эту ссылку на этот вот кейс из HBR, но вот прям Johnson & Johnson, они сделали вот все правильно, и это считается таким эталоном, как компания выходить из серьезного кризиса. Вот я попробую найти это. Да, спасибо, прийду к купшему ноту. Я думаю, мы очень плодотворно обсудили эту тему. И дальше у нас рубрика «ненадежный Зен», и первая тема в ней про уязвимость в Hombrew, которая была на прошлой неделе, по-моему даже, и я ее даже подзабыл, там что-то с Гехабом было, Валер, ты помнишь детали? Я совсем детали уже, конечно, тоже не помню, но основное дело было в том, что у Hombrew есть процесс по принятию плуреквестов на основе чего-то в духе автоматически прогнали, ничего не сломалось в мерджи. Насколько я понимаю, так сделано, потому что в Hombrew, поскольку это менеджер пакетов, где пакеты мейнтейнятся при помощи плуреквестов, было бы тяжело отсматривать человеческими глазами все возможные плуреквесты. И в общем, вот плуреквест, который автоматически оценивается, я уже не помню детали, что именно туда можно было гадкого положить, но в общем можно было положить что-то настолько гадкое, что оно проверку-то пройдет, а ко потом все равно произвольное выполнено. Я уже не помню, то ли на CI, то ли на машинах-пользователей, но это даже не важно, потому что где-то можно выполнить произвольный код. Это не очень хорошо, мягко говоря. Что еще ненадежно, это Postgres, как ни странно, и распределенная система в целом. Как вам может быть известно, в Postgres есть довлер? Традиционный дисклеймер, что если вы пишете распределенную систему, возможно по возможности не делать этого. В Postgres есть репликация синхронная и асинхронная, а также физическая и логическая, и много разных флагов для управления ею. В 9 какой-то был реализован параметр, называется Remote Apply. У вас есть мастер и реплика, когда вы выполняете транзакцию на мастере и потом говорите commit, ваша транзакция не пройдет до тех пор, пока она не будет закоммитирована на реплике. Количество реплик тоже настраивается. Там можно выбрать хворум из N, у тебя 5 реплик, ты говоришь, что ты хочешь, чтобы хотя бы на 3 закоммитировалось. Или на любой из заданных, при том, что у тебя опять же 5 реплик, ты говоришь, что те 3 самые важные, на любой из них должны закоммититься. Это достаточно гибко настраивается. После чего у тебя на мастере происходит commit, и ты получаешь ответ, что все закоммитировалось, все здорово. Это решало такую проблему, что до того, как это было реализовано, не было Remote Apply, ты мог закоммитить транзакцию на мастере, потом пойти на реплику и прочитать там старые данные. И в целом ожидание такое, что либо у тебя транзакция локально не закоммитится, и тогда этих данных не будет на реплике, либо закоммитится, и тогда у тебя данные везде. Это твои интуитивные ожидания от поведения этой фичи. В Postgres это работает не совсем так, как ожидается. На то есть веские причины. Поскольку в Postgres не используется модные протоколы типа Raftopax и еще чего-то, в Postgres он все равно достаточно просто. И в Postgres пишется Write a Headlock. Рэта Headlock реплицируется как есть на все реплики. Ты не можешь откатить что-то из того, что уже среплицировалось. Ты не можешь среплицировать часть, ты не можешь придержать кусочек Write a Headlock, потому что у тебя параллельно много транзакций выполняется, не только твои, ну как бы в заданной сессии. Извини, я немножко доказать, дополню, что как бы commit транзакции, поскольку мы говорим про логи, а не про транзакции, то все-таки commit транзакции это будет у всех в логи. Откат транзакций он тоже у всех в логи будет, это просто будут отдельные сообщения в логи. Все так. И с этим связана такая проблема, что когда ты commit транзакцию, ты commit транзакцию, у тебя в Write a Headlock пишется, что транзакция закоммичена. После этого вот эта запись, она улетает на реплики, реплики это проигрывают, если они это успешно проиграли, они, на самом деле они просто сообщают смещение мастеру, на каком смещении в Write a Headlock они находятся. И мастер знает, что вот эта реплика, она закоммитила транзакцию, она теперь видит эти изменения. Не нужно быть ими пятем во лбу, чтобы понять в чем здесь проблемы. В том, что допустим, ты говоришь на мастере commit и мастер умирает. Например, ты как клиент, ты не получил ответа на то, что транзакция была закоммичена. И ты в данном случае не уверен в ее состояние. Но это еще нормальный сценарий, потому что когда система, ну либо ручная система фейллайвера, либо автоматическая такая, как стол, лилпатрония выберет нового мастера, ты просто не знаешь состояние твоей транзакции. Она может быть закоммичена, может быть не закоммичена, это все нормально. Но в чем прикол? Оказывается, что помимо вот этого бинарного закоммичена и не закоммичена, есть третий вариант. Например, если ты пользуешься PSQL клиентом, ты можешь выполнить транзакцию, складывать commit, потом у тебя чего-то где-то подвисло и ты нажал CTRL-C. В этот момент, ну как бы с точки зрения здравого смысла, ты типа отменил транзакцию, ты же типа CTRL-C нажал. Но в позграсте это как бы не так работает. Ты уже сказал commit, у тебя уже в райдахайдлога записался commit, и уже уехала на реплики commit. Поэтому ты можешь ошибочно предполагать, что твоя транзакция, она не закоммичена, но она уехала на реплики, она там закоммичена. Хуже того. Оказывается, что вот эта фишка с CTRL-C, она есть не только в PSQL. Она также используется несколькими клиентами, ну и типа большим количеством клиентов, и как я понимаю, в JDBC, например, это используется. Используется это по той, в общем, там зачем-то, не уверен зачем, реализована логика, что если ты там сказал commit и долго не получаешь ответа от сервера, то, наверное, на сервере что-то где-то подвисло или, не знаю, где-то какие-то проблемы. И поэтому клиентские библиотеки, они прям, они открывают новую сессию к позграству. И говорят там вот в той-другой сессии, типа, прибейте, как бы в кавычках нажми в ней CTRL-C. И тогда с точки зрения пользователей клиентской библиотеки, ты получил exception, то, что, чувак, ты пытался что-то выполнить, но у тебя там timeout exception. И ты как клиент ожидаешь, что твоя транзакция, она завершилась с ошибкой, она не закоммичена. Ну, подожди, кстати, нет, я не согласен. Я как энд ожидаю, что я не знаю. Ну, давай так, зависит от того, насколько ты сообразительный программист. Если ты сделал такой, знаешь, генерик обертку, что любое exception это плохо, то ты можешь ожидать, что она не закоммичена. Если ты сделал умную обработку, что вот если это timeout exception, то это одно, если это другой exception, то это другое, то... Я согласен, даже если ты сообразительный программист, очень сложно отследить, что ты нигде не делаешь такого предположения. Какая особенность это exception в Java? В общем, про эту особенность Postgres нужно знать. Это немножко противоречит некоторым местам документации, потому что я добавлял эту новость неделю или две назад. Я уже сейчас точно не скажу, где именно это написано. Ну, короче, там где-то в определенном, там буквально есть одно предложение, где его можно трактовать двояко. Про какие особенности нужно знать. Не полагайтесь как бы на свою интуицию в отношении того, как оно работает. И помните, что распределенная система эта сложная. Наверное, это вот то, что я хотел озвучить. Вообще не полагайтесь никогда на свою интуицию. Всегда все прожиаете, как оно на самом деле происходит. Делайте тесты и глядите, как все в настоящей системе у вас работает. В shownotes вы найдете там дополнительную информацию, там предлагаются некоторые почек по сгрессу. Как это можно... Ну, разные ограниченные случаи описаны. И с чем люди сталкиваются на практике. Если у вас этот вопрос более сильно интересует, перейдите по ссылкам и ознакомьтесь. Вопросы и комментарии по этой теме. Еще. Тогда мы переходим к следующей теме. Рубрика Time Scale Zen. Компания Time Scale подняла Round B. В Round B получила 40 миллионов долларов от Redpoint и некоторых других инвесторов. Redpoint это венчурный капиталист, который инвестирует в... Ну, не хочу сказать в базе данных, в высокотехнологичной компании. У них здесь в списке Snowflake, Stripe, которым мы добрым словом вспоминали недавно, Hiroku и разные-разные другие. А, Twilio, кстати, отсюда же. Собственно, это новость одной строкой. Этого удивительно, что в компании Time Scale присоединился один из ведущих подкастов. И спустя пару недель компания получила 40 миллионов. Это совпадение. Так что вы задумайтесь, может быть, вы хотите там Валеру себя нанять или советов. 40 миллионов они так на дороге не валяются. Я немножко смеюсь здесь, потому что обычно очень много времени проходит перед тем, как Round завершается. И он публично обсуждается. То есть, скорее всего, Саша, его закрыли намного раньше. Просто сейчас публично стало. Была очень жирная шутка с подачи Саши. Мне кажется, Саша не скрывал, что это была жирная шутка. Вам не удастся раскусить мой... Как это? Мастерский покер-фейс, давайте так назовем. Это пост-ирония над пост-иронией. Но кому интересно, да, компания долго проходит после закрытия раунда. У них еще наступает эволюейшн, который долго длится. И перед тем, как это становится публично известно, проходит какое-то время. И иногда компания по секрету может вам сообщить о текущем состоянии в плане раундов. По этому случаю компания радует пользователей серии крутых новостей. Это компания называется Always Be Launching. LoanChain... Свет, как правильно произносится? LoanChain. Нету O, там будет LoanChain. Ладно. Просто... Запускает, короче. Одно это запускает, а другое постоянно кушает. Хорошо. И одна из фишек, которые была анонсирована, зарелизился TimeSkillDB версии 2.2, и в нем реализована штука под названием indexSkipScan. Сейчас я расскажу, что это такое реализовано, но в качестве кастомной ноды. В смысле ноды как в плане исполнения запроса. Что такое indexSkipScan? Допустим, вы хотите... У вас есть много метрик в базе данных. Ну, вы храните таймсерию в базе данных. У вас есть много тегов. Например, много устройств, которые репортят температуру, давление, что-то еще. И вы хотите по каждому тегу узнать, например, когда была получена такая-то та или иная метрика. Это можно сделать с помощью запроса SelectDistinctOn и так далее. Физически это реализовано как... Если у вас построен подходящий индекс, вы спускаете по этому индексу по нужному ключу, и представьте себе, что у вас дерево, и у вас по одному из интересующим ключей много значений в этом индексе. Поскольку это здесь таймсерия запрос, и вас интересует только последнее полученное значение, то из этого под дерево, где у вас много значений, вас интересует только одно, самое последнее. А все остальные вы можете пропустить. Это можно себе представить как специальная ссылка возле дерева, которая говорит, что вот это значение последнее, ты его получил, теперь прыгай вон туда, там другой ключ, который тебя интересует, другая метка. Это не то, как оно реализовано в Позгрессе. В Позгрессе такого нет. Есть патч, который пытается реализовать индекс скипсканы. Он с 2018 года переходит из Комитфеста в Комитфест, пока его не приняли. Оказывается, это можно реализовать в виде расширения, в виде кастомной ноды. И опять же, там нет никаких меток, но реализована это как спуска по дереву до заданного ключа. Ты получаешь последнее значение, а потом снова спускаешься по дереву, но в другую ветку, где следующий интересующий тебя тег. Как н-ное количество спусков по дереву. Надеюсь, я объясняю, как я могу без картинок. Ну, короче, да, тебе придется картинку нарисовать, приложить. Даже я ничего не понял. Для тех, кто тоже ничего не понял, в шелнотах будет статья с наглядными картинками. И оказывается, что это позволяет существенно ускорять некоторые запросы. Тут приводится цифры до 8 тысяч раз, но в среднем чуть скромнее, то есть в 20-40 раз, но все равно неплохо. Если у вас используются похожие запросы, то вы можете поставить себе TimeScaleDB и даже не использовать функционал, связанный с тем сериями, потому что это работает для обычных таблиц. И что-то я еще хотел сказать. А, и это демонстрирует гибкость Postgres, то, что ты можешь реализовать даже вот такие замороченные вещи в виде просто плагина. У меня все. То есть, друзья, я правильно понимаю, что я посмотрел на картинку, я правильно понимаю, что идея в том, чтобы вместо того, чтобы сделать скип-лист, который еще подеорганизуй, мы просто берем обычное бы дерево и просто шаримся, как это, на всякий случай сразу смотрим в следующую большую ноду, прежде чем начать ковыряться в предыдущей. Или в чем идея? Ну, грубо говоря, насколько я тебя понял, да. То есть, нужно понимать, что это кейс, это оптимизация, и этот сценарий часто возникает в том сериях. И чем это серия характерна, то, что у тебя по... Если ты представишь себе пару метка и время, и ты построил индекс по, например, там, тег и тайм, то у тебя по одному тегу в индексе много-много-много по деревьям для разного тайма, потому что ты постоянно-постоянно туда дописываешь. И если ты по этому дереву спустишься в тег и потом к самой последней записи, а потом пойдешь вверх к следующему тегу, то ты сэкономишь очень много хождения по дереву. Поэтому это позволяет добиться такого улучшения в производительности. Если у тебя другой индекс, или у тебя данные редко обновляются, то оно будет работать не быстрее, может быть, даже чуть медленнее. Как-то так. Я надеюсь, на тот вопрос ответил. Да, спасибо. Валера, у тебя по работе возникали похожие запросы? Мне кажется, да. Я предполагаю, что это то, работать так, как я думаю. Да, в принципе, на прошлом месте работы мне что-то такое могло бы помочь. На текущем месте работы скорее нет чем, да, потому что я уже, кажется, рассказывал, что лично я скорее занимаюсь тем, что обматываю, дружу Spark с всякими экзотическими источниками или не очень экзотическими источниками данных. В какой-то момент там еще возникал пачкальсайд. И сейчас у нас скорее задача в том, чтобы быть максимально абстрактными, чем максимально производительными, поэтому сейчас таких задач не возникает. А следующая тема, Double Bane, называется Upt Encounters of the Third King. Да, это такое сложное название, а у нас есть вообще время, нет ли? У нас полно времени. Достаточно большая тема. Еще минимум полчаса. Отлично. Я на всех там буду перенести. Отлично.",
    "result": {
      "query": "Postgres commit transaction anomalies"
    }
  }
]