[
  {
    "segment_id": "9f27103f-1cb2-4ddb-8120-eea62b129c79",
    "episode_id": "ee7cc804-18cf-46fd-8263-4ad3fe3eb225",
    "episode_number": 125,
    "segment_number": 5,
    "text": "фьючер в скале в том или ином виде пытаются быть монадами, чтобы это не значило, в питоне на это вообще никакой заявки нет, это всё-таки классическая ООП, и это скорее классическая правильная имплементация реактив паттерна. Но на самом деле это всё равно монада, просто они это очень скрывают, они очень постарались, чтобы это скрыть, и им это неплохо удалось. Тут будет пуристский спор сейчас о том, что такое монада, давай мы это отложим, ну да, наверное, окей. Мне хочется добавить здесь то, что когда речь идёт о выборе языка программирования для какой-то конкретной задачи, речь не всегда идёт о том, что лучше использовать питон, либо джаву, либо скалу, речь часто идёт о том, какие у вас есть текущие люди и на чём у вас текущая инфраструктура написана, и порой выгоднее использовать скалу вместо питона. Про скалу вместо питона я могу сказать очень многое, потому что у нас есть там команды, которые вместо скалы выбрали питон для спарка, потому что скалу учить это тяжело, долго и риски непонятны, а делать на питоне оно понятно и в принципе всё известно, при том, что вы делаете перформанс, гэпа там большого не происходит. Я же говорю, если у тебя есть команда, которая уже знает питон, и для них есть риск изучения скалы, когда у тебя есть команда, которая знает скалу, то для них риски уже в другом. Да-да-да, поэтому питон, я не скажу, что он уступает на какие-то рынки, питон улучшается, у питона есть большой драйвер роста, они постоянно что-то улучшают в себе, внутри, и это важно. По сравнению с тем же Руби, которая как-то в последней версии, она на мой взгляд была не сильно улучшена, но опять же я в Руби не большой знаток, но вот в питоне за год произошли изменения, можно подозревать, что это подговорительные изменения, когда платформу всю почистили, как-то причесали для того, чтобы идти вперед и улучшать именно, для того, чтобы там появился джит, и джит это то, что питоне должно появиться неизбежно, если в текущей ситуации на рынке мемко-процессоров мы хотим получить какие-то перформансы, там, импрунт или какие-то улучшения. Ты слышал, а какое твое мнение по поводу того, что язык программирования Go все больше и больше отвоевывает рынок у питона, как ты к этому относишься? Ты знаешь, буквально на одних праздниках я психанул и попробовал Go, ощущения двояки, например в Go есть такая в стд-либе, есть такая вещь как http.req, это реквест, и я, ну, не для моего тамуха. В микроприложении нужно было получить заголовок http-host. Оказалось, что чтобы получить это, делать не через структуру хидр, или хидр, которая есть в стд-либе и в рек, а просто через свойство хост, которое является стимингом. И вот это inconsistent в лайбре, оно мне кажется очень показательным, что в Go оно все очень тяп-ляп, такое вот намазано, ну вот развиваемся, причем это во всех местах, это не только в рамках Runtime и GC, а вот именно в стд-либе. Такое inconsistent в инфраструктуре заставляет задуматься, а стоит ли вкладываться в этот язык, потому что сейчас ты будешь работать вот так, а через полгода тебе придется просто все переписывать, потому что стд-либ изменится в более консистентной сфере, или там через год. Понимаете, да, что для большой корпорации это большие риски. А то, что. .. Ну, большая корпорация Google в это вкладывает и идет в это направление. А то, что тебе приходится на Go писать в два раза больше кода, чем на том же питоне, тебя не особо смущает? Говорят, что я на Go взялся его попробовать, с учетом того, чтобы понимать, что это вообще такое, даже на вкус. Вот вкус мне не понравился, кода там больше-меньше, это плюс-минус, потому что в писательных языках похуже, там Pascal, Cabal и все такое. Так что здесь можно спорить, а вот именно inconsistent в стд-либе и поведение, которого ты не ожидаешь, и то, что компилятор тебе разрешает делать очень странные вещи, это не очень хорошо. Но при этом, да, Google выпустил же у нас недавно такую штуку под названием Grumpy, это транслятор Python на язык Go. Как вам такое? Ну, это же супер экспериментал, и как обычно. То есть, может быть, они на самом деле уже закончили разработку, просто выкинули в open source, как обычно. Но это похоже на 20% проект, и непонятно, что с ним будет дальше. Посмотрим. Вы знаете, я его попробовал. Я скачал, поставил, запустил бенчмарк, который про Fibonacci, и во-первых, при подробном изучении оказалось, что все-таки там идет речь о параллельном, а не о конкарнопрограммировании, потому что там идет разговор о трэдах, а не о, допустим, разделяемых счетчиках. И он производит интересное впечатление. Например, на однопоточном коде у меня Python выиграл у Go. То есть, когда я сказал, что у меня один экзекьютор, и я считаю числа Fibonacci, у меня Python порвал Go. Ну, не Go, а Grumpy. Это был очень интересный experience, так сказать. А я прямо слышала, что там совершенно разные алгоритмы имплементации для поиска чисел Fibonacci. Нет, там один код на Python, потом он транслируется в код на Go. Я код на Go читал, причем там смешно, если смотреть сегодня, то там для многих вещей используются греческие буквы, то есть там альфа, бета, гамма, пи, и очень смешно читать. Это же транслятор, он сначала переводит в Go, а потом ты этот Go компилируешь. Это такая трансформация кода. Потом ты компилируешь этот Go и получаешь экзекьюшн какой-то. Можно вопрос из чата? Алексей спрашивает следующий вопрос. Почему даже на питомных этапах на вопрос, кто использует Python 3 в продакшене, поднимают руки в районе третьи? И что с этим делать? А точнее, надо ли вообще что-то с этим делать? Отвечаю. Я регулярно задаю этот вопрос. За последние полтора года треть сменилась на гораздо большее количество людей. Сейчас мне сложно сделать оценку, но гораздо больше. Тренд продолжается. Мигрирует с Python 2.6, 2.7. Стало гораздо проще на 3, тем более что все почти библиотеки уже сейчас, у нас сейчас уже все в принципе есть и можно спокойно все переписывать на 3.6, на 3.5. Никаких особых глобальных подобных камней вас не ожидает. Об этом говорится много, звучит из каждого утюга, новые проекты стартуют вполне спокойно и больших проблем не испытывают. Скорее, это уже зашел из разработчиков и такое неприятие исключительно в головах людей, даже не менеджмента, а конкретных исполняющих лиц. Мне кажется, просто тяжело переводить проекты, которые очень большие, на кто-нибудь... Я не про Legacy. Я не про Legacy. А, ты про новые? Да, про новые конечно. Про Legacy там все всегда неоднозначно. И второй вопрос от Олега Акбарова. Спросить про бенчмарки сетевых аппликейшенов. Он уверен, что Python проигрывает, но JS GO и JVM? В какого рода бенчмарки? Давайте так, бенчмарки это вещь сложная. Что мы понимаем под проигрывает, в каких бенчмарках, это всегда нужно смотреть по конкретному вещам. У нас там были же всякие перед Новым годом, народ пьянствовал и показывал, как... Как это сказать... Показывал, что такое бенчмарки. Если интересно, могу рассказать кратко. Нет? Нет, лучше по интересному в Python, давайте пройдем до конца. Давай, ну, про интересное в Python. В общем-то, последнее, что там осталось, это Type Hinting. Наконец-то, там была такая дырка большая в спеке на Type Hinting, что все сделали, кроме Variable Annotations. То есть, когда мы локальные перемены, их типы должны были как-то аннотировать. Опять же, это ни на что не влияет в рантайме, но спецификации такой было упущено. Наконец, сделали спеку, реализовали, все хорошо, наконец у нас Type Hinting можно пользоваться вообще во всех аспектах и никак не страдать. Работает это или нет, работает, в тестах мы проверяем, вполне себе хорошо в некоторых вещах спасает. Для печати? Или для чего он может победить? Он очень хорошо работает во всяких вещах типа... В общем, в очень известной IDE для Python он хорошо работает. Когда вы делаете Type Hinting, он прямо в рантайме вам подсказывает, когда вы пытаетесь передать значение того типа функцию или возвратить, у вас получается возврат, он прям отлично срабатывает и хорошо. Очень сильно помогает, не ошибиться. Я для некоторых своих проектов прям вёл в связи с рабочих правила, что код не мержится, если у него Type Hinting. Это очень хорошо. Так, ну что, ещё какие-то вопросы здесь? Я, если честно, хотел поспрашивать про использование Async.io в продакшене, то есть ты, наверное, единственный из моих знакомых, кто его, скорее всего, использует. Я не скорее всего использую, у нас есть несколько проектов, которые стоят и на бакенде, и в микросервисах, да, мы их используем под большой... Не скажешь так, большой это очень красивое слово, под серьёзной, на мой взгляд, нагрузкой, под продакшен-нагрузкой для отдачи пользователям. Такой вопрос, знаешь, обычно те, кто говорят, что мы знаем Python, скорее всего, не используют Async.io для продакшена и для вот этих вещей, но он достаточно новый и мало кто его туда засунул. И вот у тебя есть какой-нибудь опыт, вот пришёл новый человек, который вроде как знает Python 2.7, пересадить его на 3.6, ну это вроде как не так сложно там почитать, посмотреть, и пересадить на Async.io. Смотри, на 3.6 он только сейчас вышел, поэтому у меня опыта почти нет, да, он 3.6.0 как-то странный. На 3.5 был разок по поводу Async.io, да, мне довелось работать с несколько разработчиков, которыми я показывал, рассказывал подробно, мы с ними проходили кейс про обучение, не скажу, что я их научил или сделал гуру, но повышать их знания в асинхронной разработке, да, мне довелось. Вполне себе они... Насколько сложно, насколько быстро они вникают и понимают все слабости и как это правильно делать? Вообще зависит от подхода, но как стандартно, например, от месяца до трех, как и любая технология. Ничего такого, не rocket science, ты говоришь, что, ребят, вы знаете, главное, вот вы нигде не блокируйтесь, вы не должны ни в коей вашей функции долго тупить. И в тот момент, когда ты говоришь, ты знаешь, вот у нас есть большой цикл, и твоя функция, каждая из них, она стоит в этом цикле. И в этот момент у людей в голове все складывается, они такие говорят, а, окей, ты понимаешь, что каждый раз где-то здесь тупишь, ты не дашь другим работать. И люди такие, а, да, точно, все. И после этого... А когда же ты делаешь там асинг или там await-асинг, ты разрешаешь другим работать. И после этого люди как-то быстро начинают соображать, и все становится лучше. Ну понятно, что это сейчас красиво звучит, но после 10 повторений и просмотров там код-ревью, оно работает. Окей. Это не такая сложная как кажется. Тейвилл. Да не, я тоже не думаю, что это сложная. Просто как бы она не так давно появилась, непонятно все вместе. Секс. Реактив луп, ну с этого, в питоне она появилась с Вистеда. Вообще это там 2001 год. Так, ну что, пойдем дальше? Да, мне кажется, что пора переходить. Тейвилл. Ну тут грумпи как раз, мы уже зацепляли, да? Секс. Да-да-да, вот про грумпи мы уже сказали, что оно в общем-то очень клевое, то есть на многих потоках оно работает лучше, чем на одном, но на одном оно работает хуже, чем на одном на питоне. И это то, что Google так аккуратненько обошел стороной в своих бенчмарках и не показал. Тейвилл. Вообще для меня, если честно, это знак. То есть смотрите, как бы смотрим историю. У нас появляется некий язык, который называется питон. У нас есть компания, которая нанимает автора этого языка и говорит, всё, теперь это стандарт де-факто в нашей компании. Проходит какое-то время, появляется новый язык внутри этой самой компании, и компания пишет транслятор с старого языка на новый язык. То есть, ну всё, на мой взгляд, дни питон сочтены. Тейвилл. Прости, а Гвида сейчас не работает в Google, он работает в какого? В Dropbox. Тейвилл. В Dropbox. Но это для меня ещё одно подтверждение того, что Google не собирается больше поддерживать питона. Тейвилл. Да вообще не понятно, что Google собирается поддерживать, он же вкладывается и в JavaScript, и в Go, и в чёрта лысого, и Google это такая корпорация, которая не очень умеет дружить, как мы знаем. Ну, кроме шуток. Поэтому Google это Google. Опять же, ценности мнения Google в некоторых местах сильно переоценены, на мой взгляд. Тейвилл. Ну, на мой взгляд, это крупная компания, которая знает, как правильно вести большие проекты. И если она говорит, что питон не подходит, в большинстве случаев надо использовать другой язык, и говорит, вот такой язык надо использовать, и мы его используем, то надо прислушиваться, по крайней мере, к этому мнению. Тейвилл. Ты знаешь, мне кажется, что Google просто решил пересадить всех своих системных администраторов на какой-то более приятный язык, чем Bash. Потому что известно, что Google изначально разрабатывал Go как язык, чтобы там CC плюс программисты переходили, а оказалось, что очень быстро пересаживаются люди, которые привыкли писать на интерпретированных языках. Тейвилл. Я думал, ты про питон рассказываешь. Тейвилл. Нет, нет, нет. Сейчас не про питон. Тейвилл. Пересаживать с Бэша на новый язык – это прям про питон. Тейвилл. Да нет, вот как раз питон-то здесь не взлетел, а Go как-то некоторые мои знакомые говорят, что питон-то, простите, Go – это огонь. Сейчас я прям к концу цитаты приведу. Знаешь, я вот пишу и не думаю, говорят. Конец цитаты. Тейвилл. Так, ну что? Ю. Неужели тему себя исчерпала? Тейвилл. Похоже, что так. Тейвилл. Да ладно, вот Go, кто там на Go пишет, расскажите, какая там скорость, когда вы ССЛ там используете? Ю. Слушай, у нас нет синтаков, которые пишут на Go. Тейвилл. Синтаков, которые пишут на Go? А про Ирланг есть? Ю. Ну, прям на Ирланге писали. Тейвилл. Писали, и чё как? Медленно? ССЛ-то там работает? Ю. Да всё нормально там работает. Я никогда не дрался в скорость по ССЛ, не по ССЛ, по Ирлангу. Тейвилл. Слушайте, а чё там тогда Хироку написал про ССЛ коншейк в 5 раз быстрее? Ю. Просто Ирланг не нравится. Но переход был знатный, согласен. Тейвилл. Хироку не нравится Ирланг? Ю. А, слушай, мы не сможем это рассказать, ты хотел рассказать Валеру. Тейвилл. Да я могу рассказать. Чё там рассказывать-то? Там же смешная история. Если почитать исходники про файлинг, в общем Хироку выложил, ну, очень хорошо, всё классно. Оно правда работает. Вопрос только в смешном, что если так совсем, как сказать, шоршственно рассказать, то оказалось, что когда у ССЛ соединения, то сертификаты, которые лежат на диске, они каждый раз отчитываются с диска и каждый раз транслируются в нужные представления Ирланга. И Хирок выпустил патч, который эти представления один раз поднимает и кэширует уже в волнительные представления Ирланга, чтобы потом быстро установить этот хендшейк. Что, в принципе, сократило им внутреннее время по некоторым замерам чуть ли не в 5 раз, и это со ССЛ до 20-25 мс. Это круто. Ну, всем радоваться, счастья. Есть и отдельный патч, есть ОТП 19.1 он вошел. В общем, всё хорошо, всё клёво и прям огонь. Я против Ирланга, честно говоря, не имею никаких предпосылок, история знатная, всем читать, всем про файлинг и как это вообще в Ирланге делается, оно, в принципе, переносимо на все другие платформы рантайма. Там деталей не очень много, какая-то статья, но смогли, мы сделали, вот посмотрите графики. Нет, нет, нет, там есть ссылка, во-первых, на гитхаб патч, есть ссылка на замеры, гитхаб патч вполне себе читаемый, даже для людей, которые не идеально знают Ирланг. Поэтому стоит посмотреть, хотя бы чтобы понять, что такое бывает и в чем, может быть, суть проблемы в другом рантайме или в другом языке. Потому что сейчас все мигрируют на хтп2, сейчас многие используют хтп2. Вот, спасибо большое. Всё рассказал. Ну, раз мы всё набрасываем, может быть, немножко мы набросим на что-нибудь другое, совершенно нестандартное. Ребят, выберите какую-нибудь тему. На раст? На раст? Нет, нет, нет, давайте я что-нибудь выберу уже, сколько можно про языки программирования, в самом деле. Да, да, да. Вот, например, да, вот эта вот мне тема нравится. Она про то, что чуваки взяли ардуину, взяли 3D принтер, напечатали на нем руку, ну, как человеческая рука, да, только такая, но вспоминаем игру Deus Ex и вот это всё. И сделали на ней протез, который прям работает, функционирует. То есть человек без руки, без кисти, он может управлять этой рукой. Работает это, ну, там можно посмотреть видео, оно такое очень наглядное, то есть некий ремешок, который, я не уверен в принципе его работы, как именно он работает, но он, ну, если вы рукой пошевелите, вы обратите внимание, что на, как называется, вот есть предплечье, а другая часть это... Не поверишь, но плечо. Плечо это из руку. Ага. Ну, ладно, короче. От локтя до кисти. От локтя до кисти, да, вот в этом месте у вас шевелятся мышцы, когда вы пытаетесь шевелить пальцами. И этот ремешок, он как бы определяет, каким пальцем вы хотите пошевелить и соответствующим образом приводит в действие вот этот протез. Вот по-моему это совершенно потрясающий проект, вот, и я всем рекомендую посмотреть. Он пока что не очень красиво выглядит, потому что он такой на макетной платье и всё такое, но я так понимаю, ребята собираются их производить и продавать. А кошачьи лапы так можно делать? О чем ты хочешь шевелить на кошачьей лапе? Лапе, ну как, когтями. У тебя стоит острая проблема кошек без лап. Кошек без вайфай, я бы сказал. Слушай, а как они определяют, я имею в виду там какой-то датчик, который определяет какие мышцы действуют? Это был тонкий-тонкий переход, на самом деле, но мы к нему вернемся. Вот для меня стоит загадка, как работает этот датчик, то есть у него, видимо, меняется проводимость в зависимости от давления на разные его места, то есть это, наверное, такой датчик давления с несколькими точками. Просто он же очень неточный, я вот к чему. Ну, он, судя по виду, достаточно точный, но то есть он не заменит тебе твою настоящую руку, но с его помощью можно много делать. Менее удобно, конечно. И на фотках там классно видно, что довольно большая часть это батарейки. А это, я не помню, какие они там использовали. У них там 4,2, да, по-моему, стоит? Да, 4,2. Нет, это, по-моему, не 4,2, это, ну, у тебя аккумулятор 4, но это аккумуляторы, там есть другой стандарт тоже на круглой батарейке, это как в фонариках, может кто-нибудь подскажет в чате или где-то, это немножко, по-моему, это немножко другой стандарт, они толще по диаметру. Я вижу, тут точно есть 2 кроны, и непонятно, то ли 2, то ли 4 похожие на 2А, может быть, это похожие по стандарту. Ну, то есть кроны, понятно, для чего они нужны, для серводвигателей, а от 3 вольт, видимо, питается сама Ардуин и всё остальное. Ну, это похоже, по-моему, было, сколько у них серводвигателей, но... Но это всё можно само напечатать, верно? Я так понимаю, проект закрыт, потому что они собираются это продавать. А, ну да. Но они просто похвастались прототипом. В принципе, тебе ничто не мешает сделать такой же, просто я не уверен, что они выложили исходники, в смысле вот этих 3D-частей и так далее. А, собственно, плавный переход был на тему про кошек, которые раздают Wi-Fi. Как вам идея? Это ещё и ужасно. То есть, давайте кто-нибудь другой расскажет, у меня всё ещё болит горлышко. Ну, тема такая, что можно взять домашнего питомца, какого-нибудь мяука ещё желательно, и привязать к нему точку доступа, условно, там Ардуин, по-моему... Нет, там, по-моему, Raspberry Pi был с точкой доступа. Ну, небольшую плату, такую, типа 5 на 5 сантиметров примерно. И пустить его гулять по городу. Ну, они же по городу гуляют, вот, соответственно, это создат... И немножко попрограммировав, может стать межсеть. И они будут перемещаться, и эта сеть будет постоянно поддерживать некое состояние. Идея, наверное, интересная, вопрос у меня возник первый. Там в комментариях к теме был вопрос о том, что... А как на питомцев влияет вот это вот радиоизлучение? Но у меня был другой вопрос. А где взять бонитовую палочку, и куда её к питомцу вставлять или там... Приделывать, чтобы она вырабатывала электричество? У меня был первый вопрос, как этих питомцев заставить ходить и гулять, и чтобы их потом не отлавливала служба поймки животных. Я думаю, сразу отловят какие-нибудь бомжи, чтобы передавать эти платы. Нет, на самом деле, служба... А, причём, их находится легче, ещё становится, ты же можешь их, это, посмотришь... Тренировать. Усилится, у твоей Wi-Fi... У Wi-Fi приёмника усиливается, доходишь просто до него, и вот тебе мясо. Огонь. Ну, а шутки шутками, по-моему, вот эта служба, которая ловит животных, она не ловит, если есть ошейник. Ошейник? Но не Ардуино. Я здесь вообще не вижу, например, вот в Лондоне каких-то бездомных животных, хоть ни одного не видела ещё. Да-да-да, сколько, например, европейских нет. Мне нравится, как на сайте написано, то что... Cat exploit – это проект, фокусирующийся на создании независимой свободной Wi-Fi-сети, используя кошек в скобочках так называемых server entities. И там дальше бла-бла-бла. А почему бы на птицах это не делать? Они не утащили корм. На голубях, например. Попугаев? Нет, я думаю, будет работать. Ты понимаешь, у тебя в роли сервер-энтити может быть любое животное. Как уже отмечалось, если оно мяукает, оно работает намного лучше. Вообще, свобода стоит дорого, мы понимаем. А подробности? Подробности, то у нас выпустили... Талос выпустил уже сервер на Power 8, это OpenPower, с полностью полным-полным-полным свободным софтвером. Начинает с firmware, то есть биос, и всего лоу-левел, и заканчивается операционной системой. Цена недорогая, можно взять в любом хозмаге или сельпо, всего за 3100 долларов. Копейки. Да-да, это же ничего, копейки. Зато теперь свобода имеет цену, вы теперь точно знаете. Что значит свобода? Там вообще полная свобода? Что они имеют в виду? Имеется в виду, что оно полностью свободное, то есть оно полностью открытое, и там точно нет никаких закладок за вами. Если даже за вами кто-то следит, то он вот в этот код написал, что он за вами следит. Можете почитать и выпилить уроду. Не, ну закладки еще могут быть в железе, я не знаю, там еще... А там же не, OpenPower приколен тем, это как то, что консорсум открыл именно спецификацию на процессор. Не, ну я не видел, не видел... В схемотеке она открыта. Не только процессор, там же и хотя бы там сетевуха, видюха, там куча всего еще. А вот тут я скажу откровенно, я не дочитал, но я что-то слышал, что там тоже все открыто, и вполне себе доступно для прочтения обычным людям. Я хочу купить и установить туда винду сразу. А нет, там с виндой будет быть проблема, потому что винда под павер не работает, это же риск, там такой совсем суровый, и будут проблемы. А слушай, а это в виде какого-то персонального компьютера? Да, да, да, это такой workstation, прям берешь себе домой компьютер, знаешь как в детстве собирали, когда-то в 90-ом каком-то году. А к нему какую-нибудь монитор можно будет подключить? Кого? Монитор какой-нибудь. Да, конечно, ну это все, это workstation. И он будет работать, все нормально? Все по-настоящему. Или там дрова компилировать сидят? У Ubuntu, не, у Ubuntu Linux, там же под Power8, под риск архитектуры у вас же есть, там C++ компилятор, все есть, у Ubuntu скомпилируется, все отлично. Ну то есть мое понимание, что это такая открытая, все как бы выше, но большая материнка на самом деле. Ну она не очень большая, она вполне сиятая, X вот, материнка, то есть обычная, по fourfactor это обычная материнка, просто там процессор не x86, а другой, точно такой же, но другой. И это поэтому стоит денег. Я к тому, что насколько это имеет ценность в связи с тем, что не знаю, последние лет 5 я только ноутбуками пользуюсь. Вот я хотела к этому аккуратно привести. Но это первая версия, они будут потом уменьшать. То есть я очень excited, когда выходят, у кого там было сейчас, ну кто-то там делал полностью открытые ноутбуки, то есть их выпускает сначала условный Asus или Fujitsu, и потом FFs говорит, что да, это полностью открытый ноутбук. Да, он открытый, но просто не закрывается. Да слушай, Вон, ты ничего не понимаешь. Да вы ничего не понимаете, вот там чувак взял комп с нуля, 2000 интегральных схем, вот вам класс, а вы тут в ноутбуке-ноутбуке ничего не понимаете реально. Ну да, это новый плавный переход, на самом деле, который заглушил превосходную шутку про ноутбук, который не закрывается, мне понравилось. Ну Свет, а ты сама сочинила его, только честно? Нет, только что сейчас пришло это в голову, по-моему, неплохо вышло. Да, отожгло. А что ещё может быть полностью открытым, интересно? Полностью открытая ИДИ. Ты боишься, что его закроют? Да, полностью открытый текстовый редактор. Да, хомбрюс CPU, это на самом деле супер баянистая тема, потому что, ну то есть я не прочитал вообще там в книжке, которая там издавалась, типа, не знаю, типа лет 10, но сайт мне очень понравился, поэтому я добавил его в тему, в рубрику, в закладке. То есть чувак взял интегральные схемы, типа логические, которые там 7.4 и X, X вот эти вот, и на их базе сделал полностью, ну как бы сделал компьютер, при том не только сделал, потом ещё запустил на нём веб-сервер, и этот веб-сервер он ещё и раздаёт сайтик, называется magic-1.org, вот, и если вам прям очень интересно, то там есть, прям на этом сайте, кстати прикольно, у него на первой странице ну что-то пошло не так, там картинка не до конца отдаётся, по крайней мере у меня она такая серенькая в конце, там есть, можно скачать всю схему и так далее, и при желании дома спаять такой же компьютер. Интересно, что некоторые чипы, которые используются в этом компьютере, они были выпущены в 69-м году, вот, то есть это там из тех, которые использовались в чём, в Аполлоне, наверное, вот, ну то есть вот, если вы всегда мечтали сделать свой процессор, то это ваш шанс, и кто-то забывает ставить мьют. Я так понимаю, я единственный, кто очень excited по изготовлению собственных компьютеров, полностью открытых. Я вообще в этом смысле не вижу, но я понимаю, что это интересно, если ты этим занимаешься. Это фан, чувак потратил много времени, провёл его интересно, делал что-то руками. И Миникс заиспользовал, вот это он молодец. Надо же хоть в чём-то линус утереть нос. Я поражаюсь квалификацией этих людей, я надеюсь, что к старости я стану процентов на 10 таким же. Я же с тобой не согласен. Чувак сделал, не только сделал компьютер, он потом ещё формил Миникс и портировал его на этот компьютер. Представляешь, какая должна быть квалификация у чувака? Представляешь, сколько у него свободного времени? Да, вот хотел это сказать. Наверное, у него просто нет жизни. Зато у него есть свой компьютер. С Миниксом открытый. Ну что стало лучше, жизнь или полностью открытый компьютер? Для кого-то открытый компьютер – это и есть жизнь. Да, точно. Так, ну что, давайте тогда дальше. Давайте я тогда старую тему закрою, а то я её уже почти забыл. Значит, одна из моих тем – это... Я прочитал как-то случайно, вышел на статью, в которой рассказывается про игру, была давным-давно такая игра, «ФЕР», с точками после каждой буквы. И я увидел ТД-овку, в которой рассказывается, как они используют «Азвёзочка», «Астар» для принятия решения, а не только для того, чтобы путь искать там где-то. Статья интересная, потому что она немножко ставит с ног на голову... Ну, по крайней мере, у меня человек очень далёкого от всех игр, мне немножко поставили, видимо, правильное положение, как делается логика в игре, и каким образом здесь применим «Астар». То есть рассказывается про небольшую историю, как она в целом работает... О, проси, прибью. Я вот когда читал тему перед выпуском, я от геймдева вообще очень сильно далёк, и мне было так непонятно, что такое «Астар», и о чём это вообще идёт речь. Можешь сказать вкратце, для непосвящённых? «Астар» — это классический алгоритм выбора пути, когда у тебя есть начальная точка, конечная точка, и тебе нужно... Извини, я поправлю, не совсем всё-таки поиск пути. Чё-то мне плохо, что-то у меня мозгом идёт. Это, я бы сказала, алгоритм обхода графа. Алё? Да-да. Это... давай где-то обобщим это. Алё, алё, чё-то мне не слышно. Не алёкай, тебя все отлично слышат. Давайте кто-нибудь продолжит про «Астар», а я напишу Ваню. Ну давай, я попробую рассказать. Это давно, правда, было, когда я это изучала. Собственно, есть некоторое множество алгоритмов, которые позволяют вам искать и обходить граф, искать что-то в графах. Вот довольно известный — это «Дейкстра», а есть ещё «Астар». Так вот, «Астар» позволяет, если у вас есть граф, у вас задана вершина А, вершина Б, вам нужно пойти из вершины А в вершину Б, и у вас есть пути... Пардон, я просто изменила руку. Ты возвращаешься опять в поиск пути, ну да. Нет, у вас есть... Ты можешь не знать, где твоя точка Б, тебе нужно прийти в состояние с некоторыми свойствами. Да, и у тебя заданы какие-то веса, которые... Каждый раз, когда ты преодолеваешь дугу, соединяющую точку один... Ох, блин, у меня с терминологией проблема. Я половину на русском, половину на английском это звучит. Когда вы соединяете один пункт со вторым пунктом, у вас есть дуга, это соединяющая эти два пункта. У этой дуги есть какой-то вес. И вот алгоритм «Астар» позволяет в зависимости от этих весов проходить в этот нужный граф, чтобы достигать в нужной вам точки с минимальным либо максимальным весом, в зависимости от того, что вам интересно и что вам нужно. Что намного важнее, в алгоритме есть функция, называется ее «евристика», которая оценивает примерное расстояние до твоего пункта назначения, скажем так, и при определенных свойствах этой «евристики» ты находишь оптимальный путь. Но, собственно, да, одна из интерпретаций, что действительно это поиск пути, например, на карте, другая интерпретация – это как мне нужно поворачивать кубик Рубика, чтобы он собрался. Это тоже путь, то есть это вопрос определения. И статья хороша тем, что она как-то... Ну, мне было очень интересно, по крайней мере, показала, как они строят логику для всех ботов, то есть стоит где-то бот, не делает ничего, а в следующий момент времени он должен атаковать человека или бежать, спасать, прикрывать своего товарища, который атакует человека и так далее. И здесь рассказывается, то есть я всегда предполагал, что там делается какой-то ФСМ, я был прав, то есть чаще всего используется ФСМ, и как раз ФЕР, они попытались идти от ФСМ на вот как раз состояние и правильное прикладывание вот этого пути, который на самом деле не путь, как мы сейчас определили. Они это делают с помощью декларативного определения конечного состояния, то есть как в мейк-файле вы пишете, то есть я хочу, чтобы у меня было всё скомпилировано, а C файлы компилируются в О файлы, а О файлы компилируются в бинарник, а дальше делай сам что хочешь, лишь бы у меня вот сошлось всё. Здесь примерно то же самое, то есть как бы ты для каждого АИ пишешь, что я хочу, чтобы он там стоял, защищал эту дверь или убивал всех, кто подходит к ней, а дальше у тебя есть пути, например, у тебя есть тамагавка, которые ты можешь кинуть, у тебя есть, не знаю, там, пистолеты, с которой ты можешь стрельнуть, а ещё есть два ножика, которыми ты можешь порезать, но чтобы порезать надо подкрастся поближе, и желательно, чтобы тебя не заметили. И получается, что у тебя есть конечное состояние, начальное состояние и список действий, которые ты можешь предпринять, у каждого действия есть какой-то вес. То есть подкрастя не получится, если чистое поле и толпа народу смотрит, зато, если есть пистолеты как бы издалека, можешь подстрелить и вес вероятность того, что пистолета удастся из ножиков нет выше. Ну и получается, что у тебя как раз вот этот граф рисуется, просто он не... как это... его трудно с самого начала заметить, если только ты изначально так не думаешь в этих терминах. Но зато, когда ты начинаешь думать, в конечном итоге у тебя получается, что всё довольно легко строится, вся логика довольно легко строится, для того, чтобы по этому графу можно было с помощью а старой искать. Это прям прекрасный, кстати, пример применения этого гейммической абстракции для решения прикладной задачи, если, конечно, вы это смогли заметить, но прекрасный пример, я очень одобряю. В общем, я крайне советую, особенно тем, кто далеки от игр, потому что мне было реально интересно почитать. А ещё таким образом решать с примером половины олимпиадских задач. Ну там Дейкстра как-то больше и чаще бывало. Так... А на Расте олимпиадные задачи решаются? Конечно, конечно. Кстати, у меня есть ещё одна новость на Расте, я потом поделюсь. А все на Расте задачи решаются? А что, есть какие-то задачи, которые нельзя решить на Расте? Ну не знаю, вот... Кто как считает? Ты предлагаешь тему про энтиписяк, я правильно понимаю? Да я думаю, что вообще можно всё на раз переписать и не париться. В последнее время есть такой тренд, кто как считает, Раст это язык нового поколения, можно всё вообще заменить? А есть твое мнение? Точно нельзя. Давайте, давайте. Топи против. Ну хорошо, ладно, я был неправ, действуй. Не, ну так не катит, вот смотри. У Раста нет гарбочеколлекторов, всё, пипец, приехали. У Сии его давно нет, ничего, живём. Да ладно, вот Real Engine у тебя же, Боэхминг, GSC, и вообще без GSC в 2017 году только всякие неразумные живут. Ничего не знаю, я на Сии до сих пор пишу, всё работает. На Сии или на Си++? На Сии. А как ты относишься к тому, что Си++ сделали, 17-ый вот вышел? Подожди, давай сначала тему за Раст. Ну да, ну что за Раст? За Раст всё просто. Короче, последние недели после Нового года народ вышел из алкогольного коматоза, и, видимо, ещё не до конца, поэтому он предлагает всякое странное. Там вышел товарищ, говорит, а давайте постгрэсквель перепишем на Раст. Потом народ из НТПСЕК очнулся и сказал, давайте мы перепишем тоже на Раст или на ГОУ, НТПСЕК весь. Ну и третья новость это то, что вышел, там товарищ делает GPU Accelerated Terminal Emulator на Расте. Я его, кстати, скачал, скомпилировал, работает, всё клёво, да, но это, в общем, очень какой-то странный тренд, всё, что можно переделать на Расте, и я как-то в это слабо верю, откровенно говоря, ну кто-то должен мне сказать, что нет, нет, я не прав, и вообще на Расте всё будет зашибись, и будет вообще это будущее, и ты не прав, чувак. Расскажите мне. Вот по счастливой случайности именно сегодня наша компания открыла библиотеку на Расте. Точнее, систему телеметрии, сбора телеметрии логов. За Open Source ли она работает в продакшене уже полгода? А, ну то есть вы тоже теперь всё на Расте переписываете? Ну не всё, вот эту систему написали на Расте. А почему не всё, а остальное? Ну это первый пробный шаг, всё работает, не знаю, наверное, дальше сейчас вот прям сядем и с завтрашнего дня все перепишем остальное тоже. А вы эту либу у себя с чем линкуете? Ну в смысле где используете? Ну она вся телеметрия, и логи у нас через неё идут. Да, но ваш основной код, если не секрет, на чём? А, всё остальное. Там разные кучи, то есть Python, Go, Elixir, Erlang. Но вы в итоге написали, как сейчас модно, микросервис на Расте, который всё раздаёт? Да, да, да. А, ну вот, в этом был мой вопрос. И что, прям вот у вас есть команда разработчиков на Go и команда разработчиков на Rast. Насколько далеко их пришлось рассадить, чтобы... Они не подрели? Чтобы разницы потенциалов между ними не привела к открытию чёрной дыры. Слушай, а ты что, серьёзно думаешь, там есть большая разница потенциалов? Они наоборот вступаются и начинают все писать на Rast. Думаю на Rast, а не на Go. Вот это вообще вопрос. Вот если в бочку мёда там добавить, то это всё. Конечно, всё превращается в Rast. Почему? Ну, во-первых, там нет garbage collector, и это всех прям сбивает сильно с толку. Во-вторых, там... Ну, там же унылый подсчёт ссылок. И вот эти скидки ссылки, ад, трэш, и вот это всё. Всё, что можно, всё любим в C++. Там подсчёт ссылок — это одна из опций. И есть их несколько. Поэтому, как бы, не знаю. То есть ты можешь передавать управление в смысле владения. Это тоже ещё вариант. Ты можешь копировать, как, скажем, в Erlang. Ну, то есть, как бы, у тебя полный набор действий, делай что хочешь. Вот. Во-вторых, у тебя там неплохой синтаксис. С точки зрения того, что там алгебрические типы данных, паттерн-матчинг и всё такое. То есть... И все гаисты, они прям плачут грызгами, что они всё ещё не пишут на Rast. Послушай, а вот это алгебрические типы данных, это что такое? А то, опять же, вдруг кто не знает, а вот... Слушай, мы их уже упоминали сто тысяч раз. Все их точно знают. Да, окей. Ну, отлично. Вот, если на Rast попытаюсь что-нибудь написать, у меня не будет такой же боли, когда ты стругаешь Estadolipo, у тебя ощущение, что он какой-то кривой, косой и собран лишь бы был. Слушай, ну, я сам не больших на тот Rast, но вроде как большая часть того, что нужна, она уже написана и вроде как работает. То есть, когда у нас проект писался, у нас в библиотеке из Estadolipo, по крайней мере, ничего не переписывалось, чтобы что-то не нравилось, грубо говоря. А ещё такой очень важный вопрос. А Rast, он, в принципе, порождён, так понимаю, исключительно тем, что у нас теперь много ядер на процессорах, правильно? То есть, а ваша мотивация какая была? То, что вам нужно было утилизировать вот эти много ядер или потому что это модно, или что? Ну, во-первых, это просто красиво. Это всё понятно. Основной и самый важный аргумент. Нет, на самом деле получается... О, кукушка. На самом деле получается так, что когда ты пишешь на Rast, у тебя идёт возможность использовать много ядер, с одной стороны, с другой стороны у тебя идёт чёткое понимание, где и как используются ресурсы, у тебя чаще всего это как на Haskell'е, если ты написал скомпилировал, скорее всего, работает. А он будет быстрее Haskell'а или нет? Конечно. В-третьих, то есть у него нет garbage-коллектора, он работает напрямую с памятью и работает в нативном коде. Конечно, он быстрее Haskell'а. Если у тебя скомпилировалось и у тебя логика написана более-менее внятно, это, скорее всего, значит... Ну, в смысле, что ты не копируешь направо и налево, а пытаешься переиспользовать ту же самую память, то у тебя, скорее всего, оно достаточно оптимальное. Ну, то есть, плюсы есть, если хочешь пользоваться. А он этот... Как сказать... А монады там есть? Во всех языках есть монады. Ну что ты так вот прям все... С козырей заходишь. Так нельзя, слушай. Так нужно. Ну, я предлагаю закрыть уже кино Rasta. То есть я много сказать не могу, у нас нет фанатов, которые пишут на Rasta, я чуть-чуть касался, у меня там есть пара человекомитов, по-моему. Или нету еще. Но я имею в виду, что я небольшой фанаток. Может быть, как-нибудь позовем какого-нибудь расиста. А по поводу... А ты ж на оси пишешь. Много? В том числе, да. А как ты относишься к С++? Не очень. Не очень позитивно. Почему? Без энтузиазма. Да. А вот скажи, а если я скажу, что С++ 17, теперь у нас уже есть в полный рост, это изменит твое мнение? Конечно. То есть нужно брать... Нужно брать. Еще больше. Почему? Он слишком сложный. То есть они с каждым стандартом добавляют сложности настолько, что войти в язык становится вообще невозможно. Я не знаю ни одной компании, которая бы не писала полностью на 14, а мне используют 11, скажем. А тут уже выходит 17. Ну кто на нем писать будет? Нет, самое главное, не очень понятно, зачем эту сложность добавляют. Мне на самом деле вот тот С++, который в учебниках, например, такой сискласс, мне довольно нравится. Опять же, я сейчас увлекаюсь ардуино вот этим всем. Там ты пишешь код на С++. Диалект. Они как-то очень избегают ответа на вопрос, что это за язык, потому что они обычно называют его язык программирования ардуино, в других, там, у новых они называют его вайред. Еще где-то есть отсылка, что это на самом деле язык процессинг. Есть такой процессинг.орг. Но смысл в том, что это реально такой сискласс. И он простой, понятный, на нем прикольно пишется. Ну то есть это мне нравится. А зачем они вот добавляют то, что они добавляют, мне просто не очень понятно. Ты можешь объяснить? Ну слушай, вот у меня, мы недавно это спорили, и мне приводили кучу доводов на тему, почему нужен, скажем, 14. То есть в 14 было добавлено большое количество оптимизаций про мув семантику. То есть когда у тебя данные, которые приходят в одну точку, могут без копирования уйти в другую точку. То есть когда ты просто так обычно вызываешь там... Когда ты работаешь на... Я вообще большой специалист по C++, поэтому слушайте меня больше. Но насколько я понимаю, проблема, когда ты работаешь, у тебя часто вызывается конструктор копирования какой-нибудь, который ты не можешь никак обойти. То есть если большой поток пришел данных, то ты должен его практически полностью скопировать из одного места в другое. Или, скажем, владение как-то передать. Ну то есть та же самая проблема, которая появляется в расте, они пытаются с помощью дополнительных ухищрений решать примерно так же. Просто сложность большая получается. А давайте пригласим какого-нибудь плюсиста, который нам все это ответит. Тогда нужно еще и растиста пригласить, чтобы они там окончательно подрались и вызвали дьявола. Но там вообще была же этот адовый в ЖЖ, так сказать, междусобойщик среди ограниченной тусовки перед Новым годом. И это был, я бы сказал, что это голубой огонек в плохом смысле погромистов. И народ мерился там всем, чем можно и нельзя, чем настоящие погромисты могут мериться. Они мерились языками. Мерились, соответственно, Go, Swift, C++, Haskell, C++, Rust. А подождите, мы не сказали еще о чем новость. Новость-то в том, что в GCC, в G++ они поддержали полный стандарт 17. Да, да. И Shlang на подходе, ну, Clang. Clang, он на подходе. И вообще 17-й год, и еще 17-й стандарт будет. То есть он будет не в 18-м году, не в 19-м, а в 17-м году будет полная поддержка C++, Z, и там. Один Z. В версии GCC 7.0. Так что вот, ждите. Аж фанаты ждите. Да, только там фанаты, это, наверное, те, кто разговаривают, даже уже не в библиотеке, а в макробиблиотеке или какой-то... Не, не в библиотеке, а в стандартной. Да, фанаты, которые заводят стандартные, ждите. Да, классно. Ну вот, народ перед Новым годом по пьяной лавочке там померил все, что можно, и оказалось, что, в принципе, если брать идиоматические какие-то, даже не идиоматические, а одинаковые версии кода, написанные для разных языков, то там якобы раз всех заруливает и всё хорошо. Кто-нибудь вообще читал там статьи микро-микро-микро-микро-бенчмарки, нет? Нет, и что? Что там? Там прям клёво, потому что оказывается, что если, в принципе, писать, вот как бы сказать, как бог на душу положит, то, конечно, компилятор в языках, которые помощнее, он делает более оптимальный код. Но если взять и применить все техники НИЗИ, которые знают очень хутые разработчики, то оказывается, что, в принципе, там производительность измерима с точностью до погрешности измерений. А можно ссылку? Ты ещё о какой-то ссылке говоришь. Да, я сейчас поговорю о какой-то ссылке, одну секунду, вы там, пожалуйста, заполните паузу. Легко заполнить паузу, я скажу, что всё это полная ерунда, конечно. Мы, когда я работал над компилятором, над Cichlon же, мы анализировали, что может делать компилятор и что человек делает руками. Но чаще всего на ошибках каких-то людских, то есть смотрим на код, понимаем, что человек здесь делал оптимизацию, как-то преждевременную оптимизацию, потому что он думал, что компилятор не справится. Из-за этого у него код получился настолько сложным, что даже компилятор не может его полноценно прооптимизировать. В итоге всё становится только хуже. То есть напиши программу так, как ты хочешь написать, а остальное должен сделать с тебя компилятор, вот основной вывод. Ну и более того, когда у тебя придёт в команду новый человек, ему придётся разбираться с тем, что кто-то наоптимизировал самостоятельно. Да, да, да. Риски возрастают, соответственно, у нас больше проблем, вероятно. Я видел код, в котором люди разворачивали циклы, потому что компилятор не умеет по-нормальному разворачивать циклы. Делали какие-то более сложные вещи с предподкачкой каких-то данных. Ну, в общем, страшные вещи, и всё ради того, что они просто не верят в компилятор. А есть ещё байки про то, что можно в классах, в объектах упорядочивать поля, выстраивать их в определённом порядке, чтобы они у тебя вылазили в киши. Тоже известная байка в джава-мире. Я не знаю в джава-мире, но в эмбеддет-устройствах это может помочь. То есть если у тебя неправильно в структуре сделаны поля, у тебя будет большое количество пропусков посередине, и оно может занимать значительно больше объёма. И, скажем, если у тебя есть массив из 10 тысяч таких штук... Слушайте, если говорить про явы-мир, там есть много вещей, которые логично делать, ориентируясь на C-мир, в том числе пайдинг, многие техники оптимизации работают, и это вполне себе понятно, потому что у вас компилятор близко находится, и ява в своё время пыталась конкурировать с C, но единственное, за что они продавали, у них был селлинг-пой, это то, что теперь нужно слить за памятью. Тот же Rust или Go, они играют на другом. Почему нет? Ты имеешь в виду нет на эти оптимизации преждевременные? Нет, я имею в виду, что, как говорят профессионалы, что вообще вы просто пишете код, а потом смотрите самые горячие места и применяете техники оптимизации, которые необходимы для этих горячих мест. Если для явы характерна оптимизация, когда мы разворачиваем массивы, а для C, может быть, мы разворачиваем, делаем loop unrolling, а для других кодов делаем что-то ещё, ну окей, для Python, может, в Cython переписываем, то есть мы как-то на C переписываем или ещё что-то. Почему нет? Разворачивание массивов – это такая оптимизация, до которой ты дойдёшь очень нескоро. В первую очередь у тебя будет тормозить соединение с базой данных и куча-куча мелких вещей, и там кто-то решил взять какую-то рандомную библиотеку притащить, которая будет тормозить. Но дойти до оптимизации вот такого уровня – в большинстве своём такие задачи мало кто решает. Эти вещи сопряжены с… ну не знаю, пример таких вещей – это HFT. Хотя большинство, конечно, пишут на плюсах. Но вот это тот пример, где приходится применять такие оптимизации. В большинстве своём такого в Java делать не нужно. Из тех, кто я знаю, HFT у меня пишут на C, и там с домесками на крестах. В Java, ну так, мне довелось слышать краем глаза, что там тоже приходится делать всякие трюки там, без копирований и вот это всё. Ну и там off-heap, чтобы тоже ускоряться. Ну, всё сложно. Но повторюсь, это, ещё раз, вы сначала пишете программу, как Бог на душу положит, а потом уже где-то там оптимизируется, чаще всего. То есть оптимизируется в самых горячих местах, когда вы сможете доказать, что это горячие места, когда вы сможете объективно показать, что это горячие места, а не так, что кто-то притащил библиотеку, которая там дает overhead 600%, и потом учить с ней живёте. Нет. Кстати, вот в тему, как я его нашёл, у нас в темах наброс про микробенчмарки ГОСа с вертом с С++ Лева, и потом сравнение Хаскеля и С++. Ну так мы об этом и говорим, да. Вот это, да, как раз? Да-да-да. Угу. Вот, что он там... Я добавил в текущую тему. Так, а я его не успел прочитать, а что там в результате получилось? Да ну а что в результате? Я же говорю, что там народ набрасывал-набрасывал, что вот там один язык хуже того, хуже сего, вот там, потому что GO, вот там, потому что garbage collecting, а по факту всё уперлось в итоге к тому, что, а как мы правильно аллоцируем память, что вот есть техники аллокации памяти, которые идиоматичны для того или иного языка, если мы это правильно сделаем, и в итоге народ уже мерялся просто тем, с какой скоростью у нас память выделяется при наличии того или иного аллокатора. Нет, ну вот у Максима Сахатского, я вижу, разница отличается в два раза. То есть на Rasty быстрее всего. Так его потом там показали, что говорят, что ты, брак-то не брак. А, я всё понял, я комментарии не читал, извини. Конечно, там же на C пацаны пришли и говорят, друг мой, а ты понимаешь, что ты вот на C каждый раз выделяешь память, а на Rasty у тебя там вообще-то память заранее выделена. И после этого оказалось, что если на C заранее выделить память, то перформанс-то будет один и тот же. Ну просто потому, что у тебя компилятор примерно одинаковый делает оптимизации, примерно одинаковый машинный код генерирует, а память ты заранее выделил.",
    "result": {
      "query": "Python vs Rust performance"
    }
  }
]