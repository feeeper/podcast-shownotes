[
  {
    "segment_id": "1e4e628c-3394-4363-93a8-743add8574b2",
    "episode_id": "5670cae8-970b-483c-963d-f17cf343b8d3",
    "episode_number": 199,
    "segment_number": 2,
    "text": "Там есть некие хаки, связанные с тем, что в ГО есть гарутины, которые легковесно отряды отрезать, веб-ассембля пока что тоже нет, и с тем, что там нету ГОУТУ, прямо вот в синтексе с виртуальной машиной нету операции, которая может делать переход безусловный, и, соответственно, они это решают тем, что во всех тех точках, где гарутина может влечаться, они делают большой-большой свитч и переходят. Но это хак, конечно, и связан с тем, что авторы веб-ассембля считают, что ГОУТУ не нужен, всё можно заменить более высоковыражными конструкциями, альч, кейс и так далее. Ну вот для авторов, кто пишет всякие компьютерные концепты, это, конечно, не так хорошо, но пока такой обход нашли. Ты думаешь, это будет сильно использоваться? Ну, я по первой ссылке, в статье Брайана Кэттилсона, известный в ГОУТУсовке чувак, он как раз говорит о том, что через несколько лет он рассчитывает, что примерно треть людей, которые сейчас приходится иметь дело с фронтендом, будут писать на бэкэнд языках или просто на ГГХ языках, не на джеки. Я вижу, да, то, что... Ну, конечно, для серьёзного фронтенда делать сингл-пейдж фронтенд на ГОУ, или на РАС, или на C++, мало кто будет, если никто. Ну, кто-то попробует, конечно. Но есть юзкейсы, когда это полезно, когда нужна высокая прозрительность, не знаю, 3D-графика, или вы хотите пошарить много кода, и при этом вы не хотите писать на Node.js, поэтому шарите эти коды, бэкэнд язык шарите, а не фронтенд язык. Мне кажется, это прикольная идея, потому что кроссплатформенный UI, при этом без... не знаю, как бы не на JavaScript, а на том же скиннер, на чём всё остальное приложение, или от Binky, мне кажется, довольно сильная идея. Ну, вот как раз в этой части меня она немножко волнует, если честно. Потому что, смотри, с одной стороны, у нас есть Node.js, который сказал, что типа, окей, мы используем фронтенд-язык на покейде, сейчас мы тут понаделаем. И понаделают. Такого, что до сих пор приходится всё это разгребать. Если мы сейчас увидим реализации React, Vue, Angular и так далее на куче разных бэкэнд языков, я думаю, особо хорошо не будет. А такие уже есть. Есть уже сделка на Go, которая, по сути, является попыткой сделать React или Vue на Go. Сейчас её можно транслировать в ассембле, и она, собственно, будет работать. Помню, были попытки разработки на Go под Android, и вот насчёт iOS я не помню. Ты не подскажешь, в каком сейчас состоянии здесь всё находится? Это Go Mobile, да, и действительно под iOS тоже есть. То есть там есть тул-чейн, который компилируется, работает. Это просто не в фокусе. То есть оно всё ещё есть, оно всё ещё официально поддерживается. Окей, оно всё ещё официально, как сказать, не Tier 1, так сказать, платформа, но всё ещё код есть, никуда он не выпиливается и так далее. Но просто пуша в эту сторону нет. Нет людей, которые в этом заинтересованы. Насколько я знаю, человек, который этим занимался, он ушёл от этого всего и начал тем другим заниматься. Поэтому просто нет людей. Основная причина, я бы сказал. У меня есть небольшая cool-стория про язык Go. Я тут, ну я временами перечитываю свои старые заметки, там было про Haskell, и так далее. Вот я всё это читывал, и я вдруг понял, что код, который я писал сколько-то лет назад, там 3 года, например, я его сам уже не очень хорошо понимаю. То есть мне приходится очень сильно мозг обрекать, чтобы понять, что делает скальп. И в этом смысле у Go прям огромное преимущество, потому что на нём не понять, что делает код спустя какое-то время, прям очень трудно. Так что это очень мудро было в плане дизайна языка не тащить в него всякие map-фильтры, вот это всё, монады, простите. Ну да, я полностью согласен. Мне кажется, это как раз киллер-фич языка, то что в нём ни одной киллер-фичи нету. Можно сказать конкарнси, гарутины, синглбайнеры и так далее, но вот именно самая главная киллер-фич — это Go. Это правда сложно продать, поэтому пытаются продавать по-разному, но всем мы любим Go именно за простоту. И собственно, как следствие этой простоты в Go 1.11 никаких новых фич в языке нет вообще. Вторая большая фича в толчении, про которую я уже говорил, это Vigo, но мы это уже подробно обсуждали в одном из путешествий. Там включён, его нужно будет отдельно включать. Где-то через год, через два релиза он будет уже исконен. То есть changelog — это только веб-ассембли. Веб-ассембли, Vigo и много всяких нестандартной блятьек. Там поддержка новых платформ, деприкейт старых платформ, которые уже не поддерживаются, и там какие-то bug-фиксы в блятьеке, немного новых фич, но всё это в стандартном блятьеке в языке, особо ничего нет. В толчении, ну там есть улучшения, связанные с профайлингом и всё такое, но это тоже такой, знаешь, постоянный фокус, это постоянно что-то с ним делать. Поэтому об этом уже тоже как бы раз из раза интересно говорить. А можно для всех, типа меня, которые за языком госледят, очень поверхностно напомнить, вот не всю драму вокруг Vigo, а вот что теперь в итоге будет способом работать с депендами? В ближайший год это будет, примерно через год это будет Vigo. Если кратко. Окей, в чём отличие, если, как бы вот, чисто технически, опять же, без драмы, чисто как бы вот в двух словах, как бы как садить кош, чтобы он не сломался? Я понял, на самом деле большая часть истории, которая вот именно Vigo и DEP, это как раз драма, поэтому если драму убрать, там вообще-то немного. DEP работает по принципу, как работают почти все остальные пакетные менеджеры, там, не знаю, Bunder в Ruby, Cargo в Rust, то есть классические два файла, зависимости, локфайл и так далее, и тому подобное. С небольшим нюансом, что Go использует для зависимости скорее исходники, а первый файл использует для того, чтобы ограничить версии. То есть, если тебе какая-то версия указана в этом файле, но по факту она вообще не используется, это не будет использоваться. Ну, примерно, представляется, что этого нет и не надо. Вот, Vigo идёт радикально другим путём, он использует другой алгоритм выбора версий, использует минимальные версии, они очень консервативно обновляются, и самое главное, что, как бы, наверное, более важное изменение, он, если ты используешь Vigo для сборки, твои зависимости используют Vigo или могут импортироваться Vigo, что почти всегда возможно, тебе не нужно настраивать локально GoPath. Для многих людей GoPath — это прям попа-боль, я согласен с тем, что для всех новых людей это обогромная попа-боль, а так ты можешь клонировать GitHub в любое место, не заморачиваться, чтобы положить его в файловую систему по нужному месту и просто собрать. Или в GoBuild всё будет работать, точнее, GoBuild в будущем. Вот, то есть концепция GoPath точно полностью уйдёт. Концепция под путём останется, но она будет иметь уже меньшее значение, потому что тебе не нужно уложить это ровно по тому месту, как она написана в выборах. — Вопрос такой, если я, вот как стартёр, продолжаю по-старому подключать зависимости, вот там, я не знаю ни про какие там Vigo, ни про что, и просто пишу пути репозиториям в импортах, кто там будет. — Ну, когда-нибудь автор репозиторий его удалит или сломает, или сделает несовместимые изменения, у тебя заборок сломается. Ну, то есть вся эта история, она про версионируемость сбора, про повторяемость и про стабильность. Вот, если ты зависимости не вендоришь никак, они у тебя сломаются когда-нибудь. — Понял. — Я порой понимаю, что, получается, сейчас нужны рекомендации использовать DEP, а потом, когда Vigo станет официальным способом менеджмента депендов, нужно будет просто переписать весь свой файл с депендами. — Ну, не совсем. Vigo автоматически импортирует зависимости с DEP, то есть он может прямо сейчас, если у тебя есть какой-то библиотекарь или какой-то проект, который использует DEP для сборки, Vigo автоматом сработает. Ты делаешь Vigo build, он видит, что есть DEP, видит, что файла go.mod, которые используются в Vigo, нет, и он его автоматом создаст. Дальше ты проверяешься, применяешься тесты, проверяешь, что в принципе все то же самое, и на самом деле дальше ты можешь DEP-овские файлы оставить, и все будет хорошо. То есть Vigo импортирует данные с DEP-овских систем, но в первую очередь с DEP-а, прозрачно, и это будет долго, несколько лет. — Окей, спасибо. Понятно. Перейдем к следующей теме, или я могу набросить немного? — Почему или? Можно сделать это-это. — Мне на самом деле было интересно, вот у тебя как человека, который, я так понимаю, постоянно пил в гугле, и уж совершенно точно больше нас всех, что для тебя вот самой большой болью в языке является? Ну кроме там типа сообщества, без всяких софт-фигни, вот именно в языке. — Именно в языке или в тулчейне, или вообще во всем. — Ну давай так, ну просто с чем больше всего проблем возникает? — Ну я бы сказал, что история с управлением зависимости стала сильно лучше, чем она была, но все равно как бы не так хорошо, как хотелось бы. То есть у нас там одна из следующих тем будет кубернат, в качестве спойлера, и те, кто пытались вендерить кубернат с клиент в го, это вообще, это такая боль, это так плохо, то есть там с такой большой количеством зависимости, и они используют там лок файл немножко сломан явным мерч-коммитом, и в общем это все очень больно, это все пока еще плохо работает, но этот кубернетус, это значит такой святой Граль, то есть я знаю человека, который пишет компайл, у него вот такая цель, что типа версия 1.0 будет, когда он сможет собрать SQLite, потому что SQLite — это там огромный программно-сист, сложный и все такое. Вот как бы когда хотя бы одна толза сможет нормально вендерить к 8С клиент, это будет просто счастье всем. В языке, вот прям в языке самом я бы сказал, что у меня нету какой-то такой четкой интуиции, как работает shadowing в го. Когда ты объявляешь применную, да, и она имеет имя что во внешнем контексте, ты ко внешнему контексту не можешь настучаться. Это немножко усложняется тем, что в го могут быть объявлены имена выходных параметров, и плюс есть синтаксис для краткого присвоения, объявления и присвоения в одной строке, то есть ты пишешь 2.0 равно там, и у тебя x и y автоматически появляются и присваиваются значения, тип выводится. Работает, на мой взгляд, не так очевидно, как хотелось бы, если одна из этих применных уже была объявлена. Если обе были, то эта ошибка так нельзя сделать. Если одна из них была, то одна из них объявится, другая переиспользуется. Но если это уже во внутреннем скоп, например, в подфункции или в под иф, или в чем-то еще, то высходит shadowing, и мне кажется, это не очевидно. То есть для меня это такая самая большая боль в языке. Понятно объяснять? Да, да, вопрос. Python 3.7. Я хочу поговорить об этом, пока мы не ушли слишком далеко от темы языков, и на самом деле это одной строкой, потому что не имею прям очень много чего сказать. Новость на OpenNet, датирована 28 июня, то есть довольно, ну как бы уже не слишком свежая про релиз Python 3.7, и тут не очень, не могу сказать, что прям впечатляющие новые новшества. Появилось что-то, напоминающее не алгебрические типы, но можно теперь удобнее объявлять классы, которые состоят только из полей, ну как это в Java называется? Pojo, да? A plain old Java object. Ну вот, нечто вот это похоже. Про остальные... Как стучит в гонку, на самом деле. Вот, я не мог сказать, что остальные фичи там прям вызывают у меня бурю эмоций, но тут кэширование чуть помнее сделали, не по таймстэмпам. Имеется в виду кэширование байт-кода питанячего. Подожди, а как же изменения в модуле тайтинг, они не вызывают у тебя бурю эмоций? Я могу ошибаться, конечно. А, про генерики что ли? Ну да. Могу ошибаться, но по-моему это всё ещё не совсем честное типизирование, то есть оно несёт такой характер типа, чтобы программистам было понятнее, но по-моему же в рантайме не упадёт, если тип не совпадёт. В деф-режиме упадёт. А, в деф-режиме? Ты делал. А что, в девелопант режиме упадёт, да. Я тут недавно с одним программистом на PHP общался, и вот в PHP оно упадёт в любом режиме, то есть даже там сделано лучше в этом смысле. Поэтому, повторюсь, меня не вызывают бурю эмоций вот эта хрена фича, но мне нравится вектор, в котором называется язык, то есть может быть он в какой-то момент станет прям более типизированный, чем он есть сейчас, и этот момент я явно одобряю. Мне кажется не очень правильным, что он становится сложнее, вот эта аннотация Data Class, которая добавляет не суперполезную фичу, как мне кажется, не суперполезную. Вот в этом плане мне больше нравится подход Go, когда у нас новый релиз, но мы там типа ничего не добавили. Отличный релиз, я считаю. У нас на GFB-проконе был отличный доклад выбирательства из патрик, который там с жж-мем, с hd и так далее. Он как раз рассказывал, что Go становится асимптотически скучнее. Мы уже практически упали до самого-самого низа, и даже релиз Go 2, который там вещает, обсуждается и так далее, он не будет такой ломающий, как релиз Python 3, например. Так что да, подробных проблем в Go не будет. Есть свои. А продолжая тему Python, в грядущем релизе 3.8 нас ждёт потрясающее заменение под названием pep 5.7.2, и Алексей знает, к чему это большое дело. Это большое дело, потому что pep называется statement expressions, и речь идёт о том, что давайте сделаем специальный синтез для того, чтобы присылать значение, точнее объявлять применно и присылать им значение. И это было выражением, а не как statement по-русски, кто знает выражение. Экспрессион? Выражение. Нет-нет-нет, тогда подождите, тогда экспрессион. Это выражение, стейтмент. Стейтмент это утверждение, скорее. Нет-нет, ну в терминологии, в компьютер-сайенс терминологии, в российской, как это называется? Ладно, видимо в чатике все смотрят футбол, делают, а из нас никто не помнит, поэтому кто-нибудь потом в комментариях напишет. В общем, о чём речь, о том, что, во-первых, я рекомендую почитать pep, потому что у меня лично мнение было такое очень негативное, но вот здесь вот в pep прямо в самом начале написано, что очень важно смотреть на реальный код, то есть и сторонники, и противники этого pep делают какие-то слишком маленькие примеры игрушечные, если давать большой пример, то его откидывают, потому что слишком сложный и не показывает реальную проблему. Поэтому должен быть какой-то некий баланс, и на самом деле ещё имеет смысл собирать большую-большую статистику, типа как... Ну вот здесь вот есть некоторые примеры Гвидора, как он собрал статистику по коду по дропбоксу, судя по всему, и, соответственно, как они приняли, решили всё-таки этот pep принять. О чём речь? О том, что в некоторых местах было бы удобно объявлять переменную, присылать ей значение автоматом и делать узкий скобу для этой переменной. И в тех местах, где раньше этого сделать в Питоне было вообще нельзя, например, внутри ифа, или, например, внутри цикла while, вот в первой строчке, где вы объявляете условия, там можно написать value, двоеточие равно какой-то вызов функции, например, из notNone, и дальше тело цикла. Вот, аналогичный код в текущем Питоне будет выглядеть while true, значение это, то break, и дальше уже тело цикла, то есть это одна только три строчки вместо одной. Вот, при этом используются специальные синтексы с двоеточия равно, а не просто равно, для того, чтобы именно подчеркнуть, что это ещё более локальные переменные, чем обычные, и для того, что значение есть, и автоматно присылается. При этом этот синтекс, он как бы, ну, похожий синтекс есть и в ГО и в Питоне, ой, в Питоне, в ГО и в Паскале, там как раз он означает прямо обцепложенный, потому что ни в ГО, ни в Паскале, expression для этого нет, там присваивание это всегда стейтинг. Плюс, во многих местах, где этот синтекс можно ново использовать, обязательно стоят дополнительные скобочки для того, чтобы опять же показать, подчеркнуть это, и ещё скобку подчеркнуть этой переменной. В целом, такое большое мнение, там большое обсуждение хакер-ньюс, кто за, кто против, но вот мне кажется, тут вот пойнт про то, что надо смотреть на реальных примерах, а не на маленьких, игрушечных, вот очень важно. В этом смысле мне нравится опять же, как делают в ГО, я там просит, во-первых, делать experience-репорт, если вы хотите что-то, какое-то изменение предложить, а во-вторых, при помощи Bigtable или специальной компании, которая на этом специализируется, SourceD, они ищут по большому объёму кода на GitHub, как часто ситуации на практике случаются. Довольно интересно, какие алгоритмы они при этом используют, ну то есть, вот так, слёту, если бы меня попросили найти конструкции, которые в языке часто повторяются, именно в смысле давайте попытаемся их как-то обобщить какой-то другой конструкцией, вот мне прям слёту хороший алгоритм в голову не приходит. Ну, там есть тупой вариант, когда вот есть Bigtable, Google, и они там, ради примера, загрузили огромное количество Go кода, какие-то простейшие вещи, там их ходить просто регулярно выражение, они такие сложные, там огромные такие псевдоискривые запросы, то есть, их сложно, всё отлично, всё быстро работает. SourceD это компания, которая специализируется на машинном обучении для Source кода, то есть, они просто выкачали в себе огромный объём кода, парсят ст, делают некие универсальные ст, есть возможность их попросить что-нибудь сделать, если ты хочешь сделать изменение, буквально рука на своих машинах.",
    "result": {
      "query": "Go язык управление зависимостями"
    }
  }
]