[
  {
    "segment_id": "408ea505-5e99-493a-84ba-661b25a9b96a",
    "episode_id": "d82cae81-440b-4bc9-aeff-907acc3f5a90",
    "episode_number": 21,
    "segment_number": 2,
    "text": "вставляются, и ты не всегда можешь понять, что и откуда, и какого чёрта. Но с одной стороны, конечно, да. С другой, вот представь себе, что у тебя, ну, допустим, ну вот из недавнего, то, что я вспоминаю, я к проекту прикручивал камон, знаешь, такой камон. Ну, я поясню для слушателей, это вот в Erlang'е есть обсервер, который там строит всякие красивые графички, там позволяет посмотреть процессы, там их текущие стэктрейсы, такие вещи. Вот, короче, посмотреть в кишки, да, что происходит в актерах. Или там можно это делать через RemShell, а в Аке это решается с помощью камона, это такая штука, которая либо в SaaSD, либо в какой-то другой сервис фигачит кучу-кучу разных метрик, и ты там можешь посмотреть длинные очередей, ты можешь там какие-то свои метрики прикрутить. Вот, очень здоровская штука. И камон, он у тебя в кишках использует Actor System. И представь себе, что тебе нужно постоянно, ну вот ты написал что-то в какую-то библиотеку, тебе нужно пробрасывать Actor System, да? Вот ты передаешь первую функцию Actor System, передаешь там вторую функцию тоже Actor System, да, и так далее, то есть тебе постоянно нужно передавать этот аргумент. Это может быть не Actor System, а Handler, там какой-то connection к базе данных, еще что-то, ну там просто я уже штук пять раз таких примеров видел. Неудобно же постоянно вот там пробраться в этот аргумент, а если он не один, а их там пять, например. Намного удобнее написать implicit и как бы все отлично. Вот понимаешь, тут получается другая проблема. Вот смотри, у тебя есть какой-то метод, метод, допустим, разрастается, у тебя становится в методе, допустим, скажем, переменных семь. Ну, пожалуй, наверное, многовато и хотелось бы вот эти параметры, ну, наверное, следует уже перефакторить. И тут в голову приходит замечательная идея, ты думаешь, а что если мне там, ну, несколько этих параметров сделать implicit? И как бы мета становится лучше, некоторые передаются implicit, они как бы, как-то смотришь на код, и они как бы не видны, и с виду все хорошо. Но ты знаешь, такая ложная история, когда ты не решаешь саму проблему, решаешь как-то вот, ну, не так, как ее следует вообще делать. Ну, ты правильно сказала, то есть в данном случае проблема решается не теми средствами, потому что вот эти implicit аргументы, они не для одного метода, а как раз наоборот, если у тебя есть 20 методов, и им всем нужно там семь одинаковых аргументов, всем методам одинаковые семь аргументов, тогда ты можешь, чтобы постоянно явно их не передавать, передавать их не явно. Ну и что ты делаешь этим лучше? Ты только что запутываешь код, ты не делаешь его, ну, то есть более читаемым, наоборот, ты только хуже делаешь. Ну, как раз я делаю его более читаемым, потому что... Ты делаешь его неподдерживаемым, вот человек, который будет читать твой код, ему будет намного сложнее понять, а зачем ты это хотел сделать? Не будет ему сложнее понять, потому что Свету будет сложнее понять. Это будет сложнее понять, потому что, Саша, когда считаешь, что знакомый библиотеку вот с такими вещами. Я пишу на скале, и мне не сложно. Я тоже пишу на скале. Я делаю очень просто, я навожу там на метод курсор, жму control-Q, по-моему, и смотрю на сигнатуру, я понимаю, что у нее есть implicit аргументы. Ну, это ого, ты понимаешь, что есть implicit аргументы, ты можешь сказать, просто глядя на сигнатуру метода, какой из тех implicit, которые у тебя есть в твоем мексическом скоупе, туда приедет? Или откуда он вообще приедет? Ну, обычно это всегда один и тот же аргумент. То есть в случае с actor system у меня вообще одна actor system на проект. Ну, так вот, смотри, а если у тебя так, что как бы есть ситуация, когда у тебя бывает больше одного implicit, во-первых, доступно, во-вторых, ты вообще не знал, что там есть какой-то implicit, посмотрел на сигнатуру, ага, implicit, а потом ты пытаешься понять, откуда он вообще, черт возьми, берется здесь. Ну, вот еще другой пример. У нас в проекте есть некий di, и есть такой implicit аргумент, который называется binding module. И ты постоянно, ну, представляешь, тебе во все конструкторы классов, там, всюду-всюду в проекте нужно пробрасывать этот binding module, потому что у него там есть метод inject, который тебе делает di. И постоянно его всюду пробрасывать, это вообще будет кошмар. Намного проще передавать его имплиситом, и ты знаешь, что у тебя на весь проект всего один binding module, у тебя как бы нет какой-то особой проблемы. А вот послушать, в один раз конструктор генетик завязать и... Почему ты считаешь это проблемой, Саша? Что именно? Ну, то есть у тебя по сути каждый... Почему я не хочу передавать постоянно одни и те же аргументы? Нет, в принципе так может, конечно. Ну, как бы спору нет. Мне кажется, что это там, типа, нарушение dry, ну, которое don't repeat yourself, и что, блин, ну если у меня там одна или две одинаковые случайности на проект, почему бы не скрыть её вот таким образом? Я правильно понимаю, я как человек малопонимающий в скале, что это некий аналог того, что мы делаем в Хаскеле с помощью выделения в монаду какого-то состояния, и постоянной передачи этого состояния сквозь все вызовы, которые вы там делаете, да? Ну да, это похоже. Ну, то есть это... оно... вы сейчас сказали, что монада это плохо, по сути. Нет, ну, блин, извините, монада вообще другая вещь. Ну, вообще-то нет. Я не согласен с тем, что это как-то похоже на монаду. Почему? У тебя неявность передаётся какая-то херота. Монада это не для передачи неявной хероты, монада это как-то... она может, в частности, использоваться для этого. Ну вот. Во-первых, монада гораздо более явная штука. Ну, в самом случае, нет. Да, она явная, более явная, это точно. То есть ты совершенно точно знаешь, что у тебя написано в типе IO, ты совершенно точно знаешь, где и в каком модуле это обрабатывается. Если тебе написано где-то какой-то параметр, которого ты вообще не видишь, пока ты не наведёшь курсор в vde, потом ты наведёшь курсор в vde, ты видишь, что там есть какой-то имплейсинг. Какого-то типа, а ты всё ещё не знаешь, откуда он там берётся. Так я говорил, же. Извините, раз. Это почти всегда какой-то один или два этих аргумента вообще существует. Так нет, понимаешь, ладно один или два, но откуда он от тебя берётся? То есть ты можешь взять за код сказать, он из того импорта берётся? Ну ты можешь по типу поискать. Ну так блин, в том-то и дело, что... Два раза нужно нажать shift и всё. В том-то и дело, что вместо того, чтобы просто посмотреть на код, тебе нужно произвести там 3-4 действия навигации. И теперь представь, ты разбираешься в какой-нибудь кодовой базе типа Аки или Ряка. Ты же убьёшься. Нет, ты заметь, таким образом тебе очень сложно отследить вот эту вот цепочку в простом текстом редакторе. Теперь тебе приходится обязательно пользоваться идеей. Никак без неё. Нет, ну не хочешь, не пользуйся. Как ты найдёшь тогда? Ребята, вообще странная постановка вопроса. Ну хорошо, если вам не нравится иплист, вас же никто не заставляет им пользоваться. Не, ну это же необходимая штука получается, чтобы решать проблему. То есть, ну я вполне... Нет, нет, нет необходимости никакой. Ты можешь их не использовать. Я могу их не использовать, и тогда если у меня есть 20 параметров... Да, в тяжёлом коде-то они всё равно есть. А, ну да, и тем более, да. Не, ну давайте так, а вот если я хочу передавать эти 20 параметров, ну мне что, вручную их писать всё время? Я тут с Сашей полностью согласен, то есть мне вот это вот... А ты думаешь о ситуации, у тебя 20 параметров, это вообще нормальная ситуация? Ну я... Тебе наверняка что-то уже в вашей колокольне не так, если вы 20 параметров хотите передавать. Ну тут я не знаю, это у тебя готово хорошо ответить. Ну подумаешь, может подумай. Давай как бы от обратного. Допустим их не 20, а ну например 3. У меня есть Actor System, какой-то объект для DI, и например, полу-коннект в базе данных. Плюс логирование, дебаггинг, например, который ты хочешь протащить, чтобы в какой-то момент... Ну логирование обычно так не пробрасывает. Ну я, например... Просто миксин и всё. Я стараюсь как-то более-менее, ну вот то, что я видел в Scalip передаётся имплиситом. Вот у меня 3 аргумента. Ты предлагаешь мне там в половине... ну вот как ты предлагаешь? Что сделать? Я предлагаю делать все явные параметры. Вот как написано в Python, лучше делать всё явным, чем неявным. Соответственно, вот этого поддерживается и здесь. Хорошо. Смотри, у тебя получились куча методов, у которых первые 3 аргумента, они там всегда одинаковые. Ну там, то есть Actor System, Bending Module и Pool Connector. Потом ты в какой-то момент решила, что, не знаю, у тебя появился какой-то четвёртый параметр. Ты по всему коду во всех 20 местах будешь править эти... А ты не думаешь, что у тебя проблемы уже в дизайне программы, если у тебя 20 методов таких получается? Хорошо, а как ты предлагаешь изменение дизайна, чтобы решить эту проблему? Во-первых, можно в конструкторе засунуть его, во-вторых, можно это всё завернуть в один объект. Ну то есть ты предлагаешь использовать Singleton? Не обязательно Singleton, но смотри, ты во-первых можешь все 20 параметров, как бы сделать какой-то объект, не знаю, параметр holder или какая-нибудь штука шняга, и в неё это засовывать. Во-вторых, ты можешь передавать не в каждый метод, а один раз передать при конструировании объекта. Да, но объектов тоже больше одного. Как бы ты в объекты можешь один раз передать какую-то... Ты в фабрику объектов можешь один раз передать ссылку на какой-то вот такой контекст, дальше фабрика каждый раз уже в объект подсовывает это за тебя. Просто я слушаю это к тому, что можно решить эту проблему другими способами, и тот вариант, когда имплиситы есть, это не лучший способ. Есть подозрение, что тот второй тоже не лучший? Да, потому что вы по сути предлагаете, ну в случае с Singleton это вы говорите, а давайте использовать глобальную переменную, что может пойти не так? Не, подожди, насчёт Singleton... А у тебя не явная глобальная переменная получается? Ну, кстати, да. Нет-нет-нет, подождите, она, во-первых, это не глобальная переменная, а локальная, и более того, ну в случае с Singleton вам нужно к нему сразу как-то синхронизировать доступ. Где Singleton вообще увидел? Ну ты сам сказал. Где я сказал? Я сказал, что будет петь-то в фабрике, у тебя фабрика может быть не Singleton. Я просто сказала про Singleton. Да, ты сказала про Singleton. Я как раз сказал, что Singleton не обязательный. Я сказал, ты можешь какой-то объект-параметр-холдер сделать, это не Singleton, это какой-то экземпляр чего-то, просто способ, ну короче, считай такой кортеж именованный. Ну я вижу, мы здесь не можем прийти к единому мнению. Свет, а как-то ты очень удачно уклонилась от ответа про Java для всего, как-то так перевела стрелки на другую тему. Так оно для всего или не для всего, Света? Отвечай, не задумывайся. Java... И вот без этих твоих женских хитростей про имплиситы. Java хороша для своих целей. То есть не для всего. Есть хорошие инструменты для своих задач. Ну подожди, подожди, ну я понимаю, это такая попсовая фраза, она так очень умно звучит, но мы-то с вами понимаем, что, конечно, свой инструмент для всех задач, но там, знать 20 инструментов, это головы не хватит. Хватит, нормально хватает. Ну то есть ты считаешь, что использовать в проекте там месиво из Java, бетона, баши, еще хрен знает чего, вот там 20 инструментов каждый для своей задачи, это ок. Да. И ты когда к тебе приходит программист, он должен, соответственно, знать все эти 20 технологий. Ну учить понемножку, да. Во-первых, во-вторых, мы же профессионалы. Во-первых, единственная в чем проблема, во-вторых, смотри, у тебя все равно, скорее всего, сложность не в языке. То есть ты, скорее всего, берешь какую-то технологию, именно технологию, какой-то набор чего-то, не знаю, ты берешь кавку, сразу берешь, считай, скалу, зукипер, что там еще, JVM, ярн. Нет, ярн-то уже, с самой скалы ярна нету. Ну, все далее, берешь замзу, берешь кавку, берешь ярн, берешь зукипер, берешь JVM, вот то есть ты хотел просто процессить потоки, казалось бы, а ты втащил себе сразу большой-большой-большой-большой жирный стек. И у тебя вся сложность не в том языке, на котором он написан, ну то фиг с ним, это можно выучить за пару недель, чтобы просто на уровне того, чтобы это все прочитать и где-то там вонзиться в случае необходимости. А у тебя сложность возникает в том, что у тебя есть какая-то большая штука с нетривиальной архитектурой, которую, во-первых, ее нужно как-то операционно поддерживать, во-вторых, тебе нужно для нее разбираться с ее API и всяким таким. То есть, ну не знаю, если какие-то параллели проводить, то есть, не знаю, ты если в интерпрайзе пишешь, ты вот ищешь программистов не там со знанием, просто Java, со знанием Spring, например. Хибернейт обязательно. Ну или гибернейт, я говорю, к тому, что нужно знание основного стека, и поэтому количество языковых технологий совершенно пофиг, потому что у тебя в одной технологии может быть куча языков. Если у тебя, при этом, всего одна такая технология, то ну и ок. Мне кажется, Валер, сам себе... Нет, подожди, ты абсолютно про другую ситуацию. Саша задал вопрос, когда у нас в проекте получается 20 языков программирования, и каждый хорошо решает свою задачу. И каждый со своим стеком. У нас не бывает 20 языков программирования. У нас, как правило, бывает 20 стеков. Ну 20 стеков тоже не очень хорошо, но у нас при этом же еще бывают ситуации, когда у нас есть, не знаю, один стек, но в нем куча языков программирования. Валер, вопрос был конкретный. Вопрос был не про стеки, вопрос был про языки. На что Света ответила, что каждый язык для своей задачи. Язык, а не стек. Так вот, а я считаю, что язык... Я не понимаю, зачем ты пришел... Действительно, какое отношение имеет язык, на котором мы пишем к решению задачи? Ну серьезно, потому что, как правило, имеет отношение с стеком. То есть я очень люблю ирландский, считаю, что это язык, на котором нужно писать все разнообразные системы, но там, не знаю, кафки на ирландске нет. Вот я о чем говорю. Ну у нас рэббит есть. Ну рэббит говно по сравнению с кафкой. А вам не кажется, что это немножко разные технологии? Рэббит и кафка? Да. Знаешь, я с тобой совершенно соглашусь, что это совершенно разные технологии, но тут есть такой тонкий момент. Вот ты хочешь просто message queue в себе в проект, но так, чтобы она не теряла данных, и при этом была с репликацией. И все, у тебя, в общем-то, кроме кафки, выбора-то нет. Потому что рэббит мк в некоторых ситуациях вполне может потерять данных. И вообще у него нет нормальной репликации, на самом-то деле. Если читать доки внимательно. Да и вообще может Амазон, я не знаю, раскопать бульдозер и все похерить на все. А подождите, а в каких ситуациях рэббит теряет данные? Ну при том, что у нас персистентная очередь. Начнем с того, что он просто может hemen падать. Объем, большой объем накопленных данных у него не хватает памяти, и он валится. При этом внутренняя амнезия может выйти из строя. То есть, да. У тебя есть внутренняя амнезия и две реплики. Не по причине, что у нас хватает памяти. То есть ему это все, окей. Ну смотри, сплит, сплитнула, и какая-то одна из репликов продолжала обслуживание, потом сплит восстановился. Значит, не так, обе реплики продолжали обслуживание. Сплит восстановился. И какая-то из реплик выиграет, какая-то проиграет. Ну то есть, данные проигравшие реплики окажутся в нигде, где в нуле. Хорошо, а как это ситуа... Понимаешь, в чем дело? В случае с кроликом есть какие-то способы решения этой ситуации. Проблема в том, что это не проблема именно кролика. Очень у многих систем есть такие проблемы, у Монг есть такая же проблема. Это к тому, что если ты хочешь выбрать какую-то технологию хорошую, если ты знаешь, что эта технология лучше, и у тебя не стоит выбора между втащить еще один стек, или втащить еще одну технологию, или не втащить. У тебя выбора-то нет. Ты знаешь, что это штука единственная, которая удовлетворяет твоим требованиям, решает твои проблемы. Возвращаюсь к оригинальной теме. Валера, подожди, я хочу вопрос задать. Ну давай. Собственно, Валера, ты сказал, что это по сути стандартная проблема спритбрейна. Как решать эту задачу кавка? Потому что я не знаю, как это... То есть если ты знаешь, как это внутри реализовано в кавке... Ну смотри, там есть Zookeeper. Там есть такое понятие, как наиболее... короче, реплика-сет. Мажорити. Что? Ну через мажорити. Там не через мажорити, в том-то и дело, там не через мажорити. Там есть инсинг-реплика-сет, это как бы реплика-мастер, которая назначена выбором лидера через Zookeeper. Вот, и есть какой-то набор реплик, которые находятся... которые успевают вычитывать данные с мастера и применять их себе. А если не успевают всегда? То есть у нас опять же eventual consistency получается. Нет, там нет eventual consistency, там strict consistency. У тебя записи только в мастер, записи не могут идти никуда, кроме мастера. Реплики просто вычитывают из мастера. То есть их лог – это повторение лога мастера. Соответственно, у тебя не может быть так, как в Zookeeper, что у тебя клиенты пойдут в два разных места и запишут в два разных места. Собственно, способ решения этого с кролем тоже можно сделать через какую-то внешнюю систему выбора лидера и ходить только в лидеры, пока он не помрет. И при этом у Zookeeper'а есть такое понятие, как инсинг-реплика-сет, что ты знаешь, что у тебя вот эти реплики, из них можно выбрать нового лидера, если он предыдущий обломается. Там тоже есть edge-кейсы, когда у тебя инсинг-реплика-сет стал единички равен, а вторые машины на самом деле не совсем умерли. Там тоже может быть кейс с потерей данных, но он, во-первых, очень невероятный почти, во-вторых, есть какая-то опция в конфиге, которая позволяет этот кейс выключить. Просто, ну, как бы по умолчанию считается, что он настолько маловероятный, что лучше его допускать и при этом продолжать обслуживание. Вот. Вот, собственно, там никакой мегамагии нет, обычная синхронная репликация и с выбором лидера через Zookeeper. Я ответил на твой вопрос? Глобально – да. Но тем не менее всё равно остаётся маленькая вероятность того, что получится неконсистентная данная. Почему? Нет, нет, нет, её… откуда ты считаешь, что тебе берётся такая вероятность? Я могу так сказать, сославшись ни на свой опыт, ни на какие-то свои знания, просто могу сказать, что её тестировали этим Джепсоном, и вот, исключая тот кейс, про который я говорил, она данных не теряет. И там не то, что там неконсистентность, там именно потеря данных в случае, что вот мы же понимаем, что у нас здесь не осталось мажорити, но типа мы считаем, что они у нас действительно… ноды прямо отсохли, они просто невременно недоступны, поэтому мы продолжаем обслуживание. Либо это поведение можно перекрыть и сказать, что если у нас нет мажорити, то мы просто идём нафиг. Ну да, в каком случае звучит неплохо. Мы про Java говорили, помните, да? Угу. Про Java говорите интересно, что такого интересного в этой вашей Java? Так не нужно интересный быть, нужно быть простой, понятный, решающий свою задачу, быстрый. Любую задачу. С кучей библиотек, вообще подо всё. Ну на самом деле это не совсем правда, то есть есть библиотеки, которых нет под Java. Ну сравни с другими стэками. Да, да, да. То есть, понимаешь, по сравнению с другими для Java есть всё, что тебе нужно. Ну с другой стороны тут понятно, что как раз я перешёл на стэки, почему люди выбирают некоторые стэки, почему люди тащат много технологий? Потому что есть какая-то киллер технология на ком-то стэке, то есть там не знаю, опять же, как я уже говорил про кавку, то есть хочешь кавку, но тебе придётся всё это втащить. Хочешь React, придётся втащить Erlang. И Java. Да, ты, правда, намекаешь, что там есть Solar встроенный. Ну да. Но ты можешь его не тащить. Я могу Cassandra потащить, а не React. В зависимости от твоих нужд. Ну ладно, я вижу, что мы все сошлись на том, что Java замечательный язык и вообще технология. Поэтому следующую тему предложила Света. Я? Сейчас играю. Что я предложил? Что происходит? Какой сегодня год? Как подкаст называется? Тема с прошлого выпуска, перекочевала. Называется «10 причин, почему вы не должны писать тесты, юнит-тесты и вообще тесты зло». Такая интересная статья, мне она понравилась. На самом деле в ней не 10 причин, в ней всего лишь 7 причин. Но они такие смешные. Автор сказал, что 10 просто звучит классно, поэтому оставим 10. И первая причина, потому что вы являетесь Neo. И вообще вы представляете, как код работает на уровне битов, байтов. И вообще вы прекрасно понимаете все, как оно работает. И вам тесты в принципе не нужны. Дальше следующая причина. Если ваш продакт-тонер является, как это перевести? Десятым аватаром лорда Кришна, все правильно. Круто. И по сути в такой ситуации вам тоже не нужны тесты. Он просто говорит правду. Всегда. Классно. Вот, дальше третья причина. Если ваша команда умеет предсказывать будущее, и в такой ситуации вам тоже не нужны тесты. Вам не нужен никакой рефакторинг, все, вы знаете наперед. Короче, это сарказм и писать тесты нужно, я так понимаю. Короче, был такой писатель детский, кажется, Григорий Уластер, да? У него были бредные советы. Да-да-да. Если вы там бла-бла-бла-бла. Вот в точности вот оно. Даже когда на русский переводишь, такой же интонация прям можно зачитывать. Вот, ну мне, что-то тебе понравилось, такая юморная, и прям я порадовалась. Ну да, да. Все ведь согласны с этим? Я не согласен. Ты считаешь, что не надо писать, да? Тесты? Тесты – это просто трата времени, очевидно. Ну в смысле, вот то время, когда ты писал тесты, мог Фичу написать за этот же вред. Конечно. Зачем? А мы все пишем без ошибок, я согласен, да. Это как раз Нео, я вижу битвы. Первый, да, первый пункт. Я вижу битвы. Саша, ты Нео? Он видит зелёненькие циферки на экране. Нет, я Фискон. А, красную таблетку уже ту сегодня? То только синюю. Как глубоко в кроличьей норе? Не скажешь, что… Я купил таблетку, но она такая… Не красная, это может быть. Жёлтенькая и в ней какие-то синие гранулы. Не, не пей, это не оно. Не оно. Ну что, пошли дальше? Да, да, да. Добивая темы, которые не вошли в прошлый выпуск, я хотел сказать пару слов про Энсимбл Тауэр, о том, как я… На чём я остановился в прошлый раз? Потому что я что-то рассказывал коллегам, что-то в подкасте, я запутался. По-моему, ты про Тауэр тебе говорил Ваня, и ты сказал, что я посмотрю. Всё. Серьёзно? Нет, нет, нет, нет, ты рассказывал, что Тауэр… Что я его, по-моему, поставил, но пока это всё. Да, да, и что это просто красивые картиночки, и я ещё говорил… Мы спорили, я ещё говорил, что можно то же самое сделать и на консоли, зачем оно нужно, и ты сказал, что там для конфигурирования и смотрения всяких логов. Да? Ну, я не уверен, что я именно так выразился, но допустим. В общем, я хотел дорассказать, чем всё закончилось. Добей. Да, значит, удалось заставить его работать, но в Тауэре оказалась куча разных нюансов. Значит, во-первых, во-первых, ему обязательно нужен рут на инвенториус. Я, кстати, вспомнил вот то слово, которое я пытался вспомнить, но не мог. То есть у них там вот эти вот тачки, ну, весь твой парк называется, наверное, это произносится инвенториус, или как? Инвенториус, я бы сказал. Ему обязательно нужен рут, хотя там типа в настройках есть, что там «ведите другого пользователя», «ведите там… поставьте галочку «использовать в суду», но эта фигня не работает. Вообще, я не смог разобраться. Короче, ходите рутом на все тачки, и всё будет хорошо. Потом, там не всё, на самом деле, можно делать через веб. Блин, я запамятовал, что там нельзя. По-моему, там нужно сами рецепты всё равно класть в папочку, заходя по SSH. То есть даже не так, что у тебя там есть какой-то редактор в веб-интерфейсе в Ямле, а вот именно нужно зайти по SSH, в ВИМе там куда-то что-то положить, и тогда всё будет здорово работать. То есть он как бы не ко всему даёт интерфейс. Удобно чё. Вот, и последнее, там получилась забавная ситуация с службой поддержки, потому что, я вам рассказывал, у меня не получалось ставить тауэр, он там не мог настроить постгрейф SQL, в итоге я разобрался, просто поставил постгрейф SQL руками, потом поставил Ansible, уже как бы, имея локальный постгрейф, всё получилось хорошо. Где-то позавчера, наверное, мне пришло письмо от support Ansible, что типа, ну раз вы ничего не комментируете к вашему ish-ю, то мы его закрываем, как типа, Resolved. И там такой приводится как бы история этого ish-ю, что якобы чуваки там мне что-то отвечали, там попробуйте то-то-то, но мне просто письмо это не дошло. Ну может оно в спаме? Нет-нет-нет, нет у меня никакого спама. То есть у них там какой-то, ну не какой-то, а вполне конкретный Zendesk, и он видимо потерял одно письмо. В Dev Null пустил. Ну да-да-да. Всё видимо на Gravit MQ. И что меня печалит, у них этот Zendesk он никак не индексируется, то есть если кто-то сталкивался с какой-то проблемой, и ему могли её решить, то ты через Google это не найдёшь. Для сравнения, у других проектов они делают просто Google группу, Google группа отлично индексируется. Ну это же нехорошо полить проблемы своего проекта, как же так? Ты же должен сказать всем, что у тебя строго консистентная база данных поддерживающая ACID, потом всем рассказывать, почему у них в продакшене всё развалилось. Это ведь гораздо интереснее так продавать, чем честно сказать, что мы там не знаю, какие-то гарантии предоставляем. Зачем вообще на сайте писать, что работает, что не работает? Так, простите, была моя минутка ненависти ко всему, что маркетится. Да, там маркетинг такой маркетинг. Сейчас даже я знаю, что такое ощущение, что сейчас появился оппозиционно честный маркетинг, когда на сайтах, наоборот, предельно чисто пишут, что мы такие-то и такие-то, такого-то не умеем, такого-то не умеем, в таком-то случае наш продукт брать не стоит. И дальше как-то поднимается на щит, что мы такие-то суперчестные, и это как часть маркетинга начинает идти. Ну то есть, например, если посмотреть, у нас маркетинг какой-нибудь Монги, маркетинг какого-нибудь Aerospike, и маркетинг, например, Foundation DB. Вот Foundation DB, например, такого маркетинга, когда прям всё выкладывается просто как есть. А про Aerospike что ты скажешь? Про Aerospike скажу, что не верьте, то есть он, правда, быстрый, но не верьте всем этим заявлениям про консистентность, это бушит. Ну и там же нету такой консистентности, там говорится, что там eventual consistency, ты можешь включить, чтобы была строгая консистентность, но… В том-то и дело, что ты можешь включить, они говорят, что вы можете включить ACID, но вот это не ACID ни разу вообще никогда, это не ACID совсем никак, это не близко даже к ACID, это просто вот, точно так же в Cassandra они сделали микротранзакцию, то есть они сделали compare and swap по ключевой, им хватило вот ума назвать это ACID. А шо ж мать. Прям боль какая у тебя сквозь. Да, ну серьёзно, понимаешь. Бомбит, прям бомбануло Валерия. Да, вот ты идёшь, пытаешься найти технологию, которая решает твою задачу, идёшь на её сайт и пытаешься понять, что же мать её она делает. Ты не можешь понять, потому что они накидали настолько базовордов, из-за которыми совершенно потеряли смысл и описание того, что система умеет, чего она не умеет. Да, это реальная проблема, к сожалению. Ну то есть качестве хороших примеров могу назвать React, RabbitMQ, кстати вот я его ругал, но сайт у них нормальный, у них там всё честно описано. Могу назвать Kafka, качестве хорошего примера, RethinkDB и FoundationDB. Вот они прям честно и честно всё пишут, аккуратно и понятно. Так даже не делай себе. Мне понравилось, вообще в Scala сообществе там всё очень открыто, всё в Google группах, то есть там всё всегда можно найти, обсудить. Вот у меня была проблема с Камоном, я обратился в группу, там мне не особо помогли, но по крайней мере, когда я нашёл решение, я его туда запостил и оно теперь в Гугле. Ну то есть вообще это ко всему относится, к Scala, к Аке, к плею. И мне даже понравилось, вот есть Адерски, а есть второй разработчик, не забыл как его зовут, который очень много комментирует именно в Scala, именно в компилятор. У него есть несколько докладов, они там из серии «Почему в Scala всё плохо, всё через жопу и как это сделать правильно, куда двигаться». Он там приводит умопомрачительные примеры о том, что функция map в идеале должна иметь такую сигнатуру, но на самом деле она имеет там очень-очень сложную сигнатуру и иногда она там ведёт себя как-то совсем-совсем не так, как вы ожидаете, хотя казалось бы, блин, это долбанный мэп. Ну вот, я постараюсь найти ссылку на доклад и прилепить в шоу ноты, но не обещаю. А, Саша, расскажи, какая у тебя была проблема с коммоном? А, оказалось, что плей, когда... вот я запустил свою приложенку на плей, да? Он инициализирует Actor System лениво, а коммон, у него висит хок именно на запуск Actor System. И получалось так, что ты пока не запросишь первую страницу из-за плей, у тебя не репортятся метрики. Понимаешь? Ну вот, но это можно решить, как бы, там есть такой объект Global, и ты через него можешь принудительно вычислить Actor System, и всё хорошо. Actor System у тебя создаётся плеем, да? Плеем, да. Ну вот, а как бы, подводя итог по Ansible Tower, фигня полная, ну, по крайней мере, на данный момент, может, они её когда-нибудь допилят, но в целом я пока не советую, т.е. если вам нужен именно веб-интерфейс, то, наверное, нужно смотреть куда-то в другую сторону, сам пока не знаю в",
    "result": {
      "query": "Scala implicit arguments pros cons"
    }
  }
]