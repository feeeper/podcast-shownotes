[
  {
    "segment_id": "8c42bf2b-7c4b-46bb-bc18-9ea2a30d51d4",
    "episode_id": "6e24db21-cfb2-435c-bdde-92de9755af96",
    "episode_number": 108,
    "segment_number": 3,
    "text": "Так вот Василий приходит обязательно к нам на ретроспективу и приносит нам задачи. В клювике какие-нибудь от разработки, крупные какие-нибудь штуки, мы совместно с ним разрабатываем, куда и как мы поплывем часто. Вот как раз это такая точка соприкосновения в основном. Другие разработчики конечно нам тоже могут задачи помещать. Но это на регулярной основе происходит. Да, да, это именно системный подход, когда мы обсуждаем глобально, куда мы побежим в следующие две недели. И Василий это представитель от разработки у нас постоянно, постоянный гость. Коль скоро, вопросов больше нет, я вижу, ты принес нам интересных ссылочек. Например, что означает CPU IO wait time. Что же он означает? Ну мы пошли по теме, значит. Ну, окей. Ну это твои темы. Да. Интересная тема. Возможно просто немногие обращали на это внимание. Если Вы на сервере запустите какой-нибудь там топ, атоп и так далее. Ну или просто распределение ресурсов посмотрите, то на загруженной машине Вы можете увидеть не нулевой IO wait time. Ожидание. И оно относится в топе в каком-нибудь он относится к CPU. И один человек, товарищ вот из этой статьи, который написал статью, он задался вопросом, а как так получается, что IO wait относится к CPU, но с другой стороны, когда происходит IO wait, когда процесс ожидает ввода вывода, он снимается с процессора. И процессор занимается другими задачами. Тогда как так получается, что это характеристика CPU? Вот. И в своей статье в 2013 году он подробненько рассмотрел как и что происходит. По-видимому, кроме меня никто не заглядывал в статью, да? Нет. А можно вкратце? Ну вкратце он говорит, что IO wait, которая показывается, она на самом деле действительно не является характеристикой CPU, процессора. Она характеризует процессы, которые могли бы исполняться в это время. То есть другими словами, если вы видите IO на CPU, то это характеристика не загруженности процессора, а его простоя. То есть IO wait это часть idle, а не часть нагруженности процесса. И эту штуку как раз многие не понимают, когда рассматривают. Поясни для слушателей, это в метриках глобальные или по одному процессу? По процессу. Потому что когда она усредняется по нескольким процессам, она вообще в кашу превращается. То есть это время, которое процесс мог бы выполняться, но вместо этого он ждал IO? Да. То есть это время, практически это время, когда ваш процессор простаивает из-за того, что процесс не может исполняться. Удобная метрика, как по мне. Ну да, она очень... Ее не все понимают правильно. Но это потому, что контраинтуитивно. Да. Поэтому эту статистику очень рекомендую посмотреть тем, кто рассматривает performance в сервисах. Я предлагаю следующую темку, которая там вылезла, чуть-чуть отложить. Хорошо, давай. Я пока могу рассказать, вот мы там про Pathgres говорили, добьем последнюю ссылку. Она... секундочку, ссылку в чат запостил. Она про плагин. Саш, ты сейчас что-то говоришь? А, я опять замутился. На чем я замутился? Сори. Ты скопировал в чат ссылку и все. Ага, я понял. Ссылка на плагин. Плагин называется pg-variables. Он добавляет, строго определение такое, сессионные перемены в Pathgres. Что это такое? Вот, не знаю, Валер, тебе говорит о чем-то? Интересно, потому что я этот термин не так давно услышал. Ну, я подозреваю это то, как в итоге сконфигурирован Pathgres в интернете конкретной сессии. Если я правильно понимаю, что это такое, о чем речь, то вот мы можем какие-то параметры определить еще внутри сессии, кроме того, что они глобально в конфиге определены. Я правильно понимаю? Близко, но речь не про параметры того, как ведет себя Pathgres, это у тебя в сессии... Глобальные переменные. В сессии глобальные переменные, которые не в транзакциях. То есть типичное применение на самом деле такое, то есть как бы зачем реальным людям это нужно? Ты, например, сделал транзакцию, в ней вложенную транзакцию, в ней там еще несколько, и вот тебе нужно куда-то делать как логи, только вот не логи, а куда-то чего-то записать, да? Ну, типа, что ты делал на комшаге для отладки, например. Но опять же, только не в логи. И вот тебе хочется такую переменную, которая вроде как у тебя к транзакциям отношений не имеет, но при этом можно использовать ее с транзакцией. И тогда ты можешь там написать, я начинаю транзакцию первую, я начинаю первую вложенную транзакцию, да? А откатывается, когда оно? Ну вот, ты делаешь rollback, у тебя все откатилось, но в эту переменную весь лог записан, понимаешь, да? Такой вот, это типичный, как их используют. А на самом деле это просто переменные, которые живут у тебя в сессии, в коннекте, и вот просто key value без транзакций, понимаешь? Без транзакций, то есть если две транзакции одновременно выполняются, они туда вообще зафигачат какую-нибудь ерунду? Они сессионные. А, они сессионные, точно-точно. То есть они, ты в одном коннекте не видишь переменные другие. Ну вот. Это довольно удобно не только вот в описанном кейсе, но на самом деле это такой key value in memory в Postgres. Так что если вам вот по каким-то причинам, ну не знаю, вы не хотите там 30 коннектов открывать, да, например, там один к Postgres, еще там к MySQL, Redis, еще к чему-то, вот, поинтересуйтесь этим плагином. Он клевый, он умеет не только там строчечки, он разные типы умеет, у него есть что-то типа namespaces, вот, довольно клевая штука. Ну то есть, ну вот я смотрю, и вот как в прошлом Backend разработчик прям радует. И жалею, что не было. Погоди, а он там, не знаю, ты хочешь некий аналог некой последовательности записать, там я делаю шаг 1, я делаю шаг 2, я делаю шаг 3 с таким значением, ты должен append-ить к строчке, или это массив строк, или как это правильно сделать? Да я думаю, да я думаю и так и так правильно, то есть и как массив, и append-ить. Я вот смотрю на конкретно API этого плагина, здесь есть setText и getText, то есть, ну тут видимо только append-ом. То есть, сейчас посмотрим, текстовые, целочисленные переменные, timestamps, timestamps с timezone, и data, jsonB, и рекорды. Ну, похоже, что здесь массивы на данный момент не поддерживаются, не массивы, а, ну собственно, они в json поддерживаются, ты можешь туда append-ить, ну то есть понимаешь.",
    "result": {
      "query": "Postgres сессионные переменные плагин"
    }
  }
]