[
  {
    "segment_id": "94ce5171-cfee-42f7-b2af-d18f8ccdd05e",
    "episode_id": "90d7808f-e304-446f-9bca-eeeb1bbebf3d",
    "episode_number": 462,
    "segment_number": 2,
    "text": "Например, Эктором в Swift был посвящен один большой такой питч. Это прям супер документище. Это можно как книгу читать. Вот. А когда добавляли в язык, его разбивают на разные пропоузалы, то есть как бы изменения, которые уже вот по чуть-чуть добавляют в язык. И, соответственно, для этих пропоузелов есть отдельный репозиторий на Гитхабе. Так и называется Swift Evolution. И там, соответственно, папочка пропоузлс, и они там по номерам. Вот. Сегодня я как раз зацеплю четыре из них, и я привожу все ссылки в шоу-нотах. Вот. Значит, я пытаюсь воткнуться головой в стену, а точнее в акторы и синхронное вычисление, как это правильно делать на Swift. Вот. И у меня очень получается с большой пробуксовкой. Как видите, два года уже целых пробуксовываю. Надо было читать так сразу. Но все равно получается интересно. В прошлые разы мы обсуждали, что такое акторы, когда я в прошлый раз притаскивал эти темы. И я напомню, что акторы — это попытка создателя языка сделать окружение, в котором вы четко будете понимать, что вот у нас есть структура данных, это структура данных, там у нее есть какие-то методы, там, я не знаю, класс это или структура, это разные вещи в языке, но не суть. Вот. И в нем при обработке каких-то данных вы можете, два одновременно потока выполнения могут одновременно что-то сделать, и вы получите race condition. Когда у вас либо один поток сначала что-то сделает, а потом другой, или в обратном порядке, у вас может неконсистентно что-то выполниться. Для примера всегда приводят, что у вас там есть два счета, и вот вы с одного счета перекидываете деньги на другой счет, но когда вы с первого счета эту сумму списали, в этот момент на втором счете там, с этого, как его, кто-то второй тоже берет и вписывает эту сумму, и так вы уходите в отрицательную сумму. Вот это все. Классический пример с этими, с гонками, и в паск-дискель, наверное, подобные примеры всегда приводятся. Вот. Поэтому я в простые примеры погружаться не буду, тем более, что мы это уже обсуждали, а пойду дальше. То есть, для того, чтобы решить эту проблему, были придуманы экторы, которые, на мой взгляд, очень похожи на то, что было предложено изначально в Ирландии, и идея в том, что�екеры всегда идут, всегда выполняются на каком-то отдельном потоке, и все, весь доступ ко всем данным, которые лежат внутри эктора, они всегда выполняются только на одном потоке. То есть, не может быть такого, что два разных потока прочитают что-то внутри одного эктора. Для того, чтобы не путаться, это, да, я сейчас... Прости, чтобы уточнить, я буду встревать. Все правильно. Разные экторы могут выполняться на разных потоках? Да. И здесь надо уточнить еще, что эктор в данном случае, это не... В Ирландии эктор – это независимый агент, который что-то делает. В рамках свифта эктор – это структура данных, которая энкапсулирует внутри себя какие-то данные. Ну, то есть, как бы, вот у вас был struct, структура, или был класс, а теперь вы заменяете слово структура, и вы заменяете слово структура, и вы заменяете слово структуру. Construct на Actor. И это говорит языку и рантайму, что типа вот это у нас структура данных, которая должна выполняться только на одном потоке все время. Этот поток может переключаться. То есть когда он уходит в какое-то ожидание, он может внезапно проснуться на другом CPU, в другом трейде. Но идея в том, что никто не может в несколько одновременно concurrently, то есть как бы в один и тот же момент времени прочитать или записать какие-то данные внутри. И как раз вот про это я сегодня немножечко порассуждаю и буду давать ссылки. Значит, во-первых, пропоузл номер 306. Это изоляция данных в Actor. И мне лично это очень интересно читать. Мне это интересно читать, потому что, во-первых, эту идею решения... решения рейсов все решают по-разному. И я очень много работал с языком Erlang, в котором это решено совсем по-другому. Здесь начали использовать подобную же... подобную же концепцию, в смысле подобное же название. И меня это немножечко путает и сильно дает неправильные ассоциации. Но одновременно они решают подобную проблему с помощью совершенно других решений. Поэтому сравнивать очень интересно. Спасибо. Итак, в Swift все доступы к Actor производятся синхронно. Синхронно... Асинхронно, простите. То есть у вас есть, как и в Erlang, какой-то mailbox, в который скидываются все запросы на доступ к данным. И, например, если у вас очень простая структура данных была, банковский счет, на котором какая-то сумма денег. Вот эта сумма денег хранилась раньше в классе. Для того, чтобы раньше не было... Было гонок, вы всегда делали какую-то... Какую-то защиту. Там, mute ставили, lock ставили, еще что-то делали. И тот поток, который пытается считать, он берет этот lock, берет lock у другого банковского счета, например, у двух одновременно, что-то куда-то записывает, что-то где-то меняет, перекидывает данные, потом отпускает этот lock, и работа продолжается. Вот. Соответственно, в Actor они решили сделать так, чтобы у вас это было как бы структурой, как бы структурой языка, которая на уровне рантайма поддерживается. Поэтому, если вы в Actor написали, вот у меня есть такое количество денег, как это поле этого Actor, то при доступе к нему не надо никаких локов. То есть у вас будет гарантировано, что вы, и только вы в данный момент времени читаете эти данные, и это делается как раз с помощью вот этого Mailbox. То есть все запросы к чтению или записи поля попадают в Mailbox, а потом есть какой-то шарф, который обрабатывает, как и в Erlang, очень похожая система, обрабатывает все эти запросы раз за разом и посылает обратно куда-то ответы. Это делается невидимо для вас, вы ничего этого не контролируете и ничего этого не знаете, но одновременно это гарантирует, что если два потока одновременно сделают запрос в Actor, это превратится в то, что это появится в виде двух сообщений внутри Mailbox, и обработчик будет обрабатывать их один за другим. Он, соответственно, скажет, первый запрос, о, вот тебе значение, вот тебе ответ. Вот второй запрос, вот тебе значение, там изменение значения, вот тебе ответ. Вот.",
    "result": {
      "query": "Swift Actors data isolation"
    }
  }
]