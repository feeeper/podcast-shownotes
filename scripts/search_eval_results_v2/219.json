[
  {
    "segment_id": "8f2e5239-c368-42ff-a8ec-2b27b2bf439f",
    "episode_id": "3958bf0e-77a9-468d-8ec3-31a57e6eef52",
    "episode_number": 219,
    "segment_number": 2,
    "text": "Зачем все это нужно? У них там несколько, кстати, надо в шумоводок приложить, описаний изначального протокола, там, в отличие от современного РФЦ, который описывает, как оно работает, как оно должно работать и так далее, вот этот исходный документ очень неплохо описывает мотивацию, то, к сожалению, что в РФЦ сейчас нет. Они там говорят, что одна из причин, почему они это хотят сделать, это уменьшить лентности, уменьшить количество хендшейков, типа, там, не знаю, увеличить throughput, при этом оставить все совместимым пределы, например, UDP, потому что UDP все-таки везде есть и есть шансы, что будут использовать, это, например, объясняет, почему они не решили, там, SCTP везде есть, пользователи вообще сделать какой-то свой собственный IP-pool, вот, но основная их мотивация была в том, что Qwik им позволит быстрее обновлять версии протокола, потому что он сделан в визерленде, да, то есть, когда там TCP делает какие-то нововведения, там, меняет алгоритм изменения окна, меняет, там, еще что-нибудь, какие-то вещи появляются, нужно долго ждать, пока они разобьются по всем ядрам, в некоторых случаях это вообще происходит очень медленно, то есть, например, TCP и PSTACK в Windows, он довольно стабилен, он хороший, но он медленно для Google обновляется, то есть, если они могут свои сервера на Linux обновить, у них там все ускорится в два раза, да, то в Windows у них все равно ставятся на Windows XP, и, соответственно, никакого ускорения они на том же YouTube не получат, при этом, если они ставят, там, последний Chrome на этот XP, ну, не знаю, конечно, на XP уже, наверное, не поддерживаются, ну, допустим, на семерку какую-нибудь, то у них уже YouTube будет работать по квику, у которой они могут быстрее с ним делиться и быстрее подгонять параметры, смотреть на практику, как это работает, чтобы оно все работало быстрее. Вот вообще, вы смотрели на квик, знаете, что это такое? Вообще нет, я лично вообще не глядел. Даже если бы мы это делали, думаю, для слушателей все равно было бы здорово пояснить. Ну, в общем, основная идея, да, то есть, я вам сказал, если вот на пальце, то это во многом TCP плюс шифрование, то есть, вот как происходит классический хендшайк в TCP, да, мы посылаем TCP SYN, к нам приходит TCP SYN плюс ACK, мы дальше посылаем TCP ACK, все, окей, TCP все где-нибудь установился. Во-первых, это мы нам ворачаем TLS следующим слоем, да, то есть у нас есть транспортный уровень, во-первых, у него там какой-то следующий уровень в модели AC, в модели, не знаю, там, сессии, там уровень сессии. Делаем TLS, TLS client hello, TS server hello, TLS finish, все сертификации обменялись, ключ получили, все, пошел HTTPS. Вот туда-сюда, пока мы бегали, там мы уже сколько, 4-5 раунд-трипов сделали. Квик в идеальном случае у него раунд-трипов 0. Сказал бы, что за бред, как это возможно, но идея в том, что если квик подключается к серверу, к которому уже подключался Дэф, то есть было предыдущее соединение, теперь используют как бы некую специальную куку, клиента, и сразу в этом же бреде идут уже и первые данные. Тем самым получается, что по сути раунд-трипов 0. Если такого соединения еще не было, я людям отвечаю, что я не знаю, что это такое, давай-ка мне сделают авторизацию. Авторизация в зависимости от нескольких факторов может занимать либо один, либо два раунд-трипа. Опять же, кажется, что это довольно, ну как-то странно, но по большому счету, основано на том, что нету вот этого явного синака, вообще нет установки соединения, потому что это UDP, вот, и есть некое такое виртуальное соединение, которое идентифицируется своим айдишником. Причем, что интересно, этот айдишник, то есть уникальный дефокадр соединения в квике, это просто число, 64 бита, и не пара IP, порт на обоих концах, как в случае с IP-соединением. Вот, что, конечно, это имеет свои последствия, а, и этот айдишник его генерирует клиент, то есть клиент его отсылает на сервер, и он его сам случайно генерирует. При этом может использовать предыдущее, тогда это будет предыдущее соединение, или может, если какой-то злоумышленник, он может постараться его прихватить, как-то расшифровать, она тут расшифрована, и отправить то, и тогда он ему сломает это соединение. Но на практике это довольно сложно сделать, а случайно подобрать 64 битовые числа. Это же как интересно, зачем так сделано? Ну вот именно ради того, чтобы не было лишних хендшайков, чтобы уменьшить лепность. А, я подумал, может быть это как-то связано с построением роузинга и того, что я могу живые соединения в кавычках перебрасывать с остановившегося сервера на другой сервер, что-то в этом роде? Да, да, да. Нет, это тоже, то есть почему такая идентификация, именно да, чтобы можно было перебрасывать, но даже речь не скорее не про сервера, хотя это тоже важно, а речь скорее про клиента. То есть те самые мобильные клиенты, которые приходят от базовой станции к базовой станции, могут потенциально менять свой IP, тем самым соединение будет разрываться, или тому подобное. Потому что ты можешь ехать везде, и у тебя будет постоянно происходить перебрасывание, постоянно твои IP меняются, но YouTube будет продолжать работать. Тот самый мобильный IP, который когда-то хотели втащить, там были какие-то идеи, то, что их был пропозал, что там было Speed плюс Mobility, вот Mobility была идея в том, что такой прозрачный переброс IP, но это не реализовали, вот в FIKA это есть. А другой вопрос, как это не нарушают всякие, то есть если мы просто переиспользуем какой-то IDшник из старых сессий, какую-то куку, почему это не ломает условный TLS? TLS это не ломает, потому что TLS в большом счёте там нет. То есть есть такая штука, называется DTLS, это TLS адаптированный для датограммов, то есть для UDP, вот, QUIC тоже не его реализует, то есть DTLS используется под UDP, есть тоже классический, когда вы инкапсулируете какой-то собственный протокол, какой хотите в UDP и в DTLS, там есть классический маппинг, он тоже в начале есть Handshake. В случае QUIC делается подобная вещь, но своим собственным образом, ну и концептуально она всё-таки похожа на TLS, но именно адаптированная для того, что у тебя датограмма есть. То есть у этих ребят своё собственное крипто? Нет, крипто у них не своё собственное, в том плане, что они не изобретали там ни шифры, ни режимы работы шифров, ни методы симметричной криптографии, то есть для этого используются стандартные алгоритмы в TLS. Ну, они и Handshake поменяли, Handshake часть крипто протокола. Это скорее не Handshake, это скорее, ну, окей, ладно, Handshake можно сказать, что поменяли, хотя, конечно, как посмотреть, можно сказать, что они его адаптировали и просто приложили на пакеты по-другому. А это же как в TLS работает Session Exemption, то есть, по сути, когда ты подключаешься, ты говоришь, привет, я такой-то, вот у меня есть такая сессия, если ты меня ещё помнишь, то давай сразу начнём говорить за шифровым.",
    "result": {
      "query": "как работает quic протокол"
    }
  }
]