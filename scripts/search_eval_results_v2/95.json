[
  {
    "segment_id": "72bd9b5a-b037-4409-b1ca-ff4266086bc6",
    "episode_id": "71fbdc0d-7f18-4f0d-ab02-f3408d2e6f78",
    "episode_number": 95,
    "segment_number": 5,
    "text": "Мы такую штуку использовали очень часто и для Erlang тоже, то есть это на самом деле наглядно и удобно показывает, что к чему. Да, более того, сама библиотека тестирования Go позволяет делать много интересных вещей, например, позволяет писать бенчмарки очень просто. Позволяет очень просто писать бенчмарки как по CPU сложности, так и по памяти, то есть вы можете смотреть, есть ли у вас какие-то деградации, например, по аллокации. Вот, позволяет писать тесты в виде экзамплов, которые просто потом еще добавляются в документацию, например. И много-много таких интересных фич, которые можно использовать. Слушай, у меня только вот такой вопрос, там было две вещи в его слайдах, с которыми я немножечко не согласен. То есть, во-первых, он говорит, что если вы работаете с сетью, то не пытайтесь мокать сеть, сетевые подключения и все связанное с сетью. Используйте настоящую сеть, делайте настоящее подключение и работайте с этим. Я не исток плюсовую. Поясните, пожалуйста, как мне тогда с помощью немоканной сети сделать какие-нибудь сложные вещи, типа тестирования сплитов или возможных отказов, то есть негативные тесты. Смотри, у нас сделано как, если твоя задача протестировать конкретно сеть, то тогда ты ее мокаешь. Ну, например, на примере базы данных. Если твоя задача протестировать проблемы в базе данных, тогда ты ее мокаешь. Если твоя задача протестировать код, который работает с базы данных, то проще поднять рядом базу данных и тестировать твой код. Какое-то такое разделение. Ну, опять-таки да, в случаях, когда нужно тестировать всякие странные случаи, да, вторая футурология за сегодня, по-моему, обычно такой код немножко независим от того, с чем он работает, и там есть потом какой-то отдельный слой, не знаю, по крайней мере, почти все архитектуры, которые я видел, есть отдельный слой RPC, который реально работает с сетью, и есть некоторый распределенный алгоритм, который сидит на этом слое RPC. И распределенный алгоритм, ему на самом деле более-менее без разницы, кто там реализует интерфейс этого RPC. И все fault injection можно делать, мокая как раз RPC. Но при этом, если хочется протестировать, что RPC работает с сетью, то мокать сеть довольно странно и непрактично. Ну да, понятно. Я из этого доклада еще хотел бы некоторые моменты затронуть, которые лично мне нравятся. Во-первых, он говорит о том, что нужно писать, во-первых, тестируемый код, и дальше он рассказывает, добавляет в конце уже, что изначально они сначала тестируют только публичный IP. И если только, конечно, у вас какой-то реально сложный код внутренний есть, тогда уже и для него тоже пишутся тесты. Я его полностью поддерживаю, я всегда, когда пишу тесты в Go, я их пишу в отдельном пакете, чтобы у меня не было доступа к приватным методам. То есть я вижу, как мой код видят пользователи. Второе, это нужно предоставлять API для тестирования для сторонних пользователей. То есть если вы написали какую-то библиотеку, то очень здорово иметь какие-то функции, которые бы использовались пользователями этой библиотеки в ихних тестах. Например, функция просто инициализации каких-то внутренних систем вашей библиотеки. Это тоже очень здорово. Потом он рассказывает о том, что всем понятно, что глобальные переменные – это плохо, и что тестировать код, в котором используются глобальные переменные в внешнем состоянии – это очень тяжело. Но вторая проблема – это то, что иногда в коде записаны константы конфигурации, которые нельзя изменить. Это тоже плохо, и нужно давать возможность вашей библиотеке конфигурации для тестов хотя бы внутри. То есть это может быть вообще не публичный какой-то API для этой конфигурации. Потом интересный метод, который он рассказал – это так называемые золотые файлы, golden файлы. Это когда вы пишете тест, который, например, вызывает что-то сложное и получается сложный output. Чтобы вам этот output каждый раз не добавлять куда-то файлы, есть такая возможность, например, вызвать этот тест, посмотреть на output, понять, что этот output правильный. Если вы глазами проверили, что он правильный, и сказать, что я хочу сохранить этот output в фиктуры. И потом этот output будет использоваться для тестов. То есть такой, наверное, хелпер над фиктурами. Да, мне понравилось тоже вот это вот. То, что пишешь минус-минус апдейт, и он сохраняет в шаблонный, я даже не знаю, golden, правильный файл, этот результат сохраняет, и вы в дальнейшем его используете. Кстати, по поводу табличных тестов, в новой версии 1.7.go добавили поддержку вложенных тестов. То есть в одном тесте вы можете, по сути, как будто бы другой тест описывать. Это очень удобно для табличных тестов, потому что до этого я, например, всегда писал, что тест номер такой-то, чтобы понять, какая это итерация. А с вложенными тестами это все будет намного проще. Ура! Подожди, подожди, Олег, я ничего не понял. Еще раз можно то же самое? Ты вложенный тест, и поэтому тебе не надо их номеровать? Ну просто раньше, вот как бы я свежеизучающий go, я и периодически с ним плюющийся, это еще одна вещь, с которой я плевался. То есть они все любят делать просто. Иногда настолько просто, что вокруг этого просто нужно городить свои собственные огороды. В частности, вот этим местом, где все городили свои собственные огороды, был тестовый фреймворк, где у тебя тестов ровно один уровень. И это, в общем-то, хорошо, и некоторые другие тоже так делают, не знаю, в Elixir тоже так принято. Но потом вокруг этого возникает необходимость различать, что упало, если ты делаешь всякие табличные тесты. И это резко усложняется. В том же, не знаю, в том же Ruby при всей его тенденции быть заманки патченым, там можно сделать, не знаю, цикл вокруг объявления тестов и объявлять кучу тестов в цикле. Да, ну и еще большой плюс этого, то что можно каждую конкретную строчку вашей таблички отдельно протестировать. Если, например, у вас предыдущие ломаются, но вам нужно четвертую строчку протестировать, вы можете при тесте указать, что хочу вот этот тест, а и внутренний тест такой-то. Вот это клево, да. Я хотел еще добавить, это будет парт, там личные тесты на Java есть. Это Viki, в которой ты описываешь... Простильно тебе попал. Да, я же сказал, в Java есть. В Java есть парт, который называется fitness. Это такой, типа, Viki-сервер, в котором ты пишешь в виде Viki-разметки, в том числе вот эти таблицы с имя, под имя для них. Оно генерирует стабы для тестов. Получается, что бизнес-аналитик открывает в Viki страницу, пишет там качество, пишет какие-то контрольные значения и всякое такое, после этого генерируется парт. Можно офигарить. Слушай, Андрей, ну ты почини уже свою сеть. Да, и еще это звучит ужасно, потому что, а что если у нас есть уже тест, который написан был под стабом, а бизнес-аналитик взял и нечаянно в Viki ударил строчку? По-моему, там двухсторонняя связь. То есть я их не знаю, как там конкретно работают, я им никогда не пользовался, но я знаю, что довольно популярная штука. Звучит опасно и ужасно. Слав, ну раз уж мы коснулись Gua1.7 бета, ты давай, может быть, до конца доберите ему, что там еще будет новенького. Да, ну вообще сложно говорить, что будет новенькое, то есть они уже зафризили все, но к релизу они могут еще что-то поменять, например, по скорости, по каким-то оптимизациям. Вот, ну по фичам, это Gua1.7 не особо фичастый получился, и из основных фич это то, что они наконец-то добавили SSA backend новый, они его делали, по-моему, уже два года его делают.",
    "result": {
      "query": "Go 1.7 testing features"
    }
  }
]