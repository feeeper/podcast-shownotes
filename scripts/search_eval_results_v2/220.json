[
  {
    "segment_id": "712e01b0-8570-47f1-9a2f-8821d9384162",
    "episode_id": "0d71b6f9-88f9-432c-8a7d-a29d2843ca7d",
    "episode_number": 220,
    "segment_number": 2,
    "text": "А это время, оно как бы часовое время или время, которое выполнялись какие-то инструкции? То есть если, например, я пошел в диск и ждал IEO, то я не выполнял инструкции, но по часам это заняло много. То есть какое время, я увижу? Не совсем понял вопрос. Смотри, два случая. Я делаю вызов какого-то сисколы, например, типа «прочитайте с файла». Я проваливаюсь в операционную систему, в ядро, и она видит, что в кэшефайловой системе, например, еще нету нужных мне данных, и она говорит «Окей, хорошо, этот процесс сейчас поспит, пока там кэшефайловая система подгрузит нужные данные», и через, не знаю, 5 миллисекунд меня пробуждает и говорит «Твои данные приехали, добро пожаловать в скедулер». И вопрос вот в чем. В этом отчете я увижу время, которое я грел процессор, которое я исполнял инструкции, или время, которое я ждал по часам. Есть два вида времени, оба их можно увидеть, все зависит от настроек проекта. Дерф умеет собирать это и то. Понятно. Еще такой вопрос. Ты упомянул имена функций и так далее, то есть я понимаю, что нужны отладочные символы для программы, и вопрос, работает ли это со всем, то есть со всеми рандаймами, со всеми языками. То есть, если, например, у меня программа на Go, то насколько, ну, во-первых, поймет ли инструмент в целом ее, и во-вторых, учтет ли он какую-то специфику, что вряд ли я оптимизирую рандаймы самого языка. Ну, список всех языков я, наверное, не назову, но вообще да, то есть набор языков, насколько я знаю, ограничен. Как минимум C, C++, по-моему, Явл, C-Shot, Python. И еще какие-то. Я больше по очень низкоуровневым фичам инструмента и всех его возможностей не знаю. Я больше, скорее, хотел рассказать про то, зачем оптимизировать производительность нужно в целом. А, ну, нет, понятно. Ну, если что, я могу добавить, что Go поддерживается. Ну, короче, компьютерный Go начинает с какой-то версии, вставляет нужные штуки куда надо, и поэтому VTune это все видит. Но VTune, он видит... Меня, скорее, интересовал, не видит ли он того, чего мне, как пользователю, скорее всего, не интересно. То есть меня интересует, как правило... Ну, то есть рандайм языка меня тоже интересует, но, как правило, он меня не интересует. Я хочу сделать такой фильтр, типа, вот все, что касается ГЦ и, там, не знаю, крутин встроенного скейлера и так далее.",
    "result": {
      "query": "VTune profiling Go runtime details"
    }
  }
]