[
  {
    "segment_id": "f1eb5495-5c12-49f7-8b7a-c087c9ddf52b",
    "episode_id": "abc430b7-8530-48ec-a5f8-964e88562132",
    "episode_number": 184,
    "segment_number": 6,
    "text": "Это C++ и Python. Python настраивается чуть-чуть посложнее, но зато писать код на Python приятнее. Ввиду того, что если компилировать, допустим, ROS-овские ноды на каком-нибудь слабом железе, вроде Raspberry Pi, ну, там возникают всякие ошибки, связанные с окружением. Приходится очень много времени тратить на не программирование, а на отладку, на то, чтобы избавиться от ошибок типа CoreDump, еще всяких других штук. Иногда что-то компилируется, не хватает памяти, что-то падает. А на Python мы быстро меняем скрипт, и даже перед запуском нода у нас алгоритм начинает работать по-другому. И это все здорово. Еще одна классная штука, которую делает ROS, это то, что мы объявляем новые типы на специальном DSL, который разработан в рамках проекта ROS. И он автоматом генерирует исходники плюсовые и питоновские этих типов. Он генерирует описание классов уже. Это тоже штука мега удобная, и она работает на платформах. Он даже может генерировать код для Arduino. Можно вопрос, пока мы не ушли отсюда? Я про этот ROS ни разу не слышал раньше, и получается, что, если я правильно понял, он позволяет, из-за того, что он эмулирует, ну, и, соответственно, состоит, не эмулирует, но и работает в мультинодном варианте, а каждая нода — это какое-то отдельное устройство, либо элемент сети, который отвечает за какую-то функциональность. Ты можешь каждый элемент брать, либо настоящий железячный, я не знаю, сервопривод, компьютер и так далее, либо эмулировать его с помощью какого-то, не знаю, пакета библиотек. Я правильно понимаю? Да, каждая нода — это программный компонент, который может выполнять какой-то ограниченный функционал. Соответственно, он может либо физическим двигателем управлять, либо виртуальным, либо что-то визуализировать, либо что-то рассчитывать, либо получать данные следа и их как-то преобразовать. Но это программный компонент. А что он делает, там может быть все что угодно. А, соответственно, программа на бетоне или C — это его модификация, или его... то есть, что и как вы программируете? Вот эта мне часть не очень понятна. Сама нода описывается в формате ланч-файла, когда мы его запускаем. Она может быть нескольких видов. Первый — это стандартная программа в каком-либо пакете, который мы ставим через sudo apt-get install. Библиотека какая-то. Да, какая-то библиотека. Второй вариант — это если мы пишем свой бетоновский скрипт определенного формата, импортируем специальные либы, и в ланч-файле говорим, что нам нужно поднять такую ноду из этого бетоновского файла. Причем она должна быть оформлена по определенному формату. Либо мы говорим, что нам нужно поднять ноду из такой-то C++-либы. Либа тоже должна быть оформлена по определенному формату. И причем можно поднимать ноды абсолютно из разных источников в едином решении. То есть мы запускаем программу, в ней куча нод. И эти ноды, часть из них может быть бетоновские, часть могут быть плюсовые, часть какие-то системные. Часть вообще запущена на других компьютерах. Это все автоматно поднимается, и оно работает. Ну понятно, есть какой-то общий интерфейс, по которому все работают, и они друг с другом могут взаимодействовать. Да, да. А интерфейс я упомянул вскользь про систему типов. То есть мы описываем на DSL-е, на специальном, какой-то тип. И система компиляции, ROS-овская, так называемая KADKIN, он генерирует исходники для разных языков, для плюсов, для бетона. Соответственно это позволяет нам использовать одни и те же типы в разных нодах, написанных на разных языках программирования. Причем одновременно. Ну понятно. Слушай, ну я вообще прям ни разу не слышал, я в огромном удивлении. И эта огромная система, похоже, с кучей библиотек, и она настолько упрощает вход. То есть чем это писать все с нуля, ты уже можешь фактически все эмулировать, а потом по одному кусочку перетаскивать на реальное железо. Бесконечно удобно. А есть какие-то конкуренты для ROS? Ну вообще я познакомился с ROS, когда я искал систему эмуляции для студентов, для лабораторок. Изначально я давал на лабораторки на Microsoft Robotics Development Studio. Задумка была похожая, классная, то что можно было писать систему эмуляции, начиная от лего и заканчивая какой-нибудь куклой. Но это все плохо переносилось с виртуального окружения на реальное. И в конечном счете этот майкрософтский проект умер. Еще одна классная система была V-Ray Pro. Там тоже было полно классных роботов. Начиная от каких-нибудь простеньких. Там был R2D2, там была KUKA. Но все это программировалось на каком-то мифическом языке, похожем чем-то на Visual Basic. И да, можно было писать на плюсах, но это все делалось через какие-то костыли. Было достаточно сложно запустить. И речь так, чтобы безболезненно портировать на реальное железо, тоже не приходилось. Соответственно я искал такое легкое прохождение студентов в робототехнику. Потом я познакомился с Росом, посмотрел на среду симуляции. Да, все ок. Обычный C++, обычный бетон, можно запускать. А потом я понял, что это все можно запускать еще на реальном оборудовании, на железе. Классный проект TurtleBot. Там вообще можно писать код под виртуальное окружение, потом просто копировать на реальную железку, и он будет работать точно так же. То есть они сделали классную эмуляцию этого TurtleBot в виртуальном окружении. И я посмотрел, что он используется с многими компаниями, в том числе профессиональными автопроизводителями.",
    "result": {
      "query": "ROS alternatives for robotics"
    }
  }
]