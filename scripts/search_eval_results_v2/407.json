[
  {
    "segment_id": "0174a519-324c-48fc-870c-65b13db0d754",
    "episode_id": "42ae9a78-2d45-40f2-b976-2a170f7d34c7",
    "episode_number": 407,
    "segment_number": 8,
    "text": "Калаш-мелеш. Я видел, я видел эту фонду. Если вы не понимаете, что за калаш-мелеш мы несём, заходите в наш телеграм-канал, да, вы всё поймёте. Там ответы на все вопросы. Калаш-мелеш. Вот. Туда Света заходила, я заходил второй раз, когда получается в прошлую субботу, наверное, я ещё не болел. Вот. И да, мы поговорили про всякие разные индексы в базах данных. Я сказал пару раз фигню, одну фигню я поправил себе прямо в выпуске, а другую фигню я здесь сделаю ирату, потом ещё, надеюсь, Паша тоже принесёт мою ирату куда-нибудь в шоу-ноуты. В общем, я сказал, что, имел неосторожность сказать, что в пасгрессе, что куча, она такая в пасгрессе и типа никому больше не нужна. Это не совсем правда. Пасгресс — это просто единственная база, где есть только, ну, что я хотел сказать, что пасгресс — это просто единственная база, где куча — это вот типа The Way. В остальных системах это как-то, ну, не обязательно The Way. Но, тем не менее, там, не знаю, тот же самый Oracle тоже имеет кучу, DB2, кажется, тоже имеет кучу. Я принёс ссылку на то, где это подробнее написано. Есть ещё такая вот другая, другой момент, про который я не задумывался. Не то, чтобы я про него вообще не знал, я про него не задумывался, я никогда не считал это плюсом. Куча организованных таблиц, наверное, потому что на первом веку это уже никогда не было проблемой. В общем, утверждается, что если у вас индексы организованной таблицы, а не куча, то когда вы строите вторичный индекс, вы делаете жутко неэффективную вещь, потому что вы указываете не на tupleid фиксированного размера, а на ключ первичный индекс, и по нему уже потом находите, собственно, кортеж. Мне это кажется немножко притянутым за уши на сегодняшний день аргументом, потому что у вас потенциально возможно две ситуации. У вас или всё уже в памяти, тогда это не очень страшно, ну типа чуть дольше вы посравниваете ключи, не критично, или у вас всё не в памяти, и у вас вытаскивание страницы в память займёт гораздо больше времени, чем сравнение ключей. Единственное, это может быть реально критично, если вы сканируете очень большое число tuples, и вам прям вот это неэффективное сравнение вы делаете не один-два раза, а делаете десятки тысяч раз, и почему-то ваша база данных, она прям ходит, и каждый ключ по нему вытаскивает, по нему делает lookup вместо того, чтобы построить битмап. Потому что по взгляду в такую ситуацию он не будет использовать своё преимущество кучевой организованности, может будет использовать, может не будет, но у него в любом случае есть альтернативный алгоритм, он может построить битмап по индексу, и потом всё равно пойти сканировать кучу и просто из кучи не трогать то, что не попало в битмап. Я думаю, ты выпускаешь, что у тебя первичный ключ, говоря про недостатки, у тебя первичный ключ становится, ну в смысле индекс по первичному ключу становится бутылочным горлышком, у тебя все всегда в него начинают ходить. Ну а так у тебя все всегда ходят tuple ID, ну какая разница? Я не вижу разницы ходить по tuple ID. Смотри, у тебя есть процессы, которые читают, у тебя есть процессы, которые пишут. Когда у тебя конкурентный доступ в один индекс, это проблема, потому что у тебя эти процессы начинают драться за доступ к этому индексу. По сгоречью, у тебя такой проблем нет, потому что у тебя разные индексы, разные процессы используют разные индексы, а потом ходят в кучу. Мне это всё ещё кажется немножко компетентным заводом, то есть как бы, да, на любую историю можно придумать какой-то батлнек. Ну то есть у кучи организованной системы есть свои проблемы, например, потому что тебе всегда нужно пойти через, ну сделать плюс один хоп до этой кучи. То есть у тебя нет варианта, если ты быстренько ходишь по первичному ключу, у тебя будут свои минусы. Ну то есть да, намеренно можно придумать ситуацию. Постой, что ты имеешь в виду под лишним хопом? Ну я к тому, что, смотри, когда у тебя таблично организованный индекс, у тебя всегда есть primary ключ, и ты как это, у тебя нет этой истории про то, что вначале нужно зайти на страницу, где у тебя лежит, то есть тебе в любом случае нужно будет пройтись по верхушке B плюс дерева, потом ты придёшь в страницу, в случае пасгреса, где у тебя лежит, ну листовую страницу, короче, где у тебя лежит ключ и tupleid, и возможно какие-то вещи, которые были в include индекса. Но если в include индекса этого не было, ты потом, посмотрев tupleid, ты потом пойдёшь ещё дальше, собственно, на страницу с данными. Я понял, ты рассматриваешь сценарий, когда ты делаешь индекс scan по первичному ключу. Да-да-да. Вот, и типа с моей точки зрения, ну опять же, я просто смотрю, что просто ни одна современная система больше не запаривается с тем, чтобы делать кучу организованных хранения. Я прям не могу ни одного вспомнить такого примера. Ну вообще любая система, которая была унаследована от пасгреса, именно так и делает. Это очень много систем. Ладно, да, согласен, довольно много систем. Ну кстати, нет, не любая. Очень много кто переделал storage. Назови… Greenplum. И они сделали индекс организма таблицы. Не индекс организма, они вообще его просто сильно по-другому сделали. Ну то есть они же под аналитику делали. Я думаю, Redshift. Ну то есть, наверное, если ты берёшь старообрядную таблицу, наверное, она будет всё ещё hyperorganized, но это не то, как там в основном хранятся данные. От себя я скажу, что я был осторожен в суждениях типа POSGRES1, кто так делает, поэтому это неправильно и нужно использовать индекс организма таблицы. Я не говорю, что нужно использовать индекс организма таблицы, я имел неосторожность сказать, что только в POSGRES1 так. В общем, нет, это не только в POSGRES1 так, но кто-то делает. Вообще в подкасте мы обсуждали, что у каждого подхода у него свои плюсы и минусы. Можно найти примеры, когда POSGRES1 подход работает лучше. Можно найти, ну вот как я с контеншном за индекс привёл пример. И можно привести примеры, когда хуже. Я тут кстати ещё подумал, я тоже только что сказал, что новые системы так не делают. Я так ещё подумал, на самом деле новые системы, они просто интереснее получаются. Если брать, забыл, как называется, paper, мы это даже в подкасте обсуждали. Кажется, Degraph это делали в одной из своих систем, когда у нас LSM дерево на ключах, а значения, если они большие, лежат вообще ещё отдельно. И пойди пойми, что это такое. То есть в принципе это как бы индекс организма таблицы, но значения, которые большие, чтобы их не копировать туда-сюда в большом дереве, они хранятся типа как бы в такой дополнительной куче. И это уже получается и не то, и не другое. То есть мы когда… ну так это получается, что это как будто бы heap-организм таблицы, но только с тем, что типа маленькие ключи они заинклюжены в индекс, а большие ключи лежат где-то дальше. В общем да. А чем это принципиально… ну то есть я понимаю, что это отличается, но чем это прям качественно отличается от тост? Тост это ещё один уровень индиректа на самом деле получается, если я правильно понимаю. Ну то есть ты в начале пойдёшь… в случае тоста ты вначале пойдёшь из индекса, попадёшь в tuple, в heap-е, потом из heap-а ещё попадёшь в toast-файл.",
    "result": {
      "query": "heap vs index organized tables"
    }
  }
]