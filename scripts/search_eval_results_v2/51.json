[
  {
    "segment_id": "f2269188-05e1-42e7-a717-3e7545116bf5",
    "episode_id": "0dc842e3-0adc-4b18-b900-523487b053b7",
    "episode_number": 51,
    "segment_number": 6,
    "text": "И после этого ваш клиент, умный клиент, будет знать, куда ходить, все такое прочее. У GitHub, например, такой API. То есть на самом деле можно работать с GitHub, просто сходить в Options на API GitHub и посмотреть, что там он дает. Дальше, по стандартам ответов, вот это JSON. Есть стандарт, который называется JSON API.org. Есть еще несколько таких стандартов, которые описывают интересные вещи из серии. Как описать данные, как описать релейшены, в каком виде их отдавать, в каком виде принимать на посты, патчи, и все такое прочее. И самое интересное, что там есть, опять же, по Performance, это то, что называется сайдлоудинг. Допустим, у вас есть блок пост, блок посты коммента, стандартный пример. И, например, вот вы пришли на главную страницу, вам отдали первые 10 постов. После этого вы, например, пошли на страницу первого поста, и в принципе, можно же отдать только пост, а можно отдать пост и сразу его комменты. А можно, например, было сделать так, что отдать 10 постов и еще плюс 2 коммента от первого поста, что-нибудь такое. То есть, стандарт описывает, как можно отдавать данные так, чтобы ваш клиент умел адаптироваться к ним. Если клиент может их игнорировать, тогда он на каждый чив будет слать новые и новые запросы, но может и не игнорировать. Там же есть фильтрация, там же есть сортировка и всякое такое. И самое главное, есть куча и куча реализаций. В этом году стандарт достиг 1. 0, буквально, по-моему, то ли в апреле, то ли в мае. И он, конечно, менялся несколько лет подряд, но сейчас получается так, что если вы, например, берете какую-нибудь реализацию на клиенте, там на JavaScript, например, EmberData или RubyJS или еще что-то, и берете реализацию на Python, на Ruby или еще на чем-то, или даже на Go, то, в принципе, можно это как-то соединить, и после этого ваш клиент будет сразу же автоматически понимать данные вашего сервера, а сервер будет понимать данные клиента. То есть он не первый, кто эти проблемы заметил, но в отличие от него, от автора этой статьи, довольно много умных людей пытаются эти проблемы как-то решать. И, конечно, да, есть бинарные форматы или еще что-то, но это не значит, что REST слишком строгий, недостаточно гибкий и не подходит в каких-то местах. Он вполне отличная штука. Насколько я поняла, что автор как раз таки говорит, мол, REST слишком гибкий и недостаточно каких-то... То есть каждый понимает REST немножко по-своему, и каждый его адаптирует к своим задачам. Поэтому он настолько гибкий, что просто становится непонятно, как же его использовать в конкретном случае. Да, может быть. Это как люди ругаются на то, что SQL это какая-то странная штука, у каждого вендора свой SQL и все такое прочее. Когда ты можешь им сказать, ну окей, используйте какой-то Query Builder или еще что-то, который всю эту разницу между реализациями как-то покрывает. Тут тоже самое, есть стандарты поверх REST, которые решают ту или иную задачу. И в принципе REST можно сделать быстрым. Сейчас есть движение на тему, что да, REST это фигня, давайте мы будем использовать что-то другое. У нас в React мире популярна такая штука, которая называется Relay. Допустим, у вас есть на сервере какой-то граф данных, и вы с клиента просто посылаете такой запрос иерархический, где вы говорите, я хочу там вот это, а внутри вот это, а внутри еще вот это, вот это, вот это, с точностью до каждого поля. И вот он отдаст вам ответ именно в соответствующий пост ту или такому же запросу. Вот, в Facebook такую штуку внутри у себя используют, у Netflix есть похожая система. И в принципе сейчас много-много фронтендеров тоже там кричат, ну нафиг ваш REST, мы будем использовать что-то вот такое вот свое. Мне кажется, что это движение немножко, конечно, и вперед и назад одновременно, потому что я помню, как раньше часто были такие сервисы, где ты делал пост-запрос с текстом SQL-запроса, и этот SQL-запрос от имени этого пользователя выполнялся на сервере. Мне это напоминает даже не движение вперед или назад, а какое-то движение по кругу, знаешь, как раньше было. Типа SQL наше все, хотя нет-нет, подождите, но SQL вообще офигительные базы, SQL говно, SQL нам не нужен. А хотя нет, показалось, SQL тоже надо использовать. То есть вот такого рода. Ну, люди мечтаются туда-сюда. Мне кажется, что человек пугает REST, потому что куча людей берет REST как по умолчанию, и при этом они дальше не разбираются. То есть я вам сказал про JSON-API, кто-то не знает про JSON-API. Если люди выбирают стандартное решение, то хотелось бы видеть, чтобы их API был более-менее стандартный, не с точки зрения одного стандарта, а с точки зрения группы стандартов сразу же. И, наверное, есть задачи, где REST совсем не подходит. Но этих задач не так много. Еще мне это напоминает метание, что монолит и говно, давайте все делать на микросервисах, это вообще отличная штука, микросервис микросервиса. Хотя, постойте, нет, тут тоже есть ряд ограничений, надо как-то разумно к этому подходить. Сейчас все уже как-то более спокойно к микросервисам стали относиться, как мне кажется. Хотя... Ну, вот у меня ощущение, что на самом деле, если мне сказать, мы интервьюемся с API, если этот API не REST, это означает, что мне нужно будет писать кучу кастомного кода. А если это REST... Подожди, тебе могут дать готовую библиотеку. Вот если мне дадут готовую библиотеку, я тоже окей с этим. А вот если мне дают именно API без SDK, то я такой... Конечно, я предпочту REST именно из-за того, что я наверняка найду что-то готовое или полуготовое, которое можно будет к этому хоть как-то адаптировать. Чем если это будет какое-то совершенно странное кастомное решение, потому что в этом случае у меня даже будут проблемы и серии. Окей, я хочу это сделать, и например, допустим, изменение данных в этом API всегда происходит, например, на PUT. И я знаю, что, например, в каких-то местах нужно тоже в новом месте, я меняю какие-то новые данные, какую-то новую сущность, я тоже предполагаю, что можно сделать PUT-запрос. А если это совсем-совсем кастомный API, и там, например, серия в одном месте, это называется CREATE, а в другом месте оно называется INIT, а в третьем оно называется APPEND или еще что-нибудь такое.",
    "result": {
      "query": "REST vs GraphQL debate"
    }
  }
]