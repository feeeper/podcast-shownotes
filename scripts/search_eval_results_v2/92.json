[
  {
    "segment_id": "e805896a-9367-4d56-a0c9-37899c3a17f9",
    "episode_id": "eb8bc1ab-a149-4d85-b45b-54ae7fc5dd8d",
    "episode_number": 92,
    "segment_number": 10,
    "text": "Там искусственный интеллект именно с точки зрения, что... Как чисто вот брать, практически писать ботов, которые в вашей игре будут делать игроку интересно. Ну, поставить им чекпоинты и скриптов много намазать. Ну, вот, как бы, понимаешь, много там же... Как сделать так, чтобы было поддерживаемо. То есть, там такие практические опросы. В принципе, если тебе интересно, можешь глянуть. Вот. На этом я, пожалуй, завернул эту тему. И вернем тему света. Да, раз мы затронули тему машинного обучения, давайте-ка я расскажу про машинное обучение. Собственно, недавно Facebook рассказал про свою платформу. Платформу, которая называется FB Learning Flow. То есть, идея такая, что вот у вас есть много программистов в компании, у вас есть много данных. И вообще, было бы здорово, чтобы все вообще программисты в компании могли использовать элементы машинного обучения, искусственного интеллекта в своих проектах. Но проблема. Проблема в том, что не все программисты вообще понимают, как работает машинное обучение. Для них, в принципе, это сложно. Поэтому придумали такую платформу. Платформу, чтобы дать возможность всем программистам легко встроить в свой проект элементы машинного обучения. И иметь возможность самостоятельно тренировать различные модели, их запускать. Видеть то, что делают другие. И, знаешь, это похоже на социальную сеточку. Внутри социальной сеточки, в которой вы можете шарить свои модели и таким образом их улучшать. Потому что, по факту, когда мы говорим про количество людей, которые пользуются Facebook, даже если вы улучшите на 1% предсказание, вы получаете большой профит. Соответственно, эффект в этом есть. И Facebook рассказал, как это все у них работает. По факту, это очень похоже по описанию, по тому, как работает любая потоковая обработка данных. Там фреймворк будет то Шторм, либо Флинк, либо еще что-то подобного. По факту, вы поделяете. Вот у вас есть источник данных, у вас есть какие-то функции, либо элементы, блоки, которые этот поток данных... Что с ним делают? Его разделяют на две части, его каким-то образом преобразуют, агрегируют, фильтруют. Только это все для машинного обучения. При этом у них есть довольно интересный элемент. Был в статье, что пришлось сделать UI. UI, который будет гибко адаптироваться и показывать различные модели. По факту, просто моделей много и машинное обучение, которое... То есть машинное обучение — это такая buzzword. Но что конкретно они предоставляют? Это различные типы. Это нейронные сети, это... Что еще там было? Логическая регрессия, дальше астахотический, градиентный спуск и много-много другого. Если вы этим интересуетесь, то можете почитать эту статью и посмотреть, как это делает Facebook. Возможно, это довольно интересный подход. И в компаниях, в которых много машинного обучения, и хотите это расшарить для других разработчиков, в том числе, это вполне рабочий подход. Так что, ребята, у нас сегодня гости. Я думаю, вам тоже будет интересно посмотреть. Да, безусловно. У нас сейчас, вкратце могу рассказать, есть интересный второй проект U-сканер. Кроме социальных сетей, мониторинга, мы еще делаем второй проект. Я забыл о нем сказать. Называется он Lead Scanner. Этот проект позволяет находить интересную информацию в сетях. Это немножко похожие продукты, но у нас совершенно разные аудитории. По ходу U-сканер помогает находить так называемые лиды. Лиды – это различные информации, которые можно потом привести потенциально к продажам. У нас есть тоже аудитория у этого продукта. И вот там ребята используют машин-клонинг. Дело в том, что Azure тоже предоставляет средства машин-клонинга в Azure, с которыми тоже можно поиграться. Что-то похожее на FB, тоже некий фиксированный набор различных подходов машин-клонинга, различных алгоритмов, с которыми можно поиграться, куда-то что-то загрузить, покурить модели и прочее. В принципе, посмотреть на FB мне было бы интересно. По факту в этой статье есть пример кода, как это делается. Код – это похоже на Python. И по факту это просто берите и делайте похожего плана что-то. Но по факту это очень похоже на Шторм. Вот как в Шторме, только вместо болтов Шторма здесь называются не операторами, вместо спаута у них получается непосредственно воркфлоу. Очень-очень похоже. Мне кажется. Или мы перешли к следующей теме? Очень плавно. Я думаю, как бы правильно это сказать. Есть много разных сложных тем. В частности, ML – это одна из них. А есть еще одна сложная тема – это правильное понимание распределенных систем. И одна из самых сложных задач – это консенсус в распределенных системах. И здесь с правильным пониманием еще тяжелее. Я помню, мы как-то обсуждали одну из тем – это посмотреть, как ведут себя несколько ядер. И там была игра, заключалась в том, что поставить какой-нибудь дедлок или какую-нибудь проблему сделать, когда несколько ядер плохо синхронизируются между собой. Помните, была такая штука? Нет? Да-да, я в нее залепал долго. По-моему, Deadlock Kingdom или козаком называлась. В общем, в одном из предыдущих выпусков. И здесь я думаю, что автором является как Рысцов Денис. Да, он нас постоянно слушает. Да. Он был, наверное, один из как раз... Как это? Одна из идей, которая легла в основу этой статьи – создать визуализатор для распределенной системы, как она работает. Я не читал до этого блога Дениса, и мне было очень тяжело войти, потому что у него сразу рассказывают, что «ребята, я не буду простые вещи объяснять, потому что там есть то, есть это, вы можете почитать предыдущие темы». Я начинаю залазить в его предыдущие темы и понимаю, что область слишком большая, то есть я в Paxos до этого сильно не влазил. И я немножко понимаю, что это такое, я немножко понимаю, как работает Rust и все такое, но в детали не вникал. А тут, значит, вот здесь приходится сразу понимать всю область и хотелось поиграть с визуализатором. В общем, это крутая штука. Мне очень понравилась идея. То есть идея достаточно сложная. Если, скажем, в ядре у нас там была одна ячейка памяти, и было несколько процессов, которые туда пишут, ну, в простейшем случае, то здесь получается более сложная вещь. То есть у вас посылается несколько разных сигналов, они между собой как-то должны синхронизироваться, у них есть внутреннее состояние у этих стейтов, ну, в смысле, у разных, как это сказать, у процессов на разных, получается, машинах, которые пытаются синхронизироваться, и мы должны все это, глядя снаружи, все это понимать и видеть. И как раз Денис создал систему, в которой это все видно, два небольших куска кода, там, я не знаю, строчек по 20, и рядышком стоит всего, что здесь есть в системе. Ты управляешь не только тем, что идет в выполнении, ты можешь сказать, там, следующий шаг вот этого процесса, но ты можешь сказать, а вот этот пакет от этого процесса до того процесса потерялся, или, а вот сейчас он дошел, или, ну, в общем, как раз вы управляете полностью всем снаружи. Для того, чтобы понять, что это такое, придется прочитать код, придется понять, что означают эти переменные, но в целом получается такая довольно интересная вещь. Я не знаю, можно ли сделать проще, для меня было довольно тяжело туда окунуться, но поиграть и посмотреть интересно. Я хочу посерьезнее залезть в Paxos, и вот, наверное, подобная тема будет хорошим подспорьем. Вот. Как-то так. Мне она действительно тоже показалась очень сложной, там нет технических ошибок, в принципе, сделано довольно здорово, но я согласен с тем, что оно как-то дико сложно, в плане того, что, ну, визуализация, по идее, должна помочь въехать в тему, а здесь так получается, что... Ну, тут тема сложная, и плюс. Тема сложная, но я вот совершенно точно уверяю, что просто проиллюстрировать Paxos и работу отдельных акцепторов и пропозера можно достаточно просто, и тут самое страшное, что есть в статье, это, например, дикое совершенно введение, которое макает в бездну терминов и бездну ссылок на всякие разные штуки, не знаю, ну, как бы... Мне кажется, это может быть вообще отдельным текстом, либо быть в конце статьи, а так вот прям сходу просто... Это всем так как-то... Я думаю, это как бы здесь... Если ты читал все пейперы, на которые ссылается данная статья... То тебе, скорее всего, не нужна визуализация. Хороший вывод, да, согласен. Ты и так всё понимаешь, да. А без понимания пейперов тяжело окунуться в визуализацию, но в целом... На самом деле нет, понимаешь, что пейперы, с моей точки зрения, они там такие получились, что... Пока что часть из них реально тяжело читаются. Просто они так написаны. В то время как вообще, пакс, особенно простейший пакс, вот из наворотов, он реально достаточно простой. С ним начинаются сложности после того, как мы начинаем на голом паксе пытаться делать репликацию логов. Это именно то, почему появился рафт. Потому что репликация логов, то есть протокол, который задизайнен сразу, реплицирует лог лучше, чем построение протокола репликации лога из протокола соглашения об значении одной единственной ячейки. Потому что, грубо говоря, мультипакс, который пролог, он собирается из... Давайте согласимся о значении первой записи, давайте согласимся о значении второй записи, давайте согласимся о значении третьей записи. Только как только мы начинаем так делать, у нас сразу возникает куча проблем. В рафте того много пришло, просто потому что протокол сразу дизайнился, решать именно репликацию лога. Вторая проблема с паксосом, это то, что у нас в любой реальной практической системе нужно менять только кластер. То есть состав машин, из которых состоит кластер, потому что у нас к этой машине могут выйти истрои, мы можем хотеть ее заменить, или мы можем просто добить узлами кластер, чтобы у нас редандансы выше сталки. Эта задача в принципе сравнительно помещающаяся в мозг, в отличие от правильной реализации мультипаксоса. Но она все еще решается джойнт-кворомом, кстати говоря, рафт изначально работал на джойнт-квороме, сейчас они проще это сделали. Идея там в том, что если у нас есть какое-то транзитное состояние, то мы должны одобрение получить и от того, кто у нас раньше в кластер входил, и от кворома тех ребят, которые раньше в кластер входили, и от кворома тех ребят, которые будут новым кластером. Там возникает один и единственный заграничный случай, что если у нас вариация паксоса, где есть лидер, то нужно так, чтобы лидер не входил в старый квором, то нужно его как-то так аккуратненько сместить. Но это уже детали реализации, в принципе тоже решаемая проблема. На самом деле сейчас для репликации лога объективно фигачить мультипаксос смысла нет. Есть смысл для этого использовать рейдер раф, это будет намного проще. Но если вы пишете базу данных, которая key value, то на самом деле вам не нужна вот эта вот... Вам не нужен мультипаксос репликации лога, и возможно, вам не нужен рафт. Скорее всего, вам подойдет соглашение о значении ячейки, потому что, в общем-то, это примерно и есть key value. Тогда вам остается только научиться менять членство в этом кластере. То есть то, о чем я сейчас обсудил, например, через joint consensus. И вот вам при этом нужен на самом деле базовый паксос. Возможно, со стабильным лидером, но это реально вещь, которая имеет мало отношения к паксосу как к протоколу. Потому что паксос, ему без разницы, стабильный ли лидер или нет, это просто оптимизация. И этот базовый паксос, он реально простой. Я вот хочу сказать в защиту. Во-первых, в защиту статьи. Во-первых, прочитав статью, я узнал довольно много нового. Я до этого не окунался, и было не так интересно. Здесь достаточно простым языком все написано, не глядя на шедулях. То есть здесь в одном месте сведено примерно то же самое, что ты говоришь, плюс немножко про лог рассказано, про проблемы лога с тем, что его надо либо компрессировать, либо удалять, либо как крафт работать, либо еще что-то придумывать. Плюс, глядя на сам шедулер, теоретически, если ты понимаешь код, который там написан, то все тоже достаточно прозрачно становится, а кода там не так много. Я сейчас, кстати, тыкал-тыкал-тыкал и шедулю поставил в дедлог. Я не знаю, это так задумано или нет. Скриншот сделай обязательно. Я поздно уже, у меня страница зарелоднулась печально. Я на самом деле, статья в любом случае хорошая, в ней нет каких-то ошибок или проблем. Она просто мне не нравится тем, что она в одном месте совмещает ревизуализатора с объяснением, и одновременно историческую справку. Мне кажется, имеет смысл их разделить, но это я лично пряжу. Давайте в этом моменте я сделаю вид, что тоже пришел выпуск и расскажу чего-нибудь хотя бы. Расскажу я, но тут, кстати, не только я расскажу. Про игры в игровой индустрии, много событий на этой неделе. Так получилось, что я за ней теперь слежу. Погоди, погоди, стой. Это все на этой неделе? Ну да.",
    "result": {
      "query": "Paxos protocol visualization explanation"
    }
  }
]