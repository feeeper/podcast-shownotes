[
  {
    "segment_id": "603c87bb-a6c6-4484-aa3c-602ef25f07c1",
    "episode_id": "ea9af623-7b8b-4662-9c4d-2a289bd86191",
    "episode_number": 460,
    "segment_number": 6,
    "text": "сотни метрик на один микро сервис который еще нужно уметь поддерживать чтобы они не ломались пока так отменяешь а еще сверху надо накрутить егерь сверху и так далее и так далее и так далее и тогда у тебя появляется такой разновидность вот для здесь не имеет ни остальной ограниченности он повторяется так вот у меня heteron evangel уже естьfill потому как fluy а у компании яатра не их вы Ettizedtech но every mon ф� ты видишь все все эти тарифы температурой а thanks to this this данные по миниft через то AEH dispon lähLD measure очень слабить eggsucka мне кажется 농аль да изントри луч iemand Jewel а тогда Bibirg измерять. И простые, понятные гистограммы, ну или вот эти дайджесты, он звучит не слишком ужасно. QDigest из того, что я услышал, ну как бы мы придумали алгоритм, но вот там в нем много параметров, которые пользователь должен выбрать сам, а если алгоритм не работает, значит плохие параметры выбрали. Ну то есть самую сложную часть сваляли на пользователя. Ну, по количеству метрик я могу сказать, что хотел бы я, чтобы моя работа сводилась к мониторингу 15 метрик, но, к сожалению, там их счет на сотни идет, и все надо смотреть, так или иначе. Но все равно, давай так, во сколько метрик ты реально смотришь? В 100, да, ты сказал? Правильно я услышал? Ну, скажем так, одних алертов, одних алертов, которые меня могут запейджить, наверное, как минимум полсотни метрики, из которых они собираются, их там тоже много. Ну, простой, алерт это всего лишь скрипт или триггер на то, что какая-то метрика вышла про метрики у нас тоже был выпуск, мы разбирали какой-то пейпер, но самая простая реализация это то, что какая-то метрика вышла за коридор, который мы для нее определили. В более сложных случаях там похитрее. Ну или какое-то выражение вычисленное, из пачки метрик, которые друг с другом заджойнятся. Но все равно, допустим, у тебя на работе ты смотришь в тысячу метрик, правильно? Тысяча метрик. Я говорю, что для каждой метрики я выделяю по гистограмме объемом 1 килобайт памяти. Это мы получили 1 мегабайт памяти на все, ну хорошо, умноженный 4, 4 мегабайта памяти на все метрики в твоей системе. Это не звучит ужасно. Ну, на текущей их состоянии, да, если ты начинаешь считать стоимость временных рядов, это становится простое. Постой, временные ряды это другое. Временные ряды, они там отдельно хранятся в таймскере или в чем-то. Но мы сейчас вот только про... Ну, так-то в целом я с тобой согласен, да, абсолютно не проблема использовать гистограммы всюду, где только можно. И, по сути, мы это и делаем. Ну вот, отличное решение. Я одобряю. Подожди, а гистограммы, гистограмму хранишь за какой промежуток времени? Кому вопрос? Тебе, ну, то есть, ты хочешь хранить 4 мегабайта. 4 мегабайта это за в текущий момент времени? Я храню за период. Размер периода может быть любой, какой мне это удобно. То есть, ну, это минимальный шаг на моих графиках. Например, я хочу видеть точку на графике каждые 10 секунд или каждую минуту. Вот я за минуту собираю свою гистограмму, жду, пока система мониторинга за ней придет, или сам пушаю ее в мониторинг. И после этого свою гистограмму обнуляю, собираю за следующий интервал. То, что я могу хотеть их сагрегировать, эти гистограммы, а гистограммы легко агрегируются, в отличие от процентилей, это уже задача другой системы, которая, мониторинг, который агрегирует эти данные, это другая задача. Опять же, преимущество гистограммы, в том, что их легко агрегировать. Ну, в целом, я согласен с тобой, но на самом деле, там чуть сложнее все. Сложнее, когда ты никогда не интересен текущее состояние, тебе всегда интересны исследования за последнее время. Это используют, эти данные хранятся в моей тайм-серии в базе данных. Но это не имеет, эта задача, она не связана с задачей посчитать гистограмму или посчитать процентиль. Ну, я имею в виду, там база данных, которая в диске это хранит для персистентности и так далее. Вот. Сложность есть, ты правильно сказал. Сложность возникает, если я хочу менять размеры бакетов, когда работает моя система. То есть, если я изначально не рассчитал с количеством бакетов и с их размерами, то когда я хочу поменять их количество и их размер, то у меня ломается моя агрегация. То есть, нужно, например, всегда удваивать количество бакетов, но удваивать тоже не очень хорошее решение по понятным причинам. Да, недостатки есть, не отрицаю. У всего есть недостатки. А у QBucket есть недостаток, то что вообще непонятно, как вот эти параметры подбирать, которые в пейпере предлагается выбрать. QDigest. Ну вот, но на самом деле вот в этом в T-Digest, как бы вот то, что я почитал, в T-Digest дефолтное описание функции, оно достаточно хорошее, можно вообще ничего не менять. Поэтому, если, скажем, вы его заиспользуете, то, скорее всего, вам подойдет. То есть, не подходит он для вообще ненормальных распределений. К T-Digest претензий вообще нет, но как бы достаточно простая и понятная структура. А вот в QDigest я услышал, что вот это подберите, вот это разберитесь за нас, ну и так далее. Да, да, да. Вот. И давай дальше подойдем по статье до этих, до моментов, которые я хотел затронуть. Вот. Самое важное свойство этой системы, T-Digest, это то, что она позволяет очень легко мерзнуть эту структуру. То есть, вот это способ объединения количества, объединения вот этих центроидов, этих областей до порядка вот этого scale function, до масштабной функции. Она позволяет делать такую систему, что, например, ты разбиваешь всю свою, ну, например, у тебя есть минутный интервал с кучей-кучей данных. Ты разбиваешь их, например, на секундные данные. Прости, поправочка, это ты говоришь про QDigest, не про T-Digest. Про T-Digest, сейчас про T-Digest. А центроиды это в QDigest? Нет, это в T-Digest. Ты начинал с T-Digest, и там не было центроидов? Я начинал с QDigest. Я, может быть, ошибся? Нет, и по пейперу QDigest в конце. T-Digest, это бинарное дерево, которое ты обрезаешь снизу, ну, точнее, сверху до заданного количества уровней, а QDigest это штука с центроидами, и выбери все параметры сам. Наоборот. Ну, нет же. Ну, да же. Значит, ты нас запутал в самом начале. Всегда всех путаю. Я коснулся QDigest, и QDigest это как раз, когда ты отрубаешь какое-то количество, и в которых большая, может быть, ошибка, потому что в абсолютных значениях, потому что ты не контролируешь это. А центроиды это в T-Digest, в T маленькой буквы. Алекс, по-моему, подскажи, подтверди, подтверди. Нет, по-моему, Ваня все правильно сказал. Мое понимание совпадает с тем, что Ваня говорил. Окей, но учти, по пейперу... Я в пейпер не смотрел. По пейперу QDigest точно в конце описывается. По пейперу они вначале вводят историю, а в конце сравнивают с QDigest, потому что они как бы развили эту идею дальше. Вот. И я с тобой соглашался, когда ты говорил, что QDigest не очень, потому что в T-Digest идет автоматизация и уменьшение ошибки, а в QDigest тебе говорят, отруби какое-то количество уровней, давай-ка реши сам, а уж сколько будет ошибок, ты там потом поглядишь. Поэтому, вот эта вот QDigest, она похуже, а T-Digest получше. В T-Digest можно выбирать вот эти масштабные функции, но их нужно выбирать только в том случае, если у тебя ненормальное распределение. Вот. В большинстве систем всегда идет нормальное распределение, поэтому ничего менять не надо. И это тоже плюс. Поэтому я с тобой соглашался, когда ты до этого ругал QDigest. Я окончательно запутался. Что из этого что, поэтому предлагаю это. Это вопрос опустить, я уже не готов одобрить или осуждать что-то. Я одобряю ту структуру, которая простая, вот просто дерево, которое ты говоришь, что у меня дерево имеет столько уровней, и точность будет какая получится. Не одобряю там, где все свалили, вот куча параметров, выберите их сами. Не-не, в T-Digest не надо сильно выбирать, если у тебя обычный случай. Надо выбирать, если у тебя случай необычный. Ненормальные данные и бывают огромные скачки, куча данных в конце диапазона. И тебе нужно внезапно с этим как-то бороться. Но в этом случае, опять же, QDigest будет хуже, потому что у него нет этой автоматизации. И масштабных функций у него нет. В общем, отличие QDigest от T-Digest в том, что в T-Digest, в более поздней структуре, давайте, в более поздней идее, в более поздней идее, идет автоматизация уменьшения размера области ближе к концу диапазона. А в QDigest, в оригинальной, в более ранней, этого нет. Это и нет идеи. Там просто бинарное дерево. Вот, ну пошли дальше. Давайте закончим уже с этой штукой. Что я хотел добавить здесь, это то, что в этой системе получается из-за того, что ты контролируешь размеры областей, ты можешь делать это хитрым образом. И они добавили такую функцию, которая очень при параллелизации полезна. То, что ты говоришь, я вот разбиваю область на маленькие подобласти, скажем, минутную разбиваю на секундные. Я могу обрабатывать их в параллель и сделать там масштабную функцию чуть поменьше. То есть, как бы, чтобы у тебя было количество областей там одно. А потом, когда ты мерджишь, ты за счет того, что у тебя количество элементов, количество элементов при мердже двух соседних областей, оно... Я уже сам запутался, подождите, с самого начала. То есть, у вас есть две секунды. Они обработаны на разных машинах или на разных ядрах. И у вас получились разные центроиды. Вы берете и объединяете эти центроиды, сортируя их по возрастанию, у вас получается центроидов в два раза больше, чем надо. И потом, из-за того, что количество элементов больше, и имея вот эту масштабную функцию, сколько элементов может быть в каждом центроиде, вы можете отдельные центроиды смерджить. Каким образом их мерзнуть будет зависеть от того, какая у вас машина функция. Но чаще всего вы будете мерзнуть центральные, потому что у вас больше элементов может быть в центральных этих точках. А ближе к концу диапазона у вас элементов будет поменьше, и вы можете их там не мерзнуть. И, соответственно, вот это вот решение, оно принимается в зависимости от количества элементов в объединяемых областях, и получается очень удобная штука, что вы можете сделать 60% секунд параллельно на разных ядрах, потом свести это все в основу одну структуру, 60 разных структур объединить, замерзнуть, а потом пообъединять эти центры для того, чтобы сократить количество памяти используемой. И получается очень удобная штука, что параллелизация и небольшое количество памяти, которое нужно для того, чтобы хранить эти данные. Касательно хранения. Сейчас я найду эту точку. Подождите, подождите. Пэк-пэк-пэк-пэк-пэк-пэк-пэк. Пэк-пэк-пэк. Да, где ж это было? Так, вот. Нет, не вот. Блин, я забыл. На какой странице это было? Я листаю, листаю и не могу найти. Ну, в общем, идея была в том, что для того, чтобы хранить один элемент, я сейчас по памяти скажу, могу ошибиться, для того, чтобы хранить один сигмоид, вам нужно иметь одну точку в float point, в double, один double и одно количество элементов. Количество элементов, соответственно, это какой-то int, они говорят, что нам не нужен полный int, можем сократить до четырех, по-моему, четыре байта. Вот. Соответственно, один double и четыре байта нужен на один сигмоид. Количество сигмоидов вы определяете сами, но в среднем нам, говорят, нужно около 800 байтов на, то есть, как бы, если вы используете значение помолчания, 800 байтов на хранение всей структуры данных. И этого достаточно, чтобы ... иметь точность. Сейчас я открою точность. А точность я не помню, но вот у меня ее нет. Погоди, а сигмоид это вот этот один диапазон с центроидом? Да, да. Сигмоид, ой, не сигмоид, это центроид. Центроид, я, наверное, говорил. Центроид это один диапазон, центр этого диапазона это как раз значение, которое вы будете сохранять, double. Ширину диапазона они явно не сохраняют, что ли? Да. Ширину диапазона они не сохраняют. То есть, они хранят, вот у меня диапазон один в этой точке, следующий диапазон вот в той точке. Это центры диапазонов. А как они знают, какой из них там шире, а какой уже? Они этого не знают. Но за счет функции того, сколько, в какой точке у нас может храниться точек, они, соответственно, объединяют эти центры таким образом, чтобы у нас ближе к концу они были поуже, ближе к центру они были пошире. Ага, я кажется понял, ладно. Вот. И получается, что из-за того, что у тебя ближе к концу, а не уже, у тебя на концах будет выше точность. А на концах тебе чаще всего точность нужна, потому что вот этот разброс нормального распределения, он всегда на концах диапазона. Я понял, да. Вот. Не могу найти точность, но в общем, они говорят, что 800 байт будет хватать для для того, чтобы для того, чтобы будет хватать для хранения этой структуры с достаточной точностью. Не нашел я цифры, неохота мне сейчас это искать. Вот. При этом можно еще больше сократить, потому что в чаще всего, в большинстве случаев не нужно хранить дабл для значения, нам нужно хранить дабл для крайних значений и сохранять разницу от текущего значения до следующего значения, а там можно обычный флоу держать, поэтому это можно от 800 байт до 500 сократить. И получается, они говорят, что вот как бы для общего случая, для большинства юзкейсов, которые мы попробовали, 500 байт будет достаточно для того, чтобы вычислять любой перцентайл на любых данных с маленькой ошибкой. Вот. Я отложил бумажку, мне надоело рыскать по ней, я потерялся в ней, поэтому на этом давайте остановимся. Я надеюсь, вас сильно не запутал. Спасибо. Да нет, хорошо. Я почти все понял. Спасибо. Спасибо большое, что принес пейпер, было очень интересно. Ты большой молодец, что подготовил его к выпуску. Но вообще в целом получается такая штука, как бы я вот для себя понял, что, во-первых, надо разговаривать с людьми, которые будут хранить эти данные на стороне сервера Метрик, и соответственно, если у них, скажем, есть этот самый Q-дайджест, то вы можете ваши гистограммы, которые у вас уже есть, преобразовать в этот Q-дайджест, посылать им в виде Q-дайджеста, а не в виде значений, там, в такой-то точке у меня такое-то значение. Вот. Это позволит им на их стороне производить какие-то вычисления и вот то, что Алекс говорил, что с точностью до ширины диапазона считать персентили. То есть, как бы, самое главное это согласование вот этих вот форматов. Вот. Первое. Второе. Получается, что вот, скажем, дефолтный гистограммный подход, он на самом деле не намного дороже с точки зрения памяти используемой, чем вот этот вот Q-дайджест. Но вот эти 500 байт, это на какую-то метрику, ну, блин, это мало. Вот. И их не жалко. Да, там надо будет написать какую-то библиотеку. Кстати, надо посмотреть, я не поглядел. В момент, когда я начал читать этот пейпер, еще были уже несколько библиотек на Q-дайджесте, но они в таком были, в таком полусыромом варианте. Возможно, сейчас они уже дошли до такого production-ready. Надо поглядеть. Может быть, сейчас уже есть. И чисто в теории это, блин, неплохая структура данных для того, чтобы хранить ваши метрики, вычислять на лету любой персентиль, менять эти настройки. Ну, то есть, как бы, о, я хочу сейчас не 95-е, а 99-е, покажи мне 99-е, и хопачки, у вас эти данные уже есть. То есть, как бы, все готово, вы прям и по предыдущей истории можете все это отобразить. Это, блин, офигенно. Не надо менять никаких настроек, и хрустальный шар может отправиться на помощь. Это такая история. Вань, я могу попросить тебя добавить в карточку ссылку на... Вот уж я в Telegram скинул две ссылки. Статья на SLO и то, откуда я картинку содрал. Спасибо. Так, я не следил, нам в чате там ничего не задали? Не-не-не, я следил там слушателям. Ага, спасибо. Затаяли в дыхании слушатели. Да они же просто запутались. Наше потрясающее обсуждение. Мы переходим к темам слушателей, я полагаю. Смотрите, как на два часа наговорили, а вы боялись. Тема 460. Первую тему, которую я вижу, нам принес слушатель Dragon Master. KD Lab открыла код игрового движка Qt Engine. На нем были сделаны, в том числе, братья-пилоты и обратная сторона Земли и другие квесты студии по JPL 3.",
    "result": {
      "query": "разница QDigest T-Digest"
    }
  }
]