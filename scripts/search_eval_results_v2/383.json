[
  {
    "segment_id": "e174a515-74ba-4196-ac9a-e58a087790cc",
    "episode_id": "f5644dd0-4d15-4648-9af3-7a5a51ca6912",
    "episode_number": 383,
    "segment_number": 11,
    "text": "И это очень интересно, потому что мы сейчас вторую статью, которую мы будем обсуждать, это статья по Спектру V2. Я посмотрел в оригинальной статье, было 4 спектра V1, V2, V3, V4, и отдельный параграф, в котором описаны дальнейшие возможные вариации, и написано еще много чего. То есть я даже затрудню сказать, сколько всего спектров. Новая бумага, которую мы рассматриваем, она будет рассматривать только Спектру V2, потому что это одна из самых больших уязвимостей, и на нее больше всего внимания тратят. И давайте тогда расскажу. То есть банальный Спектр V1, самый простой вариант, который проще всего объяснить, мы как раз попытались его в прошлый раз, и немножко не получилось. Он выглядит следующим образом. Если у вас есть какая-то переменная X, которую вы контролируете, которую вы как-то можете передать в код, и если у вас внутри кода есть if, который проверяет, например, что эта переменная X не больше, чем размер массива, и если она меньше, то мы выполняем чтение из этого массива, и для простоты мы рассматриваем, что это какой-то unsigned integer. Потом мы умножаем это число на 4096, магическую константу, которая позволяет нам читать страницами из памяти. И потом мы считаем из второго массива по этому сучению. Так, подожди, у меня умножение на константу помогает нам читать страницу. Сейчас объясню. То есть, к примеру, мы считали константу. К примеру, X – это 6, число 6. А у нас в массиве 20 элементов. Мы берем и 6 умножаем, смотрим 6 – это у нас элемент массива ray1. Мы вычитываем оттуда что-то, умножаем на 4096, и по этому смещению считываем из ray2. Подожди, я знаю. Это очень тяжело объяснить. Если мы атакующая программа, как мы вообще так легко это берем и считываем? Мы на самом деле атакующая программа, потому что идея спектра не в том, чтобы заставить любой компьютер выполнять тот код, который ты хочешь. А идея атакующего – найти такой кусочек кода, который подходит под твои нужды. У меня радикальная идея. Простой, что я прерваю. Да. Просто мне кажется, я понял. Я просто хочу убедиться. Зачитай, пожалуйста, кусок кода, который содержит уязвимость. Я примерно представляю, как он выглядит. Но я хочу убедиться. If x меньше, чем ray1 size, y равняется ray2, ray2. И в квадратных скобках ray1 от x умножен на 4096. Это атакуемый код? Да. Окей. Идея здесь в том, что если ты… Здесь принципиально что? На самом деле 4096 не так важно. Принципиально что есть два массива. И ты передаешь x в эту программу. И получается, что если x меньше, чем размер массива, ты должен провалиться внутрь if'a и прочитать сначала из первого массива значение, а потом с этим смещением из второго массива значение. Вот. Но если при этом у тебя… Вот это… У тебя есть возможность запускать эту программу регулярно, ты можешь ее запускать достаточное количество раз, скажем, 100, чтобы у тебя все время x было меньше, чем ray size. И тогда у тебя… Этот предсказатель переходов, простите, предсказатель переходов запомнит, что у тебя мы всегда заходим внутрь массива, внутрь if'a, тело if'a. Вот. А в дальнейшем ты посылаешь такой x, и этот как его… Посылаешь такой x, чтобы у тебя он пошел… Размером больше, чем нужно. И как бы теоретически мы не должны провалиться внутрь. Вот. Но если ты при этом сделаешь очистку всей памяти, чтобы он у тебя забыл там размер массива, ему надо все это заново посчитать и так далее, он начнет выполнять это спекулятивно. То есть он как бы начнет это делать в спекулятивном режиме внутри, пока он будет проверять условия дополнительно. И в дальнейшем, когда он проверит условия и увидит, что у тебя x слишком большой, он скажет «не-не, все, мы сюда внутрь цикла не заходим». Вот. Но по факту спекулятивно у тебя выполнение уже произошло. И когда у тебя спекулятивно произошло вот это выполнение, мы уже считали из массивов, вот. Получается, что мы можем с помощью этого посмотреть, откуда мы считывали информацию. Вот. И откуда мы считывали информацию, как бы у нас есть второй… Когда мы выполнили вот эту вот атаку, мы по факту, мы сами вот прямо сейчас, мы ничего не знаем. Как бы спекулятивное выполнение отвалилось, процессор обнулил все это выполнение, кэши… Кэши единственное, что не обнулил. Вот. И в дальнейшем, во втором процессе, который где-то рядышком выполняется, мы можем посмотреть, какие страницы памяти отвечают быстро. И с помощью того, что мы можем вычислить, какие страницы памяти отвечают медленно, отвечают быстро… Так, еще раз, что мы это делаем? Мы замеряем время, когда мы говорим, считай мне, пожалуйста, вот отсюда какую-нибудь информацию. Считай мне отсюда какую-нибудь информацию. А, мы повторно генерируем X. Нет, у тебя… Мы повторно… Позвольте удачную, я думаю, я понял. Давай. То есть, у тебя, как у атакующего, есть два механизма, два… две ручки. То есть, с одной стороны, ты можешь задавать X, и у тебя есть вторая ручка, которая позволяет померить… Она, возможно, даже не в этой программе, где-то сбоку или в другой процедуре совершенно, которая позволяет тебе ответить на вопрос, а вот страница по такому-то адресу, она быстро грузится или медленно? Ровно так. И с помощью этих двух механизмов ты, получается, можешь сказать, как бы, если эта страница загружается быстро, это значит, что мы куда-то внутрь этого… Внутрь этой страницы мы недавно ходили. Из-за того, что ты до этого всю память почистил, все… все поудалял, то есть, у тебя будет активно, и только твоя… Только то, к чему твоя программа доступалась, оно будет быстро отвечать. Вот. И получается, с помощью этого ты можешь тролировать… Все для того, чтобы вычислить, что же у нас хранилось в тебе. И, вы понимаете, да, мне тяжело это все объяснить, потому что у нас… у нас же там есть два массива. Мы сначала из одного массива считываем значение, и потом это значение мы используем для того, чтобы обратиться в какой-то кусок памяти. Но фактически это можешь определить с хорошей степенью уверенности значение из первого массива. Точно. Но он мог быть не из первого массива, потому что ты можешь выходить за его границу. Да. Из-за того, что спекуляция. Да. Вот. То есть как бы то, что спекуляция и то, что кэши не очищаются после этого, позволяет тебе фактически читать всю память, какую ты хочешь. Вот. И это вот в этом уязвимость. Это спектр V1. Спектр V2 — очень похожая конструкция, только за исключением того, что ты делаешь IF для перехода, ты создаешь как это… indirect branch. То есть это когда у тебя есть, скажем, набор функций, в которых… Как это? Массив с адресами, куда ты будешь перескакивать. Вот. Ну, скажем, это switch, switch какой-нибудь большой, да? Вот. Или скажем, у тебя таблица функций. Если ты прыгаешь на таблицу функций по индексу, сейчас запускаешь третью там функцию, или там запуск пятую функцию. Вот. Если ты в своей программе перед атакой будешь выполнять одну и ту же операцию для того, чтобы предсказатель переходов запомнил, что ты всегда бегаешь в пятую функцию, скажем, и переход происходит по одному и тому же адресу, он запоминает этот предсказатель переходов, что ты будешь перепрыгивать на это место. Вот. В статье дается пояснение примерно, как работает предсказатель переходов, чтобы было понятнее. Вот. И, соответственно, когда-то происходит атака, ты в этот момент подаешь такие данные, чтобы он перескакивал, скажем, в седьмую. Вот. А он перескакивает по привычке в пятую, но при этом у тебя хранятся нужные... Короче, вместо IF-а ты контролируешь с помощью таблицы переходов. Вот. Это немножко разные механизмы, потому что IF – это у тебя только две ветки, а таблицы переходов – это большое количество возможных веток. Вот. А по факту получается примерно одно и то же. То есть там где-то внутри точно такой же должен быть гаджет, который будет считывать там два массива, считывать информацию, и потом ты будешь по скорости доступа к кэшу определять, считывали мы до этого эту информацию или не считывали. Вот. И... Только у меня теперь вопрос. Да. Но это ведь никак не контриться, кроме как с запретом на спекулятивное исполнение. Вот. И здесь возникает куча вопросов, как с этим правильно бороться. Вот как раз вот эта статья, которую я сегодня принес. То есть сейчас мы объяснили, что такое спектр, оригинальная статья. Это мы рассказали в спектре В1 и спектре В2. Вкратце. Есть еще В3, В4. И... А молдаун мы вообще не рассматриваем сегодня. Сейчас мы молдаун не рассматриваем, да. В молдаун не рассмотрен вопрос, вот как правильно бегать по памяти, каким образом правильно определять, что ты считал, что ты не считал, как правильно обратиться к памяти другого процесса, там же рандомизация бывает всякая и так далее, и так далее. Вот. Но это все решаемые вопросы. Вот. А в текущей статье, о которой я только сейчас принес, ему только начинаем обсуждать, тут рассказывается, что произошло за эти четыре года. То есть в 18-м году вышли статьи про молдаун спектр. Вот. И за четыре года произошло очень многое. За четыре года оказывается, как я уже рассказывал, многие все компании попытались как-то решить эту проблему. И есть два способа решения, как обычно, это в софте или в железе. Вот. В софте это решается с помощью Red-Poline. Это механизм очень классно придуман, я даже не знал, что так можно сделать. Вот. Red-Poline это Return Trampoline. То есть Trampoline это стандартная штука, в компиляторах, в библиотеках используется, когда ты создаешь временную функцию для прыжка. То есть как бы ты не сразу прыгаешь куда-то, а ты подготавливаешь временную функцию, ты сначала прыгаешь в эту временную функцию, а потом из этой временной функции прыгаешь туда, куда ты хочешь прыгнуть. Вот. А здесь это значит, это примерно то же самое, только по-другому. Вместо того, чтобы прыгнуть куда-то, компилятор вместо жампа и меняет стэк вызовов предыдущих и делает Return. Понимаете, да? То есть как бы у нас, когда мы работаем, у нас всегда есть стэк предыдущих вызовов, то есть откуда мы пришли сюда. Manda Return, она говорит так, откати меня на предыдущие, как будто бы мы вернулись из функции, которую мы вызывали в предыдущую функцию по стэку. Вот. При этом, если ты немножечко подправишь этот стэк, вот, ты можешь прыгнуть туда, а потом вернуться в то место, в которое ты должен был изначально сделать jump. И теоретически это как бы равноценные операции, за исключением того, что в случае Return у тебя не работает jump prediction. Вот. Branch prediction. Там он называется branch target buffer. То есть как бы booster целей. Ну это же и делает все медленнее, я позреваю. Это же делает все медленнее. Вот. То есть вот этот вот Red Pauline – это генеральное решение, которое работает теоретически со всеми архитектурами. Вот. И есть там некоторые твики для AMD и для ARM. Вот. Но теоретически это как бы такое общее решение, которое замедляет все значительно. Здесь не указано цифр насколько значительно, но я предполагаю, что это значительно. И соответственно, при том это решает проблему. Вот. Значит AMD и ARM, они пришли с дополнительными твиками, как сделать это быстрее именно на их ахитектурах, потому что они там что-то позволяют сделать, но по сути это примерно то же самое. Вот. И есть железячные решения защиты. Первое – это indirect branch predictor barrier. Это запрет на то, чтобы предыдущие непрямые переходы влияли на следующие непрямые переходы. То есть по факту это тот же самый Red Pauline, только сделанный в железе, чтобы у тебя история никак не сохранялась. То есть это тоже медленное решение, оно замедляет. Вот. Второе – это single thread indirect branch prediction. Это когда он запрещает гипертрэдом влиять друг на друга. Здесь чуть подальше дается информация, что он не запрещает, он продобавляет в эту таблицу дополнительный хэш, какой гипертрэд где работает. И то есть как бы гипертрэд запоминает, и в эту же самую хэш-плицу складывает данные, но из-за того, что у них получаются разные способы, разные хэш-функции, они друг на друг влиять. Вот. То есть раньше ты прыгал из такого-то адреса, при каких-то предыдущих условиях, поглядеть, куда мы прыгали. И поэтому без разницы, какой thread глядит, проверяет этот кэш, они все получат одно и то же значение. А сейчас получается, что туда еще в эту функцию хэширования добавляется, кто именно вызывает эту функцию, и получается они перестают влиять друг на друга. Понятно, да? Вот. Следующее – это, и это считается в текущий момент самое сильное решение, и самое правильное решение – это и у интела, и у AMD вышло Indirect Branch Restricted Speculation. Это… Да. Как они очень неясно и неточно описывают это во всех своих бумагах, как Intel, так и AMD. Вот. Они говорят, что это… Мы запрещаем, чтобы функции, которые работают на… Как это… Как это… Режим приоритетов – это… В процессоре есть несколько режимов приоритетов, там host supervisor, host user, guest supervisor, guest user, вот чтобы они не влияли друг на друга. И они говорят, что типа это сильно помогает всем, как это… Заранее скажу, что никакое… Никакое из решений не помогает, за исключением Red Bull Line. Вот. И у ARM вышла аналогичная вещь, которую они назвали CSV. Вот. Было очень интересно посмотреть табличку здесь. Здесь есть табличка, значит, где… Какие применяются, в каких… в Intel, в каких AMD, в процессорах применяются какие решения. Вот. И насколько это сильно… Помогает и насколько это рекомендовано каждым вендорам, оказывается там, ну, как бы все железячие решения понемножку выкатываются, видно. И они, соответственно, переключают, хотя в каких-то процессорах они предпочитают предыдущие решения, они новые, не более свежие и правильные. Вот. Интересно почитать. Вот. А дальше начинается самая веселуха. Короче. Дальше идет описание, как работает сам алгоритм в железе branch prediction. Его никто никогда не открывает, но здесь привели прямо кучу экспериментов, и они его reverse engineering устроили полной. В частности, они узнали, посчитали, сколько именно бит хранится в этом, как его, в таблице для ключа. Вот. Они посмотрели, от каких параметров он зависит, то есть привели реально там, я не знаю, миллионы экспериментов. Они посмотрели, из каких компози... Как это... Как композицион он устроен, оказалось, что там внутри два независимых, две независимых hash-функции, они не знают точно его природу, но они понимают, как происходит влияние. Вот. И оказалось следующее. Оказалось, что в интелах размер ключа примерно 14 или 14 или 17 бит для ключа, для таблицы переходов. Вот. И это означает, что полный перевор этой таблицы занимает 450 тысяч для как бы для 17-битного, то есть как бы для более сложного случая, 450 тысяч переборов тебе надо сделать для того, чтобы, вероятно, найти коллизию в этом, в таблице переходов. Вот. Что означает коллизия? Коллизия означает, что у тебя, вероятно, если ты нашел коллизию, ты можешь использовать эту же самую таблицу переходов для того, чтобы натренировать неправильно и точно также пользоваться спектр V2, как пользовались до этого. Понимаете, да? То есть как бы все вот эти вот введения, которые позволяют каким-то хитрым образом сказать, теперь мы не влияем спекулятивно, теперь мы не влияем между режимами, теперь мы ставим барьеры и так далее, это все полная фигня, потому что они по факту немножечко меняют хэш-функцию, они туда добавляют на паратном уровне какие-то дополнительные аргументы вида, вот у меня на таком-то CPU работает вот такой-то гипертрет, и поэтому мы добавим туда единичку, а вот на этом двоечку добавим, поэтому хэш-функция считает другое значение, и они как бы не влияют друг на друга, потому что ну как бы разные хэш получаются, даже если мы с одного того же адреса прыгаем, с одной и той же истории. Но если у тебя вероятность найти коллизию в этой хэш- функции единицы за достаточно короткий период времени, получается, что ты, какие бы они туда дополнительные ухищрения не меняли, у тебя сам размер ключа маленький, и поэтому они говорят, ну как бы вообще мы в целом генерально решили эту проблему, то есть вы можете что угодно в своих хэш-функциях добавить, у вас размер ключа настолько маленький, что мы всегда сможем подобрать каким образом устроить коллизию, поэтому ничего кроме RedPawline, который делает рить вместо джампа, не поможет. Вот, принципиально. Во-вторых, все вот эти ухищрения, они плохо работают на примере сисколов. То есть если у вас есть Linux, он вызывает, и вы делаете в коде какой-то сискол, вы всегда идёте в одну и ту же функцию. То есть как бы, ну сискол, это по определению, это внутри ядра есть большой-большой свитч, который делает большой перебор. Вот, и получается, что вы с помощью, а да-да-да, и обычно ядро работает на следующем уровне режима, то есть как бы он не достаёт для вас уровня, работает, то есть вы не можете, чисто теоретически, когда ядро работает на уровне режима, я прошу прощения, когда ядро работает на уровне режима ядра защиты, вы как пользователь не можете влиять на таблицу переходов его, ну за исключением от размера каша, которое общее решение, но это я пока не про это. Вот, и получается очень хитрая ситуация, когда вы делаете прыжок изнутри сискола, вы только-только зашли в эту функцию, вы в режиме ядра работаете, ну я не знаю, там, 5 этих как его, переменных инициализировать, там фактически ИФов нет в этом, в таблице переходов внутри сискола, и не было вариантов у разработчиков, кроме как если у тебя пустая история внутри этого режима, давайте смотреть предыдущий режим, и получается, что пользовательские предыдущие таблицы переходов, какие переходы были совершены, они начинают влиять на ядерную таблицу переходов, я внятно изъясняюсь или нет, или я всех запутал? Чёрт, я всех запутал. Ну меня не смотреть, у меня час ночи, я оставляю с собой правда не думать. Меня потеряли, да, уже давно. Я всё понял. Чёрт. Когда ты начал читать код, это было, знаешь, всё, это было последние кафли. Сначала «а», а потом что? Ну нет, ну на самом деле… По-моему, мы раньше не читали код. Код как раз внёс… Это было первый раз? Внёс полную язность в происходящее. Мне кажется, это был первый раз, когда мы в подкасте зачитывали код, я такого не помню. Да. Было, было, я помню. В общем… Я зачитывал пример, как в Си сел солчистое переполнение. Было. Ну и чем ты горчишься? Я был первым в Валере. Давайте, я тогда упрощу, не буду сильно объяснять. В общем, получается такая штука, что все вот эти вот попытки на железном уровне решить проблему с таблицей переходов, они не срабатывают для ядра, для сисколов. А из-за того, что внутри сисколов очень большая таблица переходов, можно подобрать себе какую-то парочку сисколов и на них производить атаку. Они это показали прямо в этой программу, каким образом это можно сделать. То есть тренируешь на этом сисколе, потом вызываешь другой сискол, хотя он прыгает в первый, и подсовываешь нужные параметры для того, чтобы сделать то, что ты хотел сделать. И казалось бы, у нас есть защита, казалось бы, там другой уровень этого режима работы процессора, но ничего не помогает. И итогу. Итогу проведена прям колоссальная работа. Мне особенно понравилось, когда они вычислили по количеству экспериментов, реально, нарисовали график, по количеству экспериментов вычислили размер бита этого ключа хэша. Вот. И размер в битах. И они показали, что эта проблема все еще остается. Они показали, что никакие текущие железные решения не помогут, поможет только RedAlign, и они пользователям всем рекомендуют продолжать его использовать. И это прямо беда. То есть, спектр никуда не ушел, и все заверения производителей железа о том, что мы решили вашу проблему, это все вулшит. Вот так вот. Дружеское напоминание, что на православной архитектуре Risk5 спекулятивное исполнение запрещено просто на уровне спецификации как класс. И мы в предыдущих выпусках обсуждали книжку, я уже забыл как она называется, мне сложно думать. Про архитектуру Risk5, как ее реализовать на FPGA, дайте мне две секунды. Цифровая схемотехника и архитектура компьютера версия Risk5. Книжка вышла, и она уже даже есть в переводе, и я читал ее, когда это не было мейнстримом, не про Risk5, я ее очень рекомендую. Это было к тому, что некоторые производители железа никак не могут решить эту проблему. А некоторые даже и не пытаются, потому что им это не важно. В некоторых никогда не было такой проблемы. Да-да-да, никогда не было. Что ж, я могу же начинать хвастаться или еще нет? Давай хвастайся. Ура! Ну подожди, а чем хвастаться? Ты же мне был первым. Тарелочки! Мне приехала тарелочка. И мне кажется первым в подкасте мне приехала именно такая тарелочка. Ну ладно, хорошо. Ха-ха! В общем... А я не уверена, что первый. А у тебя Прошка прям, или просто М1? У меня Прошка. Прошка М1 Pro, ну 14 дюймов, не 16. Метов 14? А ты нам про него ничего не рассказала. Я первый кто про него рассказывает подробно, значит. Видишь, как-то я промолчала. Я уже с ним месяц живу, больше месяца с этим. А ты же при этом не хотела Прошку? Ты помнишь, что ты говорил, что фу, такие толстенькие, не хочу. Так это на работе. А мне я хотела взять себе 16, который старый MacBook с тачбаром. Я человек, который очень любит тачбар. Я без него страдаю при... Как это... Рассказывает... Тебя работу не дает выбирать, что ты хочешь? Нет, мне сказали, что их сняли с производства, которые старые MacBook. И поэтому 16 нет. Мне для моих нездоровых глаз мне нужно больше экранов. Сказали, сорян, очень долгие ожидания. Вот тебе 14. Мы будем иметь в виду, когда появятся больше экраны. Вот. Я с ним живу, а в кавычках, уже месяц. Есть вещи, которые мне очень нравятся об этом ноутбуке. Но есть вещи, которые меня очень бесят. Ну, будет с кем обсудить тогда. Можно глупый вопрос. Почему в шоунотах ссылка на 16-дюймовый с Intel? Потому что, если ты помнишь, мы в чате обсуждали, как мой 14-дюймовый Mac на M-Pro по GPU сравнивается с тем, который стоит в самом последнем 16-дюймовом Intel. Я понял. Я понял. Получается, тема называется, Валерия приехала M1 Pro и ссылка на… Да, я потом постараюсь не забыть по гуглике, поставить ссылку на собственную M1 Pro. В общем, я заказал его еще в конце марта, как раз когда мы ездили в отпуск. Я там выпуск пропускал и постил фотки из Латландии с северным сиянием чат. Вот тогда же я его заказал. И он только позавчера или позапозавчера мне, прежде что, наконец-то доехал. Обычно Apple доставляет нестандартные конфигурации за недельку-две. Сейчас прошло два месяца, черт побери. Я так понимаю, это связано с тем, что не просто даже с кризисом чипов. Чипы, чипы. Нет, я, насколько понимаю, дело даже не в чипах, потому что все остальное ошибется у Apple. Всякую очередь не так плохо с этим совсем. Я так понимаю, проблема в том, что то, что не успели стопнуть, а это нестандартная конфигурация, видимо, не было на стоке. Потому что изначально мне есть, мы дали чуть-чуть меньше месяца. То есть, чуть подольше чем две недели, но терпимые сроки, просто бы, я так понимаю, ошибки хотели с другой стороны. Все, что не успели перевести из Китая в Европу, то есть мне нотификацию о том, что моя посылка задержится, прислали через день по с толку в Китае и в Шанхае или жесткий локдаун или что-то типа того. То есть, я достаточно сильно уверен, что это связано с китайскими локдаунами. Но и скорее нестандартной конфигурацией. Да, он нестандартной конфигурацией. Его нету в Германии по двум причинам. Прежде чем, потому что у меня раскладка, как, кстати, не совсем правильно, я себе взял ту, которую высокий Enter, а не длинный. А я хотел наоборот, я все время их путаю, и будь оно прокрыт, но придется привыкать. Я тебя понимаю, я тебя понимаю, я так страдаю. Тот, который длинный Enter, это US раскладка, это English US. Это US. Да, длинный Enter это US, да. English International это высокий Enter. Да, это европейский такой, я его считаю. Есть еще UK, и UK это вообще, короче, это ни в коем случае не берите, там вообще кнопки не те, не там. Я страдаю, я очень страдаю для меня сейчас печатать. Я вот месяц пытаюсь к нему привыкнуть, и тот факт, что у меня старый мой MacBook 13 года с американской раскладкой мне никак не помогает. Это такая боль видеть меня печатающей что-то, я все время промазываю по клавишам. Это просто больно, это очень некриятно. Слушай, у тебя ноутбук на столе стоит или как? На столе, да. Просто учитывая, что у тебя проблемы с глазами, со спиной, я бы на чем-нибудь поднял бы вверх. А, не, не, не, у меня монитор и ноутбук, то есть у меня конфигурация, я использую монитор, который делает миррор, зеркалит мой ноутбукчный экран. То есть я смотрю на монитор, чтобы у меня было нормальное сняло, а печатаю я на ноутбуке. Вот мое. Не, у меня не просто в воздухе подвешенные мониторы ноутбук, а печатаю я на отделе салонной. Я всегда с одним монитором, я нашла для себя идеальный вариант, большой монитор с яркостью выключенной на максимум, чтобы я это все видела, и клавиатура от ноутбука, прям вот мой идеал. Ну просто вообще у них внешняя клавиатура по ощущениям очень похожа на ноутбучный, поэтому, может быть, ты так можешь все починить. Я пробовала, но я не могу привыкнуть с этим, с тачбаром, тачбар, который у меня снизу, это прям суперудобно. Тачпад, да, верно. Тачпад, который снизу, очень удобно. Я пыталась это воспроизвести с клавиатурой-тачпадом, которая внешняя, и у меня ничего не получилось. Вот если бы тачбал был меньше, ну, то есть не меньше, он был по уровню, ну, шел более низкого профиля, и без наклона, наверно, никак бы это сработало. Но тачбары не такие, они с наклоном. Вот, поэтому дайте мне клавиатуру внешнюю, которая будет вместе клавиатура и тачбар, даже таким блоком. Вот это было бы идеально. А такие есть, но они, к сожалению, не маковского layout'а. Вот, то есть для меня это было бы... Дайте мне, я бы купила девайс, который был бы тачбар, клавиатура и тачпад. Такую панель я была бы очень счастлива. Вот, пожалуйста, сделайте для меня. Ладно, идем дальше. Сорян, за что сворачиваю клавиатурные разговоры. Ну, вот, да, в общем, я заказался не совсем ту клавиатуру, которую хотел, но мне сейчас обещают следующий шипинг в августе. Я подумал, что черт возьми, и привыкну к этой. К тому же я раньше такой жил. Я как-то так везет, что у меня один ноутбук был такой, потом другой, потом третий, и я уже ко всему привык. Вот. Тогда, конфигурация. Кроме клавиатуры, еще у меня получается старшая порошка, то есть следующая вариация уже будет M1 Max, и я на него поскупился, потому что там разница начинается. Мне не нужно столько CPU-производительности, потому что я никаких симуляций не считаю, просто код компилирую. И уж тем более мне не нужна эта GPU-производительность, а платите потом в основном за GPU-производительность. У меня все-таки дома есть отдельная система с прям 3080 NVIDIA и если я прям хочу в игры поиграть, я могу там поиграть. Даже если я хочу в игры поиграть за своим рабочим местом, я могу типа при помощи Moonlight'a, про который я рассказывал в каком-то из выпусков, перебросить картинку в себе на Mac. То есть нету с этим прям совсем уж нерешаемых проблем, если мне захочется во что-то такое ресурсоемкое позапускать. Вот. Ну и в принципе я подумал, что да, что M1 Max максимальной конфигурации M1 Pro мне в принципе должен устроить. И 30 ГБ памяти вместо 16. Вот. И это 4-инстинктурная модель. Да. Общее такое эмоциональное впечатление, я в последний раз такие эмоции испытывал, когда я перешел с Mac'а 10 года на первую модель 15-инстинктурной ретина. Это был полный вау от SSD, от... короче, с какой скоростью там работал декретный GPU, от всего, от того какой там был экран по сравнению с экранами до этого. Вот здесь вот похожее очень ощущение, все работает сильно быстрее, прям вот ощутимо быстрее. Там, не знаю, мой игрушечный Ray Tracer, про который рассказывал, он что-то типа в три с половиной раза это работает быстрее. При том, что там код для Intel оптимизируется под SIM, так код для ARM никак особо не оптимизируется, кроме того, что... ну смотри, никакой оптимизации на уровне библиотек там нету. Может быть, компляты хорошо оптимизируют, не знаю. Вот. Что еще я хотел сказать? По общем, да, экран. Лучше этого экрана только OLED-телевизор. То есть вот этот вот мини-лед, который делает черный-черный, и в то же время, то есть он по яркости точно ярче OLED-а, а по темноте максимально достижимой довольно близок к OLED-у. И он типа 120-герцовый в пике. Что тоже, не знаю, такой плавный интерфейс до этого сет остановил тоже только на 120-герцовом OLED-е. Клавиатура тоже, блин, Butterfly это была ошибка. Я так соскучился по клавиатуре. Она, конечно, не ощущается как механика, она не ощущается как нормальная удобная клавиатура, а не вот это вот что-то с непонятным мелким ходом. В общем, да, и наконец мне вернули Cardreader. Я без него не мог жить просто. Я из-за этого стал меньше фотографий на компьютере обрабатывать и постепенно уже даже начал переводить свой процесс обработки на мобильный телефон. Потому что Dongle это, конечно, здорово, но вот это вот все в дороге совершенно нерабочая история. В смысле, оно технически делается, но мне настолько с каждой поездкой все меньше и меньше хотелось этим заниматься. Я надеюсь, у меня вернется желание этим заморачиваться. Даша, ты просто не понимаешь, все беспроводное, порты не нужны. Большинство пользователей действительно так. Я тот вот странный человек, который до сих пор пользуется дискретной камерой. Большинство она достаточно старая, чтобы у нее не было... У нее есть беспровод, но только на телефон JPEG. А Ровкина комп, увы. А я странный человек, у которого есть 3D-принтер. И он без Wi-Fi. Да, да, да. Ну, кстати, USB здесь прежним только C, но есть SD-кард-ридер, и, а, ну, тебе, собственно, SD-шка к нему и нужна, да? К принтеру, да. Вот. И есть HDMI. HDMI-м пользоваться не планирую. У меня, собственно, док, про который я рассказывал, от него один Thunderbolt кабель, и через него потом и питание, и все остальное подается на все остальное мою, на весь мой остальный сетап. И, соответственно, монитор у меня подключен другим, это, это, дисплей порт Thunderbolt. А он не тормозит у тебя при подключении через, не через HDMI? Кто? Дисплей, конечно. Почему он должен тормозить? Вот у меня тормозит, и для меня это было очень странное впечатление. То есть, тогда вначале... Тогда получаю. У тебя, возможно, какой-нибудь проблем с пропускной способностью на комнаты с кабелем. Хороший день. Потому что Thunderbolt кабели, они все выглядят, в принципе, USB-C кабели, они все выглядят одинаково, но они внутри моего будет очень разные. У меня именно, что я... Хорошая идея. Я прямо проверял, что у меня док подключается именно Thunderbolt Thunderbolt, а монитор к доку подключается дисплей порт Thunderbolt. То есть, вот я уверен, что у меня нет батлнаков, и у меня все хорошо работает. И, кажется, я рассказывал, что я подключаю монитор дисплей порт Thunderbolt, а не дисплей порт в доке, потому что у меня в противном случае не сохраняется возможность контролировать софтверт и дисплей. Я очень люблю софтом контролировать... Я рассказывал про софт, называется Monitor Control, а до этого Brising, которые по DCCI отравляют в монитор значение яркости и всякого такого. Это очень удобно, потому что позволяет мне контролировать мой монитор с клавиатурой и мышкой, а не тянуться вот эти вот менюшечки. Плюс один, да. Это хорошая тема, потому что я заметила, что когда я по HDMI подключаю, то все отлично, все быстро работает, все замечательно, а вот через Thunderbolt все очень тормозило. Окей, хорошая тема, проверю. А ты говорил, что клавиатура классная. Мне нравятся ощущения клавиатуры, которые, если ты печатаешь, но мне не нравится, что там черный на черном. И для меня мне нужна более высокая контрастность, особенно пока я привыкаю к нужным клавишам с новой раскладкой. И я, опять же, мне интересно, насколько они делали тесты про все, что касается Accessibility, потому что вот на моем текущем Mac'е у меня белые... Слушай, у тебя подсветка что ли выключена? Нет, нет, смотри, у меня светлый Mac, и у меня черные клавиши. И это очень контрастно, и если я мгновенно вижу, что разницу на новом Macbook'е, это черный на черном, и это супер неприятно, пока я привыкаю к новой клавиатуре, потому что мне нужно на нее смотреть. У меня достаточно вот этого, знаешь, протекающего под клавишами света, то есть я не только сами символы вижу, я вижу, как подсвечивается вокруг них койомка. И мне этого достаточно обычно. То есть у меня прям очень страдает для меня эта тактакника. Попробуй поярче сделать эту яркость. У тебя она в Control Panel'е, можно контролировать Keyboard Brightness, и она обычно довольно далека от максимума даже в яркой среде. Ну вот я попробую, но пока что для меня это была такая огромная проблема. Это черный на черном, и это особенно если работать не из темноты, а из такого, ну, обычного офисного помещения, и все серое. Ну, я понимаю твою боль в этом плане. Меня это не очень напрягает, потому что, во-первых, я не очень пользуюсь этой клавиатурой, во-вторых, я не очень на нее смотрю. Ну, то есть я ее обычно пользую, только если я сижу где-то с ноутбуком, что обычно какой-то режим просмотра чего-то, не знаю, review pull requests или что-нибудь такое, я обычно программирую все-таки за другой клавиатурой. Да, возвращаясь к моим эмоциям, я теперь хочу менять внешний монитор на что-нибудь другое. Правда, пока не существует чего-то, на что бы я хотел его вот прямо сейчас поменять, но буду думать. По поводу еще интерфейсов подключения монитора HDMI, к сожалению, по спецификации 2.0 все еще. Поэтому, если бы я сейчас где-то нашел 4К 120 монитор, который бы меня устраивал по дизайну и цветопередаче, то его было бы довольно бесполезно пытаться включать в HDMI, потому что этот HDMI может выдать только 4К 60, который в этом, на этих макбуках. Тогда как дисплей-порт, который есть внутри Thunderbolt, может полностью выдать сколько нужно. Такие дела. А что ты думаешь о поводу челых? Я ее не замечаю, вообще не замечаю. То есть, даже тогда, когда я работаю с дисплеем, единственный раз, когда я заметил, это когда я открыл Xcode, чтобы поставить эти, как он называется, плеты, консоли, короче, CLI и тулс для разработки. Вот. И у Xcode достаточно много пунктов в меню. Это был первый раз. Я это сделал на маленьком дисплее. То есть, я IntelliJ, не IntelliJ, DataGrip открывал на большом мониторе. Xcode я открыл именно, когда он был отключен от большого монитора. И это единственный момент, когда я заметил, что у меня что-то уехало за челку. В остальном, она мне абсолютно не мешает. И мне на самом деле, скорее нравится эта идея, потому что она находится в том месте, где у 99% приложений нету ни черта. И за счет этого у меня больше, то есть, мне гораздо ценнее место на экране, там, где у меня окна, чем то, что меню как-то странно себя ведет. Так что меня все устраивает, я доволен. Ну и также в этой челке она большая, и в ней довольно неплохая камера. Она лучше, точно, совершенно, чем в предыдущем. Я, предпочтаю, буду свою большую камеру использовать только для каких-то встреч, где реально важна мимика какая-то, для каких-то ежедневных звонов, и буду просто, скажу, на макросской камере сидеть. Я подтверждаю. Особенно, если хорошее освещение, это вообще замечательная камера. Она даже в плохом свете не ужасно работает. Давай так, мне это в первую очередь нравится. Она конечно заметно хуже при плохом освещении, но при хорошем это прям вау. Просто у старого мака она была, ну, что называется, unusable. То есть это было больно смотреть, то, как старая камера себя ведала. То есть даже не то, что при плохом свете. Малейший контровой свет или... То есть любой свет отличный от того, когда тебе идеально в лицо фигачи цвет делал на той камере плохую картинку. На старой, в смысле. Да, по поводу производительности я уже обмолвился, что оно может круги нарезать вокруг интелла.",
    "result": {
      "query": "Spectre V2 mitigation techniques"
    }
  }
]