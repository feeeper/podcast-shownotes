[
  {
    "segment_id": "896118d5-8fdc-4a7f-8079-3cee96e27f45",
    "episode_id": "202e1585-e5e6-4c24-bf42-8921e076d044",
    "episode_number": 89,
    "segment_number": 5,
    "text": "Как ты это определишь? Это очень сложно определить, и они для этого написали... Во-первых, они сказали, что написанное имя системы визуализации работы каких-то процессов на каких-то ядрах... То есть именно графическое представление очень-очень сильно им помогло, и они после этого сейчас рекомендуют вообще всегда делать какие-то графические представления для вообще любых алгоритмов. Мне кажется, у Интелла... Сори, что прибиваю снова. Мне кажется, у Интелла такие тулы были довольно давно, я правда не уверен, что они были для Индокса. Слушай, но здесь они ничего не говорили про интеловские тулы. Вот. Может быть, они их чем-то не устроили, я не в курсе. Может, просто им ядро нельзя отлаживать, такое тоже может быть. Кстати, да, на самом деле. Ну в общем, они написали несколько тулов, в конце статьи они приводят описание тулов и как ими пользоваться, но я это оставляю, что ли, кому интересно, поглядят. Наверное, всё. И так долго задержались. Ну это прям чертовски интересно и чертовски пугающе. Это вот знаешь, из того разряда, как мы, наверное, уже полгода назад или около того обсуждали, как у нас файловые системы не работают и диски не работают, вот это из той же области. У нас и ядра операционных систем не очень работают на самом деле. Что ещё у нас не работает? Ты заранее не знаешь, на что они не работают. У нас не работает память, там не работает ECC, у нас не работают роутеры. Там теряются чексумы, ну в смысле они там неправильно считаются для битых данных. То есть суммы правильные, но для не тех данных. Мне очень забавно, когда после вот таких багов люди говорят, что там надо доказывать корректность наших алгоритмов, там типа блин, чувак, у тебя файловая система теряет данные раз в 20 минут. Не, так подожди, подожди, так как раз вот доказательство корректности могло бы возможно избежать такой фигни. Больше того, есть алгоритмы, которые позволяют, например, не знаю, если у тебя модель данных такая, что у тебя файловая система с достаточно византийским поведением, ну то есть файловая система с точки зрения твоего алгоритма это византийский актер, то в общем-то доказав корректность такой фигни, ты получается докажешь, что твой алгоритм корректен даже если у тебя файловая система ведёт себя как полная зараза. Может быть, может быть, ну то есть ты предлагаешь, вот у тебя из-за космической радиации меняются битики в памяти с ноликов на единички, ты предлагаешь там как-то дополнительно считать 32-битные чексумы для памяти. Ну в смысле, некоторые же так и делают. Ну в системах, которые особо требовательны к тому, чтобы отказывать от сбоев, да, там так и делают. Дублирование, тройное, четверное и так далее. Дублирование, если переводится в файлер, как мы знаем. Раз уж мы коснулись Линукса, я сразу тогда скажу, что в Киеве идут семинары по Linux Kernel, будут рассказываться все внутренности кишочки, про то, как правильно программировать для Линукса, девайс джайверс девелопмент и так далее. Пройдут в мае-июле 2016 года, и среди требований необходимо только хорошее знание языка оси и знание Линукс на уровне пользователей. То есть, командная строчка и все такое. Я очень надеюсь, что они выложат видео. Не знаю, они тут пишут, что после того, как вы пройдете курс, мы тут вам, возможно, предложим сотрудничество и так далее. То есть, может они это считают внутренней какой-то информацией, не знаю. Нет, в смысле, всем понятно, зачем делают такие курсы. Ты объясняешь людям, как работает open source проект, потом нанимаешь этих людей, если они толковые. Да. Ну и продолжение темы визуальных средств отладки. Александр, может ты нам расскажешь про средства отладки визуальных? Новость про то, что чуваки из AMD открыли код Excel. Это такой инструмент для отладки OpenCL и OpenGL. Очень красивый, посмотрите на картинке. Почему меня это радует? Потому что раньше ты читаешь книжку про OpenCL, там написано, что ребята, открытый стандарт, работает подо все. Давайте разберемся, как это отлаживать. Открываем Visual Studio. Ну, понимаете, работает подо все, но отлаживать можно только под Windows. Теперь это не так. Код Excel теперь есть и под Linux, и предположительно работает. Меня лично это совсем радует. Я правда не знаю, как дела под Mac'ами. Кто-нибудь интересовался? Ну, под Mac'ами есть свой tooling, притом он там есть давно. Он не такой хороший, как в Windows, но он есть, он был. В смысле, он был и он есть. Я не знаю насчет OpenXL, но в свое время, когда я писал практикум для компьютерной графики, это было уже... Извини, OpenXL. Как это считается тут? А, CodeXL, sorry. CodeXL для OpenGL, да. Вот. Конкретно про него я не знаю, но когда я года 3 или 4 назад писал практикум для компьютерной графики еще в универе, мне вполне себе хватало тулов, которые были в подставке системы еще тогда. То есть, понятное дело, что это не настоящая сварка, и возможно, настоящему сварщику нужны более суровые тулзы, но опять-таки с тех пор многие вещи сильно улучшались по камере. Если читать маркетинговый блушид от Яблоко, то просто у них с каждым мажорным релизом X-кода тулы по отладке OpenGL все лучше и лучше. То есть, возможно, хотя если хотя бы, не знаю, 1-2, даже 1-3 из этого правда, то может даже быть у нас есть и неплохие тулы под Mac. Но я давно уже к этому не трогал, потому что самое близкое, как я подходил к трехмерной графике последние года полтора, это Unity, поэтому и там опять-таки свои тулы, в свою очередь, которые немножко даже про другое, я особо не графику отлаживал. Поэтому, в общем, да, я совсем не компетентен в данном случае. Для слушателей, поясню для тех, кто все-таки не дойдет посмотреть скриншоты, просто чтобы вы понимали, насколько это круто, вы для OpenGL на специальном диалекте языка C с поддержкой векторных операций скомпилировали, я не помню, как это правильно называется, короче, ядро программы, которое будет запускаться на GPU. Вот оно у вас полетело туда, скомпилированное, и вы можете вот там на GPU поставить breakpoint, и у вас в IDE будет прям по шагам выполняться программа на GPU. Или, например, вы можете прям отрендеренные фреймы там полистать, посмотреть, вот как бы замороженные, если OpenGL отлаживаете. То есть это прям совершенно огненный инструмент. По шагам я ни разу, честно говоря, код на GPU не отлаживал, поэтому таких тулов, наверное, нет, хотя, может быть, уже и есть, кто его знает. Наши слушатели знают. Да, слушатели, придите, расскажите, я в вас верю. Коллективное сознание интернета, что может быть лучше. Следующая тема. Да, я как раз и пытался подвести к плавному переходу. Что же это так лучше, чем коллективное сознание интернета? Может быть, только консистентный распределенный реплицированный лог, то бишь, кавка, цвета. Слово тебе. Да, сегодня... Не сегодня. 19 апреля была выложена статья про то, как работает экосистема кавки в наулинг-дыне. Цифра. Они обрабатывают в день 1,4 триллиона сообщений через кавку. И используют для этого всего добра 1400 брокеров. 1400 брокеров? Да, 1400. My fucking god. Представьте, какие объемы. 1400 брокеров. Это один кластер или это разные кластеры? Это по всему миру. То есть у них есть несколько... Ты не отвечаешь на мой ответ. Это логически одна единица или это куча разных логических единиц, просто всего столько? И всего столько. Или я неправильно понимаю этот вопрос? Всё, теперь правильно понимаешь мой вопрос, спасибо за ответ. Окей. А, и каждую неделю это всё добро составляет 2 петапайта данных в неделю. То есть если сравнить с тем, что в Твиттере с картинками, то в Твиттере больше. Для порядка. Собственно, рассказываю про то, как у них система работает. Всё основано на кавке. То есть в кавку всё кладётся, из кавки всё читается. Это единая шина данных, с помощью которой интегрируются различные сервисы. Они используют свои продюсеры и свои консюмеры. Они, по сути, оборачивают существующие библиотеки, которые есть в open-source и наворачивают туда свои логики. Для протокола они используют Avro. Не Protobuf, а Avro. И как это работает? То есть продюсер имеет себе возможность проверить, точнее, синтегрироваться с конкретным протоколом. И в каждом сообщении есть такое понятие, как идентификатор. С помощью этого идентификатора можно узнать, какая схема соответствует данному сообщению и её децерализовать. У нас была такая проблема раньше, когда в прошлой компании, где я работала, использовалась кавка активно. И мы всё хранили в Avro. И когда переходили на новый протокол, это была такая интересная история. Потому что кто-то перешёл, кто-то нет, и приходилось всё договариваться. А здесь банально просто идентификатор и всё. Как только консюмер берёт сообщение из очереди, он знает, какой идентификатор. По этому идентификатору всегда можно точно узнать, какой ключ расшифровки этого сообщения. Точнее, децерализации. Подожди, как вы так Protobuf используете, что вам договариваться приходилось? Мне кажется, если в Protobuf использовать optional поля и вот такие штуки, которые... Бывали нюансы. Бывали нюансы, да всё это использовалось с помощью optional полей, но это звучит всё равно как остыть. Вместо того, чтобы использовать такой формат. Когда тебе нужно формат менять, периодически приходилось как-то это обговаривать. Разная ситуация. Обычно, да, если ты добавляешь какое-то новое поле, будет optional и всё ок. Но если ты хочешь что-то удалить, если тебе нужно что-то исправить, и у тебя получается такой протокол, в котором куча легасей этих... Ну я согласен про легаси, да. Да, то есть легаси полей. Но ты захламляешь эту структуру, и конечно хотелось бы иметь какой-то больший порядок. Вот про что я говорю. Нет, подожди, я с другой стороны. Если у тебя есть несколько различных форматов в системе разных версий, допустим, у них даже есть явные идентификаторы, тебе же всё равно нужно, по идее, мочь разговаривать со старым форматом. Тогда в таком случае у тебя всё равно нужно иметь возможность заполнять легаси поля. Просто потому что у тебя есть старый формат. А ты можешь... Нет, ты не обязательно... Ты можешь в принципе разные... Ну, разная логика будет для работы с каждым конкретным типом твоего объекта. То есть у тебя была версия 1, у тебя работает одна ветка логики, у тебя была версия 2, работала ветка логики. Нет, но всё равно тебе же нужно держать старую легаси ветку логики. Поэтому не то чтобы... Так скажем, хрена редко не слаще с моей точки зрения. Пока легаси код не выбросили, он всё равно есть. Ну, скажем, с точки зрения протокола, это довольно легко можно учитывать. То есть с помощью мониторинга ты можешь говорить, вот смотрите, мы читаем сообщение такого-то, такой-то версии, а потом раз, переключилось, всё, всё, все сообщения пошли течь с версии 2. И ты это можешь легко очень отслеживать, наблюдать. Это удобно. Ну, это хороший пойнт, да. То есть ты можешь гарантированно сказать, что всё, мы больше не читаем эту версию, давайте уберём эту ветку логики. Ну, для порядка, на мой взгляд, вот этот подход, ну, мне нравится он больше, честно скажу. Я не пробовала Protostuff, который протобав с версионированием. Ну, не знаю, может быть это работает по такому же принципу, но не суть. У них как в продюсер, так и в консюмер, вот это вот всё добавлено, автоматическая проверка версии, и у них есть отдельный сервис, который называется регистр схем, в котором непосредственно хранятся все схемы и входит вся эта вариация. Вот, всё просто и очень удобно. Они, если нужно как-то кавку конфигурировать, либо добавлять какую-то новую очередь, у них есть REST API для кавки, и туда можно подсоединяться с помощью какой-то мониторинг-системы, что-то можно, если нужно что-то добавить, что-то изменить, какие-то дефолтные параметры, это с помощью этого можно сделать. Также с помощью кавка REST модуля можно подсоединять к ней не-Java клиенты. Не знаю, насколько это будет у вас, насколько это нужно, но мне кажется, это странно. То есть через REST ходить в кавку не-Java клиентами, это как-то очень дико звучит. Не-Java клиенты в распределенной системе! Как же так, у нас не вся система на одном языке! А вдруг я напишу клиента на Ruby? Ну, то есть, серьезно, как человек, который не из Javashop и который вообще с Java работает мало, то есть у нас есть реальная проблема интегрировать кавку с Ruby и с Erlang. Все-таки для Erlang есть клиент для кавки специальный, самописный, а в тех местах, где нужно Ruby, он там на JRuby крутится. То есть это действительно у вас такая была проблема? Просто я всегда из конкретного Java мира, и мне казалось, ну окей, если вам нужно работать с кавкой, ну возьмите, используйте готовые консюмеры и продюсеры, которые на Java. А потом уже оберните, ну как хотите, в что-то ваше свое, если вам это нужно. Ну, смотри, тут проблема из-за того, что я немного, наверное, не знаю, надеюсь, я могу об этом говорить, вроде ничего секретного, но есть, допустим, у нас некоторая инфраструктура для BI. И эта инфраструктура в проекты, которые индивидуальные, игровые, торчит в частности как кавка, с которой можно консюмерить. И тебе на основе этого BI иногда может хотеться делать что-то кастомное для своей игры. Ну, то есть логично, для того BI нужен, так ведь? Вот, и у тебя игру пишет, или писали, вот в нашем случае, люди на Рубе. И у тебя все на сюрприз Рубе. И тебе нужно сделать какую-то, знаешь, такую суперпростую задачу из разряда там, посчитать что-нибудь там, вот этого я точно говорить не могу, и на основе этого чего-нибудь там немножечко покрутить параметр конфигурационный, ну там, конкретно для юзера, про которого мы посчитали. Ну и так для каждого юзера, например. Или там даже чуть ли не в Facebook что-нибудь запостить от имени этого юзера, если он нам это разрешил. Но ведь понимаешь, мы же так... И понимаешь, что ради этого... Ради этого срочно... А это не важно, нам не нужна тут суперскорость, понимаешь?",
    "result": {
      "query": "Kafka Avro schema registry"
    }
  }
]