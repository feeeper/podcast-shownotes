[
  {
    "segment_id": "c31f32ef-6d84-4019-9003-011024c4fdb5",
    "episode_id": "001e620b-b59f-485a-9b9c-5710855324fb",
    "episode_number": 490,
    "segment_number": 8,
    "text": "Да, эта тема давно лежит у нас в бэклоге, я наконец-то ее до домыслякал, долистал свою бумажку, которую я давным-давно распечатал И давайте быстренько пробежимся Я не буду её полностью прочитывать потому что как обычно нету времени, а во-вторых потому что много сложностей и без внимательного проглядывания всех графиков вам тяжело будет понять то, что я говорю вслух. Поэтому я расскажу упрощённо, а если кому интересно, поглядите внимательнее в Paper. Итак, Paper о том, как правильно сделать Google Docs. Давайте так, по-простому, когда у вас есть много людей, которые пишут документ, и вы хотите, чтобы эти много людей могли между собой синхронизировать этот процесс написания текста. Для решения этой проблемы есть уже несколько готовых решений. Это CRDT, который более поздний, но он более медленный и более плохой, поэтому его не используют и используют. Как называется OT, как расшифровывается? Операционное преобразование. Да, операционные преобразования Operational Transformation. Вот. Это интересно, потому что как раз таки недавно мы обсуждали, что современные ЦРДТ дошли до того состояния, когда они теперь нормальные и вполне себе применимые для этого. Да, оказалось. Притом как недавно, года два назад. Оказалось, что они есть. И более того, в конце этой статьи есть анализ. Они фактически загнали кучу разных текстов редактивных по-разному, включая там какой-то сделали реальный гид, реальные системы, поглядели кто как его кто какие файлы редактировал и сделали там очень простые правки. Вот, но Макс интересно же Клеп, он среди авторов, то есть как раз Клеб, он же и работал над предыдущими CRDT для редактирования текста. Да. И здесь они как раз и делают выводы, что предыдущие crdt работают и покрывают полностью все нужды, но они с точки зрения именно операционной очень сложные. Все CRDT текущие существующие, точнее как все вот до выхода этой статьи, они А давайте мы снова раскроем аббревиатуру CRDT, да? Потому что мне кажется мы года два этого не делали. Да, CRDT это комплекс Free Datatype, resolution Datatype, простите, да? Я правильно перевожу? Я не помню сейчас нужно посмотреть, у них несколько шифрок есть, но в общем да общий смысл такой, что типа данных, которые, как это, операция, над которых коммутируют и, т. Е. Как только пример привести, т. Е. У вас есть, например, счетчик, конкурентный. CRD это конфликт ready pacreatedata types. Например, сам простой пример это счетчик. Если вам нужен счетчик, который только инкрементируется и у вас много считающих, то всегда можете его представить, как просто у каждого считающего есть свой счётчик и они периодически обмениваются у кого какое значение счётчика. И вы всегда в каждом узле сети имеете точное значение своего счётчика плюс более-менее примерное хорошее знание о счётчиках соседей всегда его можете без конфликтов суморизовать просто он будет ну не идеально update и когда вы обмениваетесь своими значениями счётчика это всегда без конфликтов потому что ну свой счётчик обновляете только вы а другие объявляют только свои значения счётчика а при передаче счётчиков вы как бы говорите, что вот, не знаю, у Валеры счётчик, там не знаю, у Валеры три, у Вани счётчик, у Вани Ваня четыре. Если Валера проинкрементировал, если Валера стал четыре, и отдал счётчик Валеры четыре Ване, Ваня же свой счетчик 5 не поменял, он просто теперь еще знает, что у Валеры счетчик 4, поэтому у Вани теперь тоже сумма 8, например, а не 7. Вот, это самый простой пример. Или если еще и доводить до уровня посылка обновлений, посылать обновления можно тоже инкрементами. То есть вместо того, чтобы говорить у Валеры теперь 5 вместо трёх, можно послать Валера плюс 2. Если вы накопите все ивенты от Валеры, то у вас всё равно получится корректное значение, и без разницы, в каком порядке они пришли, без разницы, откуда они пришли. Если вас есть этот ивент вашей базе вы будете знать что это обновление Валеры было все сложите и получится правильное число. Но слышал что в подкасте было огромное количество выпусков про ЦРДТ у нас были гости которые занимались инновационными ЦРДТ так что если хотите поискать поищите по подкасту наверное мы можем экскурсию закончить в это и вернуться к paper да и возвращаемся от брата к paper у оказалось что в текущих CRT есть один недостаток это то, что нужно большое количество памяти для того, чтобы хранить все эти состояния и проверять, и схлапывать их без конфликтов. И большое количество памяти делает их малопригодными в реальном использовании. И данная статья как раз решает проблему большого количества памяти у CRT и большого количества вычислений у OT. То есть это гибридное решение, которое по факту использует плюсы обоих подходов и старается избежать минусы обоих подходов. Давайте пробежимся быстренько по статье. Во введении рассказывается про то, что такое ОТА и CRDD, которое мы уже описали. Введение рассказывается про проблемы с CRDT, то есть CRDT, оно более Оно не то, чтобы более корректно, OT тоже более корректно, но оно концептуально более корректно. То есть вы придумываете такой тип данных, который сам по себе не имеет конфликтов, вместо того, чтобы руками исправлять конфликты и находить решение каких-то локальных проблем с конфликтующими данными. Но вот CRDT в 10 раз больше использует памяти текущей, чем OT имплементации, и поэтому большинство больших проектов, которые вы используете, оно использует OT внутри себя. Значит то решение, которое они делают, оно вообще не совершенно serverless, то есть без разницы на каком узле вы производите вычисления, ему не требуется точка синхронизации, это вообще не важно. Так-так-так, пошли дальше, да. Предположение, на которое они рассчитывают. То есть в вашей системе не должно быть византийских участников, тех участников, которые пытаются испортить кому-то что-то. Первое. И второе мы всегда предполагаем, что все сообщения рано или поздно дойдут. То есть бывают задержки, без разницы, какие задержки и задержки не важны. Важно, чтобы все сообщения дошли до всех, для того чтобы данные у всех людей сошлись. В частности, где-то там в середине есть если вам пришло сообщение, исправление, у которого отсутствует предыдущее состояние, ну то есть как бы event удалить букву L, а буквы L в вашей системе еще от того чувака не пришло, то это сообщение будет ждать своего парента, пока не дойдет паррент. Поэтому фактически это означает, что все изменения с того клиента, с которого одно из сообщений не дошло, они не будут представлены в системе. Так-так-так-так-так, да. Значит, это мы прошли, прошли, прошли. Здесь есть несколько классных простых графиков, которые объясняют базовые принципы. Я попытаюсь в воздухе помахать, а вы давайте представьте, как я им машу пальчиками. Представьте, что у вас есть два пользователя, которые совместно редактируют документ, и вот один из пользователей ввел Hello с одной буквой L. Hello четыре буквы. Вот, и потом они одновременно начали править этот документ. Один человек исправил и добавил еще одну букву L, а второй человек исправил и добавил знак восклицания в конце. Получается, что у нас как раз конфликт, то есть одновременная правка, и надо как-то свести к общему результату. И очевидно нам, что это будет Hello знак восклицания, но на графе это будет как дерево фактически, идущее сверху вниз. Там первое самое верхнее это буква Х добавление, второе буква И, H, E, L, O. Вот у вас четыре буквы друг за другом добавились, это будет как бы вертикально, и потом, соответственно, влево или вправо это две разные правки. Вот эти две разные правки, которые происходят одновременно, они у них у всех один и тот же парент добавление буквы О. То есть буква О это последняя общая точка у двух пользователей. И вот до этого это было последовательное для них, для обоих, совместное общее прошлое. В дальнейшем они уходят в параллели, поэтому вот эти две точки называются concurrent. В этой истории у нас несколько общих точек и две точки, которые конкурентные, одновременно происходят. И соответственно на этом примере они там разбирают базовую теорию конфликта. Что такое конфликт, почему это конфликт, как нам правильно его разобрать, как оно разбирается на данном event walker. Да, я забыл сказать, что алгоритм называется AG-walker. Я забыл, как он расшифровывается. Простите, не скажу сейчас. Там где-то у них в тексте написано. Они представляют это как гибридное решение Блин. Меня слышно? Да-да. Вполне. Простите. Как гибридное решение CRDT и OT, IG-walker. Значит первое Нет, давайте не первое. Да, первое. Одно из ключевых особенностей то, что все данные мутабельные. Все, что вы друг другу посылаете это имутабельные данные, которые нельзя изменять, удалять и так далее. Во-вторых, на чём они основываются это детерминистичность алгоритмов, поэтому без разницы, в какой последовательности. Там на самом деле на нескольких уровнях, то есть, во-первых, у них строго определенные алгоритмы, поэтому как бы при одних и тех же данных они всегда будут исполняться одинаково, это логично. Во-вторых, у них есть гарантии, что если у вас есть два набора данных, полученные разными способами, и у разных пользователей, с разными задержками они будут приходить и так далее, вы всё равно придёте к одному и тому же результату. Ну как бы это логично. Вот. Давайте я опишу что такое, как бы это всё описать. Да, давайте начну с этого. Значит, вся идея всего алгоритма состоит в том, что они создают внутреннее представление. Почему это гибридная система? Потому что в гибридной системе, в CRDT, у вас очень большое внутреннее представление, которое помогает вам решать конфликты. И они для того, чтобы решить конфликты в большом, когда у вас большое количество пользователей одновременно правят, вам нужно большое сложное внутреннее состояние. Поэтому вам требуется много памяти, поэтому CRT используют много памяти. Однако они придумали такую систему, когда вы вот это вот когда вы решаете все эти конфликты, вы время от времени создаете какие-то снапшоты. И вот после этого снапшота вы не накапливаете больше внутреннее состояние, вы его фактически во-первых, вы можете не хранить историю, во-вторых, вы его схлопываете до состояния, когда используется очень мало памяти. И как бы этим вы уменьшаете количество памяти, которое используется в решении, нивелируете недостаток сердики. Во-вторых, почему это гибрид с OT это потому, что когда вы передаете клиенту, что клиент должен сделать, вы ему передаете очень простые инструкции вида, перейдите на индекс номер 15 в вашем предложении и удалите два символа, грубо говоря. То есть OT оперирует индексами и действиями над символами по каким-то индексам. И фактически, что они придумали? Они придумали вот эту систему преобразования CRDT-подхода к ОТ-подходу, когда они внутреннее состояние переводят в индексы, и они фактически на каждом этапе после схлопывания они говорят: Так, мы вот придумали, что этому пользователю нужно сделать, чтобы у него на экране отобразился общий для всех текст, и они, соответственно, переводят внутреннее представление CDT в инструкции как в ОТ. И получается, что это такой комбинированный подход. То есть во время сложных конфликтов они делают большое богатое внутреннее представление, как в cerdity, потом, когда они схлапывают и они передают клиенту, они начинают как в ОТ передавать с помощью индексов и уже мало используют памяти для внутреннего представления. Вопрос как это правильно представить, как это правильно сделать? И здесь самое как бы давайте попробуем просто объяснить у них хранится всегда два состояния внутреннего графа то есть вот у нас мы вели какие-то буковки от соседнего клиента пришли какие-то буковки от третьего клиента пришли какие-то буковки и они все друг друг с другом перемешаны. То есть у одного там он один был видел, что у него было три буквы в предложении, он добавил одну букву, другой видел, что было пять букв в предложении, он удалил одну букву. И вот эти все вот изменения, они создают довольно сложный граф, то есть постоянно есть разветвления в каких-то местах, когда пользователи от одной версии делают две версии, конкурентность вот эта вот concurrency, которую мы описывали в предыдущем, как это в прошлый раз, с графами А во-вторых, они иногда приводят к схлопыванию, то есть как бы когда два пользователя, мы уже схлопнули их между собой, и они пришли снова объединились в одну точку Вот. И получается, что вот эти вот сложные графы их надо как-то правильно обрабатывать. И они придумали следующий способ: во-первых, у каждого пользователя они хранят два состояния. Первое состояние это состояние, как они назвали их? Да. Вот вот вот вот вот вот вот вот подождите, вот здесь у меня записано. Записано записано. Да где ж это записано-то? Вы слышите я бумажками шуршу, да? Да, очень эстетично. Шелест листьев мертвых деревьев. Мне, если честно, мне очень нравится читать бумажки. Я вообще отказался от книг электронных. Мне просто неинтересно, не хочется. Мне нравится вот на бумаге читать. Сторабрядник что зем? Не, на самом деле это приятно, потому что когда ты перелистываешь и у тебя как-то остается, я не знаю, вот я даже когда листочки я держу, что-то на них делаю пометки или читаю, у меня в голове отмечается, в каком углу этой странички у меня какая-то идея есть. И вот я сейчас, когда перелистываю, я ищу, у меня с левой стороны в этой колонке была пометка, я вот эту пометку ищу. Как это делать на электронном устройстве, я вообще представления не имею. Хотя возможно там поиск и поэтому было бы побыстрее. Да, ты нажимаешь ctrl+f и в левой мере. Значит так, есть два внутренних состояния. Первое состояние это как они назвали prepare version это версия, подготовительная версия, а вторая это effect version, это эффективная версия и это фактически финальная версия. И все буквы, которые приходят, они как-то изменяют эти версии, но причем изменяют их по разным правилам. Они разработали ряд правил. Фактически, три операции над графом у них есть. То есть, когда у них этот граф есть, они должны каким-то образом его схлопнуть. И эти три операции это Apply, Retreat и Advanced. Это стоит машина, которая говорит: Вот у нас есть версия, у нас есть внутреннее состояние как бы из двух вот этих вот Prepare Version и Effect Version. И вот операция Apply делает вот это вот с этим, а вот это вот с этим. Фактически она говорит каждую букву мы переводим из состояния такого в состояние такое. И вот Apply, например, это всегда делает insert, advanced Retreat он делает из состояния insert он делает в состоянии not yet insert. Это когда мы схлапываем два графа, бывает такая ситуация, что у одного пользователя буква добавилась, и мы применяем сначала его версию, а потом, когда рассматриваем точку зрения другого человека, у него этой ещё буквы нет, и мы должны наложить другие операции, и мы, соответственно, эту букву мы знаем, она у нас уже во внутреннем состоянии есть, мы никогда не удаляем из внутреннего состояния, но мы этой букве говорим, что вот в состоянии у этого человека эта буква ещё пока не добавлена. И, соответственно, как бы получается очень интересная система. С одной стороны, эти правила очень просты, есть всего три операции над графом. Во-вторых, граф состоит как бы из двух кусочков, и эти три операции по-разному воздействуют на эти кусочки. Но суммарно получается очень простая система. Давайте я попытаюсь на пальцах объяснить, как это работает. Смотрите, сначала мы берем и представляем сложный граф в виде простой линейной последовательности. Строгой линейной последовательности. Причем без разницы в какой, в каком, с каким способом перейдем из графа к линейной последовательности, они доказали, показали, что их алгоритм приведет к одному и тому же результату без разницы, как мы построим последовательность из графа. То есть первое мы граф делаем в линейную последовательность, второе мы вот эти вот три операции применяем последовательно ко всем изменениям. И эти операции достаточно простые. То есть если один пользователь добавил букву, то в его версии добавляется буква. Другой пользователь пока еще не знает про эту букву, и поэтому когда другой пользователь убирает предыдущую букву, например, там знак восклицания мы добавляли в конце, помните, да? Мы добавляли его на пятую позицию: Hello восклицания. В этот момент первый-то пользователь уже добавил букву L на третью позицию, поэтому у него пятая уже сдвинулась, но второй пользователь ещё не знает про это, и поэтому в зависимости от того, мы поставим операции друг против друга, мы можем получить разные последовательности. Да что у меня экран выключается и у меня выключается при этом звук. Меня слышно сейчас тоже? Да, ты не пропагандируешь, нормально? У меня просто, когда выключается экран, всегда выключается звук, а сейчас что-то перестало. Очень позитивно. Позитивненько. Получается, что вот эти два представления одно показывает текущее состояние, что думал, что пользователь видел на экране, а второе представление это финальная версия, к которой мы пытаемся свести всю систему. И без разницы, каким образом мы объединим граф в одну линейную цепочку, с помощью пересечения вот этих состояний мы приведем все равно в одну и ту же конечную точку. То есть без разницы, мы сначала добавим букву л, а потом знак вопроса, или мы сначала добавим знак вопроса на пятую позицию, а потом добавим л в третью, потому что мы будем видеть все буквы в каждый момент времени и будем знать, а вот эта буква пока пользователю видима или невидима, а вот эта буква была или не была в этот момент. Я пытаюсь пальцами махать, мне кажется, это сложно понять, но мне кажется, концепция должна быть достаточно понятной, нет? Я понял с чем они воюют и не очень понял как именно это работает, если честно. Ну вот да, мне потому что это тяжело на самом деле объяснить. Они здесь нарисовали несколько графиков с примерами как правильно преобразовывать графы и каким образом это работает. И когда ты это прочитываешь, это все довольно легко. Но вот объяснить это на пальцах довольно сложно. Давай попробуем по-другому немножечко, попроще сделать. Может быть я попробую вопрос задать, и это поможет. Давай, давай. Смотри, этот граф это такое представление нелинейной истории. Всё время отлипаешь, говори, пожалуйста, подальше от меня. А, ты двинулся, извините. Так вот, граф это нелинейная история документа. Это правильно или неправильно? Проблема, которую они хотят решить, это они хотят уменьшить количество истории документа. Это так? Проблема, которую они хотят решить, это интегрировать все истории в финальное конечное состояние, которое должно быть равно для всех участников этой истории. Можно еще уточнить вопрос? Если я правильно понимаю, они воюют с тем, что с одной стороны у нас есть CDT, которая простая концептуальная система, но большой стоит, а с другой стороны маленький стоит у ОТ, но концептуально сложная система. Да, то есть ОТ с помощью маленького количества памяти решает тот же самый вопрос с помощью большого количества вычислений. Там даже не то что большое количество вычислений, там еще проблема, если я правильно помню, оно просто там огромное количество ограниченных случаев и вы задолбаетесь это реализовывать так, чтобы оно не ломалось. Да, и все это происходит из-за того, что у них нету достаточного количества сохраненных показателей этой системы. То есть если бы они были, то у вас было бы меньшее количество этих ограниченных случаев. Ну то есть мы с тобой говорим одно и то же, просто я использовал другие слова. Вот. И граф это порядок добавления или удаления букв из текста. То есть я сначала добавил одну букву, потом вторую. Кто-то добавил после первой в другой точке другую букву, и у нас получается произошло разъяснение графа, потом объединение графа и так далее. И имея весь граф, достаточно легко построить финальное состояние, потому что вы видите в каждой точке графа, какие происходят изменения, и если схлопнуть какую-то часть графа, всё равно эти же самые изменения вы будете проводить с этими же самыми буквами. При том, что у вас происходит никогда не происходит удаление букв, пока вы до конца всё не схлопните. Вы знаете, что вот здесь была какая-то буква, ее удалили, и там они называют это Томмстоун. То есть как бы камень могильный все еще стоит на этом месте, но мы считаем, что здесь буквы уже нет. И поэтому мы продолжаем это хранить, пока мы все до конца не схлопнули, но как только до конца схлопнули все, у нас все сложилось, картинка сложилась. Давай еще один вопрос. Давайте еще один вопрос от новичка. Я правильно понимаю, чтобы что для работы этого алгоритма нам нужно хранить вот это всё дерево редактирования, и если мы будем 10 тысяч лет непрерывно редактировать, это дерево всё равно станет огромным. Это правда или неправда? Тут два уточнения. Во-первых, тебе не нужно хранить 10 тысяч лет, если у тебя в нем было два участника, и ты у них уже согласовал версии. То есть им нужно хранить дерево только на тот момент, пока есть конфликты. То есть вот у тебя есть три участника, они прямо сейчас редактируют. Как только ты у всех трёх свёл это к одной версии всё, тебе не надо хранить то, что было раньше. Ты уже всю проблему. Мы посидели, поредактировали документ, потом пошли пить кофе и в это время система такая вся досинхронизировалась и теперь может выкинуть всю сложную историю. Если я ничего не путаю, мне это по вайбу напоминает Dot от Virgin Lectors, типа что значит когда CDT с этими Dota от Virgin Vectors позволяли типа иметь какой-то общий state, о котором уже все договорились, это типа точка, я правильно помню и какая-то такая там тема была, я уже очень давно это все читал. Я уже очень давно это все читал. Я бужу это развитие той идеи, да, наверное. Вот, более того, они приводят статистику, что в большой сложной системе, когда происходит редактирование одновременно большим количеством участников, они очень редко видели ситуацию, когда происходит конфликт больше, чем двух версий. То есть чаще всего им нужно решить конфликт между двумя участниками. А чисто теоретически это работает в оффлайне грубо говоря там я не знаю я сел на самолет редактирую мои коллеги редактируют тоже потом я выхожу в онлайн и оно все схлопывается ради этого все затевается если я понимаю Но тут такой момент, вот если ты так сделаешь на 2000 лет, вот тогда оно не схлопнется. Оно синхронизируется, вот тогда у тебя история разрастётся. Нет, почему? У тебя, пока ты сам это всё редактируешь Ну вообще это уже получается более организационный вопрос. То есть когда ты начал это редактировать, и пока это не ушло, не синхронизировалось с остальными, у тебя достаточно простые правки. То есть у тебя был текст, и у тебя линейная история, верно? У тебя не надо большого количества памяти, чтобы это хранить, у тебя просто вот как бы какая-то линейная история. Но когда ты приходишь к другим, а у них уже текст полностью поменялся, вот в этот момент у вас возникает рассинхрон, потому что у вас начальная история была тогда, там, я не знаю сколько, 18 часов назад, когда ты садился в самолет еще в аэропорту. Вот. То есть тебе надо хранить, по крайней мере, вот эти вот 18 часов изменений на той стороне. Вот. Но с другой стороны, после того, как на той стороне тоже все схлопнулось, возможно, оно тоже можно объяснить его линейно, и тогда у тебя опять объем памяти уменьшается резко. То есть ты фактически говоришь, вот ты приходишь и говоришь: А я вот такие справки сделал вот с тем изменением. Вот, и на той стороне: А у нас уже вот это вот фактически две линейные истории, у тебя опять конфликт двух версий. Тебе не надо хранить уже правку в двадцати разных вещах. То есть сложность появляется, когда у тебя большое количество правок, и что граф становится много, что он становится очень широким. Если у тебя всего две версии идет, у тебя не так много надо их хранить. Я понял. Я, наверное, задумывался, знаешь, о чем с точки зрения практической имплементации. Представь себе, что у нас есть вот этот документ и два сценария. Сценарий номер один это мой коллега сидит редактирует бесконечно, активно, я не знаю, очень трудоголик коллега. А я закрываю ноутбук и ухожу спать на ночь. Я ничего не делаю. И в этом случае получается, что система она должна знать, что я больше не участник этой системы и она, допустим, может только следить за историей моего коллеги и схлопывать историю и по сути поддерживать только одну версию. Это первый случай. Второй случай это когда я, вот этот коллега, он продолжает свою работу, но я не иду спать, а я сажусь на самолет и начинаю тоже редактировать. Но с точки зрения системы я просто пропал в пустоту. И она не знает, она может выкинуть вот тот общий узел истории в момент, когда я ушел в пустоту или ей нужно и ей нужно его хранить, потому что я потом вернусь с кучей редактирования, которое ответвилось от этой точки в истории, или не нужно его хранить, потому что я ничего не сделаю. Мне кажется, что практическое применение таких алгоритмов осложняется именно такими вопросами. Я не знаю, по профессии ли они прав. Ты полностью прав, и здесь они вводят понятие критических точек, то есть вот они, это вот как Валера сейчас объяснял, как там доточки или как там они производились. То есть если ты выкидываешь всё, что было раньше, то тебе тяжело потом восстановить историю или начать редактировать конфликт с той версией, которая была до этой точки. Но одновременно они же решают ещё и другую проблему, что если у тебя есть ну например, вот ты садишься в самолёт и полетел. В этот момент у тебя 20 человек в твоём отделе начали фигачить в историю, и они пришли к какому-то результату. Когда ты вышел с самолёта, тебе не надо решать конфликт 21 человека. Понимаешь, да, о чём я? Тебе надо решить конфликт двух людей тебя и уже объединённой истории на той стороне. Да-да, понимаю. Вот, и тут как бы здесь есть мой подраздел про то, как надо часть сохранять историю, и как правильно работать с критическими точками. Но я вот эту часть не читал. То есть, они там как-то более глубоко копаются. Насколько я понимаю, это больше административное должно быть решение, то есть вида, я знаю, что мне без разницы, что кто-то сел в самолет два года назад, и все двухлетней давности точки я уже удаляю. Справедливо, да. Да. Наверное, то, что ты говоришь, имеет смысл, потому что в практических применениях наверняка можно сделать какую-то оценку сверху и сказать, какая самая давняя точка истории, для которой мы готовы решать конфликты. Если что-то найдется старее, мы скажем ну извини. Понятно, что я очень интересные данные. Во-первых, они искали специальных случаи, которые тяжело решать с текущими CRT, случаи, которые тяжело решать с текущими ОТ-системами, и как их система справляется. А во-вторых, они взяли несколько искусственных данных, то есть они взяли какие-то гидрорепозитории, с помощью него сгенерировали тесты. Они взяли Причём там тесты были последовательных правок, параллельных правок с разной степенью конкурентности, то есть сколько агентов одновременно редактирует. Вот, и получились очень интересные результаты. Они нашли результаты, когда текущие ОТ-системы делают решение конфликта в течение 60 минут. Их система вот с помощью вот вот этого вот гибридного как это гибридного решения она делает за 30 миллисекунд То есть это прям хорошо Вот, а с точки зрения CRDT и памяти они тоже делали исследования. Вот, они оказывается есть несколько уже готовых пакетов, они прям названия пакетов говорят. Я даже и не знал, что они есть. Вот, но я, мне интересна теория, а практика мне не интересна. В общем есть Automerge, они использовали версию 0.5 или 3.9, чтобы то ни было, и использовали YGS, вот три буквы, то есть Не знаю, как это правильно произнести. Версия 13.6.10. Вот. И соответственно сравнивали с ними и вот как бы тоже выигрыши по памяти показывают, что по памяти они используют килобайты против мегабайтов. Ну то есть там ну в смысле не килобайты, а десятки килобайт и сотни килобайт в худшем случае против мегабайт в у тех систем. Вот. Не сказать, что прям большая разница, но все равно. То есть в разы, то есть почти на порядок. Вот. И и, и что-то ещё хотел сказать и забыл. Да, они написали на Rust, они написали библиотеку в качестве результатов своей работы. Они выкладывают вот эту они выкладывают свою библиотеку, они выкладывают перф-тесты, в которых они показывают, на каких тестах они что гоняли, и И всё, да. Я считаю, что это прям, если честно, очень классная тема. Я очень надеюсь, что это продвинет вперёд продукты, которые позволяют, как это, Local First, когда мы как-то, какое-то время назад мы обсуждали эту концепцию, философию Local First, когда вы можете локально редактировать и не бояться, что у вас что-то потеряется или не смержится. Сейчас этого очень не хватает во многих продуктах. И не хватает только потому, что у нас не было достаточного количества хороших решений. Вот сейчас с помощью подобных подходов, если его ещё будут дальше прорабатывать, продвигать, я думаю что оно пойдёт вперёд ускоренными темпами. И спасибо большое Клепману, величайший дядька распределёнщина. Вот, а дальше Спасибо что рассказал было интересно. Да блин, да тяжело, вот если честно я расстроился. Очень тяжело рассказывать такие вещи, когда у тебя нету под рукой доски с маркерами, чтобы можно было порисовать и показать как это схлапывается, сходит. Красных ниточек, чтобы показать какая теория заговора заговора классно получается распределенная вы услышали здесь впервые диагноз видео следующий раз мы уже не какой-то момент размышляем такой идеей но решили что нет да давайте поговорим за за темы слушателей токены серьезно понизили лимиты скачивания с хаба Personal Authenticated 40 скачиваний за час unauthenticate 10 скачиваний на один IPv4 или IPV6 под 64-битную под сеть в час. Короче, с одной стороны я их понимаю, потому что не бесплатно вообще говоря все это обслуживать, с другой стороны компания Docker решила встать в, не знаю, типа самый гребаный центр дистрибуции софта как это современного open source софта практически заменила собой репозитории дистрибутивов но такие ой пук соряньк что-то нам дорого Давайте вы теперь просто, короче, будете логиниться на нашу проприетарную систему и скачивать только по нашему щучьему велению. Ребят, вы сами себе эту ситуацию создали. И опять же, понятно, почему они сами себе создали. Потому что когда они её себе создавали, у них были бесконечные деньги инвесторов, и им хотелось стать самой используемой компанией в вере. Меня всегда немножко раздражало, что вот типа если если написать какое-то имя чего-то в Dockerpool, то он по умолчанию полезен на Docker Hub. Вот как бы, увы. При том, что сейчас в Docker-совместимых репо-историях полно, у того же самого GitHub есть какой-нибудь Github, не помню. GHCR. В принципе, любой Сильно больше одного решения сейчас по тому, чтобы хостить пакеты. И Artefactory это умеет, и да, и GitHub это умеет, ну не пакет, а в смысле образы Docker'а и можете его просто положить на файловую систему и Docker должен подсунуть. То есть проблема решаемая, но под все эти миллионы туториалов в интернете, которые написаны и документация в интернете, которая написана в своих предположениях, что с dockerhab все просто скачивается, они теперь у многих пользователей перестанут работать, потому что понятно, что можно авторизоваться, но вот лимит для неавторизованных найденных в 4 адрес это прям просто очередной камень в огород палубного интернета. Это меня печалит. А что печалит? Мне кажется, это вообще очень позитивная история. Ну типа, что люди слезут с докера? Ну, во-первых, люди слезут с докера. Понимаешь, я очень не люблю, когда в интернете ломаются ссылки. Ну, ссылки сломаются, это 100%, да. Но с другой стороны, ты понимаешь, как бы, что мы в результате получили решение, которое сейчас стало стандартом де-факто, и без него было тяжелее жить. То есть как бы альтернатива-то какая-то, чтобы они Нет, в смысле, я имею ввиду, что я же не говорю, что у Docker есть проблемы. Но я в том случае не говорю, что Docker плохой инструмент. Я говорю, что компания Docker, когда они вот в самый центр поставили Docker Hub в качестве дефолта. Они все правильно делали. Ну то есть как бы это было Молодой момент, да. Но решение нормально все, я не расстраиваюсь. Ты печалишься, и я понимаю, почему ты печалишься, но мне кажется, это не стоит таких переживаний. Ну да, сломать. Я очень хочу более персистентный веб, чем мы имеем в итоге. Ты знаешь, мне кажется, что это вообще невозможное решение, это перфекционистское желание, которое никогда невозможно реализовать. В общем, через 10 лет у нас вообще не будет нормально полноценно работающего гипермедиа. Вместо этого у нас у каждого будет локальная копия каких-то вещей, которые мы могли бы заинтересовать, которые периодически реплицируются из интернета. И локально мы поэтому ищем каким-то AI поиском, и он, дай бог, выдает то, что мы хотели. Да нет, ты же сравниваешь ни то, ни с тем. Я про лёд. Связанный интернет это одно, а то, что не работает В смысле, я просто к тому, что, знаешь, мы плавно движемся от того, что интернет был, типа люди, организации сами хостили свои страницы, которые имели ссылки на какие-то другие страницы, и ссылки более-менее, понятно, что сайты, конечно, умирали, но оно, во всяком случае, было как-то связано. Потом мы пришли, значит, к ситуации, когда у нас в App 2.0, в App 3.0, когда люди вместо того, чтобы хостить свой контент, положили все в какие-то платформы, которые друг друга хостили, которые хостили ваш контент и заливали все деньгами. Сейчас мы постепенно приходим к тому, что платформы поняли, что деньги не бесконечные и в случае социальных медиа, и в случае хостинга кода, и начали всё закрывать и удалять. И помню, как меня всё время как-то подбамблило, когда тоже, кто ж там Google сделал в серии по истории Ридонли, что-то такое, да. Они хотя бы Ридонли сделали на Google коде, они совсем выключили. Вот, и можешь по-моему, Google код же уже не существует, да? Да, они переводили в Ридонли на пару лет, по-моему, уже давно его прибили. По-моему, они загрузили куда-то, по-моему, они архивы отдали гитхавов в какой-то момент или что-то такое. Я к тому, что эти ссылки тоже поломали. Подожди, так вспомнил, у меня прям ностальгия была. Я забыл, что это существовало, что там было, там Свн или что это было? Там Свн был, да. Потом там, кстати, был гид. В последние годы существования там был гид уже. В смысле, кроме СВН. Это какой? Это 2010 год? По-моему, они, по-моему, в 2011 как раз таки начали сворачивать, или типа того. Ваня, помнишь же ты древние вещи. Вот, там не знаю, Фликр начал говорить, что мы начнем нам удобрять ваши фотографии, если вы нам денег не занесете. Вот, и то есть теперь как бы мы имеем кучу вот этих вот садов за заборами, каждый из которых вымогает деньги, иначе в противном случае будет ломать интернет. Вот, и как бы следующий логичный шаг, что просто мы, у каждого из нас будет какая-то своя, не знаю, коробочка с контентом, по которой ищет какой-то умный поиск. И мы, возможно, как-то будем обмениваться контентом, а никакого связанного в ЭВА больше не будет, потому что дорого, идите в жопу. Платите, платите корпорациям за синхронизацию, за свежие новости. С одной стороны, с другой стороны, на самом деле, мне кажется, что вот этот период оптимистичного интернета, где все можно было всюду скачать за бесплатно и сколько угодно гигабайтов, это был некий очевидно что это не могло продлиться вечно потому что инфраструктура стоит денег трафик стоит денег и в какой-то момент надо эти деньги зарабатывать правильно для меня время оптимистичного интернета это другой момент для меня время оптимистичного интернета когда я был совсем еще пиздюком я его как-то толком не застал, но как раз таки, когда каждый хостел свое, вот это для меня время подмесячного интернета. Да, вот мне кажется сейчас мы понимаем, что нет таки, нельзя думать, что какой-то благородный GitHub, Docker Hub, Google код или еще кто-то придет и будет хостить мою фигню завечно, за бесплатно. И мы наконец-то должны принять реальность, что надо подключать микрофоны. Да, что ж такое сегодня? Извините. В общем, надо платить и надо либо просто делать, как это, sustainable self-hosting, либо просто платить тому же GitHub или Docker Hub, и это нормально.",
    "result": {
      "query": "CRDT vs OT text editors"
    }
  }
]