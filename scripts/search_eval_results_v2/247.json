[
  {
    "segment_id": "978ea0a4-fa30-4c4b-94ab-13e94e7c6c18",
    "episode_id": "0dd9b3aa-fd09-4f2d-8a07-abf819b65f92",
    "episode_number": 247,
    "segment_number": 5,
    "text": "И получается так, что если вы достаточно много, это вероятность очень маленькая, но если вы достаточно много обращаетесь к одной строчке памяти, то вторая строчка памяти может поменять состояние. Особенно ярко это возникает, если у вас внезапно оказывается, что две строчки памяти имеют одно и то же состояние, а между ними находится третья строчка памяти, в которой бит будет переключаться с увеличенной вероятностью. Так, если у вас в одной строчке единичка, в другой строчке единичка, а между ними содержится нолик, то если эти две строчки с единичками часто считывать-записывать, т.е. не обязательно считывать и записывать в эту же самую единичку, можно считывать и записывать в любой ячейку этой строчки. Вот, то это, вот эти две единички будут постепенно терять ток и переключать состояние бита в строчку, которая находится посередине. Пока что понятно? Ну, более-менее. Отлично, отлично. Это физические свойства памяти. Это таким образом у нас устроена память, мы с этим сделать не можем ничего. И, соответственно, в основе как раз вот этого рамблида лежит вот это свойство. Каким образом оно используется? Используется оно следующим образом. Вы каким-то образом должны поместить в эти две строчки памяти секретную информацию. Причем в заранее указанное место, таким образом, чтобы строчка номер один и строчка номер три содержали секрет с одной и той же позиции. Теперь представьте, что вы контролируете считывание строчки номер два, которая находится между ними. И вы можете записывать информацию в строчку номер один и строчку номер три не в секретные данные, а куда-то в другое место. Но главное, чтобы это в той же самой строке были. Достаточно часто. Теперь получается, что постоянно обращаясь к строчкам один и три, вы заставляете их и секретные данные, которые находятся по известному вам адресу, постепенно перетекать в строчку посередине. Ну, перетекать я здесь неправильно сказал. То есть, смотрите, мы предполагаем, что в бите номер один содержится, допустим, единичка. Не, на самом деле не важно, что там, допустим, содержится, мы в бит номер один в нашей строчке номер два кладём единичку. И начинаем обращаться к строчкам один и три. Почти постоянно, много-много раз обращаемся и смотрим поменялась ли единичка на нолик. Если единичка на нолик не поменялась, значит у нас в строчках один и три содержится единица. Потому что, если у нас есть где-то нолик в строчках один или три, у нас бы переличилось на нолик. А так как строчки один и три равны между собой, то у нас будет либо две единички, и тогда у нас останется единички. и тогда наша строчка посередине потеряет свою единичку и станет ноликом. Понятно или уже запутаннее? Вроде понятно. Отлично. Получается, что самое сложное – это таким образом разместить память, чтобы секреты хранились в нужных строчках, начиная с нужных позиций, и между ними находилась другая строчка, куда вы имеете доступ. При этом обратите внимание, что в сами секреты вам обращаться не нужно, вы даже не пытаетесь туда обратиться, вы просто используете физические свойства утечек для того, чтобы считывать и записывать данные в строчку номер 2 посередине между 1 и 3. И вот как раз объяснением, каким образом разместить секреты в нужную строчку 1 и в нужную строчку 3 в нужном месте, и вот эти объяснения занимают 17 страниц. По факту получается примерно следующее, я сейчас попытаюсь на пальцах объяснить. Смотрите. Допустим, они на примере OpenSSH рассматривали и считывали ключ. Они рассмотрели, что вот есть у нас OpenSSH версии 7.9. Когда у нас происходит внешнее SSH-подключение, у нас OpenSSH библиотека обращается к памяти, вытаскивает, аллоцирует сколько-то памяти, сколько там страниц памяти, и там, допустим, в пятую страницу памяти кладет SSH-ключ, начиная с позиции 24, без разницы. Они это проверили, посмотрели, да, на самом деле все время так происходит, и они поэтому сделали следующее. Перед тем, как сделать очередное SSH-подключение, они посмотрели, как работает аллокация памяти в Linux. Аллокация памяти в Linux работает чаще всего с помощью стека, то есть LIFO. Если вы заиспользовали память, потом освободили, она кладется сверху и будет использоваться сверху. Я сейчас в упрощенном виде даю, потому что сложности описаны в статье, кто интересно почитает. Получается, тот, кто берет следующий, за... Если вы освободили память, то следующий, тот, кто захочет взять память, он возьмет именно ту память, которую вы освободили. И поэтому таким образом можно перебором найти те участки памяти, которые удовлетворяют вашему условию, а условием, как мы помним, является то, чтобы они были расположены там 3 строчки подряд, и там вторая строчка между ними была между первой и третьей. Вот это очень сложно разместить, потому что вы... Ну, представьте, давайте я с другой стороны зайду. У вас есть железячная машина, настоящая железячная машина. В ней есть сколько-то памяти. И вам необходимо таким образом сделать, чтобы пятая страница, 24-й бит, оказалась в нужном месте так, чтобы на второй строчке, чуть-чуть ниже нее, находилась ваша программа. То есть вам необходимо аллацировать память, зная, где физически она расположена, каким образом происходит мэппинг с виртуальной памяти на физическую память, и каким образом операционная система выделяет эту память, каким образом все это вместе стыкуется между собой. Получается достаточно сложная, с одной стороны, инженерия, с другой стороны, большое количество проверок, чтобы удостовериться, что на самом деле мы находимся в нужном месте физического устройства. Вот этому как раз посвящена статья. А все остальное – это простой принцип. То есть вы находите этот кусок памяти необходимый, вы его освобождаете и тут же инициируете внешний SSH-коннект. Этот SSH-коннект занимает ту память, которую вы только что освободили. В смысле библиотека аллацирует память для того, чтобы туда положить временную информацию, нужную ей, в том числе SSH-ключ. Она аллацирует эту память, в нужное место кладет ключ, в нужное, потому что вы знаете, сколько ей нужно памяти, и вы знаете, куда она положит ключ, с каким смещением. Потом вы аллацируете сами для того, чтобы ваш кусок лежал в строчке номер два, а потом делаете то же самое еще раз для того, чтобы SSH опять положил в строчку номер три нужную вам информацию. И все, вы можете начинать работу по вытаскиванию SSH-ключа. Примерно вот такая вот конструкция. Звучит на словах несложно, я надеюсь, с картинками еще легче, но по факту очень сложно именно сделать физический маппинг, виртуально-физический маппинг для того, чтобы сработало так, как вам нужно. Получается, что применимость очень ограничена у этой атаки. Те, кто пытаются утащить ваши ключи или пытаются что-то сочетать из вашей памяти, они должны не только контролировать, напрямую работать с вашей памятью, но и плюс они должны четко понимать, как будет работать ваша программа, откуда они пытаются утащить данные. И мне кажется, что это достаточно малое количество дискейсов, когда такое может происходить. Мне кажется, все, я больше погружаться не хочу. Да, достаточно сложная уязвимость. Да, понятно. На самом деле я ожидал, что ты скажешь про то, как ее избежать, что там какие-то рецепты были, или она настолько редка, что даже избегать не надо. А, забыл сказать, да. Когда подобные уязвимости начали появляться, многие говорили, что память ECC, которая автоматически восстанавливает вот такие флипнутые биты, она сильно поможет против подобной уязвимости, но, как вы понимаете, она не сильно помогает, потому что, во-первых, ECC память работает чуть медленнее, и можно в такте, который считывает информацию, успевать прочитывать флипнутый бит до того, как она переключится, во-первых. Во-вторых, а не помню, что во-вторых хотел сказать, уже забыл. Избежать, не пускать никого за ваш компьютер. Я имею в виду, ну, в прямом смысле не пускать. Понятно. Еще интересный момент, что даже такая небольшая уязвимость обзавелась своим сайтом и логотипом. Это, можно сказать, маркетинг в современную эру. На самом деле, очень интересно посмотреть, что эта уязвимость является следствием трех или четырех других разных уязвимостей, в частности, RoHammer, который как раз позволяет, был открыт несколько лет назад, и позволяет переключать состояние бита в соседних строчках. Про эту уязвимость давно известно, и вот спустя 5 лет, подождите, может не 5, может 7, я уже забыл, сколько точно, ну, короче, меньше 10, но все равно больше 3-4 лет, сейчас начинают появляться подобные уязвимости, которые на практическом уровне используют информацию, появившуюся столько-то лет назад. Это довольно интересно посмотреть, потому что, представьте, плюс там есть еще 3-4 уязвимости, которые позволяют понять, каким образом Linux работает с памятью, каким образом физически мапится и так далее. На самом деле, очень интересно посмотреть, как все это складывается вместе. То есть, мы берем одну уязвимость, она, в принципе, бесполезна, мы берем другую уязвимость, она тоже, в принципе, бесполезна, мы берем третью, а потом все вместе складываем, получается, в принципе, полезная вещь. Я боюсь представить себе, сколько всего суммарных уязвимостей в компьютере, я понимаю, что, скорее всего, все их можно использовать тем или иным образом. Я, конечно, не эксперт, мне кажется, такие уязвимости, они интересны тем, что совершенно или не очень понятно, как их вообще-то исправлять. И если исправлять, то это дорого, долго и медленно. Так и есть. Тут, кстати, в тему мы не добавляли, но недавно в Firefox нашли удаленное исполнение кода, поэтому обновитесь на последнюю версию, сейчас скажу, какую, на 67.0.3, в ней исправлено. Ну и вот этим такие уязвимости не интересны, то, что уже исправлено. Ну и нужно просто использовать свежую версию браузера, и она тебя не касается. А вот что делать с RampLid, с такими вещами, не совсем понятно. Это, кстати, вообще проблема с железом, что оно, как правило, не особо обновляемо. В смысле, ты не можешь на него патч поставить. Вообще не можешь ничего сделать. Можешь только не использовать. Можно ключ как-то зашифрованно хранить, даже в памяти. Проблема в том, что ты же шифруешь и расшифровываешь на этом же самом устройстве. Ну то есть, один из уровней, как это я сейчас, кавычка, говорю, шифрования, это вот является способ виртуализации и обращения к памяти не напрямую, а через кучу слоев абстракции. И все всегда думали, что вот, мол, никто не знает, как я где размещаюсь в памяти. У меня есть там сколько-то терабайт виртуального пространства, и все, и никто не знает, где я сейчас нахожусь. Все все знают, все это раскрывается с помощью разных хитрых способностей. Точно так же и ты, ну, зашифровал ты этот кусок. Ты же шифруешь его на основе какого-то другого ключа, который у тебя должен быть в памяти. Да, но это вот как принцип слоу-хэша. То есть, условно говоря, можно отдалять вероятность получения этих данных таким образом. Но это я так, просто в голове возникло. Конечно же, полной защиты это не дает. Продолжая тему ненадежности железа, тут компания Apple отзывает о макбуке.",
    "result": {
      "query": "RampLid vulnerability SSH memory"
    }
  }
]