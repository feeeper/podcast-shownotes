[
  {
    "segment_id": "571e378a-8262-454e-a082-897d84530eda",
    "episode_id": "22565d0d-651b-471e-b89a-2867d70077dd",
    "episode_number": 61,
    "segment_number": 2,
    "text": "Но в основном на Groovy. И, соответственно, ваши таски сборки — это код, и вы можете описывать их как код. За счет этого мы, ну, за счет того, что Android, например, в основном теперь собирается грейдлом Android-приложения, мы получаем просто офигенные возможности, которые на Maven, да, например, они бы решались только написанием плагинов очень сложных, там, ну, каким-то взаимодействием между ними, всем таким. А мы как бы хотим там какую-нибудь вещь сделать. Взяли, запилили там немного кода на Groovy, да, которые Gradle исполнил, и сделал нам билд там по-особенному. Ну, вот такие дела. Кто-то умер. Так, хотел что-то спросить, и тут же потерял мысль. А, вспомнил. Вот что мне не нравится в SBT, это ты можешь написать в нем одну строчечку, которая подключает какой-то плагин с GitHub, условно говоря, и в этом плагине выполняется вообще любой код. То есть он может тебе домашний каталог сносить, ваш CP куда-то ходить. А вот в Gradle все то же самое? Ну да, конечно, можно. Мне кажется, это большой недостаток в системе сборки. Она не должна такого позволять. Я бы так не сказал. Просто надо подключать доверенные плагины и следить за этим. Потому что, ну иначе, мы вернемся обратно в Maven, ты же тоже не знаешь, какой там код в Maven плагине выполняется. То же самое может сделать. Нет, ну, как мне кажется, система сборки, она должна делать примерно следующее. Тянуть зависимости, может быть, разрешать конфликты, хотя там это отдельная тема для разговора. Собирать, собственно, проект, может быть, прогонять тесты. Ну, то есть такого рода вещи. Может быть, какая-то команда сгенерировала документацию, собери мне FedJAR, может быть. Но, например, вот там, а, собери-ка мне DEP-пакет или там RPM-ку. Это уже не совсем ответственность конкретно твоей системы сборки. Это уже отдельный узелиток должна делать. И вот то, что пытаясь со всеми плагинами накрутить, но этого не нужно в систему сборки тащить. Ну, это с одной стороны. Но смотри, другая проблема с Maven, это, скажем, то, что... Ну, у Gradle есть такая фича, как Gradle Wrapper. Это просто, по-моему, идея на миллион. То есть, я не знаю, как другие системы сборки без этого живут, но какая частая проблема? У человека, ну, в смысле, у вас там 10 разработчиков, да, и сколько-то, у каждого свой environment есть, да, и у каждого там стоит версия Maven 3.2, у кого-то 3.3, какой-то плагин несовместим с какой-то версией. То есть, так как Maven нельзя просто так взять и засунуть прямо под source control, да, вашего проекта, ну, это рождает большие проблемы. У Gradle есть Gradle Wrapper, то есть, это, по-моему, JAR, да, в котором и есть Gradle, то есть, сама система сборки определенной версии. И спокойно можно там на одном компьютере разрабатывать проект, который собирается разными версиями Gradle, используя Gradle Wrapper. То есть, в каждом проекте есть своя версия системы сборки, и это очень удобно. То есть, на CI мы просто, скажем, у нас он тянет наши исходники, там уже есть Gradle, то есть, он просто говорит, а выполни мне, короче, точка slash Gradle Wrapper, да, там вызывает его, и мы можем спокойно, например, мы переходим на новую версию Gradle, он у всех обновляется, у всех разработчиков они просто тянули новую версию кода, всякое такое, то есть, там, какой-нибудь Maven, AMP, это их большой недостаток. По-моему, в SBT тоже нет Wrapper. Нет, нет, нет, в SBT все это есть, мы это успешно делаем, то есть, этим ты нас не удивишь. Какая-то мысль была. Я просто видел, как при помощи SBT, при помощи системы сборки, решали, знаешь, какую задачу? У тебя собирается DEP-пакет, потом заливается в вот этот репозиторий с пакетами, потом генерится по истории GIT ChangeLog и заливается там чуть ли не в Confluence. Вот этого система сборки не должна делать 100%. Ну, это, конечно, адовенько, с другой стороны, получается так, что каждый может это у себя локально выполнить, и это круто. А знаешь, что еще можно выполнить локально? Bash скрипт, например. Нет, на винде. Ну, не важно, на Python, ну, то есть, все что угодно можно выполнить локально. Ну, смотри, Python требует определенной версии, то есть, у тебя там стоит 2.7, а тут вышло 3. Проблема, как бы. С каким-нибудь SBT-враппером или Guild-vrapper, это вообще не проблема. То есть, он выполнится, потому что у вас все совместимо, на всех платформах JVM работает. Ну, ты придираешься к словам, ну, хорошо, Lua, например, а не Python, ну, то есть, это все решаемо. Ну, я, возможно, соглашусь, что сборка девпакета — это не вещь, ну, в смысле, это не то, что должна делать система сборки, а, с другой стороны, это сильно упрощает какой-нибудь CI, то есть, переезд, например, вы меняете, там, TeamCity на Jenkins или еще наоборот, то есть, не надо никаких плагин вставить, ничего, просто спускаете команду из системы сборки. Ну, скажем, как часто переезжают из TeamCity в Jenkins и наоборот? Ну, скажем, для своих частей open-source и private-source проектов я держу Jenkins. Мне он дико не нравится, потому что каждая версия ломает что-нибудь, то есть, обновляешь, и у тебя опять все отваливается, все-таки надо настраивать. А зачем же ты ее обновляешь? Да вот потому что я чего-то привык, что как-то обновления должны работать. Это я не прав, видимо, да, но... Где же это слыхано? В общем, скажем, TeamCity на DigitalOcean на машинке за 10 долларов, у которой один гигабайт памяти, TeamCity жрет примерно 997 мегабайт памяти, и билд, который Jenkins, который жрет 300 мегабайт памяти, собирается минут за 30, а Jenkins... ой, в смысле, TeamCity минут за 30, а Jenkins минуты за 3. То есть, я, например, часто пытаюсь их менять, и чем... У меня мнение такое, что CI должен минимально конфигурироваться, то есть, например, если вы используете Travis, вот минимальная конфигурация CI, и чем меньше его возможности вы используете, тем легче вам будет потом... ну, это как вендерлог, его сменить чисто теоретически, и на мой взгляд, чем проще собрать ваш проект, то есть, однострочный, там, какой-нибудь запустили на любой платформе, там, Mac, Windows, Linux, вот тем лучше. Ну, то есть, чем меньше функционал CI, связанного с определением системы сборки, с определением структуры проекта, используется, тем лучше, ну, на мой взгляд. Ну и как считать. — Чем меньше, тем лучше, согласен. 300 мегабайт — это Jenkins, да? — Ну да, Jenkins у меня примерно ест там 300-350 мегабайт. — Чё-то многовато для веб-приложеньки. А может, у него heap такой стоит? — Может быть. — А вот если бы был написан на C, он бы точно не жрал 300 мегабайт. — Да, да, точно. — Ладно, казалось бы, при чём тут RX Java? — Да, потому что она классная. — И для чего она вообще нужна? — А, никто не использует из вас что-нибудь из Reactive Extensions? — Ой, я так, краем уха слышал, что там, не знаю. — Ну, смотрите, и вроде вы в Scala обсуждали, там, Reactive Streams, да, у вас там что-то такое. Вот RX Java — вещь, на самом деле, близкая. Ну, по сути, это... не, это долго объяснять. Но, в общем, она даёт большую возможность композиции всяких вещей, которые могут выполняться асинхронно, при этом что-то в стиле Monad, в плане того, что вы выполняете три вещи асинхронно, комбинируете их, ошибки вы обрабатываете в одном месте, или как-то сводите результат нескольких асинхронных операций в одну, и всё такое.",
    "result": {
      "query": "RxJava purpose and features"
    }
  }
]