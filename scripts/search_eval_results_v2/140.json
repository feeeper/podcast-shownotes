[
  {
    "segment_id": "757bc7a4-ef90-4cc2-83b0-1dbd93ed4925",
    "episode_id": "d5035d65-88bd-476b-8d60-71c7be88f7a8",
    "episode_number": 140,
    "segment_number": 8,
    "text": "Это означает, что happens before действует и между тредами. Это означает, что он дает, собственно, связочку, как действия в одном потоке связаны с действиями в другом потоке. Если бы у нас была memory модель, которая бы не описывала поведение между потоками, а описывала что-то внутри одного потока, она была бы бесполезна для многопоточных программ. Такие memory модели тоже полезны в некотором ограниченном случае. Например, есть классический случай языка C, в котором определены, так называемые, sequence points, точки следования, но эта штука нужна для того, чтобы специфицировать семантику C-шного volatile, который нужен для того, чтобы правильный порядок доступа в голой памяти обеспечить. Но он не про многопоточность. И я просто хочу понять, что сама история многопоточных моделей памяти, она связана же не с тем, что процессор может сделать то, что мы раньше не видели. Это грубо так сказать. На самом деле история довольно простая, и она заключается в том, что и процессоры, и современные оптимизаторы уже давным-давно оптимизируют последовательный код. Давным-давно. Тот порядок, который у вас есть в программах, он уже давным-давно не выполняется. То есть если у вас есть инструкция, записанная в каком-то порядке, они не в этом порядке и почти наверняка не выполняются. Другое дело, что в однопоточной программе у вас почти всегда есть зависимости по данным, или зависимости по управлению, по бранчам, по циклам и так далее, иллюзию существования которых у вас оптимизирующий компилятор и процессор поддерживает. Поэтому вам кажется, что у вас однопоточная программа исполняется ровно так, как это написано в программе. Хотя на самом деле она так и не исполняется. Единственная вещь, вернее так, одна из вещей, которая разрушает эту иллюзию, это как раз смотрение на процесс этой оптимизации со стороны. То есть если мы посмотрим из другого потока, который не в курсе, что там есть какие-то зависимости по данным, зависимости по управлению, то он тогда сможет увидеть некоторое промежуточное состояние, которое по идее тот вот трек, который исполняет программу соптимизированную, не должен увидеть по идее. И это такая интересная полуфилософская программистская историческая хрень, потому что она повторяет ту же самую историю, что хотели как лучше, получилось как всегда. Что у нас были последовательные программы, мы офигительно классно их научились оптимизировать, до тех пор, пока не оказалось, что нам нужно сделать, что у нас появились многоядерные процессоры и многониточные программы, и тут-то наша иллюзия дала эту самую течь. То есть в принципе, если бы существовало состоятельное наклонение, и у нас сначала были многоядерные процессоры, может быть бы мы вообще не начали оптимизировать подобного рода single-threaded приложения. И таким образом бы эта иллюзия не существовала бы для начала, и тогда бы нам не пришлось бы ее разрушать. К сожалению, когда люди рассказывают про эти оптимизации, про процессоры и про оптимизирующие компиляторы, они там, для них по понятным причинам, эти штуки это такие черные ящики, которые непонятно что делают. И когда они про эти черные ящики рассуждают, они рассуждают о разных странных вещах. Например, меня конкретно триггернула фраза о том, что иногда компилятор оптимизирует код так, что эти переменные значения, которые вообще не связаны с этой переменной. На самом деле в меняемой модели памяти они говорят, они очерчивают множество возможных вообще исполнений программы. И во всех вменяемых моделях памяти это множество значений включает только те значения, которые программа когда-нибудь писала. То есть нет такого, как правило у оптимизатора или у хардвара нет такого карт-бланша, что он может делать вообще все, что захочет. Нет, у него есть правило, по которому он следует. У него есть, конечно, некоторый минимальный только набор правил, который может быть контринтуитивен для человека, который не сталкивался с моделями памяти до этого, но все равно там есть какие-то базовые варианты, которые должны исполняться. То есть если ты видишь какое-то значение в переменной, это означает, что это значение кто-то когда-то записал. У тебя могут быть некоторые сомнения по поводу кто-то и по поводу когда-то, но вообще говоря, по поводу того, откуда значение взялось, у тебя, как правило, сомнений нет. Я даже не знаю, как с этим планом перейти. В чем еще сомнений быть не должно? В том, что garbage-коллекторы отличаются. Тут мы уже как-то раз обсуждали, я не помню, что это за статья была, но тот факт, что некоторые странные товарищи утверждают, что горшний garbage-коллектор это вершина творения, и он заруливает что угодно на свете и посреди такого прекрасного. Хотя на самом деле горшний коллектор он оптимизирован по летности, при том далеко не до предела, там еще можно работать и работать над тем, как он сделан. И, например, если у вас бетч джобы, то вам, возможно, горшний коллектор немножко не подойдет, потому что вам тогда throughput важен. И точно так же многие... ну, пока я слышал больше одного раза, что шинандо и горшний коллектор, что шинандо в джабе пытаются сделать коллекторы как угодно, хотя на самом деле нет. И у нас сегодня прекрасный гость для того, чтобы обсудить, откуда вообще такие заблуждения берутся и как же на самом деле. Ну, смотрите, у меня есть две мысли на этот счет. Во-первых, мысль первая, она, честно говоря, оскорбительная. Эта мысль в следующем, что программистам очень удобно продавать всякие маркетинговые штуки. Если программистам правильно что-то сказать, то они с этим знанием, это знание понесут в массы, особенно не обсуждая его. Если хотите продать кошку, скажите, что она объектно-ориентированная. Ну, типа того, да. Скажите, что у нее низкая латенсия, да, и что она бьет все конкуренты. Есть вторая мысль. Вторая мысль заключается в том, что в обсуждениях garbage-коллекторов нужно понимать, что это область ресерча и разработки, которой не один десяток лет, и много-много людей этой задачей занимались. Вероятность того, что кто-то сделает какую-то прорывную идею, которую все остальные пропустили, очень-очень маловероятна. Скорее всего, эту идею все подхватят и реализуют в каком-то варианте. Поэтому если вам кто-то говорит, что мы изобрели офигительно крутой garbage-коллектор, который рвет всех и так далее, нужно как-то потихонечку лапшу-то с ушей убирать. Или хотя бы убедиться в ее отсутствии там. Потому что на самом деле, если ты возьмешь тот же самый ГЦ-шный хэндбук и начнешь его читать, то ты внезапно поймешь, что большая часть garbage-коллекторов, которые написаны, которые эксплуатируются в продакшене, это сборная солянка из тех технологий и из тех наблюдений, которые там уже сделаны в этом учебнике.",
    "result": {
      "query": "модели памяти многопоточность компиляторы"
    }
  }
]