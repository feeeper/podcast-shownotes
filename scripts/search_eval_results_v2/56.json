[
  {
    "segment_id": "db4906f8-85a1-4fdc-b09a-b323ce3f5a0b",
    "episode_id": "75a7bb7c-bed1-41ea-bff6-42ea478f3da8",
    "episode_number": 56,
    "segment_number": 4,
    "text": "А по поводу утечек и всего такого, ну блин, это не знаю, откуда ручки растут, так и оно и работает, потому что код на C это код на C. И никакой особой специфики для написания биндингов к Erlang, от написания биндингов к JVM, наверное, специфика не очень отличается. В Erlang есть специфика для того, чтобы работать с Erlang Virtual Machine более лучше, но в базовом варианте биндинги ничем особо не отличаются. Они в основном отличаются тем, что есть люди, которые довольно расслаблены, и они очень удивляются, что, например, ты ушел в C-шные биндинги, шел туда на 3 секунды. Да, и Erlang это очень не нравится. Вот я говорю, что есть способ писать эти биндинги гораздо лучше, чтобы не блокировать на 3 секунды. То есть там все нормально, просто проблема, как обычно, в людях. Не, ну проблема всегда в людях, просто Python, конечно, у него не идеальный, C++ и Python тоже вроде нормально. Ну просто смотри, в чем дело, Python просто не парится, то есть ты ушел в C-шный код на 3 секунды, и Pythonа пофиг, он все равно на поточной. В Erlang есть такая заморочка, что у него шедлеры, они прям по количеству вызовов функций считают, как бы, другое назвать количество, подсчет редукций. Каждый шедлер считает подсчет редукции, у каждого треда легковесного есть свой бюджет редукции. И при этом считается, что каждая редукция там занимает сколько-то времени примерно. При этом вызов в C, ну это одна редукция на самом деле. Если ты никак иначе в виртуальной машине про это не рассказываешь. Если ты ушел в одну редукцию, которая при этом заняла целых 3 секунды, у тебя шедлеры начинают тебя шедлерить неправильно. Потому что ты занимаешь больше времени на самом деле, чем ты об этом сообщаешь. Там для этого есть разные механизмы для работы с этим. Во-первых, можно писать не отдельные функции, а так называемые порты, которые будут интегрироваться с Event Loop'ом Erlang'овой машины. Во-вторых, можно даже просто из обычных функций сообщать, что вот здесь, например, я потратил не одну редукцию, там не знаю, 50. Во-вторых, можно из нифок типа временно возвращаться, там есть сейчас недавние версии виртуальной машины такой функционал. В-третьих, сейчас работают так называемые грязными шедлерами. То есть там есть способы это все сделать так, чтобы это нравилось виртуальной машине. И это как раз в первую очередь потому, что чтобы позволить виртуальной машине поддерживать очень-очень много одновременных подключений, очень-очень много одновременно работающих потоков. И питону нет этих проблем, потому что он не пытается эти проблемы решать, грубо говоря так. Кстати, интересная мысль пришла в голову.",
    "result": {
      "query": "Erlang C bindings performance issues"
    }
  }
]