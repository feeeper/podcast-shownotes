[
  {
    "segment_id": "95cc3731-062b-44ce-8474-65164af59e06",
    "episode_id": "01f1a3fe-dd00-4fff-9f24-d5896be45a72",
    "episode_number": 77,
    "segment_number": 2,
    "text": "Нет, конечно. Я далеко не все запрограммировал, только основные вещи, которые случались чаще всего. Многие моменты опускались просто из-за того, что они требовали больших выследительных ресурсов, которые и не давали большого преимущества какого-то. К примеру, столкновения шин друг с другом я совершенно не обрабатывал. Столкновения с внутренним углом машины или шины, чего угодно, тоже не обрабатывал. Ну, то есть моменты, которые достаточно редкие. Их можно было опустить и не считать. Вот с какой-то точностью считать. Да, то есть точность все равно была не идеальная, но, скажем так, предполагалось, что в большинстве случаев она будет у сока. А по поводу физики, на самом деле, наверное, во многом помогало и то, что я по образованию физик, и мне было проще интуитивно понять, что должно, что учитывать, что может быть важным, что не важным в этих моментах. А вообще, что ты считаешь самым важным в этом? Что дало тебе такое преимущество, что остальные не смогли тебе дотянуться? Ну, я скажу, что главная сложность в этом конкретно, ну, вообще в этих соревнованиях, особенно в соревновании последнем, в том, что пространство поиска оптимального решения очень большое. С простым перебором перебрать невозможно. И приходится придумывать способы, как сократить пространство поиска. Вообще в этой области много разных алгоритмов придумано. К примеру, алгоритм, который в конечном итоге я написал, такой дерево поиска траектория, он, скажем так, не мотивирован, а навевается, основан на идее дерева поиска Монтекарло, в котором я плясал от этой идеи и пытался применить его к реализации в данном случае. Хотя не очень похожие задачи. Там Монтекарло-дерево используется для игр с Пашаговых, а тут реалтайм, физика и немножко другое. Но все равно что-то общее было. И вот все приемы, которые я использовал, хитрые, они были направлены на то, чтобы отбросить малоперспективные варианты и выбрать только те, которые могут привести к успеху. Подожди, но дерево Монтекарло ты просто случайным образом выбирал что-то, потом пытался это улучшить, если это давало более-менее неплохой результат? Не совсем. Я использовал из дерева Монтекарло идею того, что нужно больше времени, вычислительного времени, выделять с тем направлением, которое кажется более перспективным. То есть когда дерево Монтекарло, в классическом дереве Монтекарло, в чистом дереве Монтекарло, там нет оценочной функции, там просто случайная игра идет дальше. Вот этот момент я не использовал. Но кроме этого еще там используется момент, что ветви, которые более перспективны кажутся, на них выделяется больше времени, чем на остальное. Дерево получается асимметрично. И в принципе, вот как я в статье рисунок привозил, у меня тоже дерево асимметричное. И это как бы в этом схожесть есть, Эльфей. Это идеи. Собственно, когда я начинал его писать, я от этой идеи плясал, что мне нужно сократить пространство поиска и попытаться уменьшить количество вариантов. А расскажи, как ты пришел к идее использовать дерево поиска Монтекарло? То есть это как-то само собой получилось? Ну, как как-то? На самом деле, я еще два года назад в соревновании тоже Айкап, где были солдатики, там другая игра была, там была пошаговая игра солдатики. И там как раз я честно пытался упряменить это дерево Монтекарло, чтобы получить более-менее сильную стратегию. Но там я с ней как раз поигрался с этим алгоритмом, попробовал его, но там ничего не получилось из-за того, что была, присутствовала ограниченная видимость, это вносило искажения, и алгоритм не работал. Но тогда я с ним наигрался достаточно, и в общем, когда в этом году началось соревнование, у меня была идея попытаться что-то похожее применить. Но ведь в Айкапе на финале тоже был этот туман войны или как он назывался, когда есть ограничения по видимости? Да, в гонках тоже было ограничение по видимости, но в данном случае оно не оказалось решающим. Потому что, во-первых, оно было только на первом круге, а после проезда карта открывалась и была вся доступна. Во-вторых, последние карты были такие, что там много кругов приходилось ездить, учитывая только, что небольшую часть времени машина ехала в условиях, когда ничего не видела. А большую часть времени она уже ехала полностью разведыв карту и не имея проблем с видимостью. Поэтому как-то это мало эффектовало. Слабо отказывалось, не так сильно, как в Солдатиках. В Солдатиках это имело решающее значение. А у меня такой вопрос. Мне всегда было интересно, люди, которые принимают участие в конкурсах для программистов, как это таким словом, как это с твоей перспективы выглядело? Ты брал отпуск или писал вечерами. И что тебя мотивирует на участие в таких вещах? Мотивирует в первую очередь азарт. Это просто интересно и азартно, когда пытаешься соревноваться с другими участниками и обойти их. Для меня это как игра, как развлечение в каком-то смысле. Писал я по вечерам в основном. Иногда удавалось чуть-чуть выкроить время на работе, если не было. Было свободные моменты что-то посмотреть, разрестировать, отлазить. Но в основном это были выходные и вечера. А сколько ты длился? С учетом бета-теста, по-моему, пять недель получалось. А ты с бета-теста начал участвовать? Да, я с самого начала участвовал. Пять недель – это много, да. Первые две недели я практически ничего не делал, только так периодически. Подсчитывал? Думал. Ехал в метро и думал, как бы мне написать алгоритм. А писать начал, наверное, уже за полторы недели до первого раунда только. Ага, понятно. А вот еще такой интересный вопрос. Ты, как, получается, местами спортивный программист. Как считаешь связь спортивного программирования и промышленного? Насколько успехи в одном влияют на успехи в другом и наоборот? Ну, в данном случае можно рассмотреть разные спортивные программирования. Вот эти распространенные, где на задание дается несколько часов, нужно быстро их решить. Это одно. А на мой взгляд. А такие, как вот эта, где несколько недель на спокойное обдумывание и реализацию, это немножко другое. Они слабо связаны. Но спринт и марафон, да? Спринт и марафон, да. То есть, в промышленном программировании как раз обычный это марафон. Такого не бывает, что нужно за два часа что-то написать. Потому что, в лучшем случае, ошибку нужно исправить за два часа успеть. Обычно на реализацию требуется достаточно много времени, чтобы спокойно обдумать и реализовать правильно. Поэтому обычное спортивное программирование... У меня вообще сложно по нему обсудить, потому что я не участвовал в таких всех. А вот этот формат, когда даётся около месяца, он, на мой взгляд, достаточно похож на промышленное программирование. Большую разницу я не вижу. Просто в промышленном ещё приходится работать в команде, а тут, конечно, индивидуальное написание, поэтому есть некоторая разница. А в АЕКПе командами нельзя было, да? Нет, запрещено по правилам. Я мало следил, поэтому да, спрашиваю. Ну, насколько я знаю, в Солдатиках можно было, скажем, скопирироваться друг с другом и в итоге победить таким образом. Ну, я не знаю. Может, кто-то так и делал, но по правилам несколько игроков, работая в команде, запрещено. То есть это даже описано в правилах, можно почитать, там чётко сказано, что за это они блокируют. Да, но надо ещё доказать и поймать. Ну, обычно просто по исходным кодам. Они же все исходные коды получают. Если есть дублирование исходного кода, это уже повод для блокировки. А ещё такой вопрос. Какие книги, может быть, какие-то сайты, какие вообще в целом материалы ты посоветуешь нашим слушателям, которые полны решимости принять участие в следующем АЕКАПе и хотят там победить? Ну, сложно сказать, что может помочь в следующий раз, так как я победил только один раз, в отличие от прошлогоднего победителя, который побеждал по несколько раз. Могу сказать, что мне, какие знания мне пригодились в этом соревновании. Во-первых, мне пригодились знания физических движков. Я в было время как-то поигрался, писал небольшой свой физический движок. И из-за этого мне было гораздо проще разобраться, возможно, с тем, что в этом году предоставили в качестве соревнования. Так как физический движок уже почти каждый раз попадается, то это, возможно, было заметным преимуществом. Ещё, в принципе, классические алгоритмы, структуру данных всем тоже не помешают. Теория, это вот, игр в некоторых случаях может пригодиться, наверное. Ну, сложно сказать. Есть и другие, но конкретные посоветовать. Я бы ещё посоветовал курс на FruSerie. Там был курс про написание движка для игр пошаговых стратегий, любых пошаговых стратегий. Я забыл, как он называется, я найду ссылку, кину в шоу-ноты. То есть там в целом рассказывали про теорию игр, потом рассказывалось про применение. Писался движок на Java как раз, и рассказывалось, как его применять для произвольных пошаговых игр. Очень интересно. Я приходил, мне очень понравилось. А вот расскажи про выбор языка программирования и вообще твоё отношение к Java. То есть ты зарабатываешь на жизнь программированием на Java, ты выбрал её как язык для участия в Айкапе. Как ты вообще к языку относишься? К языку? Ну, на мой взгляд, Java отличный язык. В нём практически нет ограничений каких-то, которые мне удалось сталкиваться, которые бы не позволяли что-то реализовать, что можно сделать на других языках. Такого принципиально. Может, только на очень низком уровне какие-то сложности могут возникнуть. Но в целом, даже вот можно посмотреть список победителей в Айкапе. В десятке все на C пишут. Я единственный, кто написал на Java. Да, вот это, конечно, было удивительно посмотреть. Ты, по-моему, ещё в конце вырвался, не в начале. До этого в песочнице постоянно побеждали все C-шники, там первая десятка вся была в C-шниках. Ну, после второго раунда я на первом месте держался. Да, потом ты вырвался постоянно на первое место, и всё, тебя не смогли догнать. Вообще, когда меня уже награждали, скажем так, в Айкапе, была возможность пообщаться с другими победителями, несколько человек последними, нескольких первых мест, которые писали как раз на C, они несколько были удивлены, как, мол, на Java удалось обогнать их по производительности. Хотя, на мой взгляд, ничего невозможного в этом нет. Дело не в языке, а в алгоритме. Да, вот скорее алгоритмы здесь решали. Я не уверен, что на Питоне можно было реализовать, скажем, сколько там у тебя вариантов стратегии про за один тик? Ну, вот я подсчитывал, у меня получалось, что, скажем так, там игра вообще пошаговая, ну, не пошаговая, она как бы псевдо-реалтайм, но на самом деле там много маленьких тиков идёт. По-моему, там 60, что ли, тиков за одну секунду проходит. Так вот, за один такой микротик, 1,6 секунды, я успевал просчитывать ходов таких микротиков примерно, сейчас пытаюсь вспомнить, порядка 40 тысяч, наверное, 40-50 тысяч. Вот я писал на Питоне, и у меня цифры были намного-намного меньше. Я, конечно, не пытался его оптимизировать, но всё равно, мне кажется, таких цифр не достичь. Ну, я не писал никогда на Питоне, мне сложно судить. Мне кажется, что вряд ли дело в языке, скорее всего, просто нужна правильная оптимизация. На Питоне просто часто, может быть, пишут студенты, которые не очень глубоко знают язык и плохо знают, как его можно оптимизировать и ускорять, поэтому им сложно это сделать. Поэтому как бы корреляция присутствует. Но это не значит, что причина в языке. Как тебя, Вань, студенты, а? Нет, я не говорю, что в язык, там, вы конкретно студенты, но просто часто на нём пишут студенты, поэтому, возможно, из-за этого есть корреляция между, скажем так, силой, скоростью, которую они получили, и языком. А у тебя бывает когда-нибудь необходимость написать какую-то небольшую программку, которая делает что-то простое? Сейчас я вспомнил, у меня недавно была необходимость. О, кстати, это мне кажется интересно. Я разбирался, как... Я использовал TCP Dump, мне нужно было посмотреть, какие данные передаются по TCP, собственно. Проблема в том, что TCP Dump выводил и IP-заголовки, и TCP-заголовки. Вот те данные, которые меня не очень интересовали. И там нужно очень внимательно посмотреть на хекс, и вычесть, посмотреть на длину пакета, и посмотреть только на нужные байтики, по нужному смещению. Короче, это неудобно читать. И вот, например, мне нужно было написать программку, которая вырезает лишнее, и потом заново выводит такой красивый дамп трафика. Вот, например, такая простая задачка. Ну, простая в смысле по объему кода. Вот когда у тебя возникают такие задачи, ты тоже на Java пишешь? Ну, то есть, по-моему, для таких задач именно предназначен Python или Ruby, смотря что больше нравится. Ну, я все пишу на Java, потому что в моем понимании изучать несколько языков, если один язык может сделать все, что нужно, это трата времени. Излишняя, скажем так. Вот я не прав, конечно. Это сейчас было сильное, сильное заявление. Ну да, ты подставил. А ты говоришь именно про языки, либо про парадигмы? Ну, то есть, одно дело, мы изучим, например, Java, .NET, они, в принципе, примерно те же возможности. А вот если мы изучим, там, Java, Haskell, тот же, не знаю, Lisp, это просто полезно с точки зрения, скажем, расширения и растягивания мозга. С этим я полностью согласен. Но речь шла именно о коротких, маленьких программках, которые не требуют какой-то хитрой парадигмы. Поэтому я ответил так. Если нужно изучить новую парадигму, тогда, конечно, можно освоить новый язык. Я правильно понял, ты сторонник... Ты из лагеря Java для всего? Ну да, в каком-то смысле да. Я считаю, что на ней можно сделать практически... Я еще не сталкивался с чем-то таким, что принципиально мне так впечатлило, что чего нет в Java, а чего... Ну вот, позволь, я приведу тебе контрпример, а мне интересно, что ты скажешь. Допустим, у нас есть пользователи на бюджетных компьютерах, таких как Raspberry Pi. Это, на самом деле, в некоторых странах довольно популярно. Ты согласен, что писать десктоп-приложение только на Java под такую платформу не будет работать? Согласен, да. Я про десктоп-приложение не упоминал как-то. Хотя, конечно, есть области, где Java не очень хороша. Но просто я с ним не работаю. Десктопный, поэтому не пришло в голову даже. Десктопный, да, я согласен, с ним на Java не очень удобно. Хотя сейчас появился последний вот этот JavaFX. Но я не уверен, насколько она будет достаточно быстрая и сможет на слабых машинах хорошо работать. Она немножко не на том, мне кажется, ориентирована. На более удобство разработки десктопных приложений. Десктопный, да, пожалуй, не стоит писать на Java. Мне так кажется. Нет, некоторые, может, и стоят, но если ты хочешь, ну, как я считаю, если ты хочешь, чтобы твое десктопное приложение работало вообще у всех пользователей, даже у тех, у кого железо слабое, то тут выбор невелик. C или C++. Я полностью согласен, что есть области, где Java не подходит, но я имел в виду не конкретные области практически, а имел в виду программирование в целом. Что какие-то типа задач удобнее решать на другом языке, нежели на Java, то это у меня вызывает сомнения. Что есть какие-то подходы у языков разные к решению одного и тех же задач бывает. Очень спорный момент. Ну, да, много обсуждать. Слушай, Саша, а у меня такой вопрос. Вот на той встрече, когда вы с другими победителями общались, вы же наверняка обсуждали, какие стратегии были применены у других ребят. Можешь немножко рассказать про то, какие еще подходы к решению этой задачи были использованы? В общем, я давай, подожди, я сначала вступлю. Здесь на iCAP было отдельный форум, на котором можно было какие-то топики создавать. Сразу после окончания соревнований там появился топик, кто какие использовал стратегии, и там, я не знаю, я начал читать первые три страницы, а их там было, я не знаю, сколько, 15-20 страниц. Все делились, все перемешивались и так далее. Но мне скорее интересно именно о победителе. Скажем, топ. Не все возможные варианты, а кто еще победил. Да, мне немножко удалось с ним пообщаться. В принципе, подходы у всех очень похожи. Отличие было в незначительных каких-то решениях. Ну как, незначительных со стороны, но которые могли, если честно, оказать влияние на производительность решения. То есть у всех было примерно то же самое, но мой оказался с алгоритмом самым быстрым, с более глубоким расчетом по времени, по глубине ходов вперед, скажем так. И просто обыгрывал их за счет этого. То есть, например, второе место, которое в «Песочнице» было второе место, а в финале он занял по пятое место, это Колотьенко Нику, участник был. У него очень похоже решение было на мое, только оно работало медленнее, поэтому проигрывало по цели. Кстати, одной из очень удивительных вещей, которую я не предполагал, но когда прочитал твой пост, понял, что на самом деле оно имеет смысл, это то, что у Александра шла эмуляция на большое количество шагов вперед оптимальной стратегии. И на следующем тике, когда он снова просчитывал, куда и как двигаться, он предполагал сразу ее идеальный. И поэтому свою самую оптимальную он уже практически не пересчитывал, а только, может быть, пытался улучшить уже в какую-то сторону. И это позволяло ему сильно экономить ресурсы. То есть ты на каждом следующем тике должен попытаться улучшить уже самую хорошую, которую ты до этого нашел, но не делать это с самого начала. Только за счет того, что у тебя четкое понимание физики с точностью всех знаков после запятой. Во многом благодаря этому, хотя и с меньшей точностью можно было бы это сделать, просто сложнее было бы. Да, просто вычисления распределялись по времени. Не все вычисляем за один тик, а постепенно каждый тик вычисляем, потом добавляем, добавляем, добавляем. Стараемся не терять. Практически у тебя как в процессоре уже современной архитектуры. То есть если у тебя происходил какой-то бранч, ты столкнулся с чем-то внезапным, с чем не рассчитывал, вот этот внутренний угол и так далее, то тебе приходилось заново все это простраивать, восстанавливать. Да, это похоже на то, как работает предсказание перехода в процессе. Наверное. Да, да, да. В этом что-то есть, да. Интересно. У меня вопрос такой к Александру. Ну раз уж мы заговорили про Java, вот это все расскажи, как у тебя выглядит твое рабочее окружение, я имею в виду операционную систему, IDE, любимая система контроля версии, вот это все. Да, да, да. Ну, ничего особенного. Intelligent ID, Windows, Subversion. Вот, как-то так. Subversion. Ну, это же Ubuntu, Вань. Да, да, да, да, я прям так. А, ты ностальгичный, да? Конечно. А, я подумал, это задумчиво, я понял. Не, нормальная система, на самом деле. Это с любовью. Я в свое время очень любил Subversion, когда мы переходили на него со всяких SCCS, SVS, и так далее. Но потом ты осознал все, глубину своих заблуждений, да? Да, но когда я прихожу в те конторы, где я любил Subversion, они говорят, зачем нам распределенная система, нам не подходят они. Слушай, а давай, раз уж мы разговаривали, мы поговорим о версии, тему про систему контроля версии. Отлично, отлично, да. Вообще, я в свое время, когда я на Subversion сидел и я выбирал себе систему распределенную, контроля версии, ревизии, я в первую очередь всегда смотрел на Mercurial. Потому что он, по сути, как-то ближе к Subversion. Он структурирован, он более правильный, он хороший и все такое. Git, по сравнению с ним, это мешанина очень всего, не знаю, как это сказать. Во-первых, это мешанина концепций, про это все уже всегда говорили. Во-вторых, это мешанина технологий, которые сложны там. Помимо использования каких-то библиотечек используются и всякие скрипты, я не знаю, Shell и все такое. Но, к сожалению, к сожалению, Mercurial, похоже, умирает. То есть, нельзя сказать, что все, что-то выключилось. Но, вот одна из новостей, которые мы сейчас имеем, это то, что Matt McCall, основной разработчик и создатель системы управления, ревизиор к системе Mercurial, сказал, что он все, он устал и он уходит. Так, подожди, позволь мне прояснить ситуацию. Получается, что разработчики CPython ушли с Mercurial, создатель Mercurial отказывался от Mercurial, да он же просто помер уже. Сейчас скоро битбакеры откажутся от Mercurial. Отказываются от Mercurial. Но вообще это очень обидно, вот реально обидно. Почему? Ну, потому что это более правильная система. Нет, скорее дело не в правильности, здесь конкурент, понимаете, когда есть конкуренция, это хорошо. Это такой хороший толчок, чтобы развиваться. Плохо, когда в конкуренции побеждает слабейший. Ну, с точки зрения эволюции, ну, не должен был гид выживать с этой странной системой всего. Да, но за гидом стоит Linus. И GitHub, который сильно много делал в этом направлении. Я понимаю все эти причины, я согласен. И более того, я сейчас в гиде чувствую себя увереннее, чем в Mercurial. И поэтому, когда я создаю новый репозиторий на битбакете, я предпочитаю гид уже. Но от этого мне не менее грустно. Но ты как программист должен быть местами перфекционистом, правильно? Тебя разве не греет чувство того, что у нас теперь есть одна нормальная система контроль версии, остальные это системы. Я лелею надежду, что когда-нибудь выйдет гид в 15, в котором они скажут, вы знаете, мы ради обратной совместимости поддерживаем весь предыдущий синтаксис, но на самом деле мы переписали все, я не знаю, на Go. И теперь оно все работает супербыстро, и есть новая API, которая стройная, четкая, понятная, и все классно работает. И, кстати, это REST. Ну, почему бы нет? Нет, ну, кстати, GitHub одобрит, я вот уверен. Новая версия? Ну, может быть. Нет, я имею в виду REST API. А, да, конечно. Ну ладно, как там? RIP, давайте дальше. Да, как бы ни было обидно, но жизнь продолжается. И... Joint. Да, да, да. И следующая тема, это у нас... Я бы даже не знаю, как это правильно сказать. Unikernel не подходит для продакшна. Я правильно это говорю? Выбрасывай давай, Ваня. Вообще сложно сказать, что выбрасываю. Мы совсем недавно обсуждали, что докер купил компанию, как это называется? Mirage Oswit, да? Где все в Unikernel'ах и Akamal и все дела. И как раз следующая статья, это про то, что Unikernel'ы это анализ того, почему Unikernel'ы становятся популярны, а также показания, несколько причин, почему на самом деле они не очень подходят. То есть в качестве причин, почему его используют, обычно все приводят причину, что это, во-первых, более производительно, у вас нет дополнительных уровней абстракции в виде ядра. Во-вторых, это более безопасно, потому что у вас куча всего выброшено на самом деле, остается маленькая как это сама программа, плюс все, что необходимо для ее работы с железом. И, соответственно, чем меньше у вас кода внутри, тем меньше ошибок в этом коде и тем меньше уязвимостей. И следующее это то, что оно маленькое, очень-очень маленькое, быстрое, удобное. Но автор как раз статьи говорит, что это все обманчиво, что на самом деле там куча проблем. Во-первых, с точки зрения производительности вы все равно запускаетесь поверх какого-то гипервизора. Все современные технологии уходят постепенно на гипервизор и получается, что у вас все равно вы не работаете напрямую с железом и тогда уровень абстракции, который добавляется между вашим приложением и между железом, он все равно съедает максимальную оптимальность, которую вы могли бы получить. С точки зрения безопасности гипервизор тоже имеет проблемы, там было в последнее время в Xen найдена куча проблем и говорит, что у нас ушел Linux и теперь мы полностью безопасны. Нельзя, то есть вам все равно придется следить, вы все равно будете эти проблемы видеть. Плюс там гипервизор не видит и не знает о том, сколько вы памяти на самом деле используете, потому что вы приложение-операционная система и когда вы запускаетесь, даже не знаю, а вам нужно полмегабайта, вам доступно 2 гига, они все 2 гига будут никто не знает, что вы там используете и скорее всего вы никому их не отдадите. Ну и плюс, после того, как он разбил в пух и прах все потенциальные достоинства Unikernel, он добивает его дополнительными недостатками. Во-первых, чаще всего нет какого-то готового интерфейса, то есть когда у вас есть какая-то программа, нет чего-то подходящего, чтобы вы взяли свою программу, воткнули куда-то, запустили, нажали кнопку и все заработало. Вам все равно придется все всегда дописывать это ручками. Есть несколько библиотек, которые позволяют что-то делать. Видо как раз MirageOS или есть там для Erlang для Haskell решение. Он в качестве примеров приводит. Я не знаком с рынком Unikernel, может быть там есть еще какие-то ссылки. Но получается, что в любом случае они немножко недоделаны, то есть чаще всего они реализуют какой-то POSIX, ну в смысле не какой-то POSIX, а POSIX совместимость они делают, но Linux он не полностью там POSIX совместим может быть. В каких-то местах может быть расширение чего-то и чаще всего вам все равно придется доделывать. И самая главная беда, которую он говорит, вот как только вы ее коснетесь, вы сразу поймете, что вы сделали неправильный выбор, это невозможность дебага. Все ваши любимые дебаг-тулзы не работают. У вас там нет процессов, поэтому не работают даже простейшие PS, TOP, Trace, PIMC, TCPDAM, Netstat и так далее. Не работает DTRACE, в общем ничего не работает. Большинство проблем нужно отлаживать во-первых интуитивно, ой что-то вроде у меня пошло не так, дай-ка я прилежу и перезапущу. Или по поведению, то есть ой что-то он не то тут показывает, скорее всего вот по этой ветке исполнения мы идем. Отлаживать практически нереально и все работать на интуиции. Как-то так. Ну я с одной стороны по большому счету согласен, с другой стороны то есть в блоге Джоэнта написано, который по сути продает сервера железные и виртуальные, написано, что Unikernel это плохо. Удивительно. Ну а что поделать? Я в принципе понимаю, почему Unikernel хотят запускаться, скажем, на Ирландге, потому что Ирландг по сути это сама по себе, как это, операционная система в себе. Она внутри себя имеет вот эти процессы, которые там создаются ты можешь отлаживать и частично вот эти вот недостатки, которые он перечислил, они уходят. Вот. Но с точки зрения вот всех тех, ну то есть как бы у него нет здесь очевидных ошибок или ляпов в его аргументах. Нет, подожди, а как же скорость? Я беру Ирландг и запускаю на железе. Что не так с идеей? Я что-то возможно упустил? Нет, нет, нет, ты получаешь свою скорость, да. То есть как бы он говорит про скорость, когда вы не получаете того, что вы хотите. То есть когда говорят, что вот мы получаем максимум, потому что мы работаем прямо на железе, между нами нет никакой виртуализации и я могу все, ну в смысле нет никаких дополнительных уровней в виде операционной системы и я могу прям напрямую железяку какую-то использовать. Но из-за того, что у тебя есть гипервизор, он все равно добавляет тебе абстрактную машину какую-то, то есть какое-то усреднение и ты не можешь максимум оптимальности оттуда выжить. То есть оно будет быстрее, конечно. И в целом он в конце говорит, что я в целом понимаю, что куда идет Unikernel, то есть я понимаю, что на современных системах, где используются контейнеры, нам не нужна Linux, потому что Linux нужен как мультизадачная большая система, а мы здесь выполняем какую-то одну маленькую задачу и нам здесь Linux просто мешает уже посылить. Это на самом деле большая глупость, потому что контейнеры занимаются тем, что ограничивают, отрезают друг от друга группы процессов внутри этого твоего Linux'а, если что. То есть у тебя ядро одно, ты просто процессы очень хорошо изолировал. А ты говоришь, что ядро нам не нужно. Все верно, но все сильно зависит от твоего юзкейса. То есть, скажем, если у тебя один процесс запускается, а я имею в виду один докер-контейнер запускается на одной машине, зачем тебе Linux там? Один докер-контейнер, в котором запускается одно приложение. То есть у тебя фактически получается, что Linux как мультизадачная система, которая нужна для того, чтобы разграничивать пользователей между собой, для того, чтобы управлять памятью, она в принципе не очень нужна здесь. Но если ты запустил однопоточное приложение в докере на мультизадачной операционной системе, то да, я соглашусь, не очень нужно. И вообще ты какой-то очень странный человек, если так делаешь. В смысле странный? Ваня же говорит про однопоточное приложение, правильно я понимаю? Да, конечно. А вот сейчас у нас много таких приложений? Да, на Linux. Однопоточных приложений, конечно, дофига. Назови пример. Ну, например, PS, Top и так далее. Не, ну на самом деле, как бы это... Ну, про реальные, которые, скажем, бизнес-задачи решают. Хорошо, бизнес-задачи. Вот вы как часто программируете на потоках? Постоянно. Нет, подожди, вы на зеленых потоках или на реальных потоках? На реальных потоках постоянно. На реальных процессах тоже, ну в моем случае. Да, вот я на процессах я делаю, я согласен. На потоках я давно уже не программировал. Ну, хорошо, если я пишу какой-нибудь небольшой скрипт на том же Пайтоне, ну, мне там нужно что-то протестить, то я использую его процессы, которые я хрен знает, как внутри устроены. Не, ну это понятное дело. Я имею в виду, когда ты используешь Python для тестов, ты не будешь это запускать через Xen на Unikernel. Чаще всего тут имеется в виду, вот я хочу, я не знаю, какую-нибудь молотилку, например, запустить, и нафига мне там нужен Linux? Вообще непонятно. Запустить молотилку? Ну, я имею в виду цифры молотилку, которая там считает что-нибудь. Ну, хорошо, согласен. И ты на современных процессорах это в один поток хочешь делать? На современных процессорах в один поток. Я хочу добавить, чтобы у меня был внизу подо мной какой-то гипервизор, который будет управлять, я буду запускать их по количеству процессоров или количеству виртуальных процессоров, да? Ну, у вас и есть этот гипервизор. Да, да. Куда-то сохранять данные, пересылать данные по сети, например, или на диск писать. Все очень сильно зависит от того, что вы делаете. То есть, на последних двух моих работах мне такая штука нужна была. Но я понимаю, что это не всегда нужно. Мне нужны были и другие штуки, где мне нужны процессы, где мне нужны хорошие IOs, где они должны обмениваться, сохранять. Я согласен с вами. Но иногда нужно и так, и иногда нужно и так. Я бы так сказал, что, может быть, нужна какая-то операционная система полегче для таких задач, что в Linux там реально очень много всего наворочено. То есть тебе нужно, как ты описал, запустить процессы, чтобы они могли куда-то результат переслать по сети или на диск. То есть нужна файловая система или сетевой стэк минимальный. И что еще? Что я забыл? Ну, там процессы, но все как обычно. Ну, возможно, еще память общую заиспользовать, если их там несколько на одной машине. Да? Да. А, кстати, интересно, есть ли реально такие легковесные операционные системы, в которых как можно меньше лишнего? Ну, то есть кроме учебных, кроме экспериментальных, прям целенаправленно. Если кто знает. Может, гость знает? Александр? Нет, боюсь, я не знаю таких операционных систем. Нет, наверняка есть для embedded, но они еще и с минимальным использованием ресурсов. А на Pi, что запускают обычно? Обычно Raspbian. Ну, то есть это Linux, это Debian специально под малину скомпильной. Он порезанный как-нибудь? Он вроде не особо. То есть даже на вот этих вот маленьких дешевеньких малинках все равно запускают полноценный Linux? Ну, они не такие дешевые. То есть это компьютеры, какие они были лет 5 назад. То есть там GeekPalace... А как же P0? Ага. Ну да. Кстати, там есть еще разные операционные системы для малин. Я лично их не смотрел. И у меня есть подборка, я сейчас название не вспомнил. То есть в закладке где-то лежат. Там есть и другие. Валеру надо было бы, конечно, послушать. Я надеюсь, слушатели и Валера среди них придут в комментарии и поправят нас. Кстати, про P0, да, я упустил твой намек. Тут сделали суперкомпьютер на P0. Точнее это выглядит так. Некая компания, я не вижу названия, так бегло. Они сделали плату. В плате энное количество слотов. 16, по-моему. В эти слоты вы берете P0, который мы обсуждали. Который за 5 баксов компьютеры. И пихаете в эти слоты. USB портами вставляете. У вас получается такой небольшой суперкомпьютер из 16 Raspberry Pi. В котором еще есть который представляется большой USB хаб с подпиткой от сети. Кстати, а у всех USB хабов всегда есть подпитка или нет? По-моему, не у всех. Ну вот, и еще там пачка изернет-портов. Пока это все в виде прототипа и у чуваков у них на самом деле есть только одна P0, поэтому они собирают их там с мира по нитке для своих задач. Это мне вообще непонятно, если честно. А у них там в статье написано какие-то проблемы с доставкой этих P0 к ним в страну. Что за страна такая, я уже не помню, давно читал. А в Японии. Это компания Edein, наверное, так читается. А, то есть, подожди. Если ты хочешь купить P0, то есть, они делают явно штуку, которая будет в том числе рекламировать P0, продвигать P0, да? И они не могут договориться с производителями, чтобы им дали там несколько штук. Ну, как-то звучит диковато немножко. Непонятно, да, но очень интересно. Но выглядит очень классно. И если все получится, они собираются эту штуку доделать и продавать массово. Вот, по-моему, отличная мысль. Теоретически она не должна быть очень дорогая, потому что там нет какой-то сложной логики, там фактически разводка всяких там питания, машины и все такое. Но мне кажется, это должно работать намного лучше, чем обычный эзернетовский свитч с малинами. То есть, сейчас дома ничто не мешает собрать кластеры. И, по-моему, была на том же хабре переводная статья на тему, что кто-то взял лего, собрал из него корпус, напихал туда малин, объединил это свитчом и сказал, ребята, суперкомпьютер. Суперкомпьютер. Кстати, про суперкомпьютеры. Тут говорят, недавно один из новых ИИ на каком-то большом компьютере обыграл в ГО чемпиона. Какого-то чемпиона на ГО. Александр. Да, я читал эту статью. На самом деле, очень интересное решение у них там. Потому что это дело не в компьютере в большом и сильном, а в интересном алгоритме, который... А, кстати, на каком компьютере там известно, не этот запускали? Нет, там не указано конкретно на какой машине. Написано, что они обучали свою систему на облачных системах от Гугла своих, собственно. Какие-то большие учреждения давали на обучение. А потом уже обученная система, видимо, играла на не очень выдающихся машинах каких-то. По крайней мере, я не увидел упоминания какие конкретные. То есть, это не суперкомпьютер, а что-то там такое. Ну, всё, и ГО сдался. То есть, шахматы сдались, ГО сдался, всё уже не осталось. Да, вообще считалось, что ГО ещё долго продержится, ещё лет 10 как минимум. Но они применили нестандартное решение, которое оказалось удивительно хорошо. Кстати, оно будет интересно. А можно описать подробнее? Да, могу рассказать. Да, хотел рассказать. Я думаю, это было бы интересно тем, кто участвовал в конкурсе вроде ЭКАП, так как похоже и лично, на самом деле. Там они... То есть, это тоже пошаговая игра, ГО. Единственная её особенность, то, что в ней очень большое количество вариантов. Там количество ходов оценивают больше, чем количество атомов Вселенной. И, в общем, перебрать их простым перебором просто невозможно и не будет невозможно никогда. На обычных компьютерах, по крайней мере. До сих пор все программы, самые сильные программы игры в ГО, алгоритмы, могли соперничать только с любителями. С профессионалами не могли конкурировать. И эксперты предполагали, что ещё не скоро смогут, потому что нужны были очень большие вычислительные мощности, чтобы стандартными алгоритмами подняться до такого уровня. Кстати, я перебью тебя. Я не знал, я вообще с ГО мало сталкивался, но там в качестве примера приводили пример, что самая лучшая программа на ГО до этого могла конкурировать с человеком подобного уровня, мастером, если мастер давал ей преимущество в 4 или 5 ходов форы. То есть ты ходи 5 раз, потом мы начнем играть и я тебя всё равно выиграю, наверное, да? Ну это прям жесть какая-то. Ну как-то так. Я на самом деле подробностей про ГО не знаю, поэтому конкретно этот момент рассказать наверное не смогу, но я хотел рассказать собственно об алгоритме, который они применили.",
    "result": {
      "query": "Unikernel disadvantages production use"
    }
  }
]