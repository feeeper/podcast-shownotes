[
  {
    "segment_id": "d6f85a7f-c23c-4176-8769-132d03ae2281",
    "episode_id": "84d2dd5c-95f9-44e8-8105-3ddb5254a690",
    "episode_number": 449,
    "segment_number": 5,
    "text": "И если вы с таким продавцом столкнетесь, у вас доставка может быть несколько дней. Притом некоторые продавцы, они предлагают еще и доставку с деком к двери. Но это редко бывает, это скорее исключение, но такие есть. Но в более общем случае, если какая-то мелочевка от какого-то рандомного продавца, и действительно пакет будет ехать из Китая, то около месяца. Обычно меньше. То есть, например, я рассказывал в прошлых выпусках, что на Алиэкспрессе можно заказать и печатные платы, просто через личку поговорив с продавцом, у него есть объявление, мы делаем печатные платы, ты ему пишешь в личку, он тебе считает, сколько это будет стоить. И вот с момента заказать печатную плату, и я ее забрал с почты, принес домой, это заняло месяц. Я засекал. Это время, оно включает в себя время на производство, тестирование, упаковку печатных плат, понимаете, да? То есть, получается, именно сама доставка, она меньше месяца. Надеюсь, я ответил на вопрос. Андрей Ха говорит, что до Москвы примерно те же 2-3 недели, как и раньше. Я согласен. Так, про официальный магазин к Медведе рассказал. Вот. Есть ли вопросы, возражения, комментарии про 3D-печать и что там было до нее? Потому что я хочу перейти к SQLite. Лично у меня нету. Слушатели вроде тоже все задали. Да, спасибо, что поддерживаете нас вопросами и ответами. SQLite. Я довольно уверен, что когда-то в каком-то обсуждении, то ли в Slack, то ли где-то, высказывалась мысль кем-то, опять же, если мне все это не приснилось, что в SQLite есть проблема, аналогичная подгрузовому transaction ID Rapport. И когда она случается, ты должен остановить свой SQLite, пересоздать в нем базу данных и запуститься заново на только что созданной базе. Недавно этот вопрос снова всплыл в другом обсуждении. И как будто бы эта версия не подтверждается. То есть на сайте SQLite есть статья про RAID Headlock. И насколько я понимаю идею, я тут дилетант в этом вопросе, но идея такая, что у тебя много сессий могут читать данные и одна сессия может писать. По сути, вместо transaction ID используется смещение в RAID Headlock. То есть когда ты начинаешь транзакцию на запись, ты смотришь, ага, мое смещение в вал оно вот такое, и я знаю, что я единственная пишущая транзакция, и я знаю, что все остальные транзакции читающие. Отсюда я делаю вывод, что я вижу все данные с меньшим transaction ID. Правда, нужно сделать оговорку. Я вот сейчас понимаю, что интересно, что происходит, когда транзакция абортится. То есть в случае, если у меня вся транзакция успешная, то да, конечно, никаких проблем. Но если я делал большую транзакцию, которая много-много данных писала, потом сказала, я заабортился, то варианта два. Либо ты все данные, грязные данные, держал в памяти и ни в коем случае не вытеснял в диск в RAID Headlock, это будет работать, но можно умереть по памяти. Либо этот алгоритм не будет работать вот так в буквальной реализации. То есть там должны быть какие-то поправки на транзакции, которые абортились. Вот. Но как будто бы именно проблема транзакционной идеи раппораунда не стоит, потому что как будто бы смещение в RAID Headlock должно быть достаточно. Я так понимаю, что страницы фактически иммутабельны. То есть у тебя есть хип, у тебя есть обновленная версия страницы, которая пишется в журнал. Время от времени ты должен схлопывать свой журнал с хипом, но в целом ты знаешь, что если я вот пошел назад по RAID Headlock и нашел там страницу, это новая версия. Ну или последняя версия страницы. Если я в RAID Headlock не нашел страницу, я знаю, что в хипе последняя актуальность страницы. Вот. Надеюсь, получилось не слишком сумбурно. Если вдруг мы когда-то что-то такое про SQLite обсуждали в подкасте, то я это напрочь забыл. Мне кажется, мы этого никогда не обсуждали. Если вам интересно узнать, как работают журналы и что используют вместо Transaction ID, то вот почитайте ссылку, я оставил в чате. Вот. Иван Иванов сообщает, что в Firebird 2 есть проблема с Transaction ID Wraparound, только там еще хуже. ID транзакции закончились, все, база больше не работает. Штатная инструкция из документации для DBA. Сделать дамп старой BD, создать новую BD из того же дампа. Есть подозрение, что я перепутал Firebird 2 и SQLite. Такое нельзя исключать. Вань, ты использовал когда-нибудь Firebird? Нет, никогда. Слушай, SQLite, она... Я помню, что... Я вообще запутался давным-давно. Она позволяет работать конкарентли несколько потоков, несколько записей одновременно. Я просто последний раз, когда мы пользовались, мы точно использовали в однопоточном режиме. Потом я помню, что мы обсуждали в подкасте, что многопоточность тоже существует, но я ее никогда не использовал, поэтому для меня это вообще... Насколько я осведомлен, а я дилетант, и в комментариях придут слушатели и объясняют мне, насколько я не прав, но насколько я осведомлен, читать можно в любое количество транзакций, писать можно в одно.",
    "result": {
      "query": "SQLite transaction ID wraparound"
    }
  }
]