[
  {
    "segment_id": "38940d4b-0d95-4fc8-ac62-0a4acf1f802c",
    "episode_id": "59735a0a-1f27-4dae-b500-cbea858929bc",
    "episode_number": 438,
    "segment_number": 2,
    "text": "Кто-то ее настроил. Вот, но... Но как разработчик, или как пользователь, или как мейнтренер пакета, ты говоришь, сделай мне релизную сборку. Вот, а там уже использованы правильные флаги, которые в этом проекте должны работать, с которыми все тестируют на SCI и так далее. Это я к чему? Что мне, насколько я помню, вообще никогда в голову не приходило просто передать \"-o3\", поэтому я даже не был уверен, действительно это работает или не работает, это тестируют или не тестируют. Вот, докладываю. Postgres компилируется. \"-o3\", проверено на GCC, проверено на CLN. Вот, а конкретно опасения были по... Там в статье, которую мы обсуждали в прошлом выпуске, приводился пример кода, где в коде пытаются проверить, будет ли численное переполнение, если мы прибавим к числу заданную константу. И проверка была в стиле if x плюс 100 меньше x, then, что-то, что-то делать. И в C целочисленное переполнение означает undefined behavior. То есть, когда в большинстве реализаций без жутких оптимизаций, действительно, если вы прибавите к int 32 100 и int переполнится, тогда оно транслируется в какой-то ассамблерный код, и у вас произойдет целочисленное переполнение, и вы получите как остальное отход к отделению, да, по модулю. Но технически все это undefined behavior. И в статье писалось, что поскольку результат вычисления это undefined behavior, то компилятор C-Lang, например, считает, что может это выражение то ли выкидывать, то ли что-то. И возникает вопрос, а как Postgres проверяет факт, ну, в Postgres же тоже нужны в каких-то задачах проверять, что вот если отчисление, то это не так, то это не так. То есть, если отчисление, то это не так, то это не так. То есть, если отчисление, то это не так, то это не так. Я сложу два числа, не возникли ли целочисленные переполнения. Я посмотрел, как оно реализовано, оно реализовано достаточно просто. То есть, у тебя в некоторых компиляторах есть прям встроенные, все время забываю, как это называется. Интриги. Интриги, как? Интриги. Интриги, спасибо. Потому что мне всегда подмывает их назвать то ли прагмами, то ли чем-то. В общем, встроенные хреновины, которые начинаются там с двумя... с двух подчеркиваний, как-то хитро называется. Большинство компиляторов, они предлагают интриги для проверки, там, будет ли целочисленное переполнение или нет. А если их нет, то можно, ну, например, ты хочешь проверить, будет ли целочисленное переполнение при сложении двух int32. Как это проверить без undefined behavior? Очень просто. Кастуешь в int64, складываешь и смотришь, что получится. Вот. Это не очень хорошо работает, например, не на всех платформах есть int, int128, поэтому, чтобы проверить, будет ли целочисленное переполнение при сложении двух int64, там нужно уже немножко хитрее проверять, но это тоже в Postgres все есть. Вот. Вообще, Postgres это богатый источник хорошего кода на C. Я в свое время на GitHub заводил репозитории, где я прям выдергивал, что вот здесь у нас реализация красно-черных деревьев из Postgres, а вот здесь у нас реализация, хэштаблицы были самописные. Гоню. Но смысл в том, что если вот вы, у вас проект на C, и вам нужно в нем нечто, есть очень хорошая вероятность, что оно уже где-то есть в коре Postgres или же там под лицензией BSD MIT совместимый, поэтому вы имеете полное право это выдергивать и использовать у себя в проекте. Вот. Это был долгий рассказ о том, что Postgres скомпилируется с минус O3 и целочисленное переполнение, возможно, целочисленное переполнение проверяется не так, как сообщал автор той статьи в тексте. Ну, справедливости ради автор той статьи не говорит, что все так проверяют переполнение. Я думаю, он просто приводит пример, который человек незнакомый с этой ситуацией может захотеть написать. Я думаю, он прекрасно осведомлен, почему это не работает и как надо на самом деле. А еще интересный вопрос. А как это в других языках устроено? Там вообще это объявлено, как antifine behavior или нет? Вот в Elixir что будет? В Elixir все нормально будет, если ты забыл, то в Erlang длинка. Чтобы не бывало переполнения. Хорошо, окей. В Elixir и в Python не бывает. Что будет в Rust? В Rust... Я сейчас тебе сходу не скажу. Там это, по-моему, defined behavior. Там, по-моему, будет... У тебя есть или безопасный какой-то оператор, который стрельнет чем-то, если ничего не путаю, есть другой, который сделает целочисленное переполнение и оно, типа, это defined behavior будет целочисленное переполнение. Еще интересно, что будет в Go, например. Ну, в принципе, любой язык берешь и возникают интересные вопросы, а что будет? В общем, да, есть Act-Add, который проверяет ... Сейчас так, я сходу не найду про другой Add, но, по-моему, мне казалось, что они просто определили про это, что будет происходить. Ну, я понял. Ну, я догадываюсь, что там есть медленный и безопасный оператор и небезопасный, но там плюс-минус понятный. Ну, типа, не тот, который нельзя в... Нет, не так. Который нельзя изоптимизировать из кода и так далее. Я, собственно, дальше, во время моего у меня дальше по темам, бранд про Rust. Вот у меня там есть некоторые моменты. Ну, да, в Rust, если кратко, там есть некоторые поведения, которые могут быть неочевидными, которые, но они определены. И вот если вылезти за то, как предполагается, как себя будет вести программа, то можно словить неожиданное поведение, но у тебя Undefined Behaviour может случиться только в unsaved коде, только если ты нарушишь, короче, определенные заповеди о том, как... Ты знаешь, типа, как из разряда как будто в Haskell есть законы монадические, тебе ничто не мешает их нарушить, ты потом очень сильно удивишь пользователей. Я смотрю, ты чему-то тоже научился на этой неделе? Это, по-моему, было на прошлой неделе, но я, по-моему, про это не рассказывал, поэтому решил добавить в тему. Если вы следите за новостями, связанными с компанией Apple, в частности, с операционной системой macOS, вы, возможно, слышали, что к следующему, к релизу следующей macOS делают такую штуку Game Porting Toolkit. Это такой набор инструментов, чтобы разработчики игр могли запустить свою игру и посмотреть, как, ну, виндовую версию своей игры, посмотреть, как она вообще на маке работает. Также там входят другие всякие вещи, типа трансляторов, шейдеров и прочих других вещей, которые, собственно, портирование упрощают, но интересная пользователям часть в том, что можно игры просто запускать. Они притом, да, можно интеловские виндовые игры запускать, в том числе на DirectX 12 и Welcome. Можно запускать на современных ARM маках, и оно худо-бедно работает. Ну, то есть люди даже там Cyberpunk как-то запускали, по-моему, сам по себе GPTK мы обсуждали в выпуске как-то раз. В чем, что я узнал недавно, что во-первых, есть вокруг него уже умельцы сделали обертку, называется Whiskey, я залинковал, которая скачивает нужные версии всего. Во-вторых, я же пока не ставил бету новой операционной системы, но оказывается GPTK, во всяком случае, то, с чем я пробовал, я Unreal Tournament запускал 2004, работает на маке. 2004 Unreal Tournament на маке не очень хорошо работает, во всяком случае на ARM. Там какие-то проблемы с дерганием, с тем, что все какое-то рваное, хотя FPS нормальный, в смысле анимация рваная. Но GPTK как таковой работает на винтуре, вот, внезапно. Если вам очень хочется поиграть в какие-то Windows игры, можете попробовать. Также Alex говорит, что в Go тоже Integerary Flow по спеке. Вот. Полезно знать. А теперь моя очередь. Если ты, Саш, ничего больше не хочешь из недельного рассказать, моя очередь ранить про Rust. Давай, не сдерживайся, да? Да, в общем, я... гулял по просторам интернета и... как это... совершенно случайно наткнулся на мнение про язык программирования Rust, в духе, что... ну как же так, на Rust нельзя взять как бы...",
    "result": {
      "query": "integer overflow C undefined behavior"
    }
  }
]