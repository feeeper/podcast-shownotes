[
  {
    "segment_id": "cb27206a-0fbf-4951-a041-2850798e7c7e",
    "episode_id": "b339a75b-0c63-4d07-997f-f6b2b60878b0",
    "episode_number": 379,
    "segment_number": 6,
    "text": "Безусловно, безусловно, я планировал это сделать, то есть сначала нужно сказать, потом объяснить, то есть идея заключается в следующем, то есть похожие модели используются в питоне и в принципе в C++, когда есть QoA Async, QoA Weight, идея заключается в следующем, в принципе, асинка можно две основные реализации выделить, которые сейчас используются, то есть это стеклескарутина и стеклескарутина. Стеклескарутина используется в Go и фактически, когда мы создаем наши зеленые нити, Green Territory, которые так еще называются, мы тем или иным способом выделяем для них свой стек, это может быть Chain Stack, то есть когда у нас не одна контидиуса location, а когда у нас несколько разных локейшн, которые провязаны между собой, то список и фактически тогда нужно, чтобы у нас runtime при вызовах каким-то хитрым образом эти фреймы разбрасывали по сегментам, когда у нас закончилась память на стеке, мы алоцируем новую арену, она может не последовательно за предыдущей находиться, а где-то в другом месте в памяти и для трекинга мы каким-то образом провязываем, и преимущество такого подхода заключается в том, что когда мы в нашей кооперативной многозадачности должны переключиться куда-то, мы просто оставляем этот стекл, как есть, переключаемся логически на другой стек и начинаем продолжать код с того же места, где остановились, ну а соответственно в Rasty, в Python, в каких-то других языках, где используются генераторы, у нас фактически используются не обычные функции, а именно функции на основе генераторов, то есть это даже не совсем функции, это именно объекты, у которых есть код, есть состояние и фактически каждый раз, когда мы дошли до какой-то yield point и мы знаем, что текущий результат не готов, то есть фактически в тот момент, когда мы делаем await, если мы видим, что результат не готов, мы записываем текущие состояния, куда нужно убеждать, что он записан в объект, который букетингом занимается и делаем return с функциями, ну то есть компилятор это делает за нас и фактически, когда мы returning, та функция, которая нас вызвала, тоже получает yield и соответственно у нее нет другого выхода, кроме как тоже сделать return и этот каскад return продолжается, пока мы не дойдем до самого верха, но и соответственно на самом верху нас ждет sync-executor, который понимает, что сейчас наша хрюччина не может продолжать исполнение и нужно заняться чем-то еще, если такая возможность вообще есть, ну и в противном случае уснуть, пока мы не получим какую-то нотификацию, обычно это делают через E-POL или KQ, но в принципе есть и другие механизмы, такие как IO, E-Ring, об этом Дима",
    "result": {
      "query": "стековые корутины vs генераторы"
    }
  }
]