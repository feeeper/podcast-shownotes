[
  {
    "segment_id": "ec87370c-c3f5-4475-9b7b-5d7c2aaa1531",
    "episode_id": "e0fe5fb6-1b4d-484a-9e0a-d5ec1a8623dc",
    "episode_number": 360,
    "segment_number": 3,
    "text": "Да, и в принципе, я не уверен, как у них с менюшкой именно окна, то есть в Mac OS же нельзя без менюшки окна вверить, все равно что-то должно быть. Я думаю, в принципе, если очень захочешь, ты можешь его себе собрать, но я не думаю, что Live View и Phoenix будут какое-то отношение иметь к тому, как выглядит твоя менюшка. Они все-таки за содержимое окна отвечают, и обычно у людей цель унифицировать вот это садик на, потому что это 90% работы, а тут менюшку нарисовать, если очень нужно, ну типа это, не знаю, может 5-10% работы, оно все равно будет дергать за тот же самый функционал, который уже где-то реализован. Понял, понял, спасибо. Вот, это очень круто, потому что позволяет делать модные молодежные приложения на Elixir, но этого оказалось мало. Настоящие безумцы, они же хотят не просто приложения модные молодежные на электроне сделать, настоящие безумцы хотят запуститься на Android и iOS, настоящие безумцы запускаются на Android и iOS. Боже. Вот, это очень круто, это работает по такому же принципу, но сложнее, потому что, особенно на iOS, потому что на iOS просто в принципе забандлить R-Lang с iOS приложением это приседание со штангой. iOS приложения, насколько я понял из доклада, они не готовы загружать динамические библиотеки, ну то есть в принципе модель безопасности системы такая, что какие попало динамические библиотеки, загружаться не должны, то есть те, которые ошибятся системой они конечно будут загружены, я так понимаю, не на 100% вверх, кстати, а вот те, что вместе с приложением приехали или не дай бог откуда это еще взялись, они ни в коем случае не должны быть загружены, поэтому на iOS принято линковаться со всем чем можно статически. R-Lang, он обычно собирается вообще как отдельный байнер и на самом деле, если там внимательно копаться, его можно собрать как исошник, там есть Entry Point, в котором можно собрать исошник, с ним линковаться и есть Entry Point, в который можно заскочить из своей программы, но мы не можем сделать так на iOS, то есть на Android они так именно сделали, на iOS так сделать нельзя, потому что, ну как бы, ой, больше того, R-Lang очень сильно зависит от всяких внешних процессов, которые занимаются, например, когда в R-Lang есть такая абстракция, называется port, когда вы открываете port, именно, точнее так, там есть port, есть сетевой port, есть port, есть port program, когда вы открываете port, port program, оно запускает не сразу вот эту внешнюю программу, оно запускает такую программу, которая будет мониторить состояние внешней программы, а потом уже самому программу, это нужно для того, чтобы, если та вот программа отвалится, чтобы в этом порте появились корректные сигналы о том, что все очень плохо, вот, на самом деле, мы все равно таким на iOS заниматься не будем, но с depend'ом что-то надо делать, больше того, NIF-ки тоже, они так как бы, NIF это способ расширять R-Lang из языков, которые, то есть, на которых можно скомпилировать что-то, что будет иметь сишный ABI, вот, соответственно, NIF-ки тоже разделяемые библиотеки, непонятно как загружать, в общем, ребята приселятся штангой, и в итоге даже отправили pull request в R-Lang, и его уже даже приняли, то есть, в следующем релизе он будет прям просто, следующий релиз можно будет, R-Lang можно будет билдить как статический бинарник, как статическую библиотеку, то есть, не как разделяемую библиотеку, а как статическую библиотеку можно будет билдить, выключаю все зависимости, без которых так-то собрать нельзя, плюс они, конечно же, убедились, что все работает на ARM64, как и чем является, а, не даже ARM32, то",
    "result": {
      "query": "Erlang static build iOS Android"
    }
  }
]