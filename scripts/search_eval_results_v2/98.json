[
  {
    "segment_id": "16f6c143-d069-4d27-a718-3f34a05b49a3",
    "episode_id": "ccff6c01-cbd2-44bb-ae6d-761dba955bd4",
    "episode_number": 98,
    "segment_number": 10,
    "text": "Потому что нет цифров, это отлично работает, да? Да. При этом раньше это можно было делать так, что ты забиндил переменные во внешнем скопе, дальше спустился в какой-то внутренний скоп типа ИФА, и там смог ее перебиндить, потом вылез наружу. Это, ну в принципе понятно, как работает, но это очень неочевидный трюк. Подожди, оно таки во внешнем скопе будет изменено или не изменено? Да, да, да, будет изменено. Оу. Как в Рубе, короче, они старались сделать, как в Рубе. Оу. Но они, в общем, поняли, что это фиговая идея, и на самом деле это давно считалось кодсмел. Сейчас они официально это задеприкейтили, то есть теперь компилятор будет на тебя сыпать ворнигами на каждую такую конструкцию. Вот. То есть они сделали язык более строгим в этом плане. Молодцы. Да. Я как бы давно хотел этого увидеть, наконец они это притащили, половина библиотек сразу же, конечно, покрылась ворнигами, но ничего, подождем. То есть как бы там, не стоя на том, что считалось кодсмелом, но люди все равно так иногда по привычке писали. Особенно как бы бывшие рубисты. Вот, сейчас это официально задеприкейтили, надеюсь, что через полгодика все библиотеки перестанут на это ругаться. Но это такая приятная мелочь, но на самом деле, по факту она прямо в этом глизе ничего не меняет, кроме ворнигов. Следующий важный момент для тех, кто пишет теперь день и это наконец в язык втащили много интересных нативных типов данных для работы со временем. И всякие красивые синтексы записи времени. Вот у меня вопрос, да, вот это tilde t, tilde d, это вот считается не кодсмелом, это вот так надо писать. Вот однобуквенные сокращения, и наше все. Ну смотри, это по сути, когда тебе не хочется писать три километра квалификации, чтобы построить это по строке, больше того, построить по строке оно будет в рантайме, к тому же, эта штука тебе сразу, во время компиляции, это развернет в правильный терм. Что в принципе можно понять. На самом деле у них там есть понятие sigil, это в отличие от Ruby, это не магия уровня языка, у них на уровне языка есть понятие sigil, которое ты можешь определить как хочешь. Вот, и конкретно библиотека с этими типами данных, она определяет такие sigils. В принципе, sigils документированы, то есть в библиотеке, которую ты определяешь, ты можешь найти документацию на sigil. Это не какая-то такая магия, которую ты должен знать в языке, ты просто идешь, смотришь в библиотеку и увидишь, что это что-то за sigil. Это немножко более читабельно, ну и как бы реально в коде ты это знаешь в основном в тестах, потому что в тестах ты это не от юзера получаешь, тебе это нужно реально записать. Я вот честно, я все понимаю, но я предпочел бы что-нибудь типа date.new или как-то так. Ну, понимаешь, в чем дело? Как бы date.new, а откуда date, какой date? И начинается, что на самом деле нужно типа elixir.date.new и так далее. А если там еще не data, а native date time, то, в общем, слишком много букв получается, к сожалению. И сама дата потом еще огромная будет. Вот, но что важнее, важно даже не это синтез для записи, это все фигня на самом деле, можно жить и без него. Важно, что они наконец в язык втащили тип date.time и тип native date.time. Native date.time отличается тем, что не содержит в себе никакой тайм-зоны. Не содержит кого? Тайм-зоны. Ну, то есть он у тебя либо в локальном тайм-зоне, либо в UTC, либо в какой-то еще. Ну, то есть, как правило, если ты его используешь, значит, у тебя там UTC. Ну, часто используется, когда у тебя есть просто миллисекунды в UTC. Тебе нужно их сквозь что-то сконвертировать, ты их в native конвертируешь. Вот, и ты считаешь, что у тебя все приложение всегда в UTC работает на самом деле. Назвали бы UTC time. Ну, есть библиотека Calendar, которая есть UTC time stamp. Вот, в общем-то, собственно, к чему я все это? Потому что, наконец, ввели нормальные типы данных для работы со временем, которые, скорее всего, будут теперь использоваться во всех библиотеках. Раньше была библиотека Calendar. Было еще некоторое количество библиотек для интеграции этой библиотеки со всеми остальными, включая шаблонизаторы для HTML, всякие помогалки для работы с сектором, которые для работы с базы данных и так далее. Сейчас будут в языке, в стандартной библиотеке нужные типы данных, и библиотеки будут интегрироваться, конечно же, с ними, и больше не будет никаких вопросов о том, какие типы, где, когда использовать, потому что, ну, все будет теперь как бы нормально. Ну, дата – это такая штука, которая в приложениях нужна часто. И, слава богу, наконец-то есть в стандартной библиотеке что-то по-настоящему визабельное. Еще один важный… Ну, то есть вообще, релиз – он про более строгий язык, про улучшенный визабилити. Следующий момент – это еще удобнее стало редактировать вложенные структуры. Сейчас появился такой… То есть там давно есть такой протокол. То есть в Rixie есть протоколы. Это что-то вроде… Ближе всего к TypeClass, на самом деле. Для тех, кто не знает, что такое TypeClass, близко к интерфейсам. И там сейчас, ну, там давно есть протокол Access для того, что, ну, ведет себя как дикшенери. Ну, и, соответственно, там некоторые языковые конструкции автоматически в это транслируются. И сейчас еще добавили просто встроенную функцию, которая для всего, что реализует Access протокол, в частности, например, хешмэпы, позволяет делать апдейт глубоко вложенных структур. И позволяет это делать довольно лаконично. Это, ну, те, кто когда-то пытался работать с чистофункциональными структурами данных без линз, те знают, какая это боль. Те, кто пытался использовать с линзами, понимают, что там коды генерации и прочая фигня. И, ну, как бы работает, но хотелось бы, чтобы язык это решал, а не библиотека, которую нужно еще понять сперва. Вот, теперь вот опять-таки важную для юзабилити проблему решили прямо в языке. Ну, точнее, в стандартной библиотеке языка. Вот, дальше всяческие улучшения BuildTool'а, из которых я лично… Там их много разных мелких, но я для себя отмечу такую штуку, что они научились тесты теперь. То есть, запускают только такие тесты, результат которых может быть изменен в результате изменения файлов, которые ты изменил. Потому что вот в Erlang'е есть такая утилита xref, которая смотрит, которая позволяет построить граф зависимости именно по отдельным функциям. Ее втащили в Mix, ну и поскольку ее уже втащили, стало просто реализовать вот такую вот запускалку тестов, которая запускает только дельт-тестов, а не все. И это очень здорово. То есть это прям… У тех, кто пишет на Ruby, знают, что есть такая утилита guard, которая перезапускает тест для того файла, который ты сейчас менял. Но там оно работает просто по конвенции именования. То есть если ты знаешь, что есть файл, не знаю, page-контроллер, то page-контроллер-тест это тест для этого файла.",
    "result": {
      "query": "Elixir time data types update"
    }
  }
]