[
  {
    "segment_id": "a3077d2f-1b95-40ec-b6af-4022231bd887",
    "episode_id": "d9f3d4cd-2f9a-4c1f-b5bb-228a2ce1e11c",
    "episode_number": 47,
    "segment_number": 7,
    "text": "Видео все доступны и он просто, на самом деле, шикарен. Это раз. А вот по поводу BigData, честно говоря, даже не знаю, потому что, наверное, выберите фреймворк, который вам больше всего интересен, или поделки Twitter, или какую-нибудь ACU. Я бы рекомендовал ACU и что-нибудь функциональное, например, Scalav, которая эта штука дюбелем сшита. Ну и просто учите конкретный фреймворк и пробуйте, потому что сейчас минутка рекламы на AWS, у вас есть бесплатные инстансы, которые вам доступны на халяву, и вы можете поднять кластер и руками пробовать, я не знаю, посчитать, например, число pi. Весьма интересно прямо на кластере. И для этого вообще ничего не надо, даже платить не придется, просто возьмите учебник по акторам Scalav и вперед. Книга, которая Foundations of Statistical Natural Language Processing, авторы Крис Маннинг и Генрик Шуц, они? Да-да-да. Все, добавил. А по дискретной математике есть такая изумительная женщина Капитонова, она написала просто шикарную подборку лекций по дискретной математике, и это вам просто идеальный русский вариант категории теорий, которая сейчас нашумевшая. Ну, может быть, эта книжка чисто для математиков, но если у вас нормальная башка на плечах, то вы найдете, как ее применять в программировании функциональнее. Добавил. Отлично. А еще у меня седьмой вопрос, такой каверзный. Вячеслав, ты можешь не отвечать, если не захочешь. А вот ты назвал градацию, кодер, программист, инженер, кем ты себя считаешь? Я... да, это каверзный вопрос. Я скажу, что я медленно лезу в программисты. Вот. Как скромно. Спасибо. Да, подкололи. Ну окей. Валер, не пора ли? Да, возможно, пора. То есть мы кончили. Хорошо. Едем дальше. Сейчас у нас Вани нету. Я даже не знаю, обсуждать ли это без Вани, или не обсуждать, потому что... Я думаю, у тебя опять Google Docs не обновляется. Вполне возможно. Это печаль. Почему? У меня, видимо, тоже не обновился. Ну короче, да, вся гугловая чудесная... Нет, подожди. А, вот о чем. Ну ладно, раз уж я заговорил, то потом переставим два пункта местами. Так вот, да, собственно, что у нас случилось интересного? Вышел внезапно RLANG. Саша написал R18. Саша, R18 неправильно. У нас уже две версии, теперь у нас больше нет буквы R, у нас теперь 18.0. Серьезно? Да, уже 17.0. Раньше, а что буквы R означало, релиз или что? Ну то ли релиз, то ли что-нибудь такое. То есть, короче, давным-давно у RLANG была странная нумерация релизов, то есть там R, номер релиза, R – мажорный номер, дальше B – минорный номер. Вот. А сейчас просто, как у всех нормальных людей, мажорная циферка, точка минорная циферка. Программисты на ракет с тобой не согласны. Окей. И что там нового? Самое важное, что нового, ты вот сейчас, слава красотеньку, выделил, это там новые таймеры. То есть, раньше была такая проблема, ну как бы, это не то чтобы проблема с точки зрения эргономики, это проблема с точки зрения того, что это то, что рано или упрется, любая реализация. Если у нас есть куча процессов, которые могут конкурентно работать, и у нас есть, не знаю, пока там 2 ядра, ну и фиг бы с ним, когда начинает появляться, не знаю, 32 ядра, и каждый процесс начинает, как бы каждый шедулер под каждое ядро начинает каждым процессом какие-то таймеры ставить и время системное спрашивать. Если мы пытаемся для нашего системного времени, как RLANG, дать гарантию, что оно всегда не убывает, а если мы его очень-очень часто будем спрашивать, оно еще и меняться будет при этом каждый раз, всегда будет уникально, то это на самом деле можно сделать только через один толстяный лог. В RLANG, конечно, есть способ получить системное время, ну и лог, но это другая тема, то есть возможно, ну хочется не системное время, а вот именно вот, что это такое с хорошими гарантиями. Но ребята почислили репу и поняли, что на самом деле, как бы редко кому нужны все гарантии разом, и на самом деле кому-то нужно монотонное время, которое при этом может повторяться, например, кому-то нужны абсолютно уникальные идентификаторы, кому-то нужно просто время посмотреть и так далее. И на самом деле API по работе со временем его немножечко усложнили, но за счет этого будет работать быстрее и при этом оно семантически более ясно, что оно делает, то есть либо монотонное время спрашиваешь, либо системное время спрашиваешь, ну либо и так далее. И наконец-то мы можем забыть про этот ужасный тупл из трех элементов, который с нами был с очень древних версий Erlang, в которых еще не было big integers, ну то есть я Erlang без big integers вообще не застал, а вот это API застал, а теперь все оно будет нормально возвращать big integers без всяких странных туплов, которые потом нужно превращать в нормальные integers. Еще там из такого более-менее интересного это то, что мапы, во-первых, они наконец вышли из бетки и их там окончательно довели до состояния, когда там можно матчить их более всеобъемлюще, чем это было, а во-вторых, для мапов, в которых больше чем сколько-то там элементов, теперь будет внутри не сортированное что-то, а hash array mapped tree, то есть та реализация, которая изначально для них планировалась. И это прекрасно, потому что это наконец-то действительно не от 1, а от примерно 1. То есть мапы, они, возможно, замены рекордом иногда, а возможно замена диктом иногда. И дело в том, что те мапы, которые нам привезли, это на самом деле была просто структура данных, в которую наконец можно разумно парсить JSON вместо пропристов. В плане эргономики за... Сори, не в плане эргономики, то есть эргономику улучшили, а производительность была такая, она была нормальная, но на большом куске данных она могла быть внезапно нехорошей. А в какой версии они справили? Там был какой-то ужасный косяк, что они чуть ли не шли по всем элементам, чтобы найти нужный мап. В смысле? В 17-м так и было. Но оно было ordered, Саша, оно ordered. То есть это не oe10, это, короче, типа поиск в ordered сети. Но да, нехорошо, короче. Теперь там hamd. Вот, ура-ура. Что еще? Еще из такого помелочи, там некоторые эргономические плюшки для ETS. В остальном там, в принципе, кому интересно, могут пойти сами или из ноты почитать. С хайлайтами, пожалуй, все. Вот. Ну и теперь реклама тайм! Конференция fp.conf, которая пройдет в Москве 15 августа в бизнес-центре из Майлова Альфа. Два потока в один день. Цена билета 6 тысяч рублей в данный момент. И если вы введете промокод devzen, вы получите скидку 200 рублей. И добро пожаловать на сайт fp.conf.ru. Там можно посмотреть все подробности. Такие дела. Я хочу к предыдущей новости добавить, что в книге Лерниуса Мерланг появилась глава про это новое время. Там прям туториал. О время, о туториалы. О временах туториала. А можно еще вопрос задать по нашей новости? Конечно. Вы сказали, что у нас в Ирландии вы контрибьютите? Я не контрибьюч, я просто активный пользователь. А, я понял. Тут вы меня, наверное, закидаете помидорами за следующий вопрос. Но я же правильно помню, что Ирландия – это вот этот вот язык, которым основная концепция, когда все идет асинхронно, и вызов любого метода – асинхронный колл. Ну да. Ну, это не совсем так, короче говоря. То есть, идея языка в том, что писать можно совершенно как бы однопоточный код, который совершенно влобно исполняется, а внутри оно, как это... Оно, короче, делает выясняющую многозадачность. То есть, оно работает как процесс ООС, только они более легковесные. То есть, там не то, чтобы асинхронично прямо на каждом углу, на самом деле. То есть, это не то же самое, что завернуть каждый вызов в футуру. Совсем не то же самое. Это как раз плотный код, которого не очень много. Он какое-то время будет выполняться плотненьким и всякое асинхроничное. Просто потом, когда виртуальная машина решит, что он долго выполняется, его снимут с шедлера. Если ты впадешь в сеть, то там, на самом деле, сеть немножко так устроена, что у тебя есть... Что вы упростите? Там, на самом деле, терминология виртуальной машины немножко другая. Но, в общем, грубо говоря, у тебя есть процессы, которые тобой написаны. Есть какие-то сущности, которые выглядят как процесс, которые они, грубо говоря, драйвера. И то и другое общается с сообщениями. Вот когда ты отправляешь сообщение, тебя... Не так. Когда ты встаешь в инструкцию ожидания сообщения, тогда тебя тоже снимают с шедлера. И когда ты посылаешь сообщение драйверу, драйвер получает сообщение. Драйвер – это кусок совершенно обычной асинхронной сишки с селектом и вот этим всем. Но прелесть драйвера в том, что, как правило, его написали за тебя. Я понял. Ну и, походу, с узким местом здесь будет шедлер. Ну, даже не то, что узким. Узким местом – это то, что в большинстве случаев интерпретируемый язык. Точнее, не интерпретируемый, а язык с байт-кодом, который не джитится. И есть такая штука high-performance run compiler, которая позволяет перформанс там, где нужно поднять, но с ней как это, caveat supplies. То есть нужно, короче говоря, понимать, что ты делаешь. И одно из главных понимать, что ты делаешь – это не вызывать не хайп-код из хайп-модуля. То есть резко тебе нужно переставать пользоваться, например, стадо-либой, чтобы у тебя под хайпа был преимущество. Если нужно все хайпом собрать, ты, скорее всего, этого не хочешь. Потому что если собрать все с хайпом, там можно нарваться как-то на немножко странное поведение, например, иногда. А собрать только один модуль хайпом – это значит, что тебе нужно переставать пользоваться стадо-либой. В принципе, я это пару раз делал, например, когда нужно парсить какой-то протокол. В Erlang очень удобно устроена работа с binary. То есть мне в Erlang с binary работать удобнее, чем в C. И когда нужно какой-то протокол реализовать, то мне довольно удобно написать это в модулике небольшом и только этот модуль скомпилировать хайпом. И оно, конечно, получается медленнее, чем чисто C, но уже сравнимо с C, скомпилированной без флагов оптимизации. Окей. А можно еще один вопросик? Да. Это штука, в смысле, язык в целом, это чисто функционально или он допускает в некоторых местах нечистые вещи? Допускает. Допускает, хотя бы потому, что посылка сообщений – это не то чтобы чистая вещь. Во-вторых, exception и process dictionary. Plus есть, да, process dictionary. Плюс у тебя на самом деле в любом месте может вызываться C-шный код, который делает вообще все что угодно. Ну, это везде может быть. Ты в самом чистом языке, у тебя где угодно может вызываться чисто C-шный код. Я не знаю ни одного языка, даже с зависимыми типами, где если ты вызываешь C-шечку, ты не вызываешь C-шечку. Ну, смотря какие... То есть в Haskell, если ты не присвоил тип, что это чистая функция, то как бы ты не можешь. Ну, то есть, несмотря как ты обернул... Хочешь сказать, что ты FFI только из IEO можешь вызвать? Мне кажется, ты... Нет, я повторюсь, смотря как ты обернул. Ну, вот как бы да, ну... То есть, грубо говоря, ты даже в очень чистом языке тоже можешь это сделать. Краткий ответ – это не чисто функциональный язык. Но он во многом очень... Он намного функциональнее Scala, например. Ну, тогда сразу же вопрос, у него есть устаканившийся какой-нибудь memory module, который можно полистать или посмотреть, чтобы понять, как он себя ведет, и в каких случаях с расшаренными переменами или расшаренной областью памяти. Есть. Нету там этого просто. То есть, memory module такая, что тебе просто нельзя этого делать. Ага. То есть, там есть одно единственное исключение, которое recountится, но оно... Ну, то есть, во-первых, там все абсолютно иммутабельное, поэтому даже если бы все насквозь шарилось, то у тебя... То есть, у тебя сами объекты иммутабельные. Угу. Но на самом деле у тебя есть один тип объектов, которые шарятся, это binary. Они recountятся, они живут в отдельной куче. И у тебя есть все остальное, у тебя у каждого процесса свой независимый heap со своим независимым garbage collection. Ага.",
    "result": {
      "query": "Erlang R18 нововведения таймеры и мапы"
    }
  }
]