[
  {
    "segment_id": "46126e65-dc66-4cbb-aa2c-ab64fffc6c22",
    "episode_id": "7a769113-8941-4c39-8620-b7ba4b05d27c",
    "episode_number": 96,
    "segment_number": 3,
    "text": "И я не знаю, насколько вот именно это событие произвело впечатление на людей, но если как бы не вдаваться во все подробности, то вот из этих 20-30 человек к моменту моего ухода на скалу перешло двое. Вот. Еще где-то человека три, скажем так, с переменным успехом пробовали, ну, то есть иногда участвовали в каких-то скалопроектах, изъявляли желания, и еще плюс к этому, может быть, было еще человека три, которые просто приходили послушать. И все. Остальные просто, видимо, решили, что им это как бы не нужно, не знаю, не полезно, не знаю. Довольно грустная история в этом плане. И в этом смысле показательно то, что вот ты сказал насчет того, что одна компания решила перейти и в конце концов так и не перешла. Файбер на самом деле недалеко был от подобного исхода, и тут проблема не только в том, что найти людей сложно, тут проблема еще и в том, что для этого нужна как бы воля. То есть нужен от руководителей совершенно четкий месседж, что мы переходим. А в Файбере вот даже на момент моего ухода до сих пор было неясно, они переходят или нет. Подожди, извини, ну вот как бы есть, ну ты говоришь пять скалистов, это пять скалистов считается перешедшими рубистами? Да. Из Data Pipeline или это чисто тот сервис? Ну то есть я знаю, что у вас есть там как бы еще отдельный, как бы прокачивался данных? Да. Значит, сейчас я скажу, на момент моего ухода один скалопрограммист ушел еще до меня, то есть на самом деле это был один из тех двух рубипрограммистов, то есть он был рубипрограммистом сначала в Файбере, он там работал года три, один из самых старых программистов, ну я имею в виду с точки зрения сколько он проработал в этой компании. И остался значит один рубискалопрограммист и еще нанятых новых трое, вот так, то есть даже, ну вот грубо говоря, со мной было пятеро на момент моего ухода. А можешь сказать, что вы конкретно перели? Нет, подожди, я немножко не закончил мысль, извини, что перебиваю. Так вот, ну допустим даже пять программистов всего, это ну как бы пять зарплат программистов каждый месяц и было больше. И то есть компания не знает, хочет ли она переходить и она продолжает как бы, по сути, ну не знаю, пять программистов, но две продуктовых команды, продолжает две продуктовых команды держать на зарплате, если она не уверена, что она хочет перейти, это как? Да, действительно, ты вообще очень правильно описываешь и это действительно вот состояние дел. То есть, во-первых, в Fiber, если взять тот год, чуть больше года, который я там проработал, сменилось практически все техническое руководство. Последний человек ушел, уже когда я ушел, вот он, собственно, еще дорабатывает там один месяц и вот если его включить, то окажется, что из начальников не осталось никого, если сравнивать с тем моментом, то есть с февралем прошлого года. Это уже показатель. И плюс к этому нужно добавить, что из всех этих начальников никто до конца не хотел брать на себя ответственность, что мы вот сейчас возьмем и все переведем на скалы. То есть все мялись, что ну хорошо, давайте попробуем вот это сначала, а потом может быть получится как-то. То есть ни у кого не было до конца какой-то уверенности, что мы вот сейчас начнем вот такой план сначала, а это потом то, потом то, потом то. Все вот как-то хотели попробовать. Но на самом деле фактически они переходят. То есть на момент, опять же, моего ухода уже в продакшене было как минимум два сервиса, прям вот в настоящем честном продакшене два сервиса, написанных на скале. И Data Pipeline, насколько мне известно, он как бы так в продакшене, но как это, фича-флаг, да, то есть конечные пользователи пока еще не видят его, то есть только те, кто захочет потестировать, могут увидеть отчеты, репорты с нового Data Pipeline. Вот такая ситуация. Расскажи, вот такая ситуация с компанией, руководство меняется. У меня вопрос, а компании вообще прибыльные или надо навеститься, их только живет? Я, если честно, цифры не помню, просто меня это не особо интересовало, но да, есть какие-то с этим проблемы. Я просто даже не знаю деталей, я честно говоря, не знаю, можно их открывать или нет, но я и не особо не интересовался и не знаю. Но я точно могу сказать, что проблемы с этим есть, просто потому что были какие-то собрания, на которых нам говорили о сокращении расходов, еще что-то, при этом параллельно они покупают другие компании. Мы все, скажем так, нижний уровень работников, я имею в виду, мы так и не поняли, в чем смысл сокращать расходы здесь, при этом покупая другие компании. Ничего по этому поводу объяснить не могу, видимо, какая-то логика есть, но я ее не понимаю. Возвращаясь к моему вопросу, над каким проектом конкретно ты работал? Я работал над несколькими проектами, но самый большой, последний был это Data Pipeline, то есть Kafka как основной источник данных, в который разные торчащие наружу и внутрь сервисы складывают события. Мы писали сервис, который все это собирает, фильтрует, раскладывает в HDFS, Hadoop, дальше агрегирует и опять же после агрегации раскладывает по каким-то более удобным сториджам и потом обратно собирает для отчетов. Мы выбрали какие-то агрегации, которые… там ситуация следующая, я могу в двух словах объяснить. Данные, большинство данных, большинство событий имеет несколько ключевых полей, часть полей относится к паблишерам, а часть к адвертайзерам. Это два разных взгляда на систему. Давай тогда мы поясним, что такое паблишер и что такое адвертайзеры, потому что не всем понятно. То есть, это речь про рекламу, и в рекламе всегда есть две стороны, те, кто продает, а те, кто покупает рекламу. У нас есть человек, у которого есть приложение, и он хочет это приложение монетизировать, он получается паблишер. И у него есть какой-то плейсмент, куда можно поместить рекламу. Вот в это место адвертайзеры готовы заплатить какую-то сумму, чтобы поместить в это место рекламу. Они являются адвертайзерами, если так кратко. Да, и соответственно, в нашу систему и те, и другие смотрят, и отчеты нужны, и все события. В общем, система, грубо говоря, имеет две стороны, которые чаще всего друг от друга не зависят. В том смысле, что адвертайзерам не нужно ничего знать про паблишеров, и наоборот. Так вот, те данные, которые нужно показывать паблишерам, и те данные, которые нужно показывать адвертайзерам, объемы данных не такие уж большие, но изначальные события, которые содержат всю информацию, события, оно содержит оба среза, и для паблишера, и для адвертайзера. Если взять начальный объем данных, то он гораздо больше, как бы перемножение всех этих показателей. То есть, если, не знаю, у вас, допустим, есть, там, грубо говоря, 100 паблишеров и 100 адвертайзеров, они все друг друга показывают, то начальный объем информации в 100 раз больше, чем любой из паблишеров, либо адвертайзеров по 11, понятно? Потому что оно перемножается все друг на друга. Так вот, те данные, которые нужны только одной стороне, мы решили положить в че-нибудь попроще, поменьше, ну, MySQL, то есть там в Fiber уже был MySQL, и было много, скажем так, специалистов по его оптимизации, то, что они там с ним творили, это вообще черная магия. И поэтому такие вещи мы решили положить в MySQL. А можно про черную магию? Ну, собственно, они просто выжимали из него все до последнего, пока уже просто никак не могли. То есть, там какие-то совершенно дурмашины стояли, там, не знаю, 256 или даже еще больше гигов памяти, там какие-то просто многослойные рейды SSD и так далее, и так далее. То есть, все, что могли выжать из одной машины, на которую можно поставить MySQL, и при этом сам MySQL тоже, они там чуть ли не заказывали консультантов из каких-то соответствующих контор, которые там все тюнили им там по максимуму. То есть, ну, они хотели отказываться до последнего, скажем так. Ну, понятно, что они начинали с Ruby и MySQL, как стартап, и рано или поздно это нужно было на что-то заменять, и они, в общем, упирались до тех пор, пока уже совсем никак не получалось. Вот, собственно, это черная магия. А озвучить цифры, какие в итоге получились, какие цифры получилось достичь путем оптимизации MySQL? Нет, не могу озвучить, потому что я с ним не работал. То есть, это было где-то по другую сторону от того, чем занимались мы. Ты имеешь в виду цифры, как бы объемы данных? Да, да, то есть, что вы максимум выжали из MySQL, просто вот интересно. Не могу назвать, просто не знаю, потому что выжимал не я. То есть, выжимали люди, в основном, рубисты и связанные с MySQL IT-опсы, которые непосредственно его оптимизировали. То есть, там было как минимум два выделенных человека, которые знали все кишки MySQL и выжимали из него максимум. К сожалению, цифры не знаю. А история с MySQL чем закончилась? Вы так и остались с ним, или вы все-таки перешли на что-то другое? Ну, вообще говоря, она, как бы это сказать-то, она с одной стороны до конца не закончилась, с другой стороны стала попроще. Во-первых, потому что есть еще одна база, которую они используют, она называется Exasol. Мы тоже ее используем. Да, проприетарная немецкая колоночная распределенная база данных, сиквельная. Что, не знаю, если я что-то еще пропустил, из ее характеристик можно добавить. И вообще говоря, когда мы начинали наш проект DataPipeline, изначально у нас были, как это сказать, наполеонские планы. То есть, мы хотели вообще отказаться от Exasol. Но чем дальше процесс заходил, тем больше было понятно, что мы бы и рады, но нам никто особо не позволит. Потому что разные отделы настолько прикипели к нему, что просто даже на уровне организации, я имею в виду, что на уровне... Мы не могли их уговорить просто. То есть, выставлять мы не могли, у нас не было такого, как сказать... Опять же, это тот же вопрос отсутствия воли в управлении. То есть, мы никак не могли повлиять на то, что, допустим, там, как это называется, Business Intelligence, BI, что они вот прям прикипели к этому Exasol и совершенно отказывались с него переходить и так далее. А на что вы планировали переходить? Ну, были разные варианты, на самом деле. То есть, ну, не знаю, был вариант, допустим, использовать Impal для отчетов, которые, например, генерируются редко, но долго. То есть, какие-то месячные большие отчеты, например. Им, собственно, скорость не нужна, и можно спокойно зарядить его на ходу в кластере через Impal, или даже там Hive, или Peak, не знаю. Плюс для каких-то более, скажем так, для отчетов, которые требуют, ну, которые хотелось бы получать быстрее, но не такие сложные. Ну, был вариант, допустим, использовать Cassandra со Spark, например. Но, на самом деле, мы далеко туда не зашли. Был еще вариант использовать Druid, но, опять же, тут все-таки все-таки та же самая история. Во-первых, это отсутствие воли, с другой стороны, отсутствие специалистов, которые все это в достаточной мере понимают, чтобы кого-то убедить, что вот да, мы можем это использовать. То есть, нам дали время посмотреть на технологии, мы посмотрели на технологии, представили результат, сказали, вот, нам больше всего, судя по всему, подходит Druid. Начальство сказало, отлично, действительно, больше всего подходит, но мы не будем на него переходить, боимся. А смысл-то от этого всего? То есть, вам дают задачу исследовать рынок и выбрать какое-то решение, вы выбрали, и говорят, нет, мы боимся, не хотим, это как-то дико. Да, вот, к сожалению, это не единственный такой случай был, примерно такая же ситуация была и со скалопроектами. То есть, например, первый проект, который я написал, когда пришел, когда еще был один, мне специально выбрали маленький проект, который можно было портировать с Ruby на скалу и который бы снял довольно большую часть нагрузки. Я, значит, сидел кропотливо, изучал каждую строчку Ruby кода, все переносил, перенес все тесты, все, его проверили, все работает, он до сих пор не запущен в продакшн. И, опять же, это второй пример, и это не последний пример. Тоже странно, но ты переводишь проект с одного языка на другой, а ты прям один к одному его переводил, либо какие-то фичи все-таки внедрялись? Конкретно в этом проекте, про который я говорил, там ничего не нужно было внедрять, это был просто маршрутизатор между несколькими Ruby-приложениями, поскольку у них проблемы с потоками, они все это решают через запуск много, большого количества копий. И был некий маршрутизатор, который все эти копии между собой связывал и распределял между ними задачи. Тогда у меня возникает вопрос, а какова была ценность перехода? То есть какой смысл переходить, если у нас есть решение, программный продукт, который хорошо работает или не совсем хорошо. Но просто мы вложили время, энергию программиста и получили что на выходе? Просто переписанный? Какой смысл? Я так понимаю, что именно этот проект мне дали просто чтобы посмотреть, сравнить цифры. Как пилотный проект, взяли самую простую компоненту, решили переписать, посмотреть. Это же не просто переписать, это же еще нужно установить continuous integration, увидеть как это все в деплойменте. Это же люди, которые вообще к этому не имели отношения, я имею ввиду JVM, деплоймент скалы и так далее. Для них это все совершенно другой мир. И собственно этого так ничего и не было сделано. Я имею ввиду касательно этого проекта. В конце для Data Pipeline и еще одного проекта на скале мы все это дело установили, конечно, и деплоймент, и Мезос прикрутили и так далее. Но все это заняло год практически. От того момента, когда мне дали задание, до того, когда в продакшене действительно полноценно появился скалопроект с деплойментом и так далее, с мониторингом и со всеми остальными вещами, которые сопутствуют переписыванию кода, прошел год. Звучит как-то грустно, а вот ты упомянул, что CI устанавливали, а что вы используете в качестве CI? Ну Jenkins у нас было с какими-то плагинами, собственно лично я его не настраивал. Под конец еще, ну да, собственно CI проходил на Jenkins. А собирали SBT, правильно? Да. Понятно. А вот ты еще упомянул, что у вас был Мезос, а для чего вы его использовали? Значит, на данный момент, по-моему, здесь три компонента, которые написаны на скале, это все веб-сервисы, и они все работают под Мезосом. Потому что удобно, потому что хорошо деплоится, в смысле того, что он автоматически поднимает новую копию, проверяет, что она уже запущена, потом убивает старую, менеджит сам ресурсы и так далее, и так далее. Ну вот оказалось это удобнее всего. Опять же, я напрямую этим вопросом не занимался, почему именно Мезос. Но я когда попользовался, им мне понравилось. А кто его поддерживал? У вас опсы какие-то были? Да, опсы какие-то были. С ними, конечно, тоже отдельная история. По-моему, из опсов сменились все за этот год. И даже, мне кажется, их стало меньше. Это прям большая головная боль была, эти опсы. То есть, с одной стороны, они хотели как бы разграничить обязанности, не давали нам напрямую доступ к серверам и так далее, чтобы этим занимались по возможности как можно больше эти опсы, отвечали за все это. С другой стороны, это всегда был bottleneck. То есть, вечно были проблемы, все время нужно кого-то ждать, кого-то просить и так далее, и так далее, и так далее. Ну вот, да, Мезос, по крайней мере, им удалось внедрить, и то хорошо. А у вас не было желания как-то избежать вот этих расходов и попытаться самим это делать, чтобы перейти к этому великому движению DevOps? Конечно, конечно было желание, и конечно мы это предлагали. Но вот, я говорю, как-то не доходил сигнал, не знаю. Там явно есть какие-то были, по крайней мере, организационные проблемы, поскольку просто сам факт того, что все начальство полностью сменилось, это уже говорит о том, что проблемы явно были. То есть, либо они сами ушли, либо их ушли, и то, и другое означает, что проблемы были. То, что там есть сейчас, я не могу сказать. Мне кажется, что какая-то тенденция на выпрямление всего этого процесса, она появилась под конец. Посмотрим, что будет дальше. Но еще действительно было очень тяжело, собственно, я поэтому и ушел, потому что довести код до продакшена, это подвиг просто был какой-то. А вот какие, вот, можно назвать какие-нибудь большие проблемы, с которыми вы столкнулись при работе с Мезосом? Либо, в принципе, все было хорошо? Может быть, мы просто недостаточно, скажем так, серьезно им пользовались, но у нас, я, по крайней мере, не в курсе каких-то серьезных проблем. Наоборот, все радовались и говорили, что вот оно, счастье, по крайней мере, по сравнению с тем, что было до этого. До этого были какие-то руби-скрипты, что там, капистраны, еще что-то, я не помню, как они называются. И где все это делалось более-менее в ручном режиме, вот эти все перезапуски, то есть там просто люди приходили и по очереди перезапускали сервера. Перезапустили один, вроде работает, давайте теперь остальные перезапустим и так далее. То есть все это происходило в ручном режиме, а с Мезосом было очень удобно. То есть просто выкатываешь новую версию, он все за тебя делает и ты спокоен, ты знаешь, что он уже проверил, что если со старой на новую переключилась, значит новая уже точно отвечает. И по крайней мере до какой-то степени, по крайней мере она стартовала, и это уже хорошо. Вот ты еще пришел, даже еще до пришел, упомянул, что у вас использовался или вы планируете использовать стэк от Confluent. Да. Можешь рассказать подробнее про эту историю? Да. Это на самом деле было довольно эпичное, как сказать, изменение вообще. То есть они, когда я пришел туда в феврале прошлого года, Kafka уже была. Значит, тут был только Ruby-код, который писал в Kafka и читал из Kafka, и сообщения были в Message Packet. Это формат, который очень популярен среди рубистов, я так понимаю. И как раз примерно тогда же встал вопрос о схемах, потому что чем дальше, тем очевиднее становилось, что без схем каких-то четких, которые где-то лежат и которые можно всегда проверить, и они валидируются, да и обратно, все это очень быстро съедет. Потому что работают не два человека над всей системой, и, ну понятно, я не знаю, довольно очевидная вещь, я имею в виду, что любой человек, который меняет схему, он легко рушит всю систему, потому что где-то что-то перестает понимать. Ну, поэтому, ну, прошу прощения, что перебиваю, на самом деле у нас тоже была похожая проблема, и это решалось так, что мы хранили все в протобафе и добавляли поля только опциональные, вот примерно так, то есть изменения, которые ничего не рушат, и за счет этого оно кое-как держалось. Но проблема была в принципе всем очевидна, и в итоге у нас был со студентами проект, в котором мы сделали репозиторий схем, и по сути это было решением, это был наш такой внутренний проект, ни какой-то не внешний, мы не использовали никакую стороннюю библиотеку, либо сервис для этого. Вот, да, примерно как бы в эту же сторону началось движение тогда, и ну просто я почитал, что люди используют вместе с Kafka, и вот как раз примерно тогда же по-моему появился этот конфлюент, это компания, которую основали создатели Kafka, они вышли из линкедина и решили сосредоточиться на том, чтобы работать с Kafka и с инфраструктурой вокруг Kafka. И первая же вещь, которую они прикрутили, был как раз схема режисса, то есть тот самый репозиторий схем и все, что можно с ним интегрировать. Значит формат… ой, у меня вылетело голову, сейчас я вспомню. Авра. Авра, действительно, да. Авра. Значит там все в Авра, и опять же, вот допустим обсуждение о том, использовать или продолжать, или использовать со схемами, то есть первая мысль, которая возникла в Piber, что да, схемы нужны, мы начали над ними работать, именно формулировать вообще, вот да, такое событие у него должно быть. Там должны быть какие-то поля, тем более еще к тому времени многие события еще не были добавлены в Kafka, а обменивались просто напрямую между компонентами через какие-то просто локальные очереди. То есть все это дело начали формулировать, работать, выяснять, какие поля нужны, какие не нужны и так далее, какого типа, и тогда же встал вопрос, а переходить на Авра или нет, потому что вот есть оно решение, схема режиссера, контуент, все это интегрировано, все готово, тем более в свете перехода на скалу это вообще замечательно, потому что там все уже как бы на JVM и на скале написано, бери, используй, ничего писать не надо. В общем, это было довольно тяжело, обсуждение было долгое, упорно, не хотели переходить, первый раз, когда это было предложено, вообще чуть ли не смеялись, типа, да куда нам там, это же для нас вообще не подъемно и так далее. В общем, в конце концов перешли и на самом деле довольно хорошо все получилось, по крайней мере, если сравнивать со всеми остальными изменениями, которые происходили в Fiber, это все было всегда очень тяжело и иногда казалось, что просто нереально что-то изменить. Вот эту штуку мы все-таки смогли внедрить и она на самом деле довольно быстро, скажем так, себя окупила, потому что стало заметно меньше проблем со схемами, то есть люди, которые что-то меняли, получали сразу же фидбэк еще до того, как они сломают продакшен. До этого замечали все обычно на продакшене или близко к нему, когда что-то вдруг внезапно оказывалось сломано, ну, либо там, не знаю, может быть чуть раньше, в интегрейшн-тестах, если повезет, если они были там и так далее. Дальше, после схемы Registry в новой версии появился Kafka Connect, который вообще замечательная полза для перекачивания данных из Kafka и в Kafka из других источников. Он как раз, мы его планировали использовать в новом Data Pipeline и насколько я понимаю, сейчас он, как я уже сказал, в таком Feature Flag Production. И надо сказать, что это была одна из самых приятных фич, которые именно от Confluent Platform мы получили, потому что мы пробовали до этого несколько разных решений для Data Ingestion, это называется, то есть всасывание данных из Kafka куда-то в какое-то, допустим, в HDFS. То есть мы смотрели Fume, мы смотрели Camu, это тоже от LinkedIn решение. И кажется было, что... А, еще на SparkStream пробовали это сделать просто вручную, то есть у SparkStream есть довольно хороший коннектор Kafka. И мы пытались вручную читать данные через SparkStream и писать их, опять же, из SparkStream в HDFS своими силами. Из всего этого Kafka Connect оказался наиболее таким безболезненным и удачным решением, и на данный момент он работает. Ну и дальше, я смотрел в последней версии еще какие-то Kafka Streams они придумали. В общем, в целом выглядит очень вкусно на самом деле вся эта их система и, по крайней мере, то, что мы успели внедрить, себя оправдало, по крайней мере, даже с учетом того, что в Fiber и все это дело очень тяжело давалось нам. Какие-то еще пояснения по поводу Confluent? Я думаю, по поводу Confluent у меня вопросов больше нет. У меня вопрос еще остался, прежде чем предыдущая история, когда мы говорили про проблемы с каллой и доступом к SQL базам данных. Вот, по поводу приведения типов. А насколько ты считаешь, что это большая проблема? Ну, приводим типы, ну и что такого? Очень хороший вопрос на самом деле. Одна из моих любимых тем. Секунду, Танек, можно я тебе вопрос задам? Конечно. Свет, ты на рубль писала? Совсем-совсем чуть-чуть. Ты пользовалась что-нибудь вроде DataMapper или ActiveRecord? Нет, нет, нет. Вот в этом и дело, что оно настолько сильно... То есть, я ненавижу ActiveRecord всеми швабрами души за то, что у него куча технологических проблем, но это не вопрос того, что мы сейчас обсуждаем. То есть, просто технически ActiveRecord берешь, работает. Ты не приводишь типов вообще, то есть ты головой не думаешь. Это значит, что ты такой аргумент, который я бы поспорил. Ты додумаешь головой о продукте. Ну, там потом у тебя будут проблемы с производительностью и прочая фигня, но при написании кода ты думаешь о продукте, а не о том, как тебя побороть базово. Ты понимаешь, в чем дело? Я постоянно думаю о производительности. Вот опять же, возможно, это у меня особенности были проекта, и мне нужно было постоянно об этом думать. Постоянно думать, а что у меня с потоками, а что у меня с актерами, а как это будет работать на продагне. Я все об этом думаю. Я думаю. Не какие-то девопсы, которые будут что-то деплорить. Я об этом думаю. Это моя головная боль. Нет, ну смотри, у многих рубистов, я не знаю, из того, что я видел, мейнсет такой, что мы сейчас сделаем приложение, и оно будет решать бизнес-задачу. А с производительностью там обычно потом ее докручивают. И там почти весь стек построен вокруг того, что потом докостыряем. В принципе, есть другие хорошие подходы. Я очень люблю здесь хорошо отзываться проекта, который лексировский. Он тоже. Он уже очень грамотный в плане построения своего. В принципе, Олег, если не видел, можешь, наверное, сравнить его. Он в чем-то сравнен с Ликом, но намного удобнее. Что для меня странно, при, казалось бы, меньшем размере лексир-сообщества он развился за эти годы гораздо больше, чем с Ликом. И в то же время он тоже очень простой в использовании. А теперь об этом слова Олегу. Да, значит, я вернусь к тому, что тема на самом деле очень интересная, и про нее много всего можно сказать. И, как бы это сказать-то, даже сам Адерский, грубо говоря, автор скалы, озабочен этим вопросом. Я сейчас объясню как. Во-первых, по насчет производительности я хочу сразу сказать, что я согласен, что, по крайней мере, может быть, это связано с тем, что большинство опытных скалопрограммистов приходят с Java, из JVM. То есть, у меня тоже есть такое ощущение, что когда я пишу код, я думаю о том, сколько я наавансирую памяти, насколько я гербеш-коллектор нагружу и так далее, и так далее, и так далее. Это один вопрос, я про это не говорю. Хотя это тоже относится. То есть, если взять тот же Слик, допустим, и посмотреть на какие он ворочает горы всяких лишних объектов, это сразу больно становится глазам. Но самое интересное здесь вот в чем. Дело в том, что программируя на скале, очень быстро привыкаешь к хорошей типизации. Это вот просто такая зараза, которую потом она жить мешает очень сильно. Ну, как бы я в переносном смысле говорю. То есть, с одной стороны, это к хорошему привыкаешь, наверное, правильно сказать. И потом, просто работать с чем-то, что не типизировано, оно просто вызывает какое-то отторжение. Я, по крайней мере, говорю про себя лично, но если исходить из того, что я обсуждал с другими скалопрограммистами, я думаю, что это довольно распространенное явление. Когда ты привыкаешь писать на скале с хорошей типизацией, удобной, сильной, выразительной, то вещи типа акторов, которые не типизированы, вещи типа доступа к базе и прочее, которые типизируются, но с определенными сложностями, они все вот прям режут, не знаю, что там, глаз, мозг, сердце, что-то режут. И, например, не говоря уже о простейшем приведении типов, одна из задач, которая очень быстро встает, это, допустим, если ты хочешь выбрать, скажем, у тебя описана таблица неким образом, если ты хочешь выбрать только определенные колонки из этой таблицы, и как связать вот тот запрос, то выражение в языке, которое формулирует запрос с результатом выдачи, то есть какой оптимальный тип должен быть у выдачи. То есть хочется, например, иметь не просто там тапл, допустим, по типам, да, хочется иметь что-то типа H-листа, допустим, из шейплиса, да, то есть какую-то структуру, к которой ты можешь обращаться по именам, ну или кейс-класса, допустим, но проблема с кейс-классами в чем, что кейс-классы они стабильные, ты не можешь сказать, а дайте мне вот там из 10 полей 3 из кейс-класса, чтобы они были также поименованы и имели те же самые типы. Вот это еще одна проблема, которая очень быстро встает, если ты довольно много работаешь с базами данных, ну, типизированным с этим, я не знаю, насчет других языков, но в скале, по крайней мере, я с этим сталкивался, не знаю, десятки раз просто, и каждый раз подход был какой-то отход, скажем так, да, то есть кто во что гаразд, то есть либо какая-то библиотека, которая уже была в проекте, либо вообще самописные решения. То есть до сих пор нет какого-то внятного хорошего решения, и проблема на самом деле очень простая, проблема в том, что выразительность типов скаловских, она конкретно для этой задачи не подходит, и ее на самом деле собираются решать в будущем, то есть Адерский хочет прикрутить х-листы, рекорды и сделать между ними как бы правильную, так сказать, интегрировать их правильно, чтобы они легко были связаны. Легко друг с другом перемешивались, и вот тогда оно будет решено красиво и правильно, вот тогда слик станет тем, чем он должен быть. Подожди, если в языке будут х-листы встроенные, как ты после этого скал программистов нанимаешь, где их вообще брать после этого? Да ладно, ну, х-листы, это на самом деле... Ну, правильно Валера говорит. Ну, я набрасываю. На самом деле, просто вот смотрите, ребята, нам нужно сделать запрос к базе данных, обычный SQL, а мы здесь городим вот такие вот просто... Вот мы идем не прямым путем, но вот очень-очень окольным, чтобы решить простую задачу. Согласен. Вот просто я не понимаю, зачем это нужно делать, я вот убейте меня, я не понимаю. Я пыталась пользоваться сликом, и какое отторжение он у меня вызывал. И вот ты пытаешься, ты знаешь, как это сделать в SQL запросе, ты бы это за три минуты написал и сделал бы, уже дебажил, и всё бы оно работало, и написал бы эти преобразования типов, будь они несчастны, неладны. Но ты страдаешь и пытаешься выразить то, что ты хочешь в SQL с помощью DSL, который есть в слике, и страдаешь, и потом это пытаешься поддерживать и отлаживать. Это просто ад какой-то. Я правда не понимаю, зачем это нужно, и почему идут таким сложным путем. Простите, у меня просто такая личная боль была. Всё верно, всё верно. И слик, я никому не советую пользоваться сликом, не надо им пользоваться. Это, как это сказать, это абоминация, чудовище. Они на самом деле в TypeScape, они много таких делают, это отдельная тема, мы можем к этому вернуться. Они очень любят заниматься подобным. То есть сама идея, которую они хотели реализовать в слике, она хорошая и интересная. Но, во-первых... Да, извини, что перебиваю, и снова реклама ECTO. В ECTO сделали правильно. Хоть и немножко, т.е. Erlang он такой, так себе типизированный, но в принципе, я думаю, мне удалось бы типизировать им. Но это вот работающий слик, в общем. Да, собственно, откуда вдохновение-то они брали? Это же, как он, LIMQ, да, называется? Как правильно произносить из .NET. Я, на самом деле, отношусь с большим уважением ко всем этим майкрософтовским изобретениям, но я, к сожалению, в них плохо разбираюсь. И, насколько я понимаю, там все довольно красиво сделано. Но оно сделано на уровне языка, а здесь оно сделано средством языка. То есть, сам язык для этого не меняли, это библиотека просто. Так вот, я вернусь немножко к боли при использовании слика. Во-первых, слик плохая библиотека. Ну, т.е. просто, не вдаваясь в подробности, любой, кто ей пользовался, я думаю, со мной согласится. Просто потому, что там boilerplate'а уже одного просто объема вкода настолько много, что уже от этого больно становится. Особенно, если ты привык к скале, если ты привык еще выражать как-то кратко и выразительно. Это первое. Второе, просто проблема с тем, что не хватает средств выражения языка. То есть, вот эти все притянутые за уши шейплисы, члесты и прочие извращения, это все от того, что на самом деле средств не хватает, а хотят любой ценой решить эту проблему. И действительно, того не стоит. Но, эту проблему можно в принципе решить красиво и типизированно. Я думаю, что однажды она в скале будет решена красиво и типизированно, когда, вот собственно, h-листы объединят с туплами, с кейс-классами и с рекордами. Это все правильно, это все нужно давно было сделать. Я вручную, например, все это делал не один раз. Начинал когда-то с рефлекшена, еще джавовского рефлекшена лет 5 назад, когда в скале нормального рефлекшена не было. Потом пробовал с каловским рефлекшеном делать, потом с макросами скаловскими пробовал делать, потом шейплис дописывал. И ничто из этого меня в конце концов не доставило удовольствия. Я говорю, на самом деле причина очень простая. Когда привыкаешь писать на скале с ее типами, с типизацией, с выразительностью, то пользоваться вещами, которые не интегрируются в этот стиль, с которыми ты не можешь использовать эту выразительность, становится очень неприятно. И эти проблемы решаемы. Я думаю, что однажды они будут решены. А я пользуюсь библиотекой Scala и GDBC. Эта библиотечка очень маленькая, она не заставляет вас делать что-то такое дикое. И вы, нужно написать SQL, пожалуйста, пишите. Хотите использовать какой-то DSL, пожалуйста. Я очень ее рекомендую, и эта библиотечка мне очень нравится. Не знаю, ты ее использовал? Ссылку в шоу-ноты. Я добавлю. Да, я не использовал ее в продакшене, но я смотрел ее. Это как раз одно из тех решений, которые, скажем так, сбалансированы, которые дают достаточно неплохую типизацию без вот этих извращений и сликов. Вот как раз именно так это и нужно решать на сегодняшний день. Собственно, вот допустим, последний раз, когда я тут где-то сколько там, 3 недели успел поработать еще в одной конторе, с Scala программистом тоже в мае, вот первые 3 недели мая. И там мы как раз использовали нечто самописное, очень похожее на Scala и GDBC. То есть это как раз оптимальный подход, когда, как бы, как сказать, смиряешься с тем, что типизация вот только досюда, но не дальше, но при этом и нет никаких, скажем, наворотов, нет никаких лишних проблем с перформансом и так далее, и так далее. Это как некая золотая середина на данный момент. Но, конечно, она все равно оставляет желание, что однажды, однажды мы сможем это довести до конца. А вот тоже мне вопрос по поводу, вот ты упомянул Shapeless. Вообще, какое твое отношение к Shapeless и Scalazi в целом? Ну это можно, как сказать, мы сейчас начинаем целую большую тему, я не знаю, мы готовы к этому или нет. Давай мы тогда бампнем заодно тему, и там про функциональное программирование, заодно потычем палочкой Ваню. Ну да, давайте попробуем. У меня есть, допустим, в Fiber тоже, естественно, этот вопрос всегда задавали, его задавали и кандидаты, которые приходили к нам на собеседование, и Ruby программисты, и все, все, все. В общем, этот вопрос, конечно, мучает всех. Что там с Shapeless, Scalazi, чисто функциональным программированием и прочим. У меня вопрос, как бы за последние, не знаю, несколько лет, особо не изменился, точнее ответ. Ответ такой, если вам нужно настоящее чистое функциональное программирование, не надо мучить себя Scala, берите сразу Haskell и программируйте на нем. Потому что Scala на данный момент не готова к хорошему, красивому, настоящему, чистому функциональному программированию. Это не значит, что она плохая, в ней достаточно много всего, чтобы получить удовольствие. Но пытаться сделать из нее Haskell, это как бы путь боли. Если кому-то нравится, ради бога. Но, опять же, это все, конечно, как сказать, обобщение, которое, конечно, скрывает многие детали. А детали, например, могут быть такие, что в каких-то конкретных проектах, в каких-то конкретных задачах можно использовать какие-то конкретные фичи из Shapeless, Scalazi, Haskell и так далее. В общем, как это сейчас, Type Level, там целая организация по-натуральному. И я извиняюсь перед всеми, как это сказать, последователями. Ничего плохого я про вас сказать не хочу. Ради бога, каждый занимается тем, что ему нравится. Но в продакшене, по крайней мере, заниматься настоящим, чистым, функциональным программированием на Scala, это, по-моему, означает только одно. Либо боссы доверились какому-то программисту, который просто чисто для себя получал удовольствие от всего этого, и они ему доверили, что ну вот давай, делай теперь все, как ты умеешь. Скорее всего, причем они повелись на обещание надежности, потому что я не знаю, что еще можно получить такого с точки зрения бизнеса от чистого, функционального программира. Либо, я думаю, что более распространена вторая причина, это просто они хотят привлечь талантливых специалистов, которые тянутся к этим высотам чистого, функционального программирования. И на самом деле, я думаю, что это работает. По крайней мере, если я читаю Twitter, там всякие ребята из Scala community, они вот так или иначе сгущаются вокруг каких-то контор, которые набирают именно, ну вот сидят и используют Scala Z в продакшене, например. То есть это возможно. Но допустим, в том же Fiber, я сразу говорил, нам Scala Z здесь не нужен. Просто, ну, я не знаю, на самом деле, это довольно очевидно. То есть используя Scala Z, ты очень сильно, как это сказать, сужаешь выбор кандидатов, которые к тебе могут прийти. То есть это уже совершенно другая история. То есть чем пользоваться обычной, скажем так, ну, грубо говоря, не знаю, стандартной Scala без Scala Z, чем-то таким ближе к Java, грубо говоря. Это совершенно другая история. Совершенно другие люди, другие принципы и так далее. То есть это нужно быть, допустим, тот же Fiber, мы бы вообще не набрали людей. Я думаю, что за год, может быть, пара человек бы пришла, если бы нам сильно повезло, которые реально, по-настоящему пользовались бы Scala Z, а не просто, ну как это сказать, для понтов. Или не знаю. Да, то есть я на самом деле с тобой здесь полностью согласна. Это вот особенности Scala-овского сообщества. Я вот буквально недавно это на митапе обсуждала. Вот Scala-овское сообщество, оно состоит из двух частей. Первая часть — это те люди, которые пришли из Java и пытаются использовать Scala как лучшую Java. И вторая часть сообщества — это люди, которые пришли из FP. Не знаю, не из Haskell, либо еще из какого-то другого языка. И они пытаются сделать Scala чисто функциональный язык программирования. И это ужасно. Просто понимаешь, мы решаем задачи какой-то бизнеса своим языком программирования. И нам бизнес дает деньги, чтобы это делать. А когда мы начинаем просто делать FP ради FP и без какой-то привязки, я не понимаю, зачем это нужно. И оно очень сильно усложняет код. И когда возникает какая-то проблема в продакшене, и вам звонят в три часа ночи и говорят, давайте разбирайтесь. Я хочу, чтобы, если я там не могу ответить, например, чтобы вы могли позвонить любому человеку из команды. И человек из команды мог это решить быстро, легко. И не обращаться к гуру FP, который знает досконально, как это было использовано со Scalazia и Shapeless, как оно переплетено. Оно должно быть понятное, простое решение. Все же сильно зависит от команды. Ваня, как ты проснулся? Если у тебя в команде гуру, специалисты функционального программирования, они все это понимают. Зато записано коротко и ошибок меньше. Ну, кстати, у меня со Scalazia, конкретно со Scalazia, проблема не столько в том, чтобы это использовать, сколько в том, чтобы залезть внутрь библиотеки. Если я не могу залезть внутрь библиотеки, меня такая библиотека отталкивает. Хотя мне хотелось бы писать код со Scalazia. Нет, ну, я считаю, что, как было уже сказано, для бизнеса это просто сомнительный подход. Для своего удовольствия, ради бога. Я говорю, что когда я рассказывал, что я дописывал Shapeless, когда в Shapeless еще не было рекордов, мне очень хотелось для себя, чисто для своего личного удовольствия написать рекорды. Чтобы я мог написать SQL-запрос и получить из него HList, в котором были бы по именам, лежали мои поля с правильными типами. Вот просто ради удовольствия. Да, это можно использовать. Но в продакшене действительно зависит от команды. Если вам удалось каким-то совершенно невообразимым образом набрать команду из хороших программистов, чисто функциональных программистов на Scalazia, ради бога. Точно так же можно им позвонить ночью, они все починят. Но, я не знаю, это, по-моему, очень сложно и это просто хрупко, на самом деле. Да, это очень рискованно, потому что если у тебя из команды кто-то уйдет, тебе нужно тоже найти такого же человека, который будет состоянием осилить. Ну или научить. Учить сложно, это непросто. А это везде сложно? Не обязательно только в Scal? Нет, я имею в виду чисто функциональное программирование, все эти теории категории, монады, там монады лад. Теория категории и монады не нужны. Для функционального программирования тебе нужно просто немножко мозг сдвинуть. Для Scalazia? Для Scalazia нужна теория категории. Тебе нужна, да, для Scalazia. Просто исходник, и открой, почитай, там все прям так и написано.",
    "result": {
      "query": "Fiber переход на Scala проблемы руководства"
    }
  }
]