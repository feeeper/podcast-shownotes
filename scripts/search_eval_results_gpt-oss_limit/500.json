[
  {
    "segment_id": "8a5b374a-29d7-4e0c-8d1a-1690991e8145",
    "episode_id": "3a0d971b-397f-4d5f-aa34-814f24292436",
    "episode_number": 500,
    "segment_number": 6,
    "text": "Вот. В браузере тоже также, но это как бы немножко по-разному. Могут отличаться ключи и что-нибудь такое. То есть перенести SQLite базу с сервера на фронт так не получится, наверное. Ну это кажется нормально. Я просто не очень понял. Ты сказал, что какое-то лучшее распределение задач или что там поменялось? Можешь еще раз? Более эффективно, в JavaScript же есть асинхронность стековых залов у нас же есть синхронность. Вот, и мы когда вызываем один метод, второй метод, третий метод и так далее. И здесь просто улучшили, чтобы когда мы вызываем эти методы, и в этих методах мы что-то кладем в Local Store, чтобы мы их как бы, как я понимаю, клали более эффективно. Здесь я не до конца могу вот тоже знать, потому что, честно, сам не пользовался этой штукой. Я думаю, что кто-то пользовался, знает. Обычно на Node все приложения, то есть обычно, что с моей практики тоже видел, это, собственно, берется постгресс любимый. Мейскюль, кстати, реже видел. Вот именно pastgress и уже как нормально через специальный oram туда кладется дата. Вот и никаких там вот этих локал стореджей и тому подобных хранилок нет. Берется обычный редис и тому подобное. То есть берется скорее не нодовские штуки, но это сделано для кого-то. Наверняка это достаточно удобная штука. Я легко себе могу представить какие-нибудь, знаешь, там небольшие командные утилитки, которые ты не хочешь на них воскрес таскать, но хочешь там не знаю какие-нибудь состояния или конфиги, или еще нибудь такое хранить. Это может быть удобно, да? Да-да-да, для этого в основном мы наверняка используем. Еще один API, который на самом деле достаточно спорный, что его выкинули из библиотеки и сделали просто глобальным. Это URL паттерн. Вот теперь можно очень круто обрабатывать URL. Не во всех языках это есть. В Node. JS24 это заедет. И достаточно интересная фича, потому что позволяет, собственно говоря, сама по себе позволяет вам точно определить, как бы точно вытащить из rol точные данные. Очень удобно. В других языках для этого нужно писать свои обертки, насколько я там встречался. Дальше пермишины. В Node. Js наконец-то заезжают пермишины. Вот этой фичи на самом деле все долго ждали, потому что, наверное, Дино, например, есть аналог NodeGS это Дино. Дино выстрелил на том, что они добавили permission модель, потому что людям не очень комфортно, когда ты можешь запустить свой JavaScript файл, и он внезапно может заразить твою систему. Такое было. Извини, а можешь пояснить, что имеется в виду под permission, как это работает? Node. Js. По умолчанию, насколько я еще понимаю, она все еще будет запускать его с доступом ко всей системе. Но как это раньше работало? У нас скрипт запускался с доступом ко всей системе. То есть если ты запускаешь ноды и .script, то все, твоя система вся просвещена. Она не запущена в SandBox. То есть, этот скрипт имеет полный доступ ко всем ресурсам. Он может положить вирус, запустить вирус, положить. Понятно, что до прав рута, но условно до прав рута тоже можно дело натворить, данные спереть, например. Так вот абсолютно делали не один раз, это было десятки раз. И теперь у нас появляется возможность указать, что, пожалуйста, не ходи в интернет скрипты, пожалуйста, не ходи в файлы и так далее. Ну хорошо представим представим себе что я допустим пишу допустим замену npm а поскольку он медленно я пишу новую быструю замену и я зловред. Вот поскольку это npm, мне значит надо ходить в интернет, чтобы скачать пакеты. И мне нужно ходить на файловую систему, чтобы их сохранить локально. Соответственно, я прошу вот эти два permission, мне их дают. После этого я беру и шифрую всю файловую систему и требую денег за это. Как это решает проблему? Ну, с одной стороны, да, я с тобой согласен. У Дины, например, есть такая фича, что ты как бы подтверждаешь: Да, я точно уверен, да, я точно уверен, что я запускаю правильное приложение. В NodeJes такого еще нет, но, так скажем, наверняка они это добавят. Это помогает, ну, отчасти, безопасникам. То есть теперь они хотя бы могут что-то делать. То есть они раньше не могли вообще ничего делать с такими скриптами, а теперь хотя бы могут. Вот и хотя бы могут по рукам настучать перед тем как запускать. То есть ну такая история. Ну в целом, в целом, наверное, я думаю, что это направление благородное, но кажется, что нужно какие-то более гранулярные разрешения, то там доступ к определённой части файловой системы. Не всей что-то такое придумывается. С одной стороны да, но с другой стороны опять же эта фича есть в Dino. Насколько я понимаю, в NodeJS надо поподробнее про это почитать еще. Но насколько я понимаю, что в NodeJS тоже это есть. Чтобы вот именно часть файловой системы такое, я думаю, что есть. Например, чтобы он не выходил из папки проект. Полезно. На самом деле знаешь, что мне это напоминает? Это в давние времена у Java была идея, что значит на Java надо веб-приложение описать и у них были Java-аплеты. Но поскольку Java-аплеты были построены поверх уже существующей Java-машины, они тоже попытались сделать эту коробку. В итоге получилось, что несмотря на их титанические усилия за sandbox и java и заблокировать все небезопасные API, хитрые хакеры они все время находили хоть какой-нибудь API, который позволял Applat сбежать из и из sandbox и начать делать плохие вещи в системе и в итоге кажется уже оракол похоронил идею веб аплетов потому что ну просто не получалось сделать это безопасно и никто не хотел с этим иметь дело вот надеюсь что нод джес им будет лучше с этой ситуации потому что ну слушай кажется что сложная проблема джаво скрипт в браузере как будто бы существует последние много лет и наверное большая разница получилось за счет того что оракл попытался сразу целиком приложением приезжать на клиентский компьютер и они как бы работали они как бы решали обратную проблему берем полноценную среду и в ней разрешаем все и пытаемся запретить все что было разрешено нормальному приложению, а в случае с браузерным сандбоксом как-то так получается что он развивался видимо невозможно немножко в другом направлении что вначале был javas cap без доступа к странице постепенно постепенно возможности расширялись и насколько понимаю регулярно какие-то проблемы вылезали, но поскольку в каждый момент времени поверхность того что можно было делать была в целом не очень большая ничего особо не взорвала сейчас у нас как бы весь браузер это по большому счету операционка с контейнерами в операционке с контейнерами опять же я насколько понимаю современные браузерные rantime наверняка используют контейнерные механизмы операционной системы. Отчасти, кстати, нет. У них прямо вот прям почему браузер написать свой сложно? Почему у нас вообще на рынке всего пять браузеров, из них два недоделанных? Потому что написать свой браузер это абсолютно непростая инженерная задача. И, в частности, в том, что практически браузер абсолютно все реализует сам, потому что нельзя зависеть от операционной системы, потому что он не знает, на какой операционной системе он будет запускаться. Ну, неправда. Ну, были браузеры, которые были прибиты гвоздями к операционной системе, я согласен. Но больше того, у тебя, знаешь, ты можешь такое утверждение сделать, что нельзя сказать на какой операционной системе по сгрей будет запущен поэтому ни в коем случае нельзя записываться на файловой pi специфичный для файловой системы однако в позгрей есть просто ну некоторое количество не знаю и в депов наверное что если мы закомпилируемся под windows мы используем виндовый API а если мы используем и если компилируемся под Linux linux API если там не знаю под BSD то BSD и API я же там не знаю Для любых продуктов которые работают на многих платформах. У нас есть контейнеры на всех платформах десктопных? Мне кажется теперь уже да. А на телефончиках? Тем более. Я могу сделать приложение для айфона, залить его и залить его в App Store и я могу будет дозвольно использовать контейнеры. Я не уверен, давай так оно любое приложение у тебя уже в контейнере всегда насчет есть ли у него доступ к api операционной системе чтобы сделать дополнительное разделение на контейнеры я не уверен там возможно это примитив немножко по-другому торчит чем непременно контейнеры я очень давно на колес надеюсь не программировал и с тех пор там и я очень сильно убежала вперед Насколько я знаю, в V8, например, для JavaScript, если мы говорим про браузер и запуск JavaScript из браузера, то в V8 используются изоляты. Это специальные такие небольшой runtime, который как раз запускает JavaScript в таком sandbox режиме. Надо про это еще почитать. На самом деле проблема стоит, проблема есть. Особенно эта проблема выстреливает в функциях всяких облачных, AWS, LABDA, GUI, Cloud Functions и так далее, где, собственно говоря, надо как-то изолировать JavaScript-код от всего остального, потому что внезапно могут утечь данные с других скриптов случайно. В целом JavaScript, я думаю, что один из тех языков, у которого с собственно изолированием есть большой прогресс в работе. И второй такой язык это webAssembly. Собственно, webAssembly взял достаточно много из sandbox машин и javascript. ВебAssembly интересен тем, что сам по себе он по сути задизайн как такая герметичная виртуальная машина и единственный способ взаимодействовать с внешним миром для нее это по сути те хуки, которые ты передашь в контекст. Есть еще Васи, которая вроде как позволяет дополнительные какие-то интерфейсы к операционной системе или чему то такому иметь, но это больше типа стандарт коммуникации, чем собственно имментация машины, насколько я понимаю. Кстати в этом релизе ноды заедет 64-разрядные указатели. Теперь Chrome будет иметь возможность есть еще больше памяти. Это правда. Мне кажется, кстати, во мне есть памяти много, в том числе и потому, что есть некоторые слои абстракции, которые они абстрагируют от систем. Ты правильно сказал, что они прокидывают хуки, то есть. Но сами API они все-таки свои. То есть Это даже повеселее, чем JVM. Ну, то есть, казалось бы, можно было взять JVM, так на самом деле и делали. Netscape в свое время взял JVM и адаптировали их под JavaScript, Вот, и получилось как бы в браузере они смогли запускать скрипты. Так что JVM и JavaScript они тоже имеют родственные связи. У них есть там runtime общий, который сейчас заброшен практически никому не нужен. Но все-таки, Поэтому говорить о том, что как бы браузер он все-таки более абстрактный, чем даже JVM, который больше системно зависимых штук. И поэтому, кстати, в браузере, например, в Firefox и Safari нельзя получить доступ к файлам стриминга. То есть ты можешь открыть файл, его загрузить, как бы ты загружаешь его в контекст, а вот прямо чтобы редактировать файл из браузера, ты не можешь. А кроме можешь. В том числе и за перемешку. Поехали дальше. Еще в ноду заезжает TestRunner. Теперь можно почти выкинуть vtest. Jest. Раньше для этого использовались, собственно, эти библиотеки в основном. В основном, кстати, Dash Ad6. Что из такого добавили прямо в этот релиз? Это то, что теперь автоматически все вложенные тесты. То есть если тест в тест вложен как-то хитро, еще и с асинхронными вызовами, собственно, он теперь автоматически завершает. А раньше нужно было ждать, пока он их завершит. Теперь не нужно. Вообще Node Just она достаточно всё-всё оббирает. Её сильно, сильно, так скажем, задрайвили бан, Дино и другие рантаймы и спасибо им большое. Так что надеюсь, что NodeJS продолжит развиваться. Например, мне очень жаль, что в этот LTS релиз не попали отгрузка типов, потому что типы было бы хорошо, если бы можно было без экспериментов strip types использовать типы.",
    "result": {
      "query": "Node.js sandbox permissions JavaScript"
    }
  }
]