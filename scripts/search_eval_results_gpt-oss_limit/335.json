[
  {
    "segment_id": "0ef3693b-5012-48be-affb-46d3d0e73cb8",
    "episode_id": "01cde138-e34e-400b-a839-0bfd4009109b",
    "episode_number": 335,
    "segment_number": 16,
    "text": "используется для тестирования самого GoLong приложения, а потом оттуда автоматически устанавливается на все вот эти вот машины, и похоже, это происходит каждую ночь после перезагрузки, то есть очень сложная система CI-CD, и вот только именно сборка на отдельной машине была скомпрементирована. И второй вопрос, правильно ли я понял, что история умалчивает, как была взломана вот эта Windows машина с виртуальной людьми машины? Да, это тоже есть в вопросах, и он говорит, что у меня есть больше деталей, но расследование все еще ведется, и я надеюсь, открыть детали полегче, так что я надеюсь на вторую серию. Ну вообще, конечно, как бы, наверное, мораль такая, что по возможности, если у вас есть что-то Security-критичное, по возможности, ну типа не собирайте это сами. Ну, во-первых, да, да, Саш, да. Я подозреваю, что им нужно было ядро с какими-то кастомными флагами, ну, то есть это единственная разумная причина, зачем... А я у меня было обратное подозрение, что вот типа, наоборот, хотели сделать безопаснее, уменьшить, короче, всевозможный attack surface, поэтому собирали кастомное, чтобы attack surface был поменьше, а в итоге напоролись на то, что где собирали, там и взломали. Ну давайте мы уточним еще, что вот сервер взломали в двух разных точках, а не на фаст сервер смогли как-то взломать. Я к тому, что я вот когда гляжу на эту систему, которая была здесь описана, я, пожалуй, ни на одной из моих предыдущих компаний не имел такого уровня паранои, ну, то есть MFA на CICD-систему, да вы с ума сошли, вот, а здесь эта параноя была включена и все равно их взломали. Я к тому, что если очень хотят вас взломать, то вас взломают. Ну, потому что взломали, хочу обращать внимание, взломали не там, где было защищено, взломали как раз нашли самое слабое звено и его и взломали. По-моему, все-таки одна точка, то есть я так понял, что взломали хост машину, на которой была виртуальная машина, которую компилировал ядрой и через него, через мэзифисцерное ядро попали на NFS-сервер. Нет, нет, нет, нет, сборка, я так понимаю, что сломали, ты прав, сломали ту систему, где собирают ядро, но это ядро шло через CICD-пайплайн и больше никуда с этой машины попасть нельзя. NFS-сервер это вообще отдельная сущность, ему отдельно давали права на доступ туда. Но я имею в виду, если ты можешь модифицировать ядро на NFS-сервер, ты разве его не взломали? Нет, на NFS-сервере другая установка, вот это ядро, которое собиралось, оно было только на лот-балансерах. Ага, окей, хорошая статья, я ее вкратце полистал, я почитал твой рассказ, очень круто. Вопросы, дополнения? Я бы добавил. Мораль? Да, уважаемые слушатели, если вы думаете, что вы знаете, как защитить от взлома вашу систему, вы ошибаетесь. Пожалуйста, не оградите самостоятельные обороты, огороды, позовите специалистов по безопасности, которые знают, что и как взламывают, позовите внешнюю, я не знаю, какую-нибудь security компанию, которая приведет аудит вашей системы безопасности, проверьте несколько раз, попробуйте под разными углами одно и то же, потому что если вы на самом деле печетесь из своих данных и если кто-то захочет вас ломать, есть очень много векторов атак, которые вы сейчас даже не подскрываете, что присутствуют. Пойдет? Я думаю, что определенно принимается. Перед тем, как перейти к тем слушателям, я хотел бы на секундочку вернуться к пасгрессу, я полистал в фоне вот эти ссылки и хотел дополнить, в чем отличие поведения пасгресса от того, что написано в документации, в документации, опять же в шоунотах вы, надеюсь, это Ready, где все это есть, в документации говорится, что когда вы используете remote apply, то commit будет ждать до тех пор, пока реплик, я сейчас с английского вы меня перевожу, короче, пока не будет закоммичено на реплике. На самом деле это не так происходит, commit происходит на мастере, просто вам о нем не говорят о том, что он произошел до тех пор, пока мастер не получит реплики ответ, но на самом деле commit на мастере происходит всегда. И второй момент, что опять же это все есть в трезвии, сценарий, который не был рассмотрен, что если у вас между мастером и репликой происходит нет сплит, то есть допустим у вас remote apply, у вас в standby names сказано, что вот на такой-то реплике должно примениться, но у вас нет сплит, тогда вы commit транзакцию, у вас мастер повисает, потому что он ждет ответа от реплики, он будет дождется, в этот момент либо вы в P SQL нажимаете ctrl-c, либо ваша клиентская библиотека прибивает сессию по своей логике, и вы получаете, в текущей реализации вы получаете ответ, что транзакция, она применилась, потому что, повторюсь, на мастере она применилась, и проблема в том, что она была закоммичена, и вы предполагаете, что раз она закоммичена, то она применилась и на реплике, а это не так, потому что у вас, повторюсь, нет сплит, и если вдруг по какой-то причине мастер будет перевыбран, опять же вручную или автоматически, транзакция, про которую вы думаете, что она совсем закоммичена, она не будет закоммичена, потому что вы запромоузили реплику, которая про нее никогда не слышала.",
    "result": {
      "query": "CI‑CD безопасность сборки ядра"
    }
  }
]