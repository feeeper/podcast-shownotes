[
  {
    "segment_id": "59f4a381-e64b-49c7-a137-906d23b497b5",
    "episode_id": "220b4480-c968-4329-95a8-5c2917d998a7",
    "episode_number": 155,
    "segment_number": 2,
    "text": "А что можно сделать с этими данными в плане передачи владения этими данными? Ну, это и с одной стороны хорошо, и с другой стороны это и чревато иногда, мы уже обсуждали в одном из подкастов проблему с тем, что в библиотеке неправильно описали правила стерилизуемости или передачи по сети, я уже не помню точно, и это приводило к тому, что у тебя thread, не safe, была программа, если ты использовал эту библиотеку. Ну, то есть это налагает большую ответственность на написателей всех библиотек, в том числе открытых, то есть когда не только ты для себя пишешь, но ты начинаешь использовать чужую библиотеку, ты обязательно должен ее прочитать всю вдоль и поперек, особенно проверить вот эти кусочки типа безопасности, в смысле передачи стерилизуемости. С этим я согласен, хотя по моему личному наблюдению основная проблема, с которой я столкнулся, в том, что когда вот эта часть системы типов определяется в каких-то библиотеках, зачастую она слишком зажатая, то есть некоторые ее требования, которые в некоторых случаях остались либо по умолчанию, либо по недосмотру, где можно было бы разрешить что-то, но это не было разрешено, там, скажем, передача между thread'ами, и вот это меня зачастую задевало. С другой стороны, я особо не видел, чтобы то, как определенные типы, было опасно, хотя я, может, еще не замечал каких-то моментов, но именно в той области, с теми библиотеками, с которыми я работал, я вот в обратном трону замечал. — Когда ты сказал, что у тебя опыт работы всего лишь один год на Rasta, сразу вынавидится анекдот про требования при поиске кандидатов 10-летний опыт работы на Rasta. То есть я считаю, что год на Rasta сейчас это довольно много уже. Я не знаю, вся последняя история Rasta, она у тебя включена в твой опыт. Ну, я имею в виду, после среза первой ветки, после того, как они на стабильность вышли. — Да, я при этом еще и на Nightly сижу постоянно, мне не хватает ни стейбл, ни бейта, поэтому приходится развлекаться отдельными развлечениями. Там вообще, конечно, еще тот зоопарк, но это, с другой стороны, очень интересно. То есть там и новые фичи, и ломается оно время от времени. Так что там еще много различий, о которых можно говорить. — У нас, мы библиотечку пишем внутрь на Rasta, у нас требования, чтобы ты Nightly включал по умолчанию при компиляции библиотечки. — Да, я, например, заметил, у меня еще лежит в PumpkinDB, после какого-то релиза, который вроде уже нашел, performance test на работу PumpkinScript падает, по-моему, где-то в 5 раз. И вот пока до сих пор непонятно, и я пока PumpkinDB держу на Nightly с середины июня, потому что просто все упало, и непонятно, где вообще копать пока. То есть я почитал change log на Nightly build, но пока совершенно непонятно вообще, откуда это все идет. Nightly — это, конечно, еще том винное поле, и надо, конечно, контролировать. То есть просто тесты сами по себе не всю картинку показывают. И я прихожу к выводу сейчас, что нужно на самом деле, если проект на Nightly, то нужно, например, написать какой-то набор бенчмарков, и просто на каждый pull request, и на каждый, особенно, update, какую версию Nightly используем, слать дифф. Насколько помню, там была маленькая утилита, которая позволяет очень легко сравнивать вывод как и бенч. Очень полезно, чтобы сразу увидеть, где изменился бенчмарк. Слушай, ну вот у меня сразу несколько вопросов. Во-первых, мы тут затронули pumpkin db, я хотел бы прийти поподробнее. Во-вторых, а у вас, это же pumpkin db, он open source, я имею в виду, нельзя разве настроить какой-нибудь open source CI, гитхаби, чтобы оно все это делало автоматом? Нет, это все же есть, ну в смысле, там Travis есть, там все стандартно, все open source, конечно. Мы даже не дошли написать именно скриптик, который будет отдельно еще заниматься. Ну, то есть, просто сейчас это скри ручной процесс, то есть я там раз в несколько недель накатываю свежие Nightly и смотрю, что происходит с бенчмарками. И иногда, когда я вижу, что мое изменение достаточно большое, то прогоняю еще раз бенчмарки и смотрю, что происходит, и что было затронуто. То есть даже это когда не смена релиза, или билда точнее, а просто зачастую я заметил, что маленькие даже какие-то изменения могут приводить к серьезным изменениям по перформансу. Это как бы достаточно большая головная боль для меня в рамках Db, потому что понятно, что если пишешь и базу данных, и еще и строгий язык, искусственных замедлений не хочется. Расскажи про базу данных. Подожди, подожди, подожди, подожди, мы сейчас поговорили про Rast, я все-таки хочу немножко отмотать назад. Мы вот сейчас отследили одну цепочку тезерланга через Elixir в Rast, я сейчас хочу все-таки отследить цепочку проектов, там, Spawn Grid, который, ну, видимо, мало кому интересен, потому что он не живет и не полетел. Кстати, было бы интересно послушать, почему не полетел. Потом биткоиновское проект, и потом уже Pumpkin. Подожди, еще про языки программирования. Там была Java, как это было так? Много вопросов сразу. Я начну с какого-нибудь простого тогда, если никто не против. Давай, давай. Java — это в некотором смысле для меня такой fallback инструмент, Java или, скажем, Kotlin, не суть важная, в который можно быстренько прийти, что-нибудь наворотить и что-нибудь сделать. Далеко не всегда любимый инструмент, но когда мне все надоедает, грубо говоря, я возвращаюсь к Java. То есть когда совсем все плохо, то можно какое-то время вернуться, и там, конечно, тоже все плохо, но немножко по-другому плохо просто. То есть Java — это такое вот отдушина от, скажем, вещей, которые... Kotlin Edge, то есть которые все еще в условной бете, это зачастую просто возможность вернуться в большой набор библиотек и в язык, который двигается небыстро. Бкплан. Что-то вроде. По поводу других вопросов. Спонгрид и биткоины и Erlang, Elixir и все вместе. Спонгрид — это была очень старая идея, словно говоря, некий вариант Heroku для Erlang, но с большой спецификой для, собственно, самого Erlang и виртуальной машины. То есть с дайвбордом и с инструментом, который позволяет отслеживать, что происходит внутри HWM и собирать статистику суммарную по всем виртуальным машинам и так далее. То есть это как бы такой, не знаю, не гипервизор, но это способ дипломента Erlang-приложения. Но это не выжило по одной простой причине — у нас не было денег.",
    "result": {
      "query": "перенос владения данными библиотек"
    }
  }
]