[
  {
    "segment_id": "62445e70-f10f-49da-abad-bd1fcea90895",
    "episode_id": "12179b91-7df6-4eec-962d-35dc59c2359a",
    "episode_number": 439,
    "segment_number": 5,
    "text": "Что еще интересного было? Интересный хак они придумали с таймстемпами, потому что вместо того, чтобы просто обнулять все таймстемпы и вместо этого добавили некоторые автоматические таймстемпы релиза версии Go в пакет исходников и теперь они просто при сборке подменяют все таймстемпы именно на этот таймстемп. При сборке компилятора Go они подменяют все таймстемпы именно на этот таймстемп. Еще там была пачка специальных случаев для платформы зависимых нюансов таких как подписи пакета для MacOS поскольку они не могут распространить свой приватный ключ, они написали программу для верификации которая игнорирует ключ подписи. В общем, в чем смысл всего этого? Это что может на удивление, может не на удивление добиться легко повторяемого билда это очень и очень непростая инженерная задача. В связи с чем я хотел бы спросить Ваню что ты думаешь о том, что может быть в случае с компилятором как нашего локального эксперта сталкивался ли он в своей работе с подобной проблемой? Слушай, я именно в компиляторе подобных хаков не делал но я же много занимался и CI и сборкой компиляторов и сборкой вообще не компиляторов и идея повторяемых билдов она часто была нужна в каких-то как-то более или менее строгих окружениях то есть сделать полностью добитую у меня никогда цели наверное и не было но между тем я не ожидал, что это будет сделать так легко для ГО то есть то, что ты пересказал это звучит как логичная вещь с которой бы я начал но у меня такое ощущение, что я бы после этого наткнулся еще на 20 разных причин, почему расходятся версии и я не знаю мне бы казалось, что все будет хорошо но это будет намного сложнее а вообще я бы в целом пытался уйти как можно сильнее от сборок на окружение, которое может отличаться в сторону каких-то преопределенных окружений ну скажем запускать сборку в докере вот этой версии вот с таким уже установленным компилятором, вот с таким установленным временем, вот с такой папкой ну то есть как бы ты выполняешь докер-команду и представляешь, что у тебя точно такой же результат получился как и у тех ребят ну смотри, если у тебя в процессе запуска компилятора чуть-чуть машина лагнула и время на секунду вперед перетикнуло и у тебя таймстемпы поплыли что делать? это понятно, я имею ввиду, что это как бы ты рассказываешь про более генеральный случай я же пытаюсь с помощью докер и окружения, и установки времени и всего свести так, чтобы пришлось решать меньшую задачу, чем пришлось решать им, понимаешь, да? о чем я? я понял, о чем ты я бы начал с этого, а дальше бы уже разбирался один маленький, но очень трудозатратный момент, который я с легкой руки опустил и зря наверное, это что значительная часть работы для команды Go на самом деле было не вот то все, о чем я говорил а то, что им нужно было прошерстить весь компилятор, чтобы его поведение было идеально детерминированным например в Go итерация по мапам происходит в псевдослучайном порядке и поэтому им пришлось отыскать все места в компиляторе где это происходит достать список ключей, отсортировать этот список ключей и итерировать по уже сортированному списку и в таком духе вот отыскать все все все все все источники недетерминированности, например параллелизм, когда вы что-то компилируете или обрабатываете на нескольких ядрах, то раз от раза они могут выполниться немножко разном порядке и вам все равно после этого надо взять и отсортировать это все, чтобы оно каждый раз получалось консистентно мне кажется вот эта часть была намного более трудозатратной чем все остальные мне кажется более сложная часть это после того, как ты все эти места поправил, настроить CI так, чтобы в будущем эти места и новые куски кода это поведение не ломали в смысле тестировать, то что твой компилятор он генерирует повторяемые билды это кстати да, это тоже хороший момент, об этом они тоже пишут они для тестирования они сделали следующее, они подняли два CI один на Linux x86 а второй на Windows x86 и на каждой из этих машин они кросс-компилируют тулчейн для всех поддерживаемых платформ таким образом и после этого они сравнивают, что все вот эти кросс-компилированные тулчейны бит по биту совпадают, и если хоть один из них расходится, то значит билд падает и кто-то идет разбираться почему вот чтобы уточнить, я упустил этот момент ааа это включено верно",
    "result": {
      "query": "Go сборка детерминированных билдов"
    }
  }
]