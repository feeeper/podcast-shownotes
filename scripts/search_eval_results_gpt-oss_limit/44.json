[
  {
    "segment_id": "fa397d46-82cb-4720-a81a-271ba7ff3c9d",
    "episode_id": "ec106bb6-8c89-49ca-91dc-a865e19ffb99",
    "episode_number": 44,
    "segment_number": 7,
    "text": "поддерживать, и кому это пригодится, если мы решим уволиться и уйти в другую компанию. Собственно, они во всем правы, Lisp не нужен. Был такой похожий пример по поводу Clojure, у нас был на моей прошлой работе написан патент на Clojure, и он существовал до тех пор, пока был человек, который это поддерживал. Человек ушел, остался код, и никто туда ничего не коммитил, ничего не изменял, просто он остался, и все. Я хочу дополнить то, что на предыдущей работе был не совсем Lisp, а Haskell. Некоторые считают, что Haskell это очень правильный Lisp. Так что, была на нем написана мной система, я уволился, и ее через пару месяцев просто выкинули и написали с нуля. Потому что никто не будет это поддерживать. И правильность я важна. Там дело на самом деле было не в Haskellе, там дело было в другом. Проблема была, кажется, в ленивости, из-за которой текла память, и никому не было охота понимать, почему из этого течет память. Я и говорю, кто не хочет это поддерживать. Ленивость в головах игроводчика. Почему не разобраться в технологии, которые работают, и просто допилить ее до конца? Ну, там в том-то и проблема была, что она утекала, и не очень работала. Ты знаешь, по поводу технологии легко допилить, это огромная и большая проблема. Уж, понимаешь, я вот сейчас с этим сталкиваюсь, и есть вот кусок, много-много кода на Дотнете, на C-Sharp, и стоит задача либо допиливать его, разбираться с этой инфраструктурой, вникать вот это во все, либо взять, выкинуть это все и переписать. И вопрос, что же будет быстрее? И дайте, пожалуйста, свои оценки. И это вообще странная ситуация, как ты можешь, в принципе, давать какие-то оценки для технологии, инфраструктуры, той, которую ты не знаешь. Вот задача. Разберитесь, вы же программист, разберитесь и допилите там куда-нибудь. А потом возникают всякие странные ситуации, что вот оно почему-то здесь не компилируется, пишет какую-то странную ошибку, интернет смотришь и вообще не понимаешь, куда тут идти, кому бежать, на кого жаловаться. У меня немножко противоположный опыт. Во-первых, у меня, конечно, тоже есть опыт того, что допиливать совсем не хочется, но, с другой стороны, во-первых, есть Евгений, я думаю, не даст мне соврать, в Google, где все строится на основе того, что у нас есть какие-то уже существующие системы, есть Google File System, поверх него построим Bigtable, поверх него построим Spanner, поверх него построим что-нибудь еще, или там с другую стороны пошли, есть Google File System, поверх него построим Mellu, поверх него построим Cloud Dataflow. И мы так тоже в предыдущей компании писать свой собственный React гораздо дольше и затратнее, чем допилить React в нужных местах, а потом к нему приставить свой Stream Processing. — Подожди, мы сейчас говорим не про готовую базу данных, документированную. — Нет, но тоже же допиливали. — Ну, хорошо, окей, допиливали. Но речь была все-таки про язык, на который еще нужно программистов найти и так далее. С другой стороны, извини, я подозреваю, что после твоего ухода там большая проблема найти человека, который с этим разберется. — Ну, во-первых, у нас есть Вася, во-вторых, до моего ухода мы наняли еще человека, я тебе уже, кажется, говорил, что там на React Core завязок не так много, там довольно маленькая соприкосновение с React, в основном в том, что мы отпилили его Read-to-Write Path и поставили более подходящий под наши задачи. Но проблема в том, что не существует Data Storage, который бы имел такой путь записи и чтения, который нужен был бы нам. Ну, там, грубо говоря, путь записи, он кассандровский нас бы более-менее устроил, но на чтение у нас настолько специфичные, как ты же, мои желания настолько специфичные, посвяти меня в них. Вот, короче, вот это все. — Евгений, ты хотел что-то сказать? Мы тебя перебили. — Да, я вот хотел возразить Ване, который сказал на то, что там с ленивостью трудно разбираться, что как же так, надо же разбираться в своей технологии. Мне кажется, что тут это несправедливо, потому что в Haskell нет хороших инструментов для того, чтобы разбираться с ленивостью, и это для меня лично, например, это было бы критическим фактором в том, чтобы не использовать его в продакшене. Я знаю, что в Haskell не существует инструментов, которые мне помогут определить, что пошло не так, если у меня что-то пойдет не так с ленивостью. Вот расскажу еще историю, как мы на прошлом ICFP-контесте писали на Haskell. Значит, все отлично было, только захотелось распараллелить наше вычисление, и у нас в команде был человек, который написал значительную часть, связанную с этим, библиотеке в Haskell. И из-за утечек ленивости и так далее распараллелить наше вычисление мы так и не смогли, несмотря на то, что у нас такой сильный человек был. И никакие инструменты нам ничем в этом не помогли. Касаемо ленивости, я думаю, что если какой-либо функциональный язык и победит, то ленивости в нем не будет. Либо кто-то придумает какие-то революционные инструменты для отладки программ с ленивостью. Я бы сказал так, ленивости по умолчанию в нем не будет. Да, вот, кстати, у меня еще была такая интересная идея. Может быть, можно заиспользовать систему типов для того, чтобы ограничить количество ленивости в программе. Например, может быть, можно аннотировать типы тем, какая нужна глубина стека для того, чтобы вычислить этот терм до weakhead-normal-form. То есть это выглядит как какое-то свойство, которое должно, в принципе, поместиться в систему типов. Я поискал, есть ли какие-нибудь статьи на эту тему, ничего не нашел. Попытался сам что-нибудь придумать и сломал мозг. Но, в общем, идею высказал. Может быть, кто-то еще об этом подумает и что-нибудь придумает. Домашнее задание для наших слушателей к следующему выпуску. Вопрос задает слушатель Олег. У него возникают сложности с процессотой общения. Тут такой довольно длинный комментарий. Но суть в том, что он делает много менеджерской работы и ему иногда трудно общаться с разработчиками. И, честно говоря, тут не особо уточняется суть проблемы. Но да, с некоторыми разработчиками общаться с людьми сложно. Общаться... Что тут сказать? Честно говоря, у меня, к сожалению, нет готового ответа для товарища Олегу. Могу сказать, что если есть возможность не общаться, то лучше не общаться. То есть вообще хорошая привычка не говорить, если нечего сказать. Когда приходится, то можно по разам это решить. Может быть, письмо попробовать написать, если человек помог. Нет разработчика, нет проблем. Ну, еще есть такая классическая практика. Это, не знаю, устраивать team event, выезжать куда-нибудь на шашлычки и вот это все. Довольно неплохо, неформальную расстановку раскрепощают. Темы случаются довольно рандомные, от которых потом еще рандомно рабочий переходит и так далее в обе стороны. И, в общем-то, это иногда ускоряет отношения, как-то не даже не то, что отношения, немножко укрепляет коммуникацию в целом. В общем, мы ответили, как смогли. Если будет какое-то уточнение по этому вопросу, то в следующем выпуске попробуем.",
    "result": {
      "query": "оптимальный выбор между допилкой и переписыванием"
    }
  }
]