[
  {
    "segment_id": "021c63ab-b840-40e9-8f6d-2bb979f3f391",
    "episode_id": "6de4e439-d260-4308-9d1d-70b8c6596713",
    "episode_number": 3,
    "segment_number": 2,
    "text": "А пакет это такая черная дыра, куда попадают статьи. Которые потом никто никогда не читает. Статья называется. Почему вы должны любить Null? Ну, Null знаете, да? В Java. Ну, не только в Java. Это концепция, она везде распространена. Ну, да. C++ тоже есть. И меня прям зацепило. Потому что... Ну, все же говорят, что Null это плохо. Из-за него бывает... Расскажи. Вот эту статью не читала. Расскажи. Из-за него бывает NullPointerException. Статья, у нее очень простая мысль. И, повторюсь, меня она зацепила. Мысль заключается в том, что... Многие программисты так сильно боятся Null. Что пытаются заменить его, ну, например, какими-то значениями по умолчанию. Ну, либо есть еще паттерн NullObject. То есть, чтобы не выкидывать какого-то эксепшена, ну, в частности NullPointerException, мы делаем какой-то NullObject. Есть такой паттерн для этих задач. Он возвращает какое-то дефолтное поведение, либо какое-то поведение, которое ничего нам не разрушит. И это довольно часто я видела в рекомендациях. Когда-то пробовала даже сама заменять на Null и на такой вот NullObject. Не скажу, что у меня было плохое впечатление. Но как-то я особого эффекта в этом не увидела. Какого-то прироста. Ну, вот автор Кристиан Нойманс. Он не одобряет значения по умолчанию. Он не одобряет паттерн NullObject. Но одобряет паттерн, который optional. Он уже maybe. Которые пришли из Haskell. Которые появились в Java 8. Который был испокон веков в Scala. Он говорит о том, что когда ты пытаешься использовать какие-то значения по умолчанию или поведение по умолчанию, ты рискуешь оказаться в ситуации, например, у тебя... Ну, я не знаю. Например, он приводит пример. Ты указываешь цену какого-то товара. Ты на eBay указываешь цену. Я хочу продать что-то за сколько-то. И, допустим, ты забыла указать цену. И берется вместо Null, что цена не указана, значение по умолчанию. 0, например. И у тебя получается самое богатое разнообразие забавных эффектов. Начиная от того, что средняя цена считается неправильной. По понятным причинам. Имеется в виду товаров по всему каталогу. У тебя в магазине отображается цена на дом 0 долларов. Из такого разряда. То есть... Ну, смотри, в такой ситуации... Это было входное значение, входной параметр. В такой ситуации я считаю, что вообще неправильно, раз человек не указал, какой параметр нам нужен, почему вообще-то туда попал Null. Туда Null не должен был попасть. Это должно было отсеяться на уровне валидации. И сказать, ну-ка, введи параметр такой-то. У тебя поле опциональное. Это Maybe. Это же чистый хаскерский Maybe. Я согласен, что писать туда 0 это неправильно. И я согласен с автором, что в данном случае у тебя либо поле должно быть обязательное, либо у тебя должен быть Optional или Maybe, смотря на каком языке пишешь. Просто я здесь вижу ошибку в том, что не имплементировали нормальную ветку логики, когда этот параметр не задан. Вот какую ошибку я вижу. Это не ошибка Null Object, это ошибка отсутствия логики. Ну, да. Автор говорит о том, что если вы так сильно боитесь Null, что пытаетесь их заменить на значение по умолчанию, вы на самом деле не избегаете ошибок. Вы создаете новые ошибки, которые намного сложнее найти, вообще понять, что они есть, и как-то исправить. И лучше уж вы... Я знаю, некоторые джавники не любят Optional по каким-то своим соображениям. И если вы так боитесь Optional и боитесь допустить ошибку, то уж лучше используйте Null. У вас во время тестирования будет брошен NullPointerException, у вас будет StackTrace, вы поймете, где это было брошено. И уж лучше вы нормальные тесты напишите и найдите ошибку, и исправьте, чем использовать всякие значения по умолчанию, типа пустая строка, ноль и так далее. И мне кажется, это здравая мысль. Ну, просто понимаешь, что в разных параметрах ставить Null как-то странно. Но вот я тебе приведу живой пример. Допустим, ситуация следующая. Нам нужно найти юзера по каким-то критериям. Ситуация такая, что юзера нет по таким критериям. Что мы будем делать в такой ситуации? Вариант первый, мы возвращаем Null. Вариант второй, мы кидаем Exception. Вариант третий, мы возвращаем какой-то NullObject. Что в этой ситуации делать? Это, мне кажется, более реальная ситуация с использованием Null, а не тогда, когда мы что-то во входные параметры передаем. Что вы думаете по этому поводу? И как лучше в такой ситуации быть? Что вы скажете? Как вы делаете? А еще раз, откуда может оно прийти, если не из входных параметров? Ну, как возвращаемое значение. Наиболее часто Null идет как возвращаемое значение от какой-то там функции обычно. Но эта функция, это что? Ты лезешь за какими-то данными и не можешь их найти? Да, и лезу. Или это результат подсчета каких-то, не знаю, калькуляций? Нет, я лезу за какими-то данными, данных я не нашла. Я думаю, можно свести к самому простому случаю, что ты декодировал JSON, получил какой-то объект, типа DecodedJSON, и считаешь, что это map, и делаешь там lookup. И у тебя по какому-то ключу может не быть значения. Я правильно свел к простому случаю твой вопрос? Не скажу, что самый простой случай. Мне кажется, элемент с юзером был более простым. Ну, ладно. Тут все очень сильно зависит от того, откуда ты берешь данные, что ты с ними хочешь делать. То есть, если ты считываешь из базы, хочешь что-то отдать пользователю, то ничего страшного, если ты в этот момент упадешь, он упадет еще раз, и там, я не знаю, сеть восстановится, если ты с PazGriff можешь считать правильное значение, и отдашь ему. То есть, неконсистентность не получится. Хуже получится, если ты начал записывать, скажем, в базу, а потом в одну базу записал, а в другую консистентная запись не получилась, потому что у тебя этот null pointer exception, и тебе нужно откатить из старой, для того, чтобы эти консистентность сохранить. Это уже совершенно другое. То есть, очень сильно зависит от логики, в какой точке-то происходит проблема. От себя я хочу сказать, что это в нормальных языках, таких как Haskell, таких как Scala, сделано с помощью так называемого паттерна Optional или Maybe. То есть, если ты чего-то не нашел, ты честно возвращаешь значение Nothing. Если ты что-то нашел, ты честно возвращаешь Some или Just, и как бы вот эту обертку. В языках кривых и костыльных, таких как Erlang или, например, Go, нормальным считается вернуть кортеж с статусом OK или не OK, и самим значением. То есть, в Erlang, например, ты когда делаешь Dict.Find, то кто-то там чем-то стучит. То ты получаешь либо OK и значение, либо Atom Error. Если ты ожидал нормальное значение, то у тебя там просто не помачится. Вопрос ведь, что дальше с этим делать? Ну да, не помачится оно, но ты же сам решаешь на уровне кода, потом что делать дальше. А вот что делать дальше сильно зависит от точки, в которой произошла эта ошибка. Это уже какая-то бизнес-логика. Да, это бизнес-логика очень сильно оказывает большое влияние на то, как ты будешь с ней разбираться. А вообще в Erlang, как это, падай быстро и все будет в порядке. Ну да, типичный Erlang-овый подход, ни о чем не думай, просто падай, польза у тебя разберется. Ну да. Ты понимаешь, что я это говорю с сарказмом? Это ирония, да, это сарказм и ирония. То есть, все должны его понимать, потому что я помню, как в одном из радиотов Умбутун как раз чуть не плакал, как это быстро падать, если у вас там какие-то данные частично сохранились, частично не сохранились. То есть, здесь это все относительно. То есть, надо падать в тот момент, когда ты ничего не поломаешь и следующий запрос пользователя тебе сделает то же самое. То есть, какое-то идемпотентное чтение, я не знаю, или изменение. Но падать тоже надо правильно и с умом. Я уже об этом писал, что это неправильное понимание. У Армстронга, у него этот let it crash, он вовсе не означает, что говняк изякак придется, если вы чего-то не предусмотрели, то пусть оно падает. И у нас же Ирландка let it crash. У него ничего подобного в книжках нет вообще. То есть, в Ирландге никто не отменяет необходимость делать нормальную валидацию, ничто не отменяет там... Поддержка консистентности, разбор ошибок, то есть, это все есть. Вопрос... Ведения логов, запись метрик, это никуда не девается. Опять же, когда с актерами работала, ситуация какая? Если какая-то предвиденная ошибка, что-то пользователь не так вел, либо с базой что-то случилось, с которой мы можем понять, что происходит, зачем в этой ситуации падать актеру? Мы можем это разрулить и сказать, ну, вот такая-то ошибка, мы знаем, что произошло. Но вот если уже что-то происходит непонятное, и оно происходит несколько раз подряд в течение определенного промежутка времени, да, вот это уже есть повод упасть и пересоздать актер заново, и может тогда все восстановиться. Но падать просто так на пустом месте, это странно. Смысл. А в той статье про Java concurrency есть этот вопрос? Там, по-моему, были другие вопросы. Так, мы переходим к новой теме, значит, так, резко. Увидела интересную статью на Хабре. Ссылку тоже дадим в шоу-ноуты. Статья называется следующим образом. 100 плюс вопросов на собеседование по Java concurrency. Мне приходилось работать с Java concurrency. Не скажу, что очень много, но я нашла в этом списке кое-что интересное для себя. В общем-то, я вам тоже всем рекомендую ознакомиться с этим списком, особенно для тех, кто считает, что знает Java concurrency. И я не слышала про такую вещь, которая там указана была. Она называлась проблема ABA. Что-то такое я вот хочу рассказать. Собственно, в чем она заключается? Когда мы обрабатываем какую-то информацию многопоточно, у нас может быть ситуация следующая. Допустим, есть какая-то ячейка памяти. К этой ячейке памяти обращается поток 1. Он эту ячейку памяти считал. У него есть какое-то значение. Во время после этого поток 1 уступает свою работу потоку 2. Поток 2 опять работает с этой ячейкой памяти. Он снова ее считал. Что-то там посчитал у себя. И поменял эту ячейку памяти. Опять что-то у себя поработал. И снова поменял ее на первоначальное значение. После этого второй поток уступает первому потоку работу. И первый поток снова считывает значение из той же ячейки памяти. И он не может понять, что она в это время изменялась. И никаким образом это не может узнать. Сразу вопрос, в каком случае это имеет значение? Вопрос следующий. Возможно, такая ситуация будет каким-то образом впоследствии аффектить наш алгоритм. В качестве примера приводится реализация лог-фри структур данных и алгоритмов. Допустим, у нас есть какой-то список элементов. Из списка элементов мы убираем какой-то элемент. Потом создаем новый элемент и добавляем обратно. Есть вероятность, что этот элемент будет размещен на месте старого элемента. И в такой ситуации указатель на новый элемент может совпасть с указателем на старый элемент. И какая-то логика пойдет не так. Но это когда может произойти? Когда у нас дальнейшая логика завязана на понятии того, что изменялась ячейка памяти, либо не изменялась, изменялся какой-то объект, либо не изменялся. И она может каким-то образом, неявным образом, где-то впоследствии всплыть. Штука довольно интересная. По крайней мере, я не знала, что она называлась ABA проблемой. Я бы не ответила на такой вопрос. Мне кажется, это довольно редкий кейс, которому кто-то зачем-то придумал название. Ну, окей. А почему он ABA? Так это вот почему? Ячейка памяти была А, ячейка памяти стала Б, ячейка памяти стала А снова. Откуда оно? Ну, то есть я пытаюсь сказать, что программирование это большая богатая область и в ней нельзя всего обо всем знать. И, конечно, если ты придумал 100 проблем, которые могут быть в конкарнсе, и каждый придумал свое название, ну, зачем так делать? Флаг тебе в руки называется? Можно придумать какую-то задачку, подходящую для собеседования. Ну, то есть как-то так, зачем спрашивать у чувака, типа, расскажите, что такое ABA проблема? По-моему, это больше потроллить человека на собеседовании. Ты считаешь, что ты гуру в Java конкарнсе, а расскажи-ка про такую проблему. Просто вот посмотреть на лицо чувака. А допустим, у него реально годы опыта с настоящим хардкором, с настоящей многопоточностью, а ему какую-то теоретическую штуку дают. Ну, это странно, наверное. Нет, как бы это проблема, это частный случай проблемы, просто разделяемой памяти, когда у тебя несколько потоков могут работать с одним участком памяти, писать там и изменять ее как-то. Но можно придумать еще BCB проблему, 123 проблему и еще 15 раз. 121 тогда. Да, но как бы да, есть такие проблемы, их решают. Отлично. Просто я довольно много интересных вещей почерпнул из этой статьи, и я считаю довольно таким хорошим, наверное, планом по подготовке к Java конкарнсию. Я полностью согласен с тобой, но мне не нравится, что это дают как вопрос к собеседованию. Ну, нельзя на собеседовании такое спрашивать, меня вот это вот ставит в тупик. Ну, вряд ли, конечно, такое в принципе будет спрашивать, и это очень маленький процент людей будет это знать, что вот она проблема называется именно так. Но теперь наши слушатели будут знать. Мне статья, она тоже очень... Я ее еще не читал, мне она просто понравилась как бы идеей ее, поэтому я ее добавил в пакет и через полгода обязательно прочитаю. Ну, то есть в конце статьи там есть реклама, что в общем-то испортила впечатление от нее про курсы человека, который написал эту статью. Почему она испортила тебе впечатление? Это очень правильный способ попиариться на Хабре. Это единственный такой честный способ написать статью и в конце как бы между делом сослаться куда ты хотел. Там не просто между делом, там и расцветки указаны. Так в этом вся идея Хабры. Ты имеешь в виду, вся идея Хабры не нести светлое и доброе, а давать свою рекламу что ли? Ну, смотря с точки зрения кого мы имеем в виду. То есть с точки зрения владельцев Хабра идея такая, что у нас будет много пользователей, которые нам бесплатно напишут контент, а Google его проиндексирует и придут новые пользователи, а мы на рекламе как-нибудь заработаем. Это идея с точки зрения владельцев Хабра. Идея с точки зрения посетителей Хабра, она тоже простая. Мы напишем какой-нибудь пост, который вроде как пройдет правило, что его не занесут в черновики. И как бы между делом там попиарим свои блоги, продукты и так далее. И много людей прочитают и у нас трафик придет. Вот она и вся идея Хабра. Понимаешь, там не между делом, там явно указано, что это... Я за Википедии. Это жизнь. Ну да. Если ты никуда не занес, то тебе не рада. Давай дальше. А что дальше? А дальше ты со своими инди-играми. Да-да-да. Наткнулся на интересную статью, но мне она показалась интересной. Возможно потому, что я тоже подумывал о написании каких-нибудь инди-игр. И в этой статье разработчик, один из разработчиков инди-игр, просто дает ссылку на три различные свои игрушки, которые он сделал за последнее время. Он написал, сколько он на нее потратил времени, примерно сколько она заработала в целом и сколько она продолжает зарабатывать. И некоторые комментарии на эту тему в целом про распространение, про маркетинг, как правильно делать маркетинг игрушек и так далее. Эта статья в дальнейшем обсуждалась в... Я не помню, где она обсуждалась. По-моему, на Y-Combinator. И там тоже очень много пришло разработчиков подобных инди-игр, и они между собой очень интересно спорили. Можно очень интересно почитать, ссылку мы приведем. В целом общий вывод, который мне там больше всего понравился, это то, что богатая библиотека для написания, богатая SDK, удобная среда разработки для написания каких-то игрушек или вообще вещей под какую-то платформу, создает очень хорошую почву для того, чтобы туда приходила большая толпа хомячков. И среди этой большой толпы хомячков даже с очень хорошим продуктом довольно сложно вылезти. Не говоря уже о случае, когда продукт не очень хороший, и вылезти практически нереально. Так, у нас что-то, помеха какая-то идет. Это у меня? Свет на ее, свет на ее. А, свет. Под помехи, да. Вот. И в целом рассказывалось про этот ад апстора, когда очень тяжело... Свет, замьютесь, пожалуйста. Про ад апстора, когда очень тяжело пробиться куда-то, и вообще это невозможно сделать. В общем, я не знаю, мне очень понравилось. Я понял для себя, что если я захочу что-то делать в качестве разработчика игрушек, то нельзя ни в коем случае рассчитывать, что оно принесет денег, если делать это только строго для себя, потому что похоже, что надо либо иметь большую команду, либо у тебя ничего не выйдет. Как-то так. Если у вас есть что прокомментировать, говорите, а то перейдем к следующей. Ну, мне просто эта тема зацепила, я не знаю, зацепляет ли вас тема написания маленьких игрушечек в свободное от работы время, когда тебе интересно новые технологии пощупать. Меня очень цепляет. Я считаю, это вообще мечта любого разработчика наговнякать на Java змейку, залить ее в Google Play, и, ну, понятно, да, у тебя миллион человек захотят ее скачать, по доллару с человека и миллион долларов. Вообще как с куста. Вообще очень просто и легко. Давайте переходить. Ваня, а у тебя не было проблем с идеями для написания игр? То есть, окей, я хочу написать игрушку, а что я буду писать? У тебя сразу же были идеи. У меня есть несколько идей, я не знаю, насколько они хороши, потому что я к ним еще не приступал, но они у меня есть, и я никак не могу начать. Поэтому у меня проблема только со временем. А вообще, на самом деле, это очень занятная идея, потому что здесь мы уходим от области строго разработки, приходим к области, когда нужно придумывать не только дизайн. Дизайн очень важен во всех подобных развлекающих вещах. По-моему, он даже первостепенный. Я скажу, что нет, наверное, потому что бывают вещи с плохим дизайном, но настолько притягивающие и цепляющие. Ну, неужели ты сейчас, на скидку, не вспомнишь ни одной игрушки, которая выглядела ужасно, на которую не хотелось ничего тратить время, но она цепляла так, что пару дней на нее можно спокойно убить просто. У меня все входит в прошлое. Я вспоминаю вот эти старые пиксельные игры. Ну да, да. Но это скорее что из ностальгии разряда. Почему? Ну она же тебя цепляла. То есть с плохим дизайном она тебя зацепила. А других не было тогда, понимаешь? Тогда все такие были. А если бы мне показали тогда, смотри, какие классные игрушки с классным дизайном, то вряд ли. Ну ты знаешь, я сейчас иногда до сих пор люблю запустить какой-нибудь Heroes of Might and Magic 3. Он у меня идет в виртуальной машине в неудобном окошке. Мышка там с трудом работает и с трудом что-то иногда контачит. Но я все равно играю, потому что реально геймплей очень интересный. Она затягивает. И вот эта идея затягивания, она вообще никак, ты ее не оформишь, не сформулируешь даже, как это правильно сделать. Поэтому вот об этом очень интересно думать на досуге. И вот когда начинаешь задумываться, а что больше затянет, а вот это или вот это, а вот то или и то. Но очень богатая тема для обсуждений. Лучше интересно, конечно, обсуждать это, когда несколько человек, когда делятся мнением. Но я предлагаю уже уйти от игрушек, а то мы сейчас прямо про игрушки весь подкаст потратим. Я просто вспомнила игрушку, которая мне так нравилась с детства. Это Prehistoric 2. Просто я столько времени на нее убила. У меня был листик, где я записывала все коды, потому что мне лень было проходить все уровни заново. Но игрушка невероятно крутая. Я до сих пор... Была такая игрушка, этот Bomberman, как он Дайна назывался. Я до сих пор пароль оттуда помню, вы представляете? Я играл в нее, я не знаю, лет 20 уже назад. Не знаю сколько, 15-то точно. Ужас. А знаете, что еще ужас? Ужас – это кнопка, которая появилась у Хироку. Следующая тема. Хироку сделал кнопку. Ты у себя в репозитории в GitHub размещаешь небольшой код в readme.md и по нажатию на эту кнопку своя приложенка автоматически раскладывается в Хироку. Мне просто идея очень понравилась, очень классно сделано. Так они же сделали до этого по комиту. Зачем кнопку нажимать, если у тебя по комиту она будет раскладываться? А вот ты зашел в репозиторий с таким ярким, бросающимся в глаза названием Ruby – Rails – Sample. И тебе прям не терпится раскатить его в Хироку. Ты нажал кнопку и раскатил. Плохо разве? Ну, кстати, да. Отлично. Особенно со змейкой, если змейка раскатывается, вообще идеально. Большая красная кнопка. Только, да, чуваки в Твиттере шутят довольно очевидным способом. Хирак, хирак и в Хироку. Идея богатая на самом деле. Вот эту штуку бы объединить с обучающими вещами. То есть, я не знаю, зашел на sample-код на Haskell, который, не знаю, что-нибудь умеет делать. Ты решил попробовать, нажал кнопку, бах, у тебя раскатилось, все, посмотрел, как оно работает. Потом зашел в следующий, у тебя грубо объединяется ирландом, и сверху C++ что-нибудь погоняет. Отлично. Нажал кнопку, все начинает работать. Вообще же идеально. Больше ада. Самое интересное, что вот этот код для кнопки, в нем есть текст, в нем есть адрес картинки, но там бла-бла-бла, баттен, точка пенга. И есть ссылка там, хироку, слэш, деплой. Как вы думаете, каким образом хироку поймет, что нужно разложить, когда ты переходишь по этой ссылке? Ну, она берет, откуда ты это переходишь. Какая-то специфическая структура должна быть проекта? Ну, да, если взять ваши ответы и объединить, то да. Так и есть. Во-первых, у тебя в репозитории должен быть определенный файлик. Во-вторых, он определяет по заголовку реферер. HTTP заголовку, да. Но мне кажется, это не очень надежный способ. Вообще-то браузеры, они не особо обязаны его передавать. И всякие плагины могут их спокойно резать. Ну и при этом у тебя обязательно должна быть уже настроено, что у тебя есть деньги на хироку и так далее. Нет, но ты там по ходу пройдешь диалог, даже зарегистрироваться, если надо. Молодцы. Но мне просто кажется, что могли бы там в URL, ну то есть добавить ссылку на репозиторию в URL. Зачем так положиться на реферер? Я думаю, пару месяцев пройдет, и после 20 гневных пользователей, а у меня ничего не работает, которые сидят в этот момент за какими-нибудь, не знаю, приватными сетями у себя на работе, они эту штуку прикрутят. А еще что интересно, из интересных новостей. Мы же здесь собрались про интересные новости поговорить. JetBrains в блоге своем рассказал про AppSource. Вы же читали про AppSource? Расскажи тогда про всем. Ну JetBrains, это же очень хорошая компания. У них есть свой язык, котлин. У них есть своя IDE. Очень хорошая, мне очень нравится. Даже я бы сказала, платформа для IDE. Они очень много на этой платформе писали IDE, не только идею. Кажется, я в разборе полетов узнал, что есть плагин, который позволяет из идеи ходить в базу данных, и смотреть какие-то там столбцы, и чуть ли не автокомплит в SQL запросах делать. Я прям в шоке был, когда это услышал. Это даже не плагин, это часть идеи уже стала. Она сразу поставляется. Я сразу это вижу. Еще у них есть свой бактрекер. Я, правда, не вспомнил название. TeamCity это не у них, да? TeamCity это JetBrains продукт. А, подожди, это система непрерывной интеграции TeamCity. А бактрекер, я забыл как называется. А теперь они сделали этот апсорс. Это аналог GitLab. То есть, это интерфейс к репозиторию, где ты можешь делать там pull-requests, код-ревью, такие вещи. Насколько она хороша? Мне трудно судить, потому что я ее, разумеется, не запускал. Но они ее день назад только выпустили, да? Ну, слушай. Мне просто приятно, что российская компания развивает свою платформу, продукты делает неплохие. Здорово. Просто, наверное, из той области, где-то год назад была презентация JetBrains, когда они сказали, что пишут свой source-control систему. И это, видимо, оттуда все. Но source-control ты имеешь в виду как гид? Как гид, но вот плюс надстройку, когда ты можешь из браузера что-то видеть. Но это не как гид. Это как веб-мордок, GIT, SVN и чему-то там еще. Какой-то Perforce, я не знаю про такое. Я слышала. Да, я работал с ним тоже. Ну, понятно, понятно. Ну, хорошо, надо попробовать, посмотреть. Потому что, если честно, GitLab у меня есть несколько претензий, было, по крайней мере, когда я его пытался поднять. Может, здесь они что-нибудь совсем удобное сделали. Но они же все на Java делают, да? На Kotlin, что ты? Хотя переходят на Kotlin. Боже мой, как же я мог так сказать. Я на самом деле надеюсь, что они запустят свой SAAS и у них там будет, ну, как у Atlassian. То есть репозитория, веб-мордок к ним. И идея как-то с этим совсем интегрируется. Ну, то есть сделают нормальную свою облачную платформу и будет всем счастье. Ну, да, конечно. Звучит фантастически. Но, скорее всего, к этому и идут. Ну, да, вполне очевидно. Ну, отлично. Ну что, давайте дальше тогда? Давайте. Так, я тогда хотел сказать, что вышел новый Ansible 1.7. Я не готов сказать, что там что-то очень много важного и хорошего, потому что большая часть этого релиза посвящена Windows. Меня вообще никак не затрагивает, но люди вроде как довольны. Они обещают, что к 1.8 они вообще сделают стабильную поддержку Windows. Сейчас это бета больше. Они добавили довольно много модулей для работы. И в целом повышают стабильность, потому что здесь они исправили какую-то проблему, когда можно было с помощью специальных действий как-то хакнуть систему. Я не знаю, насколько... Я не вижу больших плюсов перехода сюда, потому что такие больше мелкие патчи для не Windows-пользователей. Единственная команда, которая более-менее неплохая, это RunOnce. Она позволяет выполнить однажды эту команду. Но к ней тоже много вопросов. Надо посмотреть, как она реализована, куда она сохраняет флаг о том, что она запускалась уже до этого или не запускалась с данной машины. Не знаю. В целом, для тех, кто не знает, Ansible – это такая... Я даже не готов сказать, что это утилита, потому что это уже большое направление. Там некая концепция стоит по оркестрации, конфигурированию сетей и кластеров машин. Не то чтобы аналог Puppet и Chef, потому что у нее другая концепция, но утилита, которая движется в подобном направлении. Подожди. Как я это понимаю, это все-таки аналог Puppet и Chef, за тем исключением, что у Chef и Puppet нужно свои клиенты ставить на серваке и потом из админки их админить. А Ansible, он весь такой из себя ходит по SSH. Тебе нужно только админку поднять. Разве не так? Дело в чем. Дело в чем. У Puppet и Chef совсем другая архитектура. Ты правильно говоришь, что на каждой машине запущен свой клиент, у тебя подняты серваки. Причем ты можешь сделать какую-то масштабируемость серваков. Поднять их 10 штук для того, чтобы твои миллионы машин могли к ним достучаться и не получить отказа в обслуживании. В случае Ansible это легковесная такая вещь. Ты с одной машины запускаешь команду, и она стучится во все остальные машины по SSH и делает на них какие-то действия. Причем в чем удобство именно Ansible в том, что она делает это идемпотентно. То есть, ты запуская несколько раз одну и ту же команду, ты не получишь разных результатов, ты теоретически должен получить один и тот же результат, к которому ты стремишься. Теоретически или на практике? Теоретически, потому что ты сам управляешь своими скриптами и настройками. То есть, ты можешь написать все так, что у тебя stop the world случится и ничего ты не сделаешь. Испортить можно все что угодно, но их идея именно в том, чтобы это было на практике. Нам удается это достигать, пока у нас все в порядке с этим. Там есть какая-то возможность, не знаю, ну вот как в шефе, написать какие-то рецепты, раскатить конфиги по серверам, сказать, что вот на этих серверах такой-то конфиг, и поскольку это конкретный сервер, подставить имя куда-то в конфиг и так далее. Или он только такой аналог PSSH? PSSH – это его далекий-далекий прадедушка. То есть, очень удобно сделано конфигурирование того, что ты хочешь сделать. То есть, там изначально они исходили только из простой концепции. У тебя есть набор хостов, и у этих хостов есть какие-то свойства, и для каждого свойства ты определяешь список действий, какие ты хочешь сделать. В дальнейшем они от этого ушли, они пришли к более большой, богатой концепции, что у тебя есть какие-то роли, есть переменные, есть задачи для ролей, есть теги, по которым ты можешь для всех ролей или для каких-то ролей выполнить какие-то действия, есть окружение, с помощью которого ты можешь модифицировать небольшое, как это сказать, слегка модифицировать то, что ты собираешься делать. И вот эта вся конфигурация, она очень простая, очень изящная и понятная. То есть, человек, который ни разу не ходил в Паппетт и начинает залазить в Паппетт, ему очень тяжело это сделать. Человек, который ни разу не ходил в Энсибл, заходит в Энсибл и сразу понимает, почему, что и как делается. То есть, они с этой точки зрения, они задачи свои справились на 5, я вижу большой будущий за Энсибл. Но, конечно, не для, скажем, Фейсбука, у которых там десятки, сотни тысяч машин, но ты замучаешься по ССАЖ заходить на 100 тысяч машин одновременно, если там захочешь что-то сделать. А вот на Лоре, Лор – это же авторитетный ресурс, ему можно верить. Там в описании сказано, что у Энсибл сценарии пишутся такие на Ямл, да еще и переменные передаются, используются через какую-то Jinja 2, я вообще не знаю, что это. Там что нужно, как программировать на XML только на Ямл? Ну, Ямл – это декларативный язык. Мы уже сегодня говорили про декларативные языки. Как XML, понятно. XML – это все-таки не… Ну, мне сложно назвать это декларативным языком. Декларативный язык – это Makefile, к примеру. То есть, ты объявляешь, что ты хочешь достигнуть, и все. А дальше к конечному действию он сам уже приходит. И из-за этого возникает простота, ты не пишешь, как они это должны достигнуть. У них есть куча моделей, которые помогают тебе достигнуть этого. То есть, есть, например, как это сказать, не в начальной версии, но в дальнейшем они стали поддерживать очень много дополнительных модулей для удобства, скажем. Они сейчас довольно давно уже добавили поддержку ЕСИТУ амазоновского. То есть, ты можешь ноды получать, не записывать файл, который у тебя статически будет храниться, а в момент запуска Ansible ты будешь получать ноды из Амазона, смотреть там, с учетом того, что у тебя это они могут динамически скалироваться в зависимости от нагрузки, ты получаешь их активные ноды, на них что-то проводишь действие, а потом все, как бы выполнил действие, выключил Ansible. Ну, то есть, очень много модулей, которые позволяют тебе легко решать твои задачи. Но я предлагаю вопрос Ansible коснуться чуть попозже. Я как раз на одном из следующих выпусков хочу очень сильно затронуть тему с Ansible, с Docker, с Puppet Chef и так далее. То есть, это очень много, можно посвятить этому времени. Просто мы сейчас глубоко, предлагаю не копать нам, мы сейчас очень можем далеко уйти. А с чем еще можно далеко уйти? Куда можно далеко уйти? Это Москва, улица Льва Толстого, дом 16, офис Яндекс, где прямо 15 августа 2014 года, даже не так. В общем, там пройдет, мне на почту свалилось, анонс новых конференций, или как это правильно сказать, докладов. В Яндексе пройдет два новых доклада. Первый пройдет 13 августа. Называется «Машинный перевод, использование бит-текстов» Да, я правильно прочитал. На родственных языках. И второй доклад пройдет 15 августа. Называется «Исследование движения глаз при работе с поисковыми подсказками». В общем, это какой-то хардкорный ИИ. И я почти уверен, что вы этого нигде больше не услышите. Поэтому записывайтесь обязательно на эти конференции. Идите туда и познавайте глубокую мудрость разработки. Разработки поисковых систем. Мы рекламируем ивенты Яндекса, но мы просто очень крутые. Я, кстати, напоминаю, что у нас на сайте есть кнопочка «Донейт». То есть, тебе уже занесли? Нет, он только предлагает, чтобы занесли. В целом, семинары очень сильные. Имеется в виду, что таких тем на самом деле очень тяжело прочитать. А уж пообщаться с авторами, которые занимаются разработкой в данном вопросе, будет очень интересно. Поэтому, если вам интересно, идите. Мне кажется, это действительно эксклюзив. Ты нигде об этом не прочитаешь, нигде об этом больше не услышишь. Правда, Яндекс всегда выкладывает видео. Так что, если вам далеко или просто неохота переться, то можно и потом посмотреть будет. Вот, кстати, про видео с конференции. Я совсем недавно наткнулся опять на… Ну, я подписан на «Эрланг-сообщество». И там проскочило, что с последней «Эрланг-юзерконференции» 2014 появились новые видео. И в том числе появилась презентация некоего Андреаса Лошер. Или Лешер, я не знаю, как правильно произносится его имя. Он рассказывал про библиотеку и утилиту нифти для «Эрланга». Очень мне понравился доклад тем, что вроде как… Я, по крайней мере, не встречал его сильно раньше на этих конференциях. Но он очень интересную идею написал, предложил, реализовал. Это идея реализации нифов в довольно удобном и безопасном виде. То есть, нифы – это такие дополнения к «Эрланговской машине», которые подгружаются в виде динамической библиотеки, и вы можете исполнять их код прямо внутри виртуальной машины. Плюсы в том, что это большая скорость, вы работаете напрямую с данными, которые не копируются никуда, а лежат где-то в памяти. А минусы такие, что вы пишете библиотеку на «Си», и если она поломалась, она вам уронит всю виртуальную машину. То есть, вам нужно быть очень аккуратным и осторожным при написании нифов. Он написал обертку, которая, во-первых, упрощает интерфейс написания. То есть, вы просто пишете h-файл, которым описан интерфейс, нажимаете кнопочку, и она сама генерирует по этому интерфейсу описание, которое воспринимается «Эрлангом», ниф-файла, и компилирует его, и подгружает в динамическую библиотеку, если вы укажете источник «Си» на источник, который тоже нужно компилировать. Очень удобная вещь. Это первое. Второе. При этом создается автоматически еще одна функция, которая по специальному наименованию «двоеточий старт» что-ли, что-то типа такого. Она стартует новую «Эрланг-ноду», в которую подгружается этот ниф. И в случае, когда вы выполняете код, автоматически происходит обращение к этой «Эрланг-ноде», и в случае падения нифа, ваша нода остается работать, и вам только приходит сообщение, ой, вот та нода упала, сходите, посмотрите, разберитесь. То есть, во-первых, вы получаете удобный интерфейс, во-вторых, вы получаете безопасный интерфейс работы с нифом. Мне очень понравилась эта идея, он это очень грамотно и красиво сделал и преподнес на докладе. Посмотрите видео и слайды, очень хорошая штука. А можно глупый вопрос? Может быть, я как-то по пути немного отключился. Чем это принципиально лучше портов? У тебя во время портов происходит сериализация-диссериализация всех данных. Ниф обращается напрямую в память, то есть, если у тебя есть большие потоки данных, которые тебе, я не знаю, тебе передается 20 гигабайт текста, а тебе нужно вытащить первый бит, и в серединке где-то бит, ты можешь это сделать гораздо быстрее. То есть, конечно, порты в целом в каких-то случаях лучше, в каких-то случаях лучше нифы, то есть, здесь нет золотого правила. Но иногда нифы нужны, и когда ты их пишешь, вот удобная штука. Вот видишь, Свет, как приходится несчастным программистам, нет, вообще программистам на языках, у которых нет нормальной компиляции в байт-код, в нативный код, или нет джит-компиляции, как приходится извращаться. Вот я уверен, тебе за твою практику программирования на Java ни разу не приходилось какие-то сишные вставки делать и так далее. Ну, в принципе, у нас есть возможность использовать нативные интерфейсы. Да, как бы, DJNI, правильно? Да, но мне на практике не приходилось, хотя знакомые такую штуку делали. И не скажу, что они отзывались очень положительно. У меня глупый вопрос, как расшифровывается ниф? Наверняка это какая-то аббревиатура. Native Interface File или какие еще? Ой, а я не помню. Ой, слушай, хороший вопрос, давайте я сейчас найду. Я не помню. Я всегда обращался как ниф, биф и все. Native Implemented Function. Первое слово угадала. Вот интересная новость на OpenNet. Чуваки разработали технологию, при том из Массачусетского технологического института, разработали технологию, которая позволяет по видео воссоздавать речь. Вы читали эту новость? Да, вообще, если честно, сумасшедшая статья. Причем даже сами авторы этой новости говорят, ну, ребят, ну это реально сумасшедшая статья. Мы посмотрели видео и подумали, а почему так не сделать? А сейчас смотрим и думаем, ну это же фантастика. Ну-ка расскажите мне, я не видел эту статью. Ну вот у тебя стоит камера в комнате, снимает горшочек на полу с цветочком без звука. Камера самая обычная. Нет, не самая обычная, высокочастотная, высокого разрешения. Нет, нет, нет, там дальше написано, что совершенно обычная DSLR камера, 60 кадров в секунду. Вот стоит эта камера, звука нет, может быть она стоит за окном. Ну вот, и ты по дрожанию листочков на этом цветочке, кусте, при том у тебя камера не может заснять эти микродрожания, потому что это какие-то там тысячные пиксели. Тут написано 5 тысячных пикселей, эти дрожания, поэтому камера их не может заснять. Но ты можешь заснять, как у тебя эти пиксели цветом переливаются. Имея это переливание пикселей, ты можешь, приложив какие-то огромные ресурсы, типа 32 гигабайта оперативки, кучу времени, в целом можешь воссоздать звук с довольно неплохим качеством. Фантастика, слушай. Реальная фантастика. На самом деле я посмотрел этот ролик, который здесь прилагается, и эти чуваки там, конечно, они, как положено любым академикам, они там все подогнали, потому что они там реально орут на эту бедную камеру, чтобы хоть... Там просто, ну вот, когда музыка воспроизводится, она там реально прям орет на всю комнату. Когда они какой-то звук голосом пытаются записать, то они реально вот прям орут на всю комнату, чтобы там прям эхо раздавалось. Блин, это удивительно, что они вообще это смогли достигнуть. Какая идея классная. Вообще четкая идея. Я в такие моменты завидую программистам, что то, чем я занимаюсь, это вообще какие-то глупости. Да-да-да. Полностью согласен. Так, ну что, все? Или у нас еще какие-то темы есть? Ну ты хочешь рассказать про... Я хотел напоследок, давайте это на последнюю тему оставим, если у нас больше ничего не будет. Но тогда можно к темам слушателей перейти, они в этот раз довольно интересные. Они всегда у нас очень интересные. Но в этот раз... С вопросиков начнем. Давай. Ну вот интересный вопрос на тему EDE. Поднимает товарищ Барлок, наш постоянный слушатель, и отвечает ему Никита Прокопов, наш хороший друг. Так ли они нужны для Хаскера или Акамова? Почему бы не направить свои усилия на разработку не библиотеки компилятора, а на EDE? Ну и так далее, и тому подобное. На что Никита отвечает, что EDE они на самом деле не нужны. Потому что EDE, он с одной стороны позволяет тебе бороться со сложностью, но с другой заставляет эту сложность терпеть. И то, что у тебя ехал класс через класс, и иерархия с пяти уровней, ты с этим нормально живешь, хотя это очень сложно и неправильно, благодаря тому, что у тебя EDE. Как мое мнение, я готов сказать, я работаю только на Vim. То есть, даже когда я работаю с большими проектами на C++ и так далее, мне сложно бывает делать иногда рефакторинг. Я с этим ничего не скажу. А расскажи, как ты его делаешь. Тебе нужно переименовать какой-то метод, который используется в N местах. И что ты каждый раз его ищешь поиском, грепом? Что ты делаешь? Чаще всего, в любом большом проекте есть какое-то разделение на модули.",
    "result": {
      "query": "Null объект паттерн NullObject"
    }
  }
]