[
  {
    "segment_id": "eb1ab30f-d6f0-4780-9850-1d3f6b65dddf",
    "episode_id": "721d8099-0ed4-460a-976b-c8db021f63c8",
    "episode_number": 99,
    "segment_number": 2,
    "text": "Ну да, потому что мы на месте топчемся. А у него есть какие-то языки, либо подходы, которые начинают такими передаваниями? Да, в скобках. Но некоторые из языков, на которые я смотрел, мне казались достаточно перспективными. Например, Erlang. Бугагашеньки. Вот у меня сейчас прямо открыт цитата про то, что вы думаете, типа, в хорошем должно быть языке программирования. Он отвечает, что несколько таких важных вещей, или более higher forces, он это называет, типа, более высоких целей, которые языки должны достигать, помогать мышлению, там, о проблемах, произрежении их и так далее. Вот. Дальше... Сейчас, вот, читаю. Помогать, в общем, моделировать ту собственную систему. Ну, ты знаешь, для меня это звучит так, как будто сейчас мы вернёмся к диаграммам, умель диаграммам, и будем программировать в этих диаграммах, а потом у нас какая-нибудь умная среда сделает код, базирующийся на этих диаграммах. Мне кажется, это уже было. И Эйбем такую штуку делал. Не, а почему? А почему UML? Почему ты думаешь, Гайд? Ну, хорошо, не UML будет. Нет, то есть, как бы то, что оно помогает думать, это вообще... Это просто как бы показывает... Нет, ну смотри, одна история... Нет, ну смотри, на примере Мако, Мако, ты это видел. Давай я закончу свою мысль, а ты пример приведёшь. Ну, одна история, когда у тебя UML-диаграммы, другая история, когда... ну, для того, чтобы понять думать, а другая история, это UML-диаграммы как средство для программирования. Нет, ну смотри, речь ведь о том, что вот если ты берёшь Erlang, то почему любят Erlang? Потому что если ты посмотришь на Erlang, то язык как бы на самом деле на тебя... Как это? Он тебя загоняет в некоторые рамки, которые тебя ограничивают в том, как строить и как не строить своё приложение. Больше того, в Erlang есть библиотека OTP, которая ещё больше на тебя накладывает стандарты некоторые. И, грубо говоря, если у тебя есть приложение, которое написано в правильном OTP-стиле, то даже если ты можешь просто заранее знать, как оно будет структурировано, ты просто посмотрев на пару файлов, можешь понять архитектуру приложения. Просто потому что ты посмотрел, посмотришь на Supervisor, на струнную иерархию Supervisor, и в принципе, более-менее уже понятно. То есть нужно, когда открываешь Erlang-приложение, тебе интересно, точнее, Erlang-ноду, какие там приложения, какое приложение иерархию Supervisor, и дальше уже смотришь по, не знаю, идёшь, например, от OTP-шного или от ABAP-ного конца и смотришь на обмен сообщениями. Так к чему это тема? Это к тому, что дизайн языка – это как раз то, что помогает тебе думать. А EML это или не EML – это вообще разницы не имеет. То есть EML можно сделать и хорошо, EML можно сделать и плохо. То есть это не критическая штука. Важная штука – это именно как структурирован язык, какой у него концепции в основе лежат, и как он заставляет тебя обращаться с ним. Ну там, не знаю, если брать тот же самый Rust, который, правда, Алан не одобрил, видимо, то он на тебя накладывает некое ограничение в плане того, как распоряжаться памятью. Это не помогает тебе дизайнить твою, как-то… Не помогает дизайну в плане того, как ты будешь взбивать свой предмет и область на куски, но зато это помогает дизайну в плане, как это… Помогает дизайну алгоритмов, скажем так. То есть он помогает на более низком уровне. Абсолютно понятно, что язык сильно влияет на то, как ты думаешь. Это, кстати, касается и обычного человеческого языка. Но какой был вообще у нас вопрос, какую мы тему обсуждаем? То есть, насколько я понимаю, язык должен быть чем-то более, еще более высокоуровнен по сравнению с тем, что у нас сейчас имеются. Это не обязательно. Ну это то, как я поняла то, о чем говорит Аллан в своем ответе. А что-то еще более высокоуровненное – это как раз какие-то схемы, диаграммы, более оторванные от языка. Да нет, ну смотри, опять-таки вернемся к примеру Эрланга. Эрланг позволяет тебе в две строчки написать фигню, которую у тебя, не знаю, на том же РАСе нужно писать в сотню строчек. Или там на Джаве тоже. На Джаве там еще будет несколько сотен строчек. Просто потому, что у тебя сразу есть концепция процесса, сразу есть концепция, процесс, наблюдающий за другим процессом, просто встроенный в язык. Это не является у него диаграммой при этом. Это же… Если у тебя появится язык, который позволит тебе строить сразу раз природные системы, там просто условные консенсусы, встроенные в языке, я не говорю, что это хорошо или плохо, просто представь, что у тебя есть такая штука, что ты берешь и просто пишешь, вот у меня вот здесь консенсус, а вот здесь у меня, не знаю, репликация такого-то типа, а здесь еще такая штука. И она тебе просто у тебя вот в языке или в библиотеке этой штуки просто есть. И ты ее собираешь из темы из настолько крупных блоков. И потом уже, если нужно, спускаешься вниз и настраиваешь. Сейчас мы, грубо говоря, когда пишем программу, мы вынуждены спускаться до уровня отдельных байтиков, даже если это не абсолютно требуется. И все, до чего мы дошли, это то, что на текущий момент текущий мейнстрим научился не на уровне байтиков писать, а на уровне, не знаю, операций с абстрактными объектами. Это все еще подсорновательно низкоуровнево, особенно если ты посмотришь на масштаб систем, которые нужно строить. Так вот про это я и говорю, что на текущий момент те модели, те подходы, которые мы используем, они недостаточно высокоуровневые. И нам нужно что-то еще более высокоуровневое. Вот у меня диаграмма, и это не значит, что это будет не язык. Это все еще будет язык. Я склоняюсь к тому, что это все равно будет недостаточно высокоуровнево. Нет, чуваки, короче, если мы будем рассуждать высокоуровнево-не высокоуровнево, это очень линейное мышление, и не очевидно на самом деле, что именно там надо искать. Давайте больше слоев наворачивать, и неочевидно. Здесь речь идет о том, что хороший язык должен помогать думать о проблемах и решать их. Например, я не знаю, математическая аннотация, она помогает проще думать о проблемах, чем объясняться в диалоге. Или как-то так. И точнее, например, это более высокоуровнево или менее высокоуровнево? Ну, я не знаю, это просто хорошая метафора. Очень точно. Ну, в таком духе. Здесь язык должен тебе помогать думать, включая окружение этого языка. Если мне нужно смоделировать какой-то процесс, то я хочу его моделировать и видеть глазами, что происходит. Скажем, РЛАН не помогает мне визуализировать, какие процессы, куда сообщения ходят. А мог бы помогать? Ну, я не знаю. Тут можно много всего придумывать, но не очень понятно, что из этого хорошее, а что из этого плохое. В любом случае, мне хочется добавить один момент, что любой язык программирования, или любая программа на любом языке программирования, она решает какую-то задачу. Какую-то задачу, за которую платят программисту деньги. Деньги платят бизнес, либо клиенты. И в конечном счете, если язык программирования хорошо решает эту задачу, и клиенты довольны, значит, этот язык программирования решает эту задачу хорошо. И по факту, на самом деле, неважно, какой это язык программирования. Высокоуровневый, низкоуровневый, функциональный, нефункциональный – не важно. Мы так спускаемся куда-то еще, я не знаю. Ну, то есть я, конечно, вообще на ассимилире могу всё сделать. И кто-то будет доволен. О чем это говорит? Ни о чем это не говорит. Просто нет более хороших вещей, нечем сравнить. Если... Не можешь? Подожди, слушай, давайте разберем этот стереотип, что я могу всё на ассимилире сделать. Это не можешь ты всё сделать на ассимилире. Ты зароешься сразу же. Ну, то есть, как бы смотри, ты можешь попытаться на ассимилире построить, ну, как бы построить дом из палок и глины. То есть ты можешь попытаться на ассимилире воспроизвести те языки, которые ты знаешь, как должны выглядеть. То есть ты можешь попытаться на ассимилире написать C, потом на C попытаться написать Java или ещё какой-то garbage collector. На нём сделать динамический язык, например. Ты можешь попытаться запустить эту цепочку, но ты ограничиваешься в итоге. Ты будешь писать, во-первых, на другом языке в итоге. А во-вторых, ты ограничиваешься тем, какие модели ты знаешь уже существуют. То есть ты знаешь, в каком направлении двигаться, какие вещи работают и как их делать. То есть ты можешь сделать это на ассимилире только потому, что ты знаешь уже, как делать, потому что другие люди попробовали, ты видишь, как это выглядит. Нет, я имел в виду немножко другое. Я имел в виду, что если в настоящий момент у нас не было бы высокоуровневых языков типа с garbage collector или даже без garbage collector, но какие-то более высокие абстракции, концепции и так далее, а было бы что-нибудь очень простое, но людям надо было решать свои проблемы, они бы решали свои проблемы на этом простом языке? Не решали бы. Ну в смысле, когда не было высокоуровневых языков, писали в софт-арт в 10 раз меньше, и он был гораздо примитивнее, чем сейчас. Тогда и вычислительная техника была не очень? Ты не думал, что из-за этого... Нет, нет, потому что сложность, потому что ты не можешь на перфокартах сделать веб-браузер. Я не уверен. Я думаю, что это было из-за того, что мы не нуждались и не могли это в технике реализовать. Не могли, потому что мыслительные ресурсы человека ограничены. Человек, это очень тупое существо. И чтобы встроить что-то сложное, ему нужны какие-то подпорки, что-ли, что-то, что ему помогает в сосредоточении. Я с этим не спорю. Я спорю с тем, что то, что в текущий момент решается на Хаскеле, какие-то, я не знаю, системы из 10 тысяч строчек на Хаскеле, высокоуровневый язык с большим количеством концепций, можно реализовать на очень простых языках? Ну, в смысле, если взять что-то простое, что ты пишешь на Хаскеле, да, это можно сделать на очень простых языках. Но я говорю о том, что есть программы, которые ты можешь написать только на Хаскеле, никогда не сможешь написать на Ассембле. Например? Ну, я не знаю, веб-браузер там точно. Я не знаю, какие самые сложные системы. Ну, скорее, ты сможешь написать на вопрос о времени и затратах? Не сможешь. Вот у Никиты концептуально говорится, что он не сможет. Я считаю, что всё ты сможешь написать. Да вот не сможешь. Вот я тоже поддерживаю Никиту, что современный браузер, как это, это сложнее, чем операционная система, на самом-то деле, мне кажется. Как там, что они писали в книжке «Мифический человеком месяц»? У СППА они писали или что они там писали? Я вот не помню. Не помните? Короче, это вся книжка про то, как они затеяли супер-адский-гигантский проект. По-моему, это операционная система какая-то была. Адский-гигантский проект, и они больше, в частности, времени, не знаю, 99% они боролись со сложностью. То, что он был суперсложный. То есть они там распечатывали какие-то документации, просто распечатать документацию того, что поменялось за последнюю неделю или месяц, и всех поставить в известность, это было нереально сложной для них задачей. Они просто боролись со сложностью, они писали проект. То есть есть предел того, что ты можешь сделать на языке. И более высокого уровня языки, они повышают этот предел, то есть ты можешь делать что-то другое. Ты можешь писать в библиотеке и делать концепции на низкого уровня языке, которые позволят тебе облегчить. Точно так же. А это и есть прогресс. Ты должен знать, в какие библиотеки писать. Ты не можешь, знаешь, давайте, нам нужно сделать суперсложный проект, поэтому давайте сядем и придумаем какие-то... Ой-ой-ой, ну скажи мне, что придумали в языках за последние 20 лет, чего не было до этого? Так вот, серьезно. Давайте сморачиваться, пожалуйста. Вот смотри, вот появился React, да? React появился 2 года назад, или 3, сколько он появился назад. До этого никто не знал, что можно так писать положение. Оказалось, это суперудобно. Думаешь, что люди, которые до этого писали веб-приложения, они недостаточно хотели их писать, им недостаточно мало денег вплотили, было недостаточно много людей? Это прогресс, появляется новая идея хорошая, которую ни у кого не было. И теперь все вдруг могут писать гораздо лучше приложения, чем писали веб-приложения. Я думаю, что это на самом деле идея не суперновая, просто ее применили в этой области первый раз и написали хорошую обертку. Ну да, да, да. Ну да, то есть мы не придумали новую идею, мы взяли старую хорошую идею и применили ее в этой области. Смотри, давайте, во-первых, немножко сменим все-таки тон спора, потому что уже практически кричим друг на друга, мне кажется, что это не так хорошо. Нет. Вот. А во-вторых, у меня такой пример пришел. До появления Go, не стоя на том, что уже был Erlang, до появления Go, до мейнстримного языка с поддержкой легковесных процессов и синхроничных, вот до появления Go у нас, ну, как бы просто реализация консенсусов, было, ну, еле-еле Zookeeper open-source, и все. Сейчас у нас есть Zookeeper, Console, etcd, загнувшиеся DoozerD, загнувшаяся, была какая-то еще штука на Go, загнувшаяся вот. Просто с появлением этого инструмента гораздо больше людей стало, как бы, строить такую инфраструктуру. Открой реализацию рафта страничку и посмотри, на каких языках они реализованы. Ты думаешь, там Go что ли реально всех подвинул вперед, что ли? Нет, я не про то. Я про то, что до появления Go этих реализаций реально в продакшене было мало. К тому же, понимаешь, на страничке с рафтом там production-ready реализации не так много, на самом деле. То есть на Erlang до сих пор нет ни одной, прям, может быть, одна немножко есть production-ready реализация рафта. Вот. Остальные не production-ready, это просто люди поигрались. То, что они поигрались, говорит тебе о качестве языка или о качестве их подхода? Смотри, я говорю о том, что, смотри, вот качество production-ready реализации на языке и то, что раньше их не было от слова совсем, на мой взгляд, говорит о чем-то. Я считаю, что рафт недостаточно сложен, чтобы его нельзя было написать даже на C. Ну смотри, одно дело, достаточно и недостаточно сложен, другое дело, такие штуки, типа, вот есть, например, в etcd есть такая штука, называется multi-raft. Это чем-то похоже, чем-то напоминает re-assemble, когда у тебя не один экземпляр консенсуса на весь кластер, а у тебя столько экземпляров консенсуса на весь кластер, сколько нужно. Вот такого рода реализации я вообще не помню, чтобы их было много. Опять-таки, если посмотреть на C++ реализацию у Refinki, то там raft, вообще говоря, написан на их карутинах, то есть у них в C++ сделаны карутины самостоятельно на ассемблярной магии, и уже на основе этого у них сделано все остальное. То есть они опять-таки тоже, они поподнялись в уровень абстракции, чтобы смочь проще писать распределенщину. Не знаю, я очень пессимистично настроен на современные, как это, все концепции. Я считаю, что мы переизобретаем велосипед по 100 тысяч раз, и на самом деле почти не движемся вперед. Очень мало концепций появилось за последнее время, которые вообще стоят внимания. В основе своей это просто давайте мы взглянем на эту проблему с другого угла и перепишем тот же самый язык, но немножко по-другому. Но реально, вот эти ваши все консенсусы, они не были никому нужны, потому что не было серьезных нагрузок на распределенных кластерах машин, на распределенном кластере. Как только появились, сразу появились. Ну, я вот именно этого не согласен, потому что я достаточно много времени провел именно ковыряя эту тему, и с моей точки зрения их не было, потому что их писать было не на чем. Их писать было некому и незачем. Да было зачем уже их писать, вот серьезно. Ну давай так, надо было Гуглу написать, они написали себе, надо было кому-то еще написать, они написали себе. А потом подумал кто-то, слушайте, может сделаем уже open source. Ну давайте запилим open source. Смотри, был же при этом Зукипер, например, был. И это была единственная реализация, она была плохая. То есть Зукипер до сих пор прям нормально, он не догнал по фичам даже свой собственный пейпер. Ну при этом многие до сих пор его пытаются использовать, потому что привыкли, вроде неплохо. Не знаю, ты не докажешь мне по-другому ничего. Не знаю, Валер, ты как бы преувеличиваешь, мне кажется, значение. То есть я считаю, что распределенщина очень нужна, очень важна. Мне поэтому интересно двигаться в этом направлении. Но реально она вот сейчас стала очень сильно актуальной, когда наконец поняли, что горизонтальное масштабирование рулит и бибикает. До этого все просто думали про вертикальное и все. Это поняли, когда я еще был в университете, а сейчас я уже с неплохим опытом работы. И как бы ситуация стала меняться только в последние пару лет. Да, потому что только в последние пару лет нагрузка стала такая, что один вертикально выращенный сервер не выдержит нагрузки. Да вот именно, что один вертикально выращенный сервер сейчас такой, ну взять вот этот недавний терабайтный интенс на Амазоне, да в него влезет большинство людей, которым нужна веб-скейтмонга. Тогда тем более не надо никаких… А может быть потому, что сейчас получили широкое распространение клаудсервисы, и там дешевые машины можно легко заказывать. Вот тоже, да, согласен. Дешевые машины, их стало много, и давайте-ка сделаем распределенщину. Ладно, давайте свернем тему, мы… Согласен, но мне понравилось. Я скорее за то, что было много факторов. Не только потому, что появились языки программирования. На самом деле, наверное, все сыграло свою роль, и в итоге мы получили то, что имеем. Дальше я предлагаю продолжить тему про JavaScript в некотором смысле.",
    "result": {
      "query": "уровень абстракции языков программирования Erlang OTP"
    }
  }
]