[
  {
    "segment_id": "b5fb7459-3c15-4fe0-9e71-2bb66eeecaf1",
    "episode_id": "a1000849-a5ae-4c5f-b830-55e574e16d1e",
    "episode_number": 85,
    "segment_number": 4,
    "text": "Пара деприкейшенов, пара импрувментов в API, пара улучшений визибилити, всякая статистика виртуальной машины. Собственно, я вот это и хотел обсудить. Тебе не кажется, что последние года, наверное, 4 в мире Аирланга, ну, собственно, ничего не происходит? Нет, ну ты не совсем прав, там на самом деле довольно дофига происходит в виртуальной машине. Там было по меньшей мере парочка таких супер существенных изменений, которые аффектят масштабируемость виртуальной машины. В частности, то, как они время теперь меряют, то есть ты помнишь, раньше был AirLang Now и iOS Timestamp. Сейчас там тонна вызовов, которые позволяют это делать. Ну то есть вот то, что они добавили новый вызов измерения времени, это прям радикальные изменения. С точки зрения VM, Саш, да. Ты сейчас можешь выбрать, что именно тебе нужно, на Samsung не знаю, тебе нужен уникальный Интеджер, поэтому тебе достаточно просто энтропии. Или тебе нужен строго монотонный Интеджер, или тебе нужно сильно монотонный Интеджер, который не отрицательный. Или тебе нужно время, или тебе нужно время, которое гарантированно не повторяется. Вот в зависимости от того, какой уровень ты выбираешь, ты можешь, то есть чем меньше гарантированы тебе нужно в этом Интаджер, тем меньше синхронизации будет происходить в виртуальной машине, тем лучше это масштабируется по ядрам, например так. Это первое большое изменение было, во-вторых, там продолжают допиливать мапы, что на мой взгляд довольно важное изменение, потому что просто сама поддержка мапов-то ни о чем, нужно чтобы они хорошо работали, и в 18-ом они довольно хорошо работают тоже. А вы используете? Да, ну в смысле в Алексире тяжело их не использовать на самом деле. В Алексире, насколько я знаю, свои мапы. Ну вот именно что они сейчас в новых версиях, если ты в Алексире работаешь, во-первых, свежая версия компилятора, то есть начиная с 17-го ланга в Алексире свои мапы почти не используются, они их почти задеприкетили. Интересно. Ты знаешь, я вот время от времени думаю про Алексир, вот когда в метро еду, думать особо не о чем, я про Алексир думаю. И вот для веба его стоит брать? Да, однозначно. То есть лучше, чем Руби? Точно лучше, чем Руби. Ну смотри, если тебе нужно сделать крут, то Руби может быть лучше просто по тому принципу, что у тебя есть уже гемы для всех возможных случаев. Если тебе нужно выйти за рамки крута немножечко, то в общем-то... Или ты делаешь вообще апишечку какую-нибудь, которая, ну опять-таки да, не просто запрос ответный, там, может что-нибудь стримить откуда-нибудь, то Алексир становится резко лучше. И в том же самом Фениксе там идет такой фреймворк для Алексира, там сейчас моднейший, мощнейший попсап. Он, конечно, мне не то чтобы прям очень нравится, потому что там, как и большинство попсапов в этом мире, там совершенно никак не решают проблему того, дай-ка мне сообщение, которые там случились, пока меня не было. Там для этого есть callback, но сам попсап этого не решает. Как, впрочем, и везде. Но там, например, довольно интересно presence сделан на CRDT, это еще не в релизной версии, но они этим активно работают. У них механизм presence, ну то есть кто в канале есть, а кого нету, он сделан вот очень моднейшим образом, вот CRDT, который converged replicated, коммутатив репликейтедейтатаймс. Вот, поэтому вот presence, система их, она спокойно переживает над сплиты, или там пользователя, зашедшего с нескольких этапов браузера. Вот, ну и в принципе, в плане realtime функционала, Феникс делает любой существующий веб-фреймворк. Я еще иногда думаю про Go, но потом я внезапно вспоминаю там в очередной раз, ну то есть я об этом вспоминаю, а потом все время забываю, а потом заново вспоминаю. Ну, как к слову, иногда всплывает в разговорах, в чатиках. То, что в Go у тебя disk.io блокирующий, вот когда я это вспоминаю, я сразу хочу забыть про Go. Нет, ну он блокирующий, но он же блокирующий в отдельном трейде, в принципе, это не так страшно, потому что, ну, как бы можно написать так код, что у тебя disk.io, он всегда в отдельную гаррутину идет, ты знаешь, что эта отдельная гаррутина будет в своем трейде, и там вокруг этого можно навернуть какой-нибудь rate limiting, который не даст тебе этих гаррутин слишком много запустить. И в принципе, наверное, так жить можно. То есть, ты вот знаешь, ну, короче, закат солнца вручную, то есть в Ирландии, чтобы диск.io не блокировал, там есть пулы синхронных тредов, в смысле, пулы тредов для синхронного диска.io, ну и всего такого, что должно работать синхронно по отношению к Ирландии, но не имеет асинхронного API. Вот, и по сути ты можешь в Go как-то вручную проэмулировать это поведение. Ну, я понял твою мысль. А вот еще, ты как главный специалист по Ирландии, ну, если у нас есть специалисты по Go, я не знаю, Андрей, ты... Не, я что хотел сказать, просто вот такая же штука, как и в Ирландии, когда у тебя есть отдельный пул тредов для того, чтобы делать блокирующие операции, точно так же сделано, по-моему, и в Node, и по-моему, даже в Ruby. И мне кажется, что в Go тоже такой пул есть. В Go именно там нет специального пула, там немножко по другому поведение, если я правильно помню, что мне описывали, я сам небольшой гофер. Вот, там ты делаешь дисковое I.O., оно блокируется, заблокированная грутина выделяется в отдельную нитку и не мешает всем остальным. А, ну пул нет. Пул нет, да. Я еще что-то хотел сказать в плане выбора Go для API. В Elixir есть один фреймлок, вот с точки зрения программиста, который решает писать. В Elixir есть один фреймлок, и все пользуются им. Ну на самом деле я лично для API пользуюсь даже не фреймлоком, а просто плагом. Ну окей, плаг, но плаг в Phoenix это как бы часть одного стэка. Ну это часть одного стэка, но плагом можно пользоваться без Феникса. Ну да, окей. Но в Go такого вот низкоуровневого даже аналога плага, которым пользуются все, его нет. И поэтому ты выбираешь что-то одно, кто-то выбрал что-то другое, и потом начинается, что приходит человек, который умеет писать на Go и говорит, вы используете не то, что нужно. У меня к Go немножко даже другая претензия, я тут недавно его ковырял на предмет посмотреть, что там есть. Там в прошлом, или позапрошлым выпуском мы обсуждали, что хотя бы тп2 завезли, я решил на эту поддержку посмотреть. И это, знаешь, такая поддержка из разряда, можно завернуть ваш существующий htp1 сервер в htp2 и будет типа быстрее. Какие возможности htp2 использовать, ну то есть нужно вокруг, то есть у них есть 2 API, парсинг фреймов и возможность завернуть существующий htp1 сервер в htp2 сервер. И есть еще клиент, конечно же. И никакого способа пользоваться возможностями htp2 из своего сервера я там не обнаружил. Возможно я плохой гофер, я допускаю, может кто-нибудь придет в комменты и расскажет, что я не прав, но вот я там возможности нормально пользоваться, там не знаю, тот же самый push stream не нашел. И я посмотрел на то, что делают люди в gRPC версии Go, они походу написали свой собственный htp2 сервер. Ого. Ну да, в Rake тоже так же в Ruby сделали, то есть поддержка протокола есть, но какие-то возможности протокола пока не используются. Ну это как-то очень печально, а зачем такая поддержка протокола вообще нужна, то есть можно же тогда просто поставить какой-нибудь реверсивный проксик, который имеет htp2 и оставить htp1 на стороне самого сервера. Nginx, да. Ну не знаю, наверное больше, я подозреваю, что это больше макеринг из серии, если потом окажется, что это очень надо, то у нас уже есть какой-то задел, который мы начали делать. И с одной стороны, с другой стороны, ну да, если они не начнут сейчас, то потом они будут отставать, поэтому люди делают сейчас то, что могут сделать быстро, а потом будут делать то, что можно сделать долго. И опять же, потом, сейчас они сделали htp2, а потом, например, они сделают push messages и об этом скажут в очередных release notes. Валер, я вспомнил, очень хотел тебя спросить, как там сейчас правильно C прикручивается к Erlang, чтобы не убить ThreadPool? Ну есть сильно больше одного способа, смотри. Ну там про запуск внешнего приложения, вот это можешь мне не рассказывать, меня вот нифы интересуют. Ну смотри, во-первых, у тебя кроме нифы есть еще порт драйвера, как минимум. Если тебе почему-то хочется делать что-то совсем блокирующее, скорее всего тебе стоит как минимум рассмотреть возможность написания порт драйвера. Там в том API, оно чуть более сложное, чем нифовская API, но оно зато позволяет паразитировать активно на event loop Erlang и всякие такие интересные штуки делать. И вот там можно прям конкретно тем же самым ThreadPool воспользоваться, которым пользуется файловый вывод. Во-вторых, со стороны нифов есть уже стабильный API, который позволяет, ну если грубо говоря, самому себе делать подсчет редукций. То есть, не знаю, если мы там прососали, например, каждые 400 байт, которые мы прососали, мы берем и говорим, эй, я выполнил кусок работы, если что мой текущий стрейц, который я могу продолжить, если хочешь, можешь меня выполнить с планировщика. И точно так же тебя потом могут зарезюмить. Вот, и есть другой еще момент, если не ошибаюсь, до сих пор экспериментальный функционал, так называемый Dirty Schedulers.",
    "result": {
      "query": "AirLang VM улучшения масштабируемости время измерений"
    }
  }
]