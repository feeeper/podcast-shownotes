[
  {
    "segment_id": "abbfca8d-374a-4a9f-b5d1-cc941c851722",
    "episode_id": "a6c36ace-4c69-4c55-917c-3d07aafe17ae",
    "episode_number": 50,
    "segment_number": 5,
    "text": "Это идеология такая, контейнер должен быть полностью виртуальным, чтобы можно было на любом железе запустить. Вот если мы видим процесс, который что-то делает с железом, открыл там девайс какой-то или у него диапазон виртуальных адресов с непонятно чем внутри, мы такую штуку не дампим. То есть железо, если есть такая привязка к какому-то конкретному железу, мы железо вообще никакое не поддерживаем. Только виртуальные вещи, которые Linux предоставляет. Обычные файлы, замапленные в память в полный рост, но только файлы на файловых системах и стандартные виртуальные устройства, типа DevNode, DevZero, вот такие вот вещи. А кстати, как файлы мигрировать? Не целиком же вы копируете много гигабайт? Как с памятью или как-то еще? Нет и да. Крио с файловой системой не делает ничего, оставляя это на совесть того, кто Крио зовет. Соответственно, с файлами можно делать разные вещи, в зависимости тоже от сценария использования. Если это живая миграция, то там возможны таких простых три варианта. Вариант первый – это у нас расшаренная файловая система, типа какого-нибудь FSA или SCF. Там вообще ничего делать не надо. Она видна на обоих машинах в одинаковом состоянии, поэтому просто здесь сохранили, там эту файловую систему смонтировали, восстановили – все, все рэдо. Второй вариант – это то, что было в OpenVZ давным-давно. Это когда файловая система локальная, тут делать нечего, ее надо копировать на вторую машину. В OpenVZ это делалось двумя R-Sync'ами. Сначала первый, потом контейнер морозится, потом запускается второй R-Sync, который изменения дотаскивает. Потом остатки миграции добегают. Это второй способ. У него недостаток, с которым мы столкнулись сразу. Он такой простой и банальный. Если у нас есть база данных, там файл на несколько гигабайт, если после первого R-Sync в него хотя бы один байт записали, все, его надо копировать заново. Поэтому мы сделали третий вариант. Третий вариант заключается в том, что контейнер живет не на файловой системе, а внутри виртуального диска. И этот виртуальный диск позволяет копировать его поблочно и позволяет узнать, какие блоки изменились. Сейчас в современном мейнстримном Linux такой функционал, например, предоставляет несколько таргетов девайс-маппера. DMSnapshot, например, или DMSyn. С помощью этих двух ребят такая задача решается. Это три способа, что сделать с файловой системой на миграции. Но, опять-таки, повторюсь, это не забота криу. Потому что, например, при обновлении ядра с файловой системой ничего не надо делать. И если мы делаем ускорение медленного старта, тоже ничего не надо делать. Если мы используем криу, например, для репликации процессов, там были такие идеи, то там нужно и файловую систему тоже реплицировать. А это совсем не то, что мы делали при живой миграции. То есть работа с файлами из криу вынесена. Для живой миграции, чтобы облегчить работу пользователя, мы специально к крию приписали надстроечку, она называется pichal. Это набор питонных скриптов, которые организуют живую миграцию и заботятся о файловой системе. Поскольку pichal знает, что он будет мигрировать контейнеры, он знает, что делать с файловой системой. Он это делает, пытается, по крайней мере. Это уровень абстракции, который уже что-то делает. Да, который криу использует как один из инструментов. Один из блоков. Я предлагаю про крию тогда пока временно закончить. Может быть, мы еще вернемся чуть попозже. И я тогда скажу про второго спонсора. Второй спонсор – это fp.conf. Конференция, которая проходит в Москве 15 августа. Цена билета сейчас составляет 6000 рублей. Идет в два потока в течение одного дня. Проходить будет в Измайлово Альфа. Есть промокод для скидки в 200 рублей. Это слово defzen. fp.conf.ru И там уже сейчас можно посмотреть список участников. Так что заходите, регистрируйтесь, идите на конференцию. Вот. И я думаю, надо переходить уже к нашим темам. Я думаю, что мы еще коснемся вашего опыта, потому что, например, первая тема как раз очень близка вам должна быть по духу. Это как раз про то, как правильно делать патчи в ядро. Как вообще с этим работать. И статья была написана автором, который сделал свой первый патч в ядро. И он рассказывает про свои проблемы и свой опыт, про то, с какими трудностями он столкнулся и как он их обошел. Мне очень понравилось, в плане того, что он интересные вещи описывает. И, к примеру, он... Вот интересные факты. Он говорит, что как бы вы хорошо не знали ядро, даже если вы давно что-то делаете, вам все равно придется что-то у кого-то спрашивать, потому что в новых кусках кода нет никакой, чаще всего, документации.",
    "result": {
      "query": "виртуальный контейнер миграция файловой системы"
    }
  }
]