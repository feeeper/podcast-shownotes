[
  {
    "segment_id": "bcdcb39a-5431-40ef-bc4b-a0f700866087",
    "episode_id": "35aa9cb7-add8-48e8-9289-92d3639f96b2",
    "episode_number": 331,
    "segment_number": 14,
    "text": "Типа ты знаешь, что они правильные, но компилятору ты не сможешь объяснить. Не то, что он не нашел каких-то багов, он слишком туп, чтобы понять, что там багов нет. И это все время путаться под ногами и довольно неудобно. В том, что он очень близок к железу, это, конечно, очень приятно в этом смысле. Ну тут смотри, как для типичных паттернов написания валидных мыслей обычно есть какие-то примитивы, даже в стандартной библиотеке или, возможно, в популярных библиотеках, которые реализуют то, что нужно через Unsafe и так или иначе предполагают, что они тестируются. Ну и в целом, наверное, когда мы говорим о... все-таки ниша Rast, так как они сами себя позиционируют, это какие-то вещи, которые критичны к тому, чтобы не истекать памятью и не быть местом, в котором производятся ошибки первого дня или какого-то нулевого дня в промышленных масштабах. Поэтому, наверное, не мочь выразить какие-то мысли, это нормально, если твоя цель это не быстро описать программы, а описать программы, которые не приведут с хорошей вероятностью к эксплуатации. Ну то есть, грубо говоря, чтобы быстро описать программы, я лучше вообще возьму или даже какой-то еще более высоковысковым языком, ну, тот же самый GVM. Получается, что ZIG это такой язык, который, мне кажется, это было бы здорово там... Ну, мне кажется, это язык, который здорово ляжет на что-то вроде людей, которые занимаются встраиваемым кодом, но не для продакшена, а по фану, то есть им нужно по-быстрому что-то накидать, или C++ для этого слишком низковысковывываю, или стеромодные, RAST для этого слишком замороченный, Go туда просто тяжело впихнуть в некоторые устройства, а вот ZIG запросто. Ну, короче, да, вот эта сложность RAST, она мне не очень нравится. Ну, а про то, что есть паттерны, я не знаю, как бы для меня, я читал статьи Рафа Левина, который... где редактор Кси писал когда-то на RAST, у него была вот такая идея, типа давайте возьмем современный язык, он вообще большой фанат RAST, как бы, и напишен на нем нормальный текстовый редактор, современный, СРДТ, он туда еще запихал, короче, много всего, вот, и он в том числе UI-библиотеку на него писал, и он в какой-то момент писал такое, что типа вот на RAST ты не можешь просто придумать и написать UI-библиотеку, тебе нужно специально спроектировать UI-библиотеку так, чтобы она была выразима в языке RAST, то есть ты не можешь сделать так, как ты хочешь, ты должен учитывать ограничение языка еще при этом, вот, и это довольно печально. Это знаешь, это очень странный аргумент, потому что я вот буквально, я уже упоминал в прошлом выпуске, что пройдет GULANG-conf 24-24 апреля в онлайне, и я готовлю для нее воркшоп, и я его готовлю по следам такой типа маленькой штуки, которую я делал для коллег, и потом повторял для некоторых патронов и коллег к подкасту, ему изначально воркшоп был написан на скале и использовал библиотеку ScalaCheck. В GULANG-е в принципе экосистема больше про фазинг, там очень много хороших туллов для фазинга, потому что оттуда вырос туллов, которые были бы похожи на QuickCheck, их всего две библиотеки, обе довольно похожи на скала, и одна из них перенесена откуда-то со стороны питона, а другая откуда-то со стороны калькаса ScalaCheck. И вот несмотря на то, что ScalaCheck удалось с мучениями выразить на ГО, этим пользоваться невозможно. То есть, что я хочу сказать, что у тебя в любом случае и диаматика языка будет диктовать API и структуру библиотеки, иначе это тяжеловато, просто возможно, если у тебя есть похожие языки, там скажем, Java от C Sharp отличается, современная Java от современного C Sharp отличается не так радикально, как скажем, они оба отличаются от ГО. Или Rasp. Погоди, кого ты не смог, ты ScalaCheck на ГО, а что такое ScalaCheck? Знаешь, что такое QuickCheck? Да. Ну вот, ScalaCheck, а так QuickCheck на Scala. Вот, и на ГО есть две библиотеки, которые реализуют QuickCheck, есть GoPter и есть Rapid. Rapid сделан на... ну, вдохновлялись питоновской Hypothesis, которая тоже там типа порт QuickCheck на Python. GoPter, они вдохновлялись, собственно, ScalaCheck, он прямо практически, если смотреть, он очень похож в плане того, как API сделано. И вот GoPter пользоваться очень тяжело, потому что он вот... поскольку переносили ScalaCheck, то как бы на ГО так писать очень тяжело, то есть вот там не используется ГОшная идиоматика какая-то. Тогда как Rapid сделан, так как если бы библиотека была, то сразу написана на ГО, и этим прям, не знаю, в миллион раз удобнее пользоваться. Она при этом не самая лучшая реализация QuickCheck, но с точки зрения показать, как к этим пользоваться, вообще, ну, там, типа, а не объяснять синтаксис и странные идеосинкразики в библиотеке, он гораздо лучше подходит. И, соответственно, вот я к чему все это сказал, что ты говоришь, что нужно там спроектировать библиотеку с счетом языка. Вот я как раз пытаюсь сказать, что у тебя в любом случае это нужно делать, просто у тебя есть группа языков, которые похожи, есть группа языков, которые там, есть какие-то языки, которые похожи, не похожи на другую группу. Соответственно, перенос чего угодно с джавы на ГО будет тоже очень сложным, типа, что тебе нужно будет иметь идиоматику. Вот перенос между джавой и си шашкой, например, будет проще, им хо. Не-не-не, в смысле, там нет переноса. Ты говоришь, да, про то, что есть библиотека, которая, типа, создана вокруг синтаксиса языка, естественно, она не переносится на синтаксис другого языка. А я говорю... Ну, вот ты говоришь, что есть нормальный QuickCheck для ГО. Ну да, ну в смысле, смотри, просто к тому, что ты даже, как ты его будешь внутри писать, можно по-разному уже писать, и ну, я не знаю, наверное, в каких-то случаях с QuickCheck это не очень интересный вариант, но, типа, если ты пишешь что-то под ГО, ты будешь проектировать с учетом или там Ирланд. Ты будешь проектировать с учетом того, что есть легковесный какой-то примитив. Если ты писал, не знаю, на Си, то, скорее всего, ты наколбасишь Event Loop с ручным управлением трэдами. И с этого сцена ты будешь все спроектированно по то, чтобы можно было работать с Event Loop с ручным управлением трэдами. Окей, ну, может быть, я неправильно себе представил, что конкретно имелось в виду, потому что это мысли другого человека, я пересказываю, они свои. Но насколько мое знакомство с Rastam позволяет, там обычные нормальные вещи, которые нет причин не иметь возможности делать, вроде бы, ну, типа, там прочитать поле какого-то объекта, который у тебя уже есть в руках, в Rast, типа, ты не можешь это сделать, потому что reasons. В остальных языках ты можешь это сделать. Вот. Наверное, у кого-то какие-то есть у этого объяснения, но, тем не менее, это не делает его ограничивающим и противоестественным по сравнению с остальными. То есть как-то так. Rast тебе нужно больше усилий прикладывать, чтобы думать о том, что язык тебе не разрешает делать, вместо того, чтобы думать о том, какую задачу ты пытаешься решить. А вспомни, наверное, у тебя было похоже ощущение, когда ты впервые разбирался с функциональным программированием, и ты такой, блин, всегда бы здесь можно было присваивать, а здесь нельзя. У тебя не было такого? Есть, и до сих пор есть. Ну, вот понимаешь, да, как бы это с той же серии. Ну, при этом мы в целом эвангелируем много лет за то, что вообще разрушающее присваивание это очень опасный примитив, и он, конечно, очень мощный, иногда очень нужен, но если удается без него, то лучше без него. Вот тут, в общем-то, такая же история. Ну да, но, тем не менее, я им пользуюсь каждый день. Он во всех функциональных языках он есть, но может не во всех, но в нормальных есть. Ну, как бы в Расте тоже есть способ выйти за стандартные ограничения, просто, ну опять же, если удается без них, лучше без них. Окей, да, здесь в моем мнении нужно очень скептически воспринимать, потому что у меня очень мало опыта работы с Растом, и желаний тоже мало, если честно. Ну, я тут тоже такой Растоман с медиума. Я просто как-то стараюсь играть с Кривидо, когда дьявола, чтобы было достаточно подосудения. Да, типа давайте придумаем современный C++ и не на 20 лет размажем вот эту фичу крип, а сразу в первый же год захерачим туда миллион фич, которые не поймать как бы взаимодействует, на каждой проблему есть какая-то своя приблуда, все это нужно запомнить, ну может у 18-20 летних людей голова резиновая, у меня уже не резиновая, мне тяжело. Может быть это просто потому, что я жалуюсь, потому что мне тяжело учить Раст. C++ это язык такой, да, ты сейчас упоминал? Да. Ваня мимикрирует под тенейджера. Hello, hello, kids. Я пишу на C++, это вообще треш конечно страшно, я просто не понимаю как люди выживают с этим. Вот это странно, я думаю, что после опыта продакшна на крестах, люди начинают резко любить Раст, похоже я был не прав. Нет, в смысле да, но по сравнению с нормальными языками, Раст это все еще ближе к C++, чем к нормальным языкам. Так в этом же идея. В чем идея? В C++ нет ничего хорошего. C++ это отвратительно, это design by committee, это миллион фич, это что-то, что ты никогда не понимаешь, как до конца работает, это новый синтаксис каждый день, типа ты 5 лет работаешь в C++ и все еще узнаешь новые фишки и новые синтаксы. Это кошмар, это сплошные минусы. Единственное, что в Расте до сих пор лучше, чем в C++, это то, что там, где в C++ успели разбежаться и нагенерировать миллион вариантов всяких флажков и еще чего-то, в Расте это пока еще не слишком народ разбрелся, но тенденция такая, что наверное это рано или поздно прийдет. Тенденция не к упрощению, а к усложнению и нарастанию возможностей места какого-то в общении. Я хочу за счет Ураста сказать, что там понятно, как работает, там очень хорошо документированный процесс design by committee с RFC и pull requests с квестами вот этим всем, поэтому в принципе при желании разобраться, как что-то работать можно и как-то дизайнироваться тоже, я согласен с тем, что design by committee и вот я про это как раз говорю, что так и задумано. Типа да, мы делаем язык за C++, некоторое сходство с омерзительными чертами C++ останется. Чего заменить C++, если не делать так? Это мне непонятно, понимаешь, у C++ нет положительных черт, все недостатки, не плюсы, зачем их копировать? Плюсы понятно, чем копировать, чем недостатки это копировать? Даже если это комменитет. Ну я не думаю, что они осознанно их копируют, я думаю, что в результате работы над заменой некоторого языка, который используется в некоторых там областях, повторение каких-то вещей, опять же, некоторые аспекты, типа там, не знаю, те же самые futures мы недавно обсуждали, продолжение как-то future имплементация в то, как она в разе сделана, да, там есть шероховатости, но нужно понимать, что это первый вообще язык с не... как это блин, с управляемой памятью, управляемой не грабыч коллектором, а вот при помощи системы типов, в котором так вообще хоть как-то реализовали вот эти futures и блин, ну, короче, да, они периодически делают ошибки, периодически делают херню, но это неизбежно, и то есть, когда ты... у тебя есть такое огромное поле, где используется C++, ты стараешься не сделать точно такую же ошибку, но скорее всего ты какую-то ошибку сделаешь и, возможно, то есть, человек пытается сказать, что C++, он такой, какой он есть, не потому что люди, кстати, хотели сделать плохо, а потому что люди решали проблемы, и, типа, постепенно понимали, что такие-то решения были дурацкие ну, организационная особенность, типа, дизайн системы отражает организационную структуру организации, которую дизайнила, ну, как бы это известное правило, и здесь то же самое, да? Есть замечательная книжка с авторством господина Староустропа в русском переводе дизайн и эволюция C++, и там от автора языка написано точно, почему те фичи были сделаны так или иначе. Ну, с тех пор навезли еще много чего другого. Короче, я согласен насчет того, что это первый язык с управляемой памятью, ну, в смысле, с таким управляемой памятью, и хочется на второй очень посмотреть. Первый мне не очень интересно, а на второй интересно, да. Следующая тема, Даша, наголосованная, это... И это, кстати, интересная идея, я сейчас очень много по этому плачу. Лучшее техническое собеседование, что мы проводили, это совместная игра Факторио. Для тех, кто не знает, Факторио такая инженерная игра. Я все хочу ее купить, но я боюсь, потому что я тогда перестану ходить на работу. Вот. И я по этому поводу очень сильно плачу сейчас, потому что для того, чтобы сейчас в современном мире проходить собеседование в разные компании, особенно в такие компании, которые много ищут людей, необходимо знать те вещи, которые в обычной жизни тебе скорее всего не пригодятся. Там, не знаю, несколько видов сортировки. Чем они отличаются, чем они не отличаются. Вот насколько часто это понадобится в вашей жизни, это вообще не важно. То есть не важно, что тебе это не понадобится вообще, никогда ты не будешь делать сортировку. Но ты должен это знать для того, чтобы пройти в компанию. Хорошо это или плохо, ну, не знаю. Я понимаю, что... Почему компании это ввели, они таким образом хоть как-то могут фильтровать, потому что иначе фильтровать вообще не почему. И очень тяжело ввести какие-то формальные методики. А здесь они могут фильтровать по тому навыку, который может понадобиться в дальнейшем инженером, и поэтому они говорят, ну, давайте вы будете все учить все, что вам никогда не понадобится, а мы потом будем по этим вашим ненужным знаниям фильтровать, но мы зато можем понять, насколько вы быстро можете учиться. И, возможно, это все-таки когда-нибудь вам понадобится. Вот. Возможно, что игра Factorio это неплохая альтернатива этому. Она тоже имеет свои недостатки и преимущества, но как бы нет хорошего ответа на этот вопрос. А про что хоть игра эта? Мне прям даже интересно стало. Организацию большого-большого мегазавода автоматизированного. Ты... Открой, короче, статью и посмотри на гифки. На гифки посмотри, да. То есть как бы там идея в том, что ты как будто бы ты начинаешь на новой планете что-то делать, первая идея ты можешь начать копать.",
    "result": {
      "query": "зачем использовать язык Rust вместо C++"
    }
  }
]