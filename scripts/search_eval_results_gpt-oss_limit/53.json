[
  {
    "segment_id": "57bfda28-e4bb-4209-aa93-04117794e367",
    "episode_id": "e3af8813-6178-439e-a675-a194c0f6c5f4",
    "episode_number": 53,
    "segment_number": 6,
    "text": "Я потом ломаю себе эту привычку, и я вижу, что это на порядок удобнее. И вот в том докладе был такой именно поинт. То есть если вы видите, что вот что-то там прямо совсем неправильно, можете прям обрадоваться и записать это, что вот проверю через две недельки, как я буду к этому относиться. Но суть в том, что вот эти все вещи в Go, они специально сделаны, не так, как мы привыкли в других языках. И каждое вот такое решение, оно месяцами сначала обговаривалось, все возможные решения, дизайн очень-очень продуманный, то есть там нет таких вещей, что с бухты барахты взяли. Ну вот у меня проблемы были похожие, да, то есть именно неиспользуемые импорты, неиспользуемые переменные. Что мне не нравится в Go, это правила про скопинг, когда можно зашедувать переменную, которая находится в внутреннем скопе. При этом, если это множественное объявление переменной, то одна переменная объявляется, одна скрывает другую. И мне кажется, это место все-таки довольно в Go слабое. Мне не нравится сравнение интерфейсов с nil, и вообще ключевое слово nil, мне кажется, имеет слишком много смыслов. Но в целом это все такие мелочи, которые поначалу непривычно, а потом ты их просто знаешь. Притом nil в Go, если я не ошибаюсь, это на самом деле что-то типа пустая строка или как-то так, или нет? Нет, нет, nil — это ключевое слово, которое является одновременно и нулевым указателем, и нулевым интерфейсом. И это иногда вызывает проблемы, например, если у вас есть какая-то функция, которая возвращает какой-то конкретный тип, а вы его принимаете по интерфейсу, то этот интерфейс не будет равен nil, потому что у него есть конкретный тип. Этот случай даже объяснил Go FACU, но он все равно довольно спорный, на мой взгляд. Я пока полистал эту спеку по вендорам, я правильно понял, что на самом деле эта штука позволяет, ну что она добавляет, она позволяет указать тег или ветку, которую я чекал, больше она особо ничего нового не делает. Ну смотри, по поводу вендоринга, я немного расширю, что Ваня говорил. На самом деле таких решений, их появилось очень-очень большое количество сразу после выхода Go 1.0. То есть я был одним из тех людей, который начал делать свои решения по аналогии с RubyGems или PyPit для Python, для централизованной репозитории, которая позволяла бы использовать версии и так далее, стандартный механизм. Таких появилось несколько конкурирующих спецификаций, которые по сути описывали одни и то же. И вендорспек — это такой некий общий подход, который бы позволил использовать разные тулзы, но с одним и тем же форматом. Нет, я же как бы не критикую, я на самом деле... Меня тоже то, что в Go удивило, когда я там начал его изучать более-менее подробно, там я читал, типа, что за фигня, нет менеджера пакетов, да, как же так? Потом почитал вот этих факт и подумал, что у них там действительно нормально написано, что вы делаете пакет, не ломаете в нем обратную совместимость, только добавляете новый функционал, и его будут люди чекаутить, соответственно. Если вы ломаете обратную совместимость, то там назовите его пакет.версия2, например. Вот, в принципе, это нормальный подход, имеет право нажать, почему нет. Немного смущает отсутствие централизованного репозитория, где все пакеты, с другой стороны, есть этот asm.go список. В какой-то степени это централизованный репозиторий. Есть централизованный репозиторий, который называется go.org, это сервис для документации, но на самом деле он вполне себе служит источником пакетов. Ну да, или как вариант. То есть я на самом деле не критикую, я хотел просто узнать, правда ли, что вендорспек в дополнение к тому, что сейчас есть, позволяет указывать еще и коммиты. Да, давай я немножко сделаю небольшой экскурс в это. Было несколько решений для версионирования, для dependency локинга и для вендоринга. То есть версионирование и вендоринг – это два разных процесса, которые часто идут вместе. И эти утилиты использовали каждый раз разный формат. И когда шло обсуждение в mail.usd о том, чтобы какое-то решение сделать стандартным или прийти к нему как к стандартному, все уперлось в форматы файлов. Вендорспек фактически только говорит формат файла, и да, там можно указывать и коммит, и тег, и… То есть только вот для этого. Соответственно, есть флаг вендор, который будет отвечать только за вендоринг, и есть вендорспек, который будет отвечать за версионирование. Соответственно, могут быть разные сценарии, когда людям нужен локинг версии, но не нужен вендоринг. Они не хотят свой приватный, например, репозиторий тянуть все зависимости. Есть такие, которым все нужно вместе. Вот так. Вот версионирование, я понимаю, что это такое. Что такое тогда вендоринг, в чем он отличается? Или почему это вообще совершенно другая вещь? Вендоринг — это когда ты все зависимости кладешь себе локально в свой приватный репозиторий. То есть у тебя интернет пропал, или гитхаб упал, но ты хочешь, чтобы у тебя код все равно билдился. Вот это называется вендоринг. Вендоринг — это то, что, например, если ты делаешь боллер-инсталл или боллер-апдейт, и все, что он стянул, ты себе локально сохраняешь в своем гите. Мы со Светой понимаем, да, это кэш Мэвена. Точка IV2. Ну, наверное. Если я правильно понимаю, как работают IV и Мэвен, то не совсем, потому что Мэвен все равно идет на центральный репозиторий, чтобы смотреть, есть ли там что-то более новое или нет. Вендоринг — это когда исходники целиком колбятся рядом, и никакого доступа в интернет не происходит. У тебя в Мэвене указывается версия, которая тебе нужна, и если она у тебя есть локально закэширована, то никуда он не пойдет. Окей, хорошо. Ну, кэш — это как вариация этого. Есть, например, у того же NPM или Bower тоже есть свои кэш, которые можно поставить у себя в локальной сети. Это актуально, когда у тебя много разработчиков. Но если хочешь, чтобы железно, чтобы не... Сейчас весь мир рухнет, а ты хочешь, чтобы у тебя код билдился, то обычно все зависимости кладут себе в какую-то подпапку, там, вендор или еще какую-то. И вот этот процесс называется вендоринг, и он, в принципе, не связан с версионированием. Ты можешь тянуть всегда последний мастер и класть, можешь один раз себе стянуть и никогда больше не обновлять, там, просто убедиться, что работает. Сценарии разные есть, но в целом важно различать, что это два различных процесса — вендоринг и версионирование, которые часто идут вместе. Алексей, кстати, может быть, я и гоню, потому что на самом деле больше работаю с SBT. Вот насчет SBT я довольно уверен, что он никуда не ходит, а Maven — нет, не уверен. Ну, я тоже, конечно, в Maven не спец, но возможно. То есть идея самого вендоринга — то, что никакого сетевых запросов точно не происходит. Он на самом деле даже и не знает, что это чужой код, это просто код, который лежит у тебя в твоем жильпоистоле. А вот такой вопрос. Из тех моментов, которые в Go на первый взгляд кажутся странными, я себя более-менее смог убедить, что мне не нужны исключения, потому что, ну, действительно, приходится писать чуть больше кода, зато ты точно знаешь, что происходит, нет вот этого неявного поведения, которое Света, например, очень не любит, неявное, все неявное. У тебя, поскольку, ну, это довольно хорошо работает со всей этой схемой, ну, со всем этим CSP в Go, потому что будь у тебя актер, у тебя нормально работают исключения, потому что, ну, бросилось исключение, актер умер, перезапустился, все отлично. Но, поскольку актеров нет, то вот те самые исключения в CSP, это довольно неудобно. Потому что непонятно, что делать с Гурутиной, если она вот умерла внезапно. Нет исключений, нет проблем. Попросите, что такое CSP? Я не помню, как правильно это расшифровывается, но это вот… Communicating Sequential Processes. Это вот Гурутина так называется? Нет, это… Гурутина и каналы между ними. Ну, это труд Хоара, с 78-го, по-моему, года, по которому была построена модель Гурутины и каналов. На самом деле, CSP и актер — это изначально одна и та же концепция, она немножко развернулась в разные стороны, но из одного можно сделать другое, по сути. Ну, да, они друг в друга конвертируются, то есть вот у нас с тобой свет модель актеров, а у ребят CSP. Я бы почитала эти пейперы, если это доступно. Если очень кратко, то принципиальная разница, что в модели актеров есть неанонимные процессы, да, именованные процессы, у каждого свой mailbox, и отправка и прием сообщения всегда синхронны. А в CSP процессы анонимные, каналов может быть несколько, это обычные переменные. И по умолчанию отправка и получение синхронны. Но опять же, с одного можно сделать другое, можно сделать буферизированные каналы, тогда будет оно как бы асинхронно и так далее. Я бы сказал, что намного важнее, что в модели актеров у тебя считается нормальным, если что-то умирает, потому что этот crash, мы пишем распределенную систему и не можем поймать все ошибки, и нам не нужно, если они там раз в три года происходят. Поэтому если что-то пошло не так, с большой вероятностью что-то пойдет не так, но мы просто перезапустим соответствующее под дерево актеров, и все нормально. Это первый момент. Второй момент, что в модели актеров у тебя по одной очереди процессы, и она нетипизированная. Туда свалится все что угодно. В CSP у тебя каналы все типизированные, но правда туда можно интерфейсы класть. Да, можно сделать туда пустой интерфейс и класть все что угодно. И у тебя один процесс может из любого количества каналов читать, писать, все что угодно. Да, но в целом из одного можно сделать другое. То есть в модели актеров можно сделать некий протокол, который будет требовать подтверждения, и сделать тем самым синхронную отправку и получение. А это было в контексте того, что меня не смущает отсутствие исключений, ну нормально, можно с этим жить. Меня не смущает отсутствие серьезного пакетж менеджера, потому что действительно есть что-то в этой их идее, что правильное управление пакетами это сложная задача, и она действительно сложная, потому что возникают конфликты и так далее. То есть тот же самый кабал хелла и все такое. Но вот что мне до сих пор не дает покоя, это отсутствие генериков. Вот успокойте меня, как жить без генериков? Ну давай я начну с того, что я вкратце продаюсь по двум другим твоим вопросам. То есть исключение в Go на самом деле есть, там есть механизм паники. Другое дело то, что аналогичный механизм кетч не достаточно удобен, чтобы использовать его как кетч. Я дополню, извини, по-моему они во всех татуировках пишут, делайте это только в крайнем случае, то есть если вообще все сломалось и ничего починить нельзя, тогда делайте паник. Да, да. Алексей, ты сейчас вводишь в заблуждение слушателей, потому что паник рекавер никогда не должны использоваться как замена исключений. То есть это действительно на тот случай, когда ну все, уже нельзя программу продолжать, ее нужно крашнуть. Я хотел бы все-таки расширить, зачем этот механизм нужен. То есть механизм паники действительно в 90% случаев должен использоваться так. Есть два, на мой взгляд, случая, когда использовать паник рекавер можно для другого. Во-первых, если у тебя есть глубокий рекурсивный вызов, и ты хочешь выйти из него быстро, а не так, что каждый раз делать ретурн-ретурн-ретурн на каждом элементе, на каждом входе, то можно сделать паник. И в смерть-библиотеке такие места есть. Второй механизм это если ты делаешь паник рекавер полностью в рамках своего пакета. В целом, если у тебя паники не вылетают за рамки твоего кода, за рамки твоего пакета, то почему нет. То есть механизм в целом паники есть. Другое дело, что использовать его как исключение не надо, но если очень хочется или есть какая-то особенность, то можно. Про пакетный менеджер мы вкратце уже сказали, и количество решений действительно очень большое. Что касается дженериков, на самом деле дженерики в ГО есть. Они называются интерфейсы. То есть почти во всех случаях, когда нужны дженерики, интерфейсы полностью решают задачу. Давайте разберемся, что мы называем дженериками. Вот что я понимаю. Может быть, моя терминология отличается от вашей или вообще принятой. Тогда поправьте меня. Я имею в виду, что ты можешь объявлять типы. В ГО это делается. И я хочу эти типы параметризовать. То есть я хочу сказать, что у меня не просто список, а у меня список от Т. И я могу сделать список интендеров, список каких-нибудь кошечек, собачек и так далее. То есть я под генериками понимаю параметризованный тип. Смотри, если мы сейчас говорим про контейнеры, то это немножко отдельный вопрос. И я хотел про него потом сказать. Все, что касается, кроме контейнеров, оно дженериками решается, точнее интерфейсами. То есть в каком случае тебе нужны еще дженерики, кроме контейнера, например? На самом деле, я тебе перебью. Есть документ очень хороший, называется Summary of GO Generics Discussions. Я могу его сейчас добавить в Show Notes. Это такой массивный документ, который по ходу еще и обновляется. В нем вопрос дженериков развернуто описан, но без контекста какой-то стороны, да, за или против. Там расписано, что люди подразумевают по дженерикам, типа дженериков. В частности, что есть generic data structures, а есть generic algorithms. И эти два вида дженериков, они абсолютно по-разному решаются. То есть в GO есть свои решения, допустим, для алгоритмов, но для дата структур, там действительно этого нет для кастомных типов. Для своих типов там есть map, а дженерики там есть встроенные, но ты не можешь создавать свои типы дженериков. Да, то есть есть массив, мэп, и он действительно параметризуется, но ты не можешь делать свой. И ты не можешь, например, вот ты спросил, Леш, где нужно помимо контейнеров, где нужно еще, когда ты пишешь обобщенный код. То есть у тебя есть какой-то метод, я, наверное, конкретно сейчас не приведу, но, условно говоря, он принимает один из этих пресловутых контейнеров, а может быть это не контейнер, а что-то более хитрое. У нас в скале это футуры, в GO это не очень актуально, хотя даже поверх гурутин футуры имеет смысл в некоторых случаях. Но неважно, у тебя есть какой-то, тебе приходит на вход параметризованный тип, например, что-то-что-то от T, и ты хочешь вернуть вот это самое T. И тебе на самом деле все равно... То есть ты сейчас говоришь именно об алгоритме, который не зависит от типа? Ну да, для простоты, у тебя на входе какой-нибудь контейнер от T, ты берешь из него, находишь максимум плохой пример. Хэт, например. Первый элемент берешь, хэт. То есть ты должен, у тебя на входе лист от T, а на выходе T. И тебе как бы все равно... Ты с самим T не работаешь, но ты хочешь получить безопасный код, который тебе возвращает именно то, что ты передал в контейнере. Да, смотри, давай я отвечу. На практике, как правило, таких проблем с твоим примером не возникает, потому что для основных контейнеров, для основных T, для основных... Основные контейнеры, они есть в GO, вот тот же мэп, да? И он используется в большинстве случаев. То есть там, где кто-то привык использовать лист, можно использовать спокойно мэп, и это решит половину проблем. То есть для встроенных типов есть генерики. Теперь давай возьмем такой пример, скажем, сортировку. Вы знаете, как стандартный стадилип, сортировка устроена в GO? Я знаю. А я нет. Давай расскажу. Для меня это тоже было, кстати, таким интересным открытием. У тебя есть тип, ты определяешь свой тип. Это может быть сложная структура с миллионом данных и полей, и тебе нужно ее сортировать, допустим, по какому-то вложенному полю. Как это делается? На свой тип ты пишешь три метода, которые будут удовлетворять интерфейсу, определенному в пакедже SORT. Это конкретно три метода LESS для сравнения SWAP и определения длины LEN. Для большинства случаев достаточно просто LESS, чтобы сравнить элемент и ты, и следующий, кто из них больше. Но для удовлетворения интерфейса нужно все три метода определить, и все. И ты используешь стандартную функцию SORT.SORT, и в нее кормишь слайс из своего типа, и все. И он сортирует. Алгоритм работает дальше сам, но не основываясь на типе, а основываясь на том, что твой тип реализует вот эти методы, он из них вызывает эти методы. Это на самом деле... Я такого раньше не встречал. Может быть, это где-то есть в других языках. В других языках это сделано наверняка, но мне это дико понравилось. И таким же методом реализовано очень много, можно найти и binary trees, и много всего. Да, но я же не говорю, что на GO какого-то кода вообще нельзя написать, например. Изерик, кстати, она не только в GO так и есть. Но у тебя проблема в том, что на выходе у тебя получается, насколько я понимаю, слайс из интерфейсов, правильно? Нет, смотри, сортировка, она меняет слайс по месту. Если мы говорим о какой-то общей функции, которая принимает некий t и что-то с ним делает, возвращает t, то ты, как правило, не можешь вынюхать конкретный тип, если ты принимаешь t, поэтому ты возвращаешь интерфейс. Ну, краткий ответ, насколько я понимаю, что этого нет и не будет, и надо смениться. Нет, я думаю не так. Смотри, краткий ответ, что если ты делаешь что-то кроме контейнеров, то это на самом деле решается интерфейсами. Мы сейчас, видимо, не очень можем друг друга понять, но в целом, да, если у тебя есть какая-то функция, которая делает что-либо с t, и это t отличается поведением, то это разное поведение прячется с интерфейсом, реализуешь общий интерфейс, принимаешь t и используешь его. Что касается контейнеров, то тут либо используешь встроенные, либо есть старый, проверенный способ, код генерации. Опять же, есть довольно большое количество инструментов, которые позволяют тебе писать код типа с шаблонами, и затем запускаешь тулзу, и после этого получаешь конкретную реализацию этого кода. То есть это такие темплейты на уровне прекомпиляции, можно сказать. Я бы не сказал, что это очень полезно, конечно, и я сам такую тулзу один раз делал, но это было скорее для демо, на практике не нужно было. Да, на практике, наверное, пока кода генерацию для замены дженериков никто не использует, хотя это возможно, и есть уже вокруг этого масса оберток. Но я не уверен, что я правильно объяснил или доступно объяснил идею того, как сделана сортировка, ну пусть это останется на домашнее задание заинтересованным слушателем. Посмотрите, там на самом деле, Саш, там нет, ты на выходе не получаешь какой-то абстрактный интерфейс, который ты должен потом приводить в рантайме к нужному типу. Ты получаешь тот же тип. Фактически операции сравнения или операции смены мест в твоем слайсе реализуются для конкретного типа, и дальше алгоритмом уже кормится твой тип уже с готовыми этими методами. Не знаю, доступно ли я объяснил, но... Да нет, я понял, я просто мыслил функционально, что у меня есть что-то на входе, что-то на выходе, а у вас все меняется на месяц, потому что язык температивный. Да, если ты хочешь делать функцию, которая возвращает новый результат, ты конкретный тип торнуть не можешь, потому что T у тебя в данном случае это интерфейс. Я в принципе понял объяснение, ну нормально, нет, имеет право на жизнь. Да, а краткое решение в том, что да, конечно же, есть какие-то случаи, когда действительно было бы удобно иметь встроенные дженерики, например, как в других языках, как те же темплейты C++, но на практике, учитывая все эти вещи, которые мы только что озвучили и какие-то еще другие, на практике таких",
    "result": {
      "query": "Go vendor spec commit tag usage"
    }
  }
]