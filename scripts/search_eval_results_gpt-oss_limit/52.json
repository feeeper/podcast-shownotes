[
  {
    "segment_id": "25d63fe1-61ff-492d-82d7-06fdba8c8892",
    "episode_id": "b9d883f2-a535-40fa-bf2c-361ceb0ba209",
    "episode_number": 52,
    "segment_number": 6,
    "text": "Вы слышали этот тредик в Твиттере и читали ли вы гист Афира? Нет? Ну, нас кидали в общий чат, да. Я читал. Ладно, говорите. Как вы относитесь к этой новости? Потому что я читала, и мне просто было так довольно смешно. Ну, понимаете, Россия вроде и развитая страна, вот люди боятся ехать туда из-за таких вот вещей. Мне кажется, это показывает всю суть того, что происходит что-то ненормальное. Так у них же пропаганда там сильно сейчас идет на эту тему, и там Джульс Польский же тоже поддержал его на эту тему, что, ребята, я в России тоже не могу, я вам не советую. То есть такое ощущение, что у людей дезинформация очень серьезная. Разработчики достаточно толерантные, мне кажется. Ну, понимаешь, все-таки там приедешь в Москву, и там найдется пара людей, которые будут себя неадекватно вести. Ну, знаешь, бывает же, даже среди разработчиков такие странные люди, хотя в принципе в целом целиком и полностью сообщество нормальное, но есть отдельные экземпляры, например, и могут быть всякие негативные ситуации, и в принципе никто же не оградит. Вот, соответственно, было принято такое решение. Ну, у него на лбу не написано, поэтому если он просто будет идти по Москве, я не знаю, как-то никто, наверное, не среагирует. Там много иностранцев шляется. Если не в США, то в Десантном флоте. Здесь еще есть другое измерение в этой проблеме, в его поступке, и не знаю, насколько это для него большую роль сыграло, потому что он пишет, что он реально боится за свою безопасность. Но есть еще такой момент, что это просто возможность выразить свой протест против, допустим, конкретных законов, которые у вас там принимаются, и в том числе по отношению к геям, и каким-то образом привлечь внимание к этой проблеме и внимание там зарубежных, так сказать, людей, и внимание самих россиян. То есть так, россияне живут и вроде как есть у нас такая проблема, нет у нас такой проблемы, большинство же не геи, их как бы не трогает. А тут посмотрели, вот из-за этого закона к нам несколько интересных людей не приехали, и в следующий раз, может быть, они по-другому на эту проблему взглянут. Ну, просто большинство своем, обычные люди, даже понятия не имеют, кто Коэфир, и чем он знаменит, и зачем, ну, не приехал, не приехал, ну подумаешь, одним больше, одним меньше. Большинству, в принципе, все равно. Они будут придерживаться своих старых взглядов. Я как-то завела подобный разговор со своими родителями, я услышала очень такое, знаешь, четкое мнение, что да кто это такие, ну, то есть они очень жестко отзывались, и я удивилась как раз вот тему того, что был закон принят в Штатах, вот мне просто было интересно узнать их мнение. Вот, я думаю, что людей в районе возраста там 50+, очень много, и это основная масса, которая имеет свое мнение, и скорее всего оно будет довольно негативным. Ну, все равно человек использует вот те ресурсы, которые он имеет, вот Коэфир, ну, да, допустим, если брать в масштабе населения России, это, конечно, никто, но там для вот нас это довольно большое имя, он там заслужил того, чтобы мы о нем упомянули в подкасте, а подкастов слушает там 3000 человек, мы выясняли, а эти люди там еще кому-то расскажут, еще Twitter, ну, туда-сюда, я думаю, какой-то вклад он в это дело делает. Вот мне интересно, до тех пор, пока он сам в Twitter не написал, что он гей, много ли разработчиков об этом знал? А он, по-моему, не пишет так, что он гей, он пишет, что он, как это сказать, большой защитник вот этого ЛГБТ, да, то есть он не подтверждает и не опровергает информацию о том, что он сам гей. Ну, тем не менее, если бы он эту тему не поднял, никому бы даже в голову не пришло об этом беспокоиться. В любом случае, я предлагаю тебе продолжать. Я думаю, что мы эту тему обсудили, и идем дальше. Слушатель Пингвина говорит о том, что в девятой Java хотят прикрутить JShell и Repel. Он надеется, что теперь станет лучше, приятнее разрабатывать. Я, правда, статью-то не читала, но я всячески одобряю, если в Java будет Repel, это огромный плюс. Вот ты, Саша, пользуешься Repel в Scala? Да, пользуюсь довольно часто. Ну и как минимум у меня Scala – это такой калькулятор консольный. То есть в таком режиме вообще постоянно, а для других целей тоже довольно часто я пользуюсь. Так что я рад за Java-программистов, если у них появится Repel. Шел 2015 год, в Java появился Repel. Ты понимаешь, в чем заключается сложность, если тебе нужно всякие классы объявить и так далее в Repel, это не очень удобно? Да, это проблематично. Но тот факт, что это появится, это огромный плюс. То есть я всячески одобряю. Слушатель Николай Карелин говорит о том, что ему было бы интересно узнать мнения ведущих о таком гибриде Haskell и Python. Ясное дело, что без компиляции. Что вы думаете? Я думаю, расскажи, Роман, если ты смотрел на эту ссылку. Да, я посмотрел немножко, я даже запустил свой баг. Штука, с одной стороны, прикольная и интересная. Особенно исходя из того, что чувак пишет в Readme, он много чего заявляет. Когда я это попытался пощупать, многое из этого не оправдало ожиданий. Во-первых, для тех, кто совсем не смотрел, я должен сказать, что это не новый язык, гибрид Python и Haskell. А это библиотека для Python, причем чуть ли не для второго Python. Он позволяет конструировать некие значения, которые будут себя вести, грубо говоря, по-haskellски. И он позволяет к ним атачить какие-то сигнатуры типов. Что меня очень сильно разочаровало, он в Readme упомянул, что это вроде как система по Hindley-Milner. Hindley-Milner, если кто не знает, это система типов и алгоритмы вывода типов, которые используются, например, в ML. Ну и в Haskell, но в Haskell гораздо более мощная система типов. Но Hindley-Milner это простейший полиморфный типизированный лямбда-исчисление. Я попробовал написать какую-то традиционную функцию, у него даже, по-моему, в Readme было объявлено, конст, функция const, которая принимает два аргумента и возвращает первый из них. И к этой функции приатачен тип a в b в a. a стрелочка b в стрелочка a, потому что он принимает два значения типа a и b и возвращает там значение типа a. И я решил проверить, как работает его проверка типов. И я начал играться с этой сигнатурой типов. Я, например, вместо a в b в a поставил a в b в c, что, очевидно, неправда, потому что в системе Hindley-Milner типы a и c должны унифицироваться. Здесь должен быть один и тот же тип a. Я написал, что это функция из а в b в c. Он это замечательно схавал. Ну, понятно, что он это схавал во время компиляции, но, насколько я понял, идея должна проверкой типов производиться, когда вы вызываете эту функцию питоновскую. Я ее вызвал с аргументами, и он нормально никакой ошибки не выдал. Я пошел дальше. Я в этой полиморфной функции написал, чтобы она возвращала не просто первый аргумент, а первый аргумент плюс один. И это должно ограничить его тип. То есть в системе Hindley-Milner вообще это не будет полиморфный тип, а это будет тип типа int в b в int. И она тоже эту ошибку не задетектировала. Все равно радостно напечатала ответ. И я создал баг на GitHub. Чувак так оперативно ответил. Он сказал, что... Я толком не понял. Он говорит, что там внутри есть какая-то система Hindley-Milner, но он ее не использует. То есть он мне указал на какой-то исходник, и говорит, смотри, там реализован Hindley-Milner, но мы никакого такого чекинга не делаем. Наверное, просто в питоне невозможно это делать. Поэтому штука прикольная. Можно почитать в Readme и попробовать примеры. Но не забывайте пробовать не только то, что он пишет в Readme, но и всякие неправильные штуки. И смотреть, где на самом деле эта система типов детектирует какие-то ошибки, а где нет. А у него этот язык или библиотека ленивая? Да, он там реализовал какую-то ленивость. Он пишет про ленивые списки, но эту часть я не трогал. Ну что, я думаю, мы обсудили эту тему. И переходим к следующему вопросу слушателя. И наш постоянный слушатель Барлок спрашивает у Александра. Вопрос по поводу Go, а заодно и по поводу Rust. Как можно писать что-то сложное без полноценного ООП? Как быть без доменной модели? Александр отвечает. Ну, скажем так, насколько я понимаю, под доменной моделью имеется в виду, что у тебя есть некоторые данные, которые что-то моделируют, некоторые методы или функции для работы с этими данными. То есть вот такая модель. И на самом деле ничто не мешает построить модель эту доменную, как с ООП, так и без ООП. На самом деле, как я это вижу, основное отличие ООП от алгебраических типов заключается в наличии наследования, при том возможности задать подтип для ранее объявленного типа кем-то другим. И на самом деле есть очень много примеров доменного моделирования без ООП. Там достаточно зайти на Hacker.sh и посмотреть тысячу пакетов на Haskell. Достаточно зайти на Cipan и найти десятки тысяч пакетов на Perl. И так далее. Для любого языка, где нету такого прям ООП. И на самом деле нет такой большой проблемы. Другой вопрос, что это иногда действительно не очень удобно. Когда вот у тебя прям реально такая предметная область, ну например, атачи к письмам. И у тебя атачи бывают просто какой-то атач, какой-то архив, картинка. А у картинок бывает в свою очередь тоже разных типов, типа JPEG, GIF и так далее. И они немножко по-разному реализуют какие-то методы. Ты можешь все это смоделировать без наследования. Но другой вопрос, что это может быть менее удобно, что тебе приходится лишнего кода написать и так далее. В принципе, я не думаю, что там супер большая проблема, потому что иногда лучше написать побольше кода, но будет более понятно, как он работает. И с наследованием иногда действительно это бывает довольно хитро, когда у тебя особенно развесистая иерархия. Хотя в принципе там тоже нет большой сложности. Прям не могу молчать. Продолжай. Просто очень жаль, что мы не выслушали все-таки Евгения, потому что я думаю, что он бы очень сильно поменял представление слушателей о том, как вообще работать с предметными областями, в том числе с доменными моделями. То есть в той архитектуре вообще не делается доменные модели в виде объектов в том виде, в котором все привыкли. И никаких там не ОРМ-ов, ничего такого нет. Поэтому может быть речь идет не столько о том, как моделировать доменную модель без ОРМ, сколько о том, как без ОРМ все остальное делать. Опять же в этой архитектуре оно может быть, может не быть. Ну, зная товарища Барлога, его вопрос, я не удивлюсь, если он немного набрасывает на самом деле. Ну да, скорее всего там какой-то сарказм чувствовался за этим вопросом. В принципе я тоже могу ответить, что совершенно неважно, есть оно или нет. Тем более, что нет необходимости навешивать класс на каждую сущность, скажем так. А я думаю, мы обсудили этот вопрос. И там дальше в принципе не так много интересного осталось. Рассказывает тот же Барлог, что коттлин не нужен, ничего серьезного на этом языке не пишут. Дальше пора ЛИСП. И последняя тема о том, что хаскель как первый язык программирования тяжело учить, потому что большинство книг написаны в форме сравнения с императивным программированием в тройной форме. Я почитал эту статью и она вообще не о хаскеле как первом языке. Ну, в смысле там чувак рассказывает, что ну я вообще раньше не программировал, мне пришлось разбираться, что такое ГИД, что такое Емакс и так далее. И у меня там были все проблемы связаны с этим. И кстати, да, я как первый язык учил хаскель. Извини, я замечу, это девушка, это не чувак. А, ну возможно, я не обратил на это внимание. Ну то есть там про хаскеле буквально параграф, наверное. Ну я могу сказать насчет хаскеля как первого языка, я бы не рекомендовал. Не потому что сложно, а потому что... Ну и потому что сложно, потому что не надо. Потому что начинать надо с какого-нибудь там питона или руби. Хаскель, он же... Там много интересных абстракций, да. Там вот эти системы типов, ленивость. Чтобы понять это все, надо сначала попробовать вот то, что пониже лежит. Там питон, руби. И когда ты на этом попишешь, ты сам почувствуешь какую-то необходимость в чем-то лучшем, в чем-то большем. И вот тогда тебе пора, значит, двигаться к хаскелю. А если ты только учишься программировать, ты будешь постоянно натыкаться на вот эти проблемы с типами. И оно просто будет тебя разочаровывать, убивать мотивацию, потому что ничего не работает. Бесконечные ошибки типов. А так ты попробовал, что-то написал, оно там большую часть времени работает и замечательно все. На самом деле еще неплохо начинать с паскаля или си. Ну то есть я, например, так начинал, и у меня была очень большая радость, когда я открыл для себя первого. Тебе не нужно постоянно следить за памятью и так далее. Ну вот, если говорить о том, что будет больше всего мотивировать изучающих, то это явно не паскаля, не си. Потому что си, бесконечный геморрой с указателями, с динамической памятью, то же самое в паскале. Ребята, я не могу промолчать. Я просто на С++ долгое время писал, откуда это ощущение, что геморрой с памятью. Умные указатели решают эти проблемы очень хорошо. Извини, я говорил про си, не про С++. Ну ладно, извини. Ну даже если про С++ говорить, вот тоже для меня звучит очень странно выражение, что начинать нужно с питона или юби. Я бы ни в коем случае не рекомендовала начинать с динамически типизированного языка программирования. Потому что, в принципе, мне удавалось замотивировать школьников седьмого класса разработками на С++. Тут дело не столько в языке, сколько в самих интересных задачах, которые ты с ними решаешь. Ну и в личности преподавателя, наверное, тоже в какой-то мере. То есть вполне можно со школьниками этим заниматься и использовать это как первый язык. Я глубоко убеждена в том, что если человек не изучил управление памятью на низком уровне в начале программирования, то потом не надо удивляться тому, что у нас операционные системы отжирают по 10 гигов, там все вот это вот. То есть вопросов у меня к разработчикам этих операционных систем больше нет, если они начинали программировать с юби или с питона. Как-то так. Вот я тоже плясую, если человек начинает с чего-то высокоуровневого, типа джава, питона и так далее. Есть шанс, что он потом разберется в C, стэках и так далее. Но шанс этот, мне кажется, становится существенно ниже. И потом очень трудно объяснить человеку, даже просто общаться с ним. Ты говоришь ему регистры, у него глаза так округляются. Что регистры? Это где вообще? А вот мы недавно с Аней доклад видели про утечки памяти в Яве. Ну и честно говоря, в докладе рассказывается, что разработчики просто не знают, что нужно вызывать методы, которые освобождают ресурс. Ты знаешь, мне кажется, это просто беда разработчиков. Если у тебя в классе есть метод, что-нибудь типа exit либо close, то желательно их вызывать, но даже не желательно, а нужно их вызывать. Там все хитрее. Там у тебя Spring регистрирует датасурс, например, а потом, когда убивается весь контейнер, то ты не освобождаешь этот датасурс, потому что большинство не догадывается подрубиться к вистенеру на падение контекста, то есть на завершение, и просто поосвобождать все. То есть там тупые утечки с драйвером SQL, там еще с чего-то, из-за которых потом пермгены при передиплоях и так далее. То есть человек просто разработал библиотеку, которая позволяет все эти лики искать и исправлять. И он рассказывал, какие тупейшие ошибки люди совершают, и половина зала была не в теме. То есть они действительно так все не делают, и у них эти лики есть. Вот о чем речь. А все потому, что в основном люди либо самоучки, либо они приходят с таких языков, где не надо париться с памятью, и они не понимают, что на самом деле происходит за горбашкой лектора и так далее. Ну, либо они используют уровень абстракции в виде Spring, и они просто не до конца разобрались во всех тонкостях этого Spring, что тоже вполне возможно. Так они просто не поймут, в чем эти тонкости состоят, потому что они необходимости не видят в том, чтобы чистить память и еще что-то. Ну, знаешь, такой скользкий момент. Здесь можно тоже обсуждать, потому что если тебе нужно определить какой-то листнер, это совсем не очевидно. И по сравнению, если у тебя будет какой-то класс, и ты вызываешь на него метод закрыть ресурсы, например. Это два разных подхода, и первый подход со Spring это совсем не очевидно. Ну, я бы не сказала, что это так уж не очевидно, просто, понимаешь, очевидно должно быть следующее.",
    "result": {
      "query": "проверка типов Hindley-Milner Python библиотека"
    }
  }
]