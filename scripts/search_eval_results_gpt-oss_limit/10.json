[
  {
    "segment_id": "037bdd1f-c626-4e47-9dc6-66c45422b2cd",
    "episode_id": "585c1eae-db55-4128-b61d-cc00bd9fd366",
    "episode_number": 10,
    "segment_number": 2,
    "text": "И похоже, что... Ну, я не знаю, может, это какие-то у меня, у хостинга такие настройки, но вот с этой фигней не прокатывает. То есть нужно именно Basha вызывать, а System, похоже, вызывает просто SH. Такие вот пироги с котятами. Ну, я предлагаю уже двигаться к следующей теме, потому что я боюсь, что все подкасты обязательно затронут эту проблему, и погружаться сильно сюда не стоит. Да. Все три. Мы же нам в комментариях написали, что есть только три подкаста об IT. Интересно, какой третий? Ну, давайте называть вещи своими именами. Первый – это Radio IT, второй – это Разбор полетов, замечательный подкаст. А третий, я даже не знаю, теряюсь в догадке. Это было тонко. Или очень толсто. Так, хорошо, сейчас поговорим про языки программирования и про то, какой язык программирования лучше. Устроим здесь холивар. Собственно, причиной была статья, которую скинул Иван, называется «Анализирование языков программирования с использованием Razette-code». Razette-code – это такой сервис, либо ресурс, если так можно выразиться, который… Вики, да, можно так сказать даже лучше. Который дает и показывает, как можно решать одни и те же задачи с использованием разных языков программирования. У них сейчас больше… Я видел там страшные цифры, порядка 500 языков программирования, да, 500 языков программирования для разных задач, задач порядка 700. И решение 7000. Да, да, да, так что очень много. Идея какая этой статьи? О том, что существует очень много холиваров про то, какой язык программирования лучше, какой быстрее, какой удобнее. И, как правило, в таких холиварах мало логики и очень много эмоций. И люди просто перестают аргументированно спорить и говорят, что вот мы лучше, потому что мы так привыкли, что это удобнее. И никакой нет конкретики. И как же аргументированно спорить, если аргументов нет? Да, и когда есть аргументы, когда есть одна и та же задача, но на разных языках, то можно уже делать какие-то метрики, почитать как минимум количество строк, как там максимум скорость и прочие интересные вещи. В этой статье есть графики, такие интересные граф-схемы. Я даже сразу в них не въехала. Интересно. Да, там целое пояснение, как надо читать эти граф-схемы. Да, потому что сразу так становится непонятно, что же здесь имелось в виду. И про то, что, как всегда, у нас есть функциональные языки программирования, почему-то их примерно вместе рассматриваются скриптовыми языками программирования. А там получилось как? Они сделали анализы сперва, потом посмотрели на результаты этих анализов. Получилось, что по многим параметрам скриптовые функциональные языки находятся очень близко. Если посмотреть по этим графам, получается, что именно так и получается. Иногда они отличаются и уходят друг от дружки далеко в каких-то властях, а в каких-то очень близко. Поэтому они их очень часто объединяют. Но их объединили, так что да, интересно. Ну да, Ruby и Haskell – это примерно один и тот же язык. Я не понимаю, как это можно сравнивать. Например, я сейчас смотрю сам PDF, не тот выбор, который они сказали. И вот у них в первом PDF идет объяснение про наиболее краткий код. А, оно, кстати, в пояснении в самом есть, в HTML. Наиболее кратком коде там показано, что C, C Sharp и Go – они все более большой код, более длинный по сравнению с Java. Это тоже феерично. Я впервые такое слышу, что C Sharp более многословный, чем Java. Меня, конечно, это безумно радует, но теперь у меня есть документация, ссылка я могу всем показать, смотрите. Вы же самого главного не сказали. Я так и не понял, я не читал эту статью. Собственно, о чем она? Вроде как рассказали, что суть в чем – у тебя есть большое количество задач на нескольких языках программирования. И большое количество решений по этим задачам на этих языках программирования. И они взяли и прогнали тестирование. То есть, они, во-первых, сперва прогоняли компиляцию, во-вторых, они прогоняли исполнение. И во время этих процессов они отслеживали размер решений, отслеживали, как много объема занимает скомпилированное решение, как много используется памяти, процессорного времени, каких-то ресурсов, и т.д. Все вот эти замеры, они выдали в виде исследования, в котором есть несколько разных, как сказать, срезов. По этим срезам они как раз делают какие-то выводы. То есть, один из срезов – это размер решений, написанных для этих задач. И вот по этим, там как бы усредненное значение берутся, и поэтому они имеют право говорить, что это показательно. Потому что у тебя для каждого языка, скажем, для данного решения есть 10... Для каждого задача на каждом языке, скажем, есть несколько решений. То есть, если бы было по одному решению, то это не показательно. А тут разные авторы делают свои решения, и в целом все равно получаешь... Нет, ну подожди, подожди, подожди. Все это вообще притянуто за уши, и какая-то ересь. Ты же понимаешь, что на разведакод, там не то что Hello World, но такие программы на 30 строк, условно говоря, это же совершенно не показательно. Это к реальному миру вообще никакого отношения не имеет. И делать на основе этого какие-то выводы, я считаю, это просто безобразие. У них есть целая глава выследований, посвященная тому, как они правильно выбирали задачи. И если ты не согласен вот с этой главой, с каким-то отдельным параграфом, я предлагаю тебе все-таки написать им рецензию на эту штуку. Но в целом мне кажется, что есть логика в их обсуждении. То есть они не выбрали уж совсем короткие задачи, типа напечатайте мне, пожалуйста, строчку, состоящую из 5 символов А. Нет, такого нет, понятное дело. То есть тебе надо решать какую-то задачу все равно. И понятное дело, что на Assembler у тебя получится решение, что хочешь делай, но на Assembler она получится чуть длиннее, чем на C. А на C чуть длиннее, чем на Java, судя по их графику. А на Java чуть длиннее, чем на F-Sharp, Haskell, Python. Там не чуть длиннее, а значительно длиннее. Сколько там, 3,5 раза в среднем у них получилось. Да, да. То есть все равно выводы какие-то можно делать. Ну, смотрите, какую-то статистику можно по этому подсчитать. А на практике у нас всегда есть интерпризные какие-то системы, у нас есть продакшн, и там всегда все не так, как в книжках. Я думаю, вы сами прекрасно это знаете. Что мне понравилось здесь, здесь в исследовании довольно много срезов. То есть по этим срезам интересно смотреть не один срез, не два среза, а то, как эти срезы между собой взаимодействуют. Скажем, давайте я перечислю просто все. Во-первых, краткость кода. Во-вторых, размеры исполняемого файла, получившиеся в результате компиляции. В-третьих, лучшие рантайм-характеристики. Ну, в смысле, как быстро они исполнялись. В-четвертых, использование памяти. В-пятых, меньшее количество ошибок. Здесь вообще отдельное объяснение, как они читали вот этот показатель. То есть у них достаточно много решений, и эти решения нельзя однозначно трактовать, если они зависли, потому что вдруг они ждут пользовательского импута, и они поэтому считали за падение только тогда, когда возвращал не ноль тест. То есть все равно я думаю, что там было довольно много зацикливаний, и они их просто не учли, поэтому показатели немножко смещены. И вот эти вот все вместе, они рисуют интересную тройную картину. И в целом, когда начинаешь на эти графы смотреть, получается, что в принципе все логично. То есть тот язык, который бесконечно быстрый, он не может рассчитывать на... Не знаю... Ну, посмотрите на графики. Мне в целом понравилось. Совершенно очевидно, что это какая-то глупость. Давайте перейдем к следующей теме. Ну вот. Я надеялся подсорить это с тобой на какой-нибудь день. Ну ладно, согласен. Давай, пошли дальше. Нет, мне нравится, мне понравилась эта статья. Но подожди, нет-нет-нет, секундочку. Смотри, как главная среди нас джавщица должна протестовать. .. Как это звучит ужасно. Должна протестовать против там замерения времени работы, на таких примерах замерения объема используемой памяти, скорости и так далее. Смотри, там не только, как ты говоришь, Hello World, там довольно интересная задача. Там есть реализации, по-моему, большого, даже не по-моему, а действительно большого количества разных структур данных. Это именно те составные кирпичи, из которых ты дальше пишешь все свои приложения. Или библиотеку, наверное, открываешь.",
    "result": {
      "query": "Razette-code сравнение языков программирования"
    }
  }
]