[
  {
    "segment_id": "bd61c87e-c511-41db-954a-1c7cca170aa3",
    "episode_id": "3d012a2a-9796-4426-b3ec-6c5e08c430bd",
    "episode_number": 312,
    "segment_number": 3,
    "text": "Я в этот момент прям сильно удивлялся, потому что я глубоко убежден, весь современный embedded разрабатывается исключительно на Python, но в крайнем случае на JavaScript, потому что так, ну, этого ского уровня языки так проще, дешевле, и микроконтроллеры самые... Да, я могу вам сказать, как это выглядит на самом деле. Есть какие-то там... То есть у тебя есть цепочка, условно, там, какой-то датчик конечный или это, может быть, если мы имеем дело с, знаешь, с позиционированием, да, это какой-то шлюз, который висит и следит за маячками, да, люди ходят с маячками на шее где-нибудь, да, или на каске, и шлюз получает данные типа силы сигнала и так далее. Вот. С них сразу данные собираются в какую-то очень небольшую железку, это обычно называется контроллер, и потом уже эта железка отправляет их дальше куда-то там на большую сервию, который очень умный. То есть контроллер обычно работает там с десятком, двумя десятками датчиков, вот, и все. И логика там довольно-таки простая, например, спать 50 секунд, потом проснуться за 10 секунд, опросить все устройства вокруг себя, собрать с них какие-то данные, эти данные одним большим куском отправить дальше. Вот. И вот этот код, он пишется в основном таки на плюсах. Вот. Не на плюсах, а на си. Вот. А, ну, иногда бывает так, что между контроллером и сервером есть еще одна железочка. То есть все контроллеры объединяются в какую-то mesh-сеть, да, и посылают данные как-то друг другу по каким-то там протоколам типа MQTP и так далее, MQTP, да, а потом это доходит до какой-то маленькой железки, которая уже начинает долбанить сервер на HTTP, да. И вот эта железка, это обычно что-то по уровню производительности сравнимо с Raspberry Pi. И соответственно там поднять, как ты говоришь, ноду или JavaScript очень легко. Вот. У нас, например, там поднимается нода, поднимается такая штука, которая называется Node-RED. Node-RED это такой визуальный билдер для обработки сигналов и для конверта сигналов из одного формата в другой. То есть вот сейчас у нас… Я однажды видел на YouTube, это там, где ты буквально в браузере квадратики передвигаешь и стрелочками соединяешь. Да, да, да, да, да. То есть там визуально именно блок схемное такое программирование. Ну, там и кастерный JavaScript Code тоже можно написать. Но идея такая, что, например, мы ожидаем от одного датчика там не больше одного события в секунду. Если оно случается чаще, то мы, например, их там или берем average или берем последний или еще что-то такое делаем. Да. Вот там же можно посчитать какие-то производные, да. Что, например, когда от этого датчика пришло там значение там между 10 и 20 от другого, между 30 и 40, то значит мы какое-то там кастерное значение создаем еще одно, и оно еще одним сигналом идет. Да. Вот. То есть вот такие штуки, они делаются на Node-RED только так. И Node-RED не единственная платформа. Есть платформы, которые существовали там еще там с 90-х годов. В основном тоже нанося какие-то desktop-ные штуки, которые там чуть ли не под Windows работают, или запускаются на каких-то там Linux. Сейчас вот этот вот рынок он приходит постепенно к тому, что JavaScript его постепенно захватывает. И в принципе вот мы начинали с какой-то другой штуки, я забыл как она называлась, но мы забыл потому что мы быстро пересели на этот Node-RED, и он работает как конфетка. То есть сегодня у нас например мы понимаем, что нам нужно использовать для конкретного вот этого проекта, какие-нибудь там устройства с ультованной бендом, и мы видим, что один например рендер предоставляет какую-то рестапишку, а другой например коннектиться к нему можно только по MQTP, но нам как бы фиолетовым мы поставили этот Node-RED, и он MQTP сконвертил нам MQTP и наш основной, скажем так, бэкенд, там где собственно говоря алгоритмическая обработка происходит. Вот ему вообще пофиг в каком формате все эти разные железки от разных производителей присылают данные. Сами железки часто бывает, что их нужно то что называется прошивать, потому что да там есть бинарь, но в этом бинаре в нужном месте нужно просто подставить условно URL какой-то вещи. Сейчас сталкиваюсь с тем, что очень сложно с HTTPS соединениями, с телосоединениями, потому что какой-то там OpenSSL или что-то в этом роде туда или не помещается на эти контроллеры, или помещается в очень обрезанном виде, и стандарт сейчас такой, что ты вот у тебя есть какой-то бэкенд, на нем есть какой-то сертификат, а ты этот сертификат за ошибаешь, и есть протокол, по которому ты хочешь работать, конкретно вот этот шифрование, то что в NGNX выставляется, себе вот это бла-бла-бла, то есть там какой обмен ключами, какой длинный шифр и так далее, вот ты вот эту штуку и свой сертификат зашиваешь в бинарь, и тогда он может коннектиться только к тебе, больше никому, просто потому что иначе математика не сойдется, сертификат будет другой допустим, или еще что-то, и в этом есть геймар, в плане того, что в LSN-крипте сертификаты живут как-то, знаешь, недолго, и это значит, что нам нужно раз несколько",
    "result": {
      "query": "embedded разработка на Python"
    }
  }
]