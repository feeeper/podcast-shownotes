[
  {
    "segment_id": "044aa632-43ac-4cdf-80f3-3c5e9fd00861",
    "episode_id": "b339a75b-0c63-4d07-997f-f6b2b60878b0",
    "episode_number": 379,
    "segment_number": 9,
    "text": "определен как имеющий метод AllRight, но при этом в своей функции, которая Async, но позвать AllRight и как-то по-авейтить его не получится, поэтому, собственно, как Дима уже говорил, тут же Tokyo и, собственно, FuturesRS библиотека предоставляют extension трейты, которые уже подают наружу что-то, что можно вывести человеческим языком, собственно, открыть файл и позвать на нем Right и написать с точки await, и, собственно, да, это бывает неудобно, собственно, когда нужно реализовывать какую-то свою кастомную фьючер, использовать какой-то API того же Tokyo более низкоуровневый и, например, в некоторых других библиотеках. Слушай, я уже говорил, вы говорите про кастомные фьючи, встанавливаю, вы так много про них говорите, я вначале подумал, что речь про какой-то общий случай, типа вы Tokyo пишете, но вы так много про них говорите, что я начинаю обозревать, что вам самим приходится писать кастомные фьючи зачем-то. Иногда действительно приходится. Да, конечно. Зачем? Конечно. Ну, кастомные фьючи тебе приходится писать каждый раз, когда ты хотел бы абстрагировать конкретную реализацию за trait. Я приведу конкретный пример, когда тебе это может понадобиться. Вот представим себе следующую ситуацию, ты делаешь некий API, то есть фактически у тебя есть степень point, ты хочешь вызвать у него какие-то методы, ну, напрашивается не делать среж, типа вызова, а реализовать это как trait, у которого есть несколько методов, вот сделать то, сделать это, получить какой-то результат. Если ты примешь такую модель, как данность, ну, кстати, это очень частый подход именно в Haskell, иметь возможность реализовать какой-то интерфейс, ну, дай класс, и сделать эффект в твою реализацию, какую-то мокнутую реализацию, которую что-то другое делает, то есть это разное биоманаду будет. И, ну, если вернуться к росту, ты делаешь такую реализацию настоящую, которая будет для методов делать HTTP вызова, и ты хочешь сделать мокнутую реализацию, которая вместо того, чтобы делать HTTP, будет, ну, какой-то константный результат возвращать или вычислим, детерминированно. И вот тут-то у тебя и возникать необходимость, что раз ты не можешь сделать асинхронный, ну, тратится с синхронными методами, тебе нужно либо вот этим кастелем пользоваться, отдавь до тонны, либо же тебе нужно будет возвращать, ну, практически делать обычный классический трейд, у которого самые обычные неосинхронные методы, они возвращают некоторые объекты, которые можно эвейтить. И что для этого нужно сделать? Для этого нужно реализовать фьючо. И того получается, что трейд и метод возвращает объект. Для этих объектов ты должен реализовать фьючо, но они же должны каким-то образом различаться, а в интерфейсе вообще-то написано, что должен быть, ну, один и тот же конкретный тип, потому что так ты задефинал свой интерфейс, вот он возвращает какой-то объект. Возникает вопрос, как это сделать? Это можно сделать ассоциированным типом, ты можешь сказать, что, ну, вот, мой метод должен возвращать какой-то тип, тип указан в интерфейсе, тип должен реализовать фьючо. Вот ты попал на то, что ты должен сам реализовать фьючо. Я надеюсь, понятно объяснил, если нет, то готов, конечно, подробнее. Ну, примерно понял, да, то есть, как бы, я, наверное, не до конца себе представляю, насколько, как бы, сколько-то много custom-edit for future, но, в общем, мне странно, что для этого нет, не знаю, какой-то макрос, удобного в топ же токио. Ну, это дебейтбол, ну, то есть, фактически этот макрос есть, этот как раз то, что сделал Дэвид Тоннен, но дает оверхед, и как раз, как раз используется то, что в других языках называется агристенциальным типом, то есть, вместо того, чтобы делать эту сложную историю с тем, что у тебя есть straight, у него есть ассоциированные типы, которые должны быть обязательно фьючими, каждый метод возвращает свой ассоциированный тип, вместо этого ты делаешь просто топорно, ты говоришь, я буду возвращать бокс фьюча, какого типа, да какого угодно типа Dean Future, динамический фьюч. Да, я понимаю, в чем проблема с возвращением фьюча, и что это сложно бесплатно сделать, меня смущает, что, типа, если это можно сделать без боксинга, ручками написать, то почему нет макроса, который тот же самый код напишет, который без боксинга будет, но только, типа, с меньшим количеством ручной писанины и ручной импрементации фьючи. Ага, и я думаю, что с е-сеттингом было полезно еще про две проблемы рассказать, то есть, мы же пишем на языке Rust, здесь не может быть просто, и в чем это проявляется? Когда ты возвращаешь фьючо, фьюч это объект, это же не просто указатель на функции, это хуже того, если бы это было еще просто какое-то замыкание, но ведь это именно объект, который хранит в себе какие-то данные, а вот что если он преметализован лайфтаймами? То есть мы же пишем на Rust, у нас везде лайфтаймы, во все поля, и когда ты хочешь вернуть что-то, что боровит данные, что не владеет, у тебя неизбежно появляются лайфтаймы, и когда у тебя появляются лайфтаймы, и ты хочешь вернуть из трейта какой-то объект, ну из трейт-метода какой-то объект, который преметализован лайфтаймами, у тебя остается буквально два варианта, первое, ты должен преметализовать сам трейт этим лайфтаймом, и пребрасывать его через объект, и второй вариант, тебе нужно каким-то образом сказать, какой-то лейфтайм ты возвращаешь, откуда ты его нужно взять, куда-то прикопать, и выясняется, что в текущем вайсе такой возможности нет, это то, что называется generic associated types, то есть фича, которую я не знаю, я помню, вначале, еще в 2018 году, но сегодня никак не доделать, потому что возникает то, что это сложно реализовать, и она дает тебе возможность делать ассоциированные типы, которые фактически преметализованы, то есть используя эту же фичу, ты можешь добиться, ну по сути, хаккатэ, то есть kind of types, ты можешь сказать, что у тебя какой-то тип в качестве ассоциированного, который можно депрометализовать чем-то, то есть это позволит, например, более удобно монаду реализовать, и вот здесь это используется для того, чтобы сказать, каким-то образом прокинуть лайфтайм, который для future задан, звучит достаточно сложно, но я вас перезываю всех слушателей, ну и вас конкретно, товарищи ведущие, если вам это интересно, мы ссылочку докинем, ее можно будет потом после выпуска открыть посмотреть, да, и как-то проникнуться этой проблемой. И понимая, что простой вопрос, да, ответ на мой вопрос, почему нельзя сделать какой-то макро, что если можно писать руками, почему нельзя сделать макро, который напишет за нас, потому что слишком сложно обобщить. Да, это сложно обобщить, и даже просто чтобы компиляторе предоставить это, оказывается, нужно больше занят на одного года, чтобы просто реализовать такую фичу, то есть, в частном случае, Дэвид Аттонне, он тем и хорош, что он как-то работает, но он вопрос лайфтаймов деликатно обходит стороной, он, конечно, каким-то образом позволяет работать. Ну как деликатно, алоцирует он, как сволочь. Да, это что касается самого future, но вот если у тебя это future что-то еще бороется, то там, конечно, все очень серьезно, если просто на лайзере посмотреть на тип, который генерируется для этих методов, можно сильно испугаться с этой привычки, и потом опять же, это ненависть куда-то обобщаться, неизбежно возникнуть проблемы, как только ты начнешь что-то бороться и не владеть. Ну да, тогда, это такой, типа, комментарий в сторону, если вы никогда не писали на расти, но вы видели, как выглядят типы в стандартной библиотеке C++, то как бы в расти многие типы выглядят так, потому что у вас будет параметры, то есть у вас есть, как бы, типовые параметры, а у вас еще потом, в первую очередь, на это навешиваются лайфтайм параметры, и сигнатуры могут разбухать. Другое дело, что сработать с этим, обычно попроще, и компилятор обычно гораздо более гуманно на ошибки указывает, а не так, что вот, короче, вот тут такая шаблонная простыня, что-то сломалось. В раз-то, эта вещь сделает сильно лучше, но сигнатурой от этого дружелюбнее не выглядит. Так, отлично. Тогда, наверное, продолжу. У нас осталось еще несколько проблем для обсуждения, но, наверное, придется немножко их зажать, чтобы не слишком подробно. Да, не парься, у нас еще есть время, у нас еще минимум полчаса. Окей, отлично. Если говорить про следующие проблемы, то, наверное, встанет проблема cancellation, то есть отмена фьюч. Понятное дело, что если мы какой-то код запустили, и нам хочется его, не всегда хочется, чтобы он выполнялся до конца, очень часто операции нужно отменять. И вот тут возникает проблема, как, собственно, произвести отмену. Если вспомнить, что фьючи это объекты, у которых есть какие-то поля, то, ну, и то, что в расти есть деструкторы, то фактически, когда мы хотим отменить фьюч, нам нужно сделать проявление следующее, чтобы память не потеряла и, если у нас есть проблема с памятью, то мы отменяем фьюч, и мы должны вызвать ее деструктор, ну и деструкторы всех полей, чтобы подчистить память. Это хорошо, если это можно сделать легко, если фьюч содержит какие-то банальные типы винтов. А вот что делать, если у нас модель, ну, что-то типа на основе IO и Ringo, или то, что в Windows называется Ucompletion Bufers, когда мы отменяем фьючу, нам вообще-то нужно ее как-то разрегистрирует из рентайма, а рентайма подает таким неприятным свойством, что фьюч-то алоцирует бухер где-то, и ядро должно как-то узнать, что мы это фьючу отменили, и должно эту память перестать использовать, потому что в такой модели мы ядро отдаем наутку наших указателей, говорим, пожалуйста, запиши сюда 100 байт, и верни нам. И в таком случае получается, что отмена мгновенно мы можем сделать, но нам куда-то нужно забукипать, что мы эту память хотим очистить. И получается, что нам нужно изобретать своего рода garbage collection, то есть отложенная диалокацию, ядро должно проснуться, и вот когда оно проснется и перестанет использовать указатель, мы тогда-то и сможем почистить память. И есть даже еще одна проблема, что, в принципе, ну она тоже разагностик, когда мы пишем какой-то асинхронный код, нам, конечно, очень хотелось бы верить, что он выглядит как синхронный, значит, нахоже на синхронный, но если мы в неудачный момент отменим фьючу, а мы, допустим, вычитывали данные сокета, то все, что мы вычитали и никуда не сохранили, не в глобальной конте, если не вернули юзеру, фьюча загилдилась, если мы сейчас ее отменим, то мы потеряем все, что мы прочитали. Если мы написали не очень аккуратно код, то только что вычитанные данные сокета безвозвратно пропали, на это тоже будет ссылка, очень хорошая статья от пользователя Tamako, он очень-очень подружный. Может бы хотя бы вот так вкратце пример привести еще раз? Да-да, безуполно. Значит, икилки у нас будут полезны комбинаторами для написания синхронного кода, у нас есть джоин, который позволяет дождаться исполнения каждой фьючи, и у нас может быть вещь, которая в разных языках называется по-разному, просто она называется селект, и работает она следующим образом. Мы и каждый из них что-то возвращает, и когда мы вызываем селект, мы хотим, чтобы вернулся результат самый первый фьюч, а все остальные мы дропаем, мы даже не смотрим на их результат, первый вернувшийся результат используем, остальные мы все отменяем. И вот сложность в том, что когда мы пишем асинхронный код, если мы как-то не очень аккуратно используем селект и пишем код так, что какие-то фьючи что-то вычитывают из сокета, но никуда до конца не передают, то когда срабатывает другая фьюча в селекте, нашу нужно будет отменить, у нее вызовется дроп, мы уничтожим те данные, которые мы вычитывали, и никуда их не продадим. То есть это именно когнитивная сложность, такой кооперативная многозадачность, непонятно, что делать, когда тебя просили отмениться. То есть если ты пишешь многопоточный код, есть понятно Petriot Concelation, который на самом деле мало кто использует, потому что у него есть ряд проблем, и они будут сейчас в них даваться. В целом ты можешь быть уверен, что если тебя не попросили завершиться, ты можешь работать сколько влезет, делать все что хочешь, bookkeeping, когда-нибудь завершишься сам, когда Exit для потока вывеш. А асинхронный код требует тебя всегда думать о том, что произойдет, если тебя отменят в самый неудобный момент, а это каждый waitpoint. То есть в разе преимущество в том, что ты видишь yieldpoint, и тебе нужно даже с условиями этого думать о том, что произойдет, если меня на этой строке отменили. Это точно нормально, если то, что вышло, просто никогда не дойдет до логического завершения. То есть нормально ли работает моя future, если в какой-то момент она просто заснет и больше не проснет, если мы не дойдем до конца. А теперь представь еще, что у тебя эта future каким-то образом в глобальном контексте что-то регистрирует, например, там контекст пользователя, а потом ты отменяешь ее, тебе нужно дропнуть. Тебе фактически нужно какой-то defer, чтобы отложенное уничтожение этого контекста произвести. И это хорошо, если отложенное вот это уничтожение, то есть то, что ты пишешь в диструкторе, в defer, если это асинхронный код. А если тебе для диалокации нужно выполнить асинхронный код, например, future такая, что по завершение она должна почти куда-то дозвониться. Это снова асинхронный код, и тут возникает проблема, что диструктор это врасте синхронные, то есть ты не можешь в них evade написать, и тебе придется обращаться к твоему любимому runtime и просить заспаунить какую-то новую future для того, чтобы подобрать за той future. А там же еще ошибки могут вылететь, тебе неплохо было бы знать, что она точно зашевелилась. То есть снова и снова возвращаемся к тому, что получается уже какой-то гадочек. Пока что не все еще не очень поняли вот эту историю, про то, что мы что-то вычитали, потом не передали, почему это проблема. То есть, как бы если мы не успели передать, ну как бы не передали, не передали, нас же хоменили. Проблема заключается именно в самой концепции асинхронного кода, что тебе всегда нужно думать о том, что произойдет, когда выполнится отмен фьюч, и она не дойдет до конца. То есть наивные реализации, которые выполнится последняя строка твоей асинхронной функции, значит нужно чистить. Так не будет работать, потому что ты никогда не знаешь, что твою фьючу доработала до конца, потому что ее могут отменить. Если ты заложился на то, что всю очистку ты делаешь в самом конце, ну сам дурак, тогда получается, что этот код просто никогда не вызовется, если фьюч на полпути была отменена. Вот о чем идет речь. Так, типа так, поятнее, спасибо. Да. Ну фактически, примерно объяснил. А Дима, еще хорошие комментарии на тему есть про structured concurrency. Да, есть такая, я думаю, многие слышали о такой концепции, как structured concurrency. Была такая статья интересная, Go statement considered harmful по аналогии с статьей Dxry, Go to statement. И, соответственно, эта статья поднимает проблему того, что мы часто используем какие-то iron-pocket задачи. То есть мы что-то запустили, и мы не ждем, собственно, запустится оно, не запустится. Мы не собираем ошибки, еще что-то такое. Часто это колбэпками какими-то, может быть. И, соответственно, вот родилась такая парадигма structured concurrency, которая, если на пальцах про это подумать, состоит из какого-то объекта, часто он называется scope или в некоторых языках, например, битонная реализация называется anniversary. Этот объект предоставляет возможность сплавлять таски и делать это как раз ограниченно для этого scope. То есть этот scope предоставляет гарантии того, что когда он выходит scope, завершает свою работу, он корректно отменяет задачи, либо ждет пока все они завершатся. И здесь хотелось бы только есть интересные особенности, что верхний уровень, вот подобные примитивы, прости, есть. К примеру, подобного можно сказать, является futures unordered, то есть такой, на самом деле, мини-экзекютер, который позволяет собрать пачку futures, словный вектор, и сказать, что хочется, чтобы они выполнялись в любом порядке и говорить, что мы получаем результаты и ждем пока все они завершатся.",
    "result": {
      "query": "токио future custom macro Rust"
    }
  }
]