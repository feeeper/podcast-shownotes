[
  {
    "segment_id": "b28b0408-15ca-4728-bf0c-e7c3f4a82adc",
    "episode_id": "fdaa0da5-5b62-4f7b-a100-680bb4841466",
    "episode_number": 408,
    "segment_number": 11,
    "text": "Суть довольно сложно объяснить без картинок, но я постараюсь, но сделаю это коротко. И рассмотрим случай, когда у вас сортировка только по одной колонке, по первой, для простоты. У тебя есть то есть вот часть колонки, которая не физически хранится, но логически они представляют собой строки. Все еще. Строки делятся на партиции. Если у тебя в первой колонке хранится значение А, то вот все колонки, которые все строки, у которых в первом столбце записано А, они относятся к первой партиции. Потом у тебя в первом столбце записано Б, это все вторая партиция. То есть у тебя вот так вот партиция делится по ключу, по которому ты сортируешь. Плюс в каждой партиции есть небольшой запас места. Ну а вдруг мы захотим записать еще колонок с значением и еще строк, где в первой колонке записано значение А. Логично. Тогда мы возьмем первую партицию, в ней есть немножко свободного места, мы допишем туда А, и нам не нужно пересортировать все данные. Пока все понятно. Но интересный кейс возникает в случае, когда у тебя партиция целиком заполняется, а ты хочешь туда еще одно записать данных. Вот оказывается, что границы этих партий, они могут двигаться. То есть у тебя есть отдельный маленький индекс сбоку, который говорит, что вот первая партиция, в ней 100 строк, во второй партий она там со 100 строки по 150, и так далее. Ты можешь границу партиции подвинуть, сказать, что у меня не первые 150 строка, а первые 151 строка относятся к первой партиции, просто поменяв индекс. Он небольшой, поэтому это дешево. И что делает Каспер? Он говорит, а давайте подвинем границу партизы, куда мы хотим записать. Соответственно, это дешево. Где мы возьмем лишнее место? Потому что за этой партией идет другая партия. А в этой партии мы возьмем первую строку из нее, и запишем в конец этой партии. То есть повторим. Есть две партиуры, в первой кончилось место, во второе есть место. Ты берешь вторую партию, берешь из нее первую строку, вычищаешь ее и записываешь в конец второй партии. Затем ты двигаешь в конец этой партии, у тебя там появилось место под одну свободную строку, и туда записываешь новую строку. Таким образом, у тебя сохраняются строки все еще отсортированные, как было запланировано, и тебе не нужно для поддержания этой отсортированности сортировать весь файл целиком. Если на словах ничего не понятно, это нормально, откройте доклад, там наглядные картинки, все более понятно. Возможно, в сценарии, когда у тебя в первой партии кончилось место, и во второй партии кончилось место, но тогда у тебя просто рекурсивно работает алгоритм, ты точно также должен расширить вторую партию за счет третьей и так далее. Подожди, я сейчас знаю, что сломалось. Ты в какой-то момент начал говорить про риордер и колонг, и я подумал, что речь про риордер и колонг между собой, а все остальное, что ты говоришь, это как будто бы про риордеринг чего-то внутри колонки, и вот тут я потерялся, потому что я не вижу связи. Нет, до этого я говорил в целом доклад, в целом доклад посвящен хранению данных на диске, точнее, не обязательно на диске, потому что здесь и про in-memory базы данных тоже, ну, про storage modules, доклад в целом, и когда мы говорили про риордеринг, риордеринг был в контексте строкового хранилища и того, как изменить порядок данных в строке, чтобы в один кэшлайн помещалось больше данных. Потом мы забыли про строчное хранилище и перешли к колоночному и строчному. Сорян, я не понял, что это не связанная концепция, извини. Да, да, это все разные темы. В сухом остатке Casper позволяет иметь колоночное хранилище, где данные отсортированы по заданной колонке, ну, или двум колонкам, трём колонкам, и при этом запись в это колоночное хранилище не приводит к переписыванию всех данных.",
    "result": {
      "query": "Casper partition boundary shifting sorting optimization"
    }
  }
]