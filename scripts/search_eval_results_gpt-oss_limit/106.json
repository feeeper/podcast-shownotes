[
  {
    "segment_id": "4fe008b4-a7d6-4284-aa1d-da9a1ff0653f",
    "episode_id": "3bfefcff-43ed-4e8b-bbc2-595265ae5303",
    "episode_number": 106,
    "segment_number": 8,
    "text": "Не будем углубляться в детали, но просто есть такой факт. Также в последних версиях iOS в Safari веб2g имеет JIT. JIT в WebKit, конечно, был давно, но, видимо, в iOS он появился со временем только. JIT — это Just-In-Time компилятор, то есть если очень сильно упрощать, он берёт JavaScript-код, ну, или точнее, после того, как он распарсился и преобразовался в структуру данных, он его оптимизирует, а потом, чтобы его максимально эффективно исполнять, генерирует уже нативный код, соответственно, должен сохранить его в память. Соответственно, у этих двух вещей есть между ними конфликт. То есть мы, с одной стороны, требуем, чтобы любой исполняемый код был подписан, а с другой стороны мы генерируем его на лету из произвольного JavaScript. То есть долгое время WebKit был хорошим таким сорсом для эксплойтов, с которыми нужно было что-то делать. В результате что появилось в... это было в iOS 10, насколько я помню. В новых версиях ARM, по-моему, с V8, у, я так понимаю, что страниц памяти, как бы есть отдельные режимы, то есть, ну точнее, режимы были раньше, есть виды памяти, которые могут быть исполняемыми, но их нельзя читать в процесс. То есть процесс может выполнить код, но он не может никогда его прочитать, чтобы, вот как мы говорили про червя, рылить и узнать там адрес какой-то функции и уже исходя из этого что-то там дальше высчитывать. Соответственно в iOS 10 они... JIT заставили использовать разные виды страниц для разных вещей и сделали кастомную версию memcpy, которая знает о, соответственно, специальных адресах, которые нужны, чтобы, ну, все это дело исполнять. Итого JIT-код он исполняем, но процесс, вот генерированный код, он не может прочитать другого свой собственный имидж. Это одна из вещей. То есть, что интересно, для этого потребовалась поддержка железа. Ну, собственно, про все остальные темы, которые мы сейчас там напишем, там поддержка железа совсем адовая. Вторая вещь, о которой он говорил, это то, как работает Touch ID. И в частности, то, как работает... Они это называют Secure Enclave или SCP. Это отдельное, я так понимаю, ядро, могу чуть ошибаться в терминологии, на систем-он-чип ARM-овом, которое отвечает за всю криптографию и с внешним миром коммуницирует, используя группу Gray Message Passing, то есть очень такой ограниченный протокол вещей. Ну, это невозможно пересказать все, что там есть, посмотрите пару раз, очень интересно. Но суть в том, что поддержка железа там нужна адовая для того, чтобы все это сделать безопасным. Количество разных ключей, которые используются и упоминаются, там, по-моему, уже больше десяти только в одном этом токе. И у каждого девайса есть, соответственно, мастер-ключ, который получается из двух вещей. Первое — уникального идентификатора, вот этого SCP, и, собственно, вашего паскода, который вы заводите при первом включении устройства. Соответственно, этот мастер-кейс используется для того, чтобы зашифровать, обернуть, как они это называют, другие ключи, другие ключи, доступные в памяти в разные моменты времени, то есть некоторые требуют анлока девайса и так далее и тому подобное. Совершенно абсолютно нетривиальная вещь. При этом Apple никогда пользовательских данных не видит. Вторая вещь, связанная с этим, если у вас есть секреты на устройстве, то вопрос в том, как их синхронизировать. То есть, я не знаю, вы добавили контакт на одном устройстве, он должен через iCloud попасть на другой. Так как пользовательские данные зашифрованы, вариантов Иван, человек, который выступал, называет два, сейчас постараюсь вспомнить, грубо говоря, первый состоит в том, что мы все шифруем на самом устройстве, и традиционным способом реализации, если вы теряете одно из ваших устройств, то все секреты с ним пропадают, это не очень круто.",
    "result": {
      "query": "iOS JIT Secure Enclave синхронизация данных"
    }
  }
]