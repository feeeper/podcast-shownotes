[
  {
    "segment_id": "3801c96d-8eb6-4954-bdd9-8fdc5a6097f6",
    "episode_id": "d6a4d374-391e-48b5-80a3-f2a574149bb0",
    "episode_number": 423,
    "segment_number": 2,
    "text": "Понятно, где будут ошибки, а это полезно для опыта. Ну хорошо. А сейчас ты занимаешься Omnigress. Расскажи, пожалуйста, в какой роли ты им занимаешься и что это такое? Да, роль... Пока это просто самолично возглавляю, делаю все, потому что это... Omnigress это пока что я. Что такое Omnigress? Я немножко предысторию тут-там, чтобы было понятно. Формирую я давно, как, наверное, большинство из нас тут вокруг. И чем дальше, тем больше меня повергает в грусть процесс создания приложений, особенно, наверное, веб-приложений и вообще в их более-менее серьезных приложениях. Кажется, что очень много чего стало усложняться, чтобы что-то запустить. А это, в общем, создается целый зоопарк, всего много. Я хотелось чего-то простого. И я много экспериментировал, естественно, как многие, с SQLite и идеями вокруг него. Но с Postgres там давняя дружба на общем уровне. И для более больших систем он все-таки лучше подходит, чем SQLite. И перед тем, как создать Omnigress, я... делал какой-то объем клиентской работы, где, собственно, я писал экстеншены для Postgres, делая совершенно разнообразную функциональность, встраивая ее в Postgres. И то, что я увидел, меня заинтересовало. То есть, понятно, что их писать достаточно сложно, но возможности, которые дают эти расширения, были интересны. И мне вернулось, наверное, у меня раньше где-то идея бродила, вернулась идея, что а нельзя ли было бы все приложение положить в какой-то один сервер? Чтобы была какая-то одна штука, которую можно задеплоить куда-то там, не знаю, в клауд, на какой-то сервер, и все там жило. И мои данные, и моя логика, и все подряд. И я вот задумался о моем опыте с расширениями, и возникла мысль поэкспериментировать. И вот так родились первые... первые компоненты, то есть, где IEF строил, например, веб-сервер в Postgres, и которые позволяют, собственно, выстраивать стандартный HTTP-стэк на самом Postgres. То есть можно задеплоить Postgres, там есть расширение, и просто отвечать на запросы с помощью, скажем, SQL-запросов, или там, stored procedures, и таким образом не вынуждать себя создавать целую deployment-систему, то есть многие сразу бросаются, там даже Kubernetes, чтобы давайте развернем здесь это, развернем то. А тут идея простая. Давайте развернем просто один узел. Пром будет все, что нам нужно, и уберем всю сопутствующую, как бы, все сопутствующие наслоения, где мы перекладываем байты из одного формата в другой. То есть нам пришел HTTP-запрос в таком формате, мы переложили в SQL-запрос, там послали тому же Postgres, и получили, потом переложили, ну и так далее. Как можно все упростить? В общем, главная мысль со всем этим проектом это, как я могу упростить свою жизнь, ну а если получится мое, то может быть и что-то еще. Это так. То есть мы говорим про, ну у меня несколько версий, о чем мы говорим, о том, как так написать приложение, чтобы оно в контейнере с Postgres работало, или как сделать движок, чтобы на Postgres, как на Application сервере запускался код с HTTP сервером. Что именно происходит? Это второй вариант. То есть общая идея, что по максимуму встраиваем функциональность приложения, строительные блоки для создания приложений в сам Postgres. То есть мы не выходим даже за пределы самого Postgres, в большинстве случаев. То есть, например, веб-сервер, который я строил, это не внешний сервер, это я взял сейшную библиотеку, которая является сервером, и прикрутил ее, чтобы она работала с Postgres напрямую. Это как пример. Естественно, это не единственное расширение, которое Omnigrace имеет, но это одно из которых максимально показывает смысл этого. Чтобы весь стек можно сократить у одного сервера. А контейнеры, там есть тоже история про контейнеры, но ее можно чуть позже обсудить, если будет интересно, о том, как Postgres, в принципе, может спать менеджером контейнеров. А пользователю предлагается реализовывать бизнес-логику на C, на LOA, на чем? По дефолту, когда случаи простые, на SQL, грубо говоря. То есть огромное количество приложений, это просто CRUD, то есть Create, Read, Update, Delete. И много чего такого кладется на простой SQL достаточно тривиально. Что-то чуть менее тривиальное очень неплохо. Кладется на SQL. Простая есть логика какая-то. Дальше уже, понятно, есть еще другие языки, то есть есть и Python, и есть LOA, и есть JavaScript, и вот сейчас Rust недавно вышел, или Rust. В общем, есть варианты. Плюс там еще есть мысли, как это можно дальше развивать. Но общая идея такая, что мы не покидаем пространство базы данных, мы сидим максимально близко к данным, то есть это вот принцип mechanical sympathy. Я, кстати, не согласен, что есть mechanical sympathy. CRUD хотел было встрять. Я держал себя за язык, не встревал, а раз ты упомянул, то я хочу встрять. Ведь у тебя при попадании, когда данные попадают в SQL, когда именно что-то не C-шное расширение, а когда оно написано на встроенном в PostgreSQL процедурном языке, который накручен поверх SQL, который называется PLPGSQL, у тебя происходит довольно много сериализации данных туда-сюда, и там уже, мне кажется, не приходится говорить о mechanical sympathy, потому что между тем, как тебе данные лежат на диске, тем, как с ними будет манипулировать функция, реализующая SQL, и сколько там потом будет хождение по поинтерам, это данные все лежат близко, в смысле, что мы их не пересылаем по сети, но это далековато от принципов mechanical sympathy. Я согласен с этим уточнением. На строгом уровне, да, абсолютно согласен, что это не низкоуровневый mechanical sympathy. Тут скорее, конечно, mechanical sympathy скорее в разрезе data locality, то есть работаем с данными, где они находятся. Понятно, что есть SQL и LPG SQL, особенно менее эффективен, то есть там интерпретатор, который проходит через это дерево, да, это присутствует. Но для моего примера, то есть когда я исследовал, как это работает, по итогам первой версии, которую я написал, показало действительно очень интересные результаты в плане того, насколько убирание вот этого прихода от грубо говоря, application сервера до Postgres помогает, даже с той же производительностью, гораздо более серьезные выходят цифры в плане запроса в секунду, если я напрямую работаю с данными локально, или когда я делаю то же самое, но вынужден даже там через Unix socket сходить к Postgres. Ну, это неудивительно. Скажи, пожалуйста, вот какую вещь. Если у меня на продакшене Postgres, то я понимаю преимущество использования, ну, либо его целиком, либо вынос определенной части логики в, ну, фактически преимущество использования Postgres как application сервера. Всю логику в базу данных, или в расширение всешнее. Нет хождения по сети, нет лишней сериализации, десерилизации, ну, по крайней мере, вот, до того момента, пока ты окончательный результат не получил, который нужно было отвыкнуть. А если вот как в OmniGres предлагают, то ты еще и по HTTP его задашь, у тебя еще и, ну, собственно, никто в СУБД так, ну, кроме как по HTTP ходить и не будет. Но, допустим, я пишу новое приложение, да, рассмотрим сценарий. Саша пишет новое приложение, и у него есть выбор. Использовать для нового приложения OmniGres, или, например, взять Go, и либо SQLite, который ты упомянул, или может быть даже какой-то LSS, типа Badger. В этом случае у меня даже, ну, если у меня запросы простые, то мне придется реализовывать некоторую логику руками, но в обмен на это у меня пропадает планирование парсинг запросов, и я могу, если меня действительно беспокоит производительность, то я могу даже от парсинга запросов избавиться. В чем преимущества и недостатки использования OmniGres в сценарии, Саша пишет, новое приложение? Одно из преимуществ, которое, мне кажется, достаточно важно, понятно, что не для всех приложений, но для многих, это то, что действительно есть интересная сейчас экосистема расширений для Postgres, то есть те же там Timescale есть, да, есть Postgres, Snap и прочие штуки, которые уже есть готовые, которые можно использовать, как бы не наращивая там сервисы и зависимости, которые там внешне висят, то есть можно, опять же, все эти штуки использовать близко к данным. Это одно из преимуществ, ну, помимо очевидных преимуществ, которые мы только что обсуждали в плане производительности. И другое преимущество, которое, мне кажется, достаточно важно, это фокусирует создание приложения на модель данных, которая у нас есть. Когда мы задумываемся, как же мы строим здесь приложение, например, мы можем уже применять, скажем, там, security, там, и давать или забирать права на колонки, и грубо говоря, делать так, чтобы сама база данных выступала как фильтр, кому что показывать, кому что разрешать, редактировать, то есть есть одна точка, да, там, набор этих policies, которая дает нам возможность определить, кто и что, и как может сделать. Других преимуществ еще, я лично для себя очень вижу важный момент, дипломенты в таком сценарии происходят весьма, атомарно, то есть можно запустить транзакцию, да, скажем, создать нам наши новые store procedures, и поменять базу данных, и так далее, и тому подобное.",
    "result": {
      "query": "Omnigress Postgres application server"
    }
  }
]