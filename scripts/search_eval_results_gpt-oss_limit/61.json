[
  {
    "segment_id": "b78b8dd3-a923-4640-a96c-b911a16c8d83",
    "episode_id": "22565d0d-651b-471e-b89a-2867d70077dd",
    "episode_number": 61,
    "segment_number": 4,
    "text": "Ну, это все, ну, фьючеры не готовы к этому, и хаппи, как бы, не очень приятен. Ну, окей, гостя мы изрядно помучили, я так смотрю по времени, поэтому давайте перейдем уже к нормальным темам, гостя, если ты не против. А? Свет, следующая тема твоя, тебе слово. Будем говорить про нормальные темы. Собственно, прекрасная новость, на этой неделе вышла ACCA 2.4, наконец-то. Вот, и самое удивительное, что написано, эта версия просто прекращает работать с версией Java 6 и 7, и работает только на версии Java 8. Но при этом есть саппорт с версией Scala 2.11. Отсюда возникает вопрос, как такое может быть? То есть я до этого считала, что Scala версии 2.11, она не работает на 8 Java, а тут написано, что она работает. Стоп, стоп, извини, я тебя перебью. То есть либо я что-то путаю, либо... Да, понимаешь, Scala 2.11 отлично работает на Java 8, у нас мы уже очень давно на Java 8, и на Scala 2.11, там все работает. Подожди, а какая самая последняя версия у вас? Вот 2.11 и дальше что идет? Ну, я точно не помню, 2.11.7, по-моему. Вот, видимо, это недавно внедрилось, потому что на ранних версиях 2.11 она не поддерживала 2. Может быть. Я могу тебя заверить, что начиная где-то с версии 2.11.2 или 2.11.3, она уже на Java 8 работала, потому что мы примерно в это время перешли. Вот, собственно, я поэтому сильно удивилась. Я, так скажем, замедляю переход на 8 Java, меня это сильно останавливает. А здесь я почитала, и оказывается, что я чего-то проспала. Такое бывает. Дальше много улучшений, касающихся модуля ACO Persistence. Его изменили, теперь он больше не экспериментальный модуль. Много улучшений, касающихся ACO Cluster. Они добавили новый модуль. По сути, это CRDT. Называется ACO Distributed Data. Звучит интересно. Ты, Саша, не пробовал, когда игрался с ACO Cluster, эту штуку? В то время, когда я игрался, это было все то ли еще в планах, то ли очень экспериментально, поэтому нет. Звучит круто, понимаешь. Мне ручки чешутся это попробовать. Протащить в продакшн, чтобы пойти не так. Попробовать на практике, хотя бы в своем подпроекте. CRDT из коробки, да, довольно круто. Меня сильно беспокоит другое. Это ACO Typed. Ты видела, как он выглядит? Я не видела. Я помню, как выглядели эти типизированные акторы до этого, и я этим не пользовалась. Я посмотрел, в свое время, почитывал посты про это. ACO Typed – это просто сломать себе мозг. Вань, ты на Ирландии пишешь, да? Ну, или писал, я не уверен, как сейчас. У тебя есть один сервер, представляешь? И у тебя есть, условно говоря, метод. Если тебе пришел запрос колом, то обработать все вот так. Если кастом, то как-то иначе. Если какой-то там произвольный запрос, ну, в смысле не запрос, а произвольное сообщение из набора заранее известных, у тебя в генсервере написано, что там может в инфо прийти. Если оно по-нормальному, то оно должно либо в каст приходить, это то, что у тебя протокол реализованный предусматривает, либо в инфо это всякие такие нотификации. Пока все более-менее правда. И к этому несложно прикрутить нормальные типы. То есть написать, что это генсервер от типа кол-мсг, где кол-мсг это какой-то тип, каст-мсг, и там. Собственно, это все по большому счету. А там накручена какая-то жесть. Я понимаю, почему она там накручена, потому что нормальных легковесных процессов нет, и тебе приходится постоянно использовать бекам-анбекам и такого рода вещи. То есть как бы менять, переходить из одного состояния в другое. И действительно, это очень сложно типизировать. Но пользоваться, насколько я понимаю, этим пользоваться вообще нереально. Ну и вопрос, скажем, какую проблему это решает? Никакую. То есть актеру могут прийти сообщения любого типа, и мы хотим ограничить эти типы, правильно? Да, все так. Но на практике я ни разу не столкнулась с такой проблемой. Ну хорошо, актер принимает сообщение такого-то типа, ты пишешь кейсы, обработчики этих кейсов, ну если пришел какой-то левый тип, напиши это сообщение unhandled. Если что-то такое произойдет, оно у тебя будет необработано, вы увидите это в логе. Ни разу такого не было. То есть как бы и зачем такое наворачивать, и зачем такое тащить, я бы подумала. Да, все намного проще. То есть нормальные пацаны пишут типизированный интерфейс вокруг этого нетипизированного актера, и у них вообще нет никаких проблем. Ну то есть я действительно не понимаю, зачем это делать. Не вижу реально ни одной причины. Ну, наверное, кто-то диссертацию защитил, да, но блин. Это единственная причина? Я понял. Ну а в мире склавы всегда так происходит. То есть там какой-то ученый решил написать диссер о том, как он передает лямбдочки по сети, да, и все это потащили вакуум. Примерно так. Ну вот, скажем, эта идея хорошая, особенно когда ты работаешь с большими массивами данных. Не данные же тебе пересылать по сети, а ты функцию переслал быстро, дешево и работает. Вот. Дальше... Почти всегда. Почти всегда. Вот. Кроме этого, были минорные улучшения, касающиеся логера с LFG интерфейса. Также еще что-то по поводу сериализации. Там теперь можно использовать любую версию протобафа. Я помню, когда-то это было для меня большой проблемой. Пришлось откатиться в АКе на предыдущую версию протобафа, потому что там с чем-то оно конфликтовало. Вот теперь такой проблемы нет. И большой плюс, что в версии АК 2.4 бинарно совместимо с версией 2.3, но не для всех модулей. То есть модуль АК Persistence несовместим, по-моему, АК Test Kit тоже несовместим. Так что есть нюансы, но в целом они говорят, что можно смело обновляться. Еще из того, что я бы отметил, АК Persistence стал неэкспериментальным модулем. Говорила, говорила. А, извини, пропустил. Сколько они пилили? Я этот 2.4, по-моему, год ждал. Он был во всяких релиз-кандидатах и так далее. Они его очень долго готовили к релизу. Я не скажу, сколько времени это заняло. Можно посмотреть? Я просто могу сказать, что у нас в проекте используется 2.4, какой-то древний снапшот, потому что казалось, вот он уже скоро выйдет, и в результате затянулось на год. Так снапшот в проекте и используется. Снапшот. Прямо обновляется постоянно. Это была не моя идея, и я ее всячески осуждаю, но так получилось, что уже назад нельзя, а вперед все ломается. В смысле, а снапшот закачан жаркой, или прям он лезет в репозиторию? У них есть в репозитории, знаешь, типа минус снапшот 2014-09, такого рода. Нет, ну это норма, честно говоря. Потому что есть проекты, которые там dependency, например, динамически все время там плюс стоит вместо версии. Все время новые версии. Это снапшот там тоже так. Но это для очень смелых людей. А можно я спрошу быстренько про Scala? А как это, если Scala компилитировал Java bytecode, как они могли не работать на Java 8? Что они там сделали? Ну в плане того, что как это вообще возможно? Java bytecode, он вроде как... Ну спокойно можно запускать Java bytecode 6 на Java 8. Светлана, ты у нас главный обвинитель в этом вопросе. Ты и отдувайся. Ты на меня все перекидываешь. Ну в смысле, я такого и не говорил. То есть у меня все работало. Там, по-моему, с ISM-ом у тебя что-то было? Ну есть библиотеки, которые генерируют именно bytecode. Вот это ISM, либо есть еще какие-то, либо я сейчас не вспомню их названия. И были проблемы при переходе на 8 Java. Это даже, скажем, для Java проектов. Я понял, да-да-да. Вот, а ISM-либо она была в хибернете когда-то, может и сейчас есть. И поэтому, ну, есть нюансы, так сказать. А учитывая, что в скале bytecode тоже много где генерируется, мы получаем довольно интересные эффекты. И порой ты эти эффекты не отловишь на своих тестах. Может быть в продакшене получишь. И я сильно стремалась переходить. Ну и после сегодняшнего выпуска я с уверенностью перейду. Переходи, переходи. На Java 8 она крутая, никакого первом гена и так далее. А то есть получается теперь все либы, которые на скала 2.11, я могу спокойно ранить на 8 Java, да? Мы так уже делаем где-то год. Ну то есть я стремалась. Правда, я сильно стремалась. Но сейчас все отлично. Все будет хорошо. Все будет хорошо. Как говорит мой коллега, все будет ха-ра-нет. Вань, а Вань, расскажи нам все, что ты знаешь про лица и книжки. Ой, неужели мы Java Мир уже полностью обсудили все, что вы хотели? Ой, я могу добавить еще один момент. Давай, давай, давай. Я знал, что ты. Ну я просто вспомнила еще одну больную ситуацию. Сегодня подошел коллега и говорит, вот смотри, ситуация. Мы используем скала МОК в проекте для тестов. И вот что-то у нас не компилируется. А там удивительная история. Что вызываешь там СБТ тест, и у тебя выскакивает в логе ошибка. То есть у тебя две одинаковые строчки. То есть там написано такие-то типы, и они не сходятся. То есть тип то же самое, то же самое. Это не одно и то же. И вот на это смотришь и понимаешь, что-то в этом мире не так. И такие вещи в скале порой случаются. Я прям взгрустнула от этого всего. Но я-то не использую скала МОК. Я использую МОКИТ, а у меня таких проблем нет. Я попыталась разобраться, что там было не так. Я просто плюнула на это дело. И говорю, слушай, у вас еще скала МОК. Только-только вы на него притянули. Берите МОКИТ и не мучайтесь. По своему опыту могу сказать, что если использовать какой-нибудь DI и просто интерфейсы, которые ты руками прям пишешь к ним. МОКИ, стабы или как они в проекте называются, то все очень хорошо. Никаких проблем нет. А там нужно было замокать интерфейс аэроспайка. И что-то там пошло не так. Подожди, подожди. А у аэроспайка у него прям есть интерфейс? Там интерфейс, да. Ну ты его можешь, значит, и без всяких МОКИТ реализовать? Ну понимаешь, тебе же нужно реализовывать, а реализовывать не хочется. И плюс, смотри, в чем разница. Вот у тебя есть МОК, у тебя есть стаб. Стаб – это значит, ты реализовал свой интерфейс, его есть какое-то там поведение. А в МОКах ты его не реализуешь, ты делаешь через какой-нибудь фреймворк МОКИТа либо еще что-нибудь. И на МОКе ты можешь удостовериться, что, например, у тебя действительно был вызван такой метод, когда были поданы такие-то параметры. И вот в этом я вижу разницу. Ну окей, ладно. То есть нужно удостовериться, что действительно был вызван какой-то метод, какой-то функции, а не просто мы вернули результат из этой функции, и он получился таким. Ну я понял, писать меньше. Это тоже можно руками, да. Ну просто писать меньше, я понял, в чем удобство, да. Согласен. Ваня, лесок, книга. Все, все, все, можно? Отлично. Где-то неделю назад, я не знаю, все заметили или нет, но Фейсбук лежал какое-то время. Он у меня довольно долго потом поднимался, то есть покажет первую новость, а потом больше ничего не показывает, ленит. Вы заметили вообще, что это было? Нет, я так Фейсбуким не хожу много. А кто-то пользуется вообще? Я им почти не пользуюсь. Понятно. Нет, я тоже не слишком часто пользуюсь, но так совпало однажды, что я прям висел в этот момент в инате, зашел на Фейсбук, а он не работает. Возвращалась ошибка, что что-то пошло не так. Это было прям удивительно для Фейсбука, это не очень характерно. И потом буквально на следующий день они выпустили «Постмортон» на тему, что же у них там такое сломалось. И у них довольно интересно получилась поломка. Они объяснили, как это верхнеуровнево так объяснили, без погружения в код и детали, что у них есть специальная система, которая проверяет, насколько правильные кэши. То есть если она обнаруживает, что кэш слегка некорректный, она заставляет его почиститься и обновиться из какого-то persistent хранилища. Позволь, я себя поправлю. Мне кажется, речь там была именно про конфиги и их кэши. А я как сказал? Я так и хотел сказать. Нет, ты про сервер сказал. И конфиги, значит, они довольно критичны, поэтому у них специальная система именно для конфигов. И когда они слегка поменяли какую-то логику или какие-то конфиги именно в самом хранилище, оказалось, что эта система ведет себя неправильно. Она заставляет всех клиентов, которые получили этот обновленный конфиг, она не верит этому конфигу, заставляет их стереть эти данные, залезть еще раз в базу и вытащить правильную версию. Поэтому все клиенты начали тут же обновляться из базы. База не могла выдержать такую большую нагрузку или два. Это еще больше ухудшило ситуацию, потому что когда клиент считывает ошибку, система должна говорить, о, тут ошибка какая-то произошла, давайте-ка я немножечко не буду сперва спрашивать, а потом спустя какое-то время пролежу, прошла ошибка или нет. Ну, там особенно, если есть какая-то экспертиза на тему, там три ошибки подряд в течение какого-то времени. А здесь эта система увидела, о, у тебя опять некорректные данные какие-то пришли, аррор какой-то, давай-ка сотри его и еще раз сходи проверь в базу. И в общем там все лежало в течение какого-то времени. И для того, чтобы полностью восстановить, им пришлось останавливать полностью поток данных, без этого база не могла восстановиться. И после того, как поток данных отключили, базу восстановили, начали понемножку клиентов подключать, чтобы при этом база могла выдержать, краши начали заполняться правильными значениями, и в общем как-то так. В общем, получилась очень веселая проблема из-за системы, которая должна решать проблемы. Вот. Хеллоу, девять девяток. То Facebook не работает, то Skype. Ничего не работает вообще. Ну, заметь, Facebook выпустили сообщение, объяснили, что у них было не так, а Skype до сих пор ничего не сказал. И не скажет. И они сказали, что они лежали примерно два с половиной часа. За последние четыре года это самое крупное лежание их. Так что я думаю, что тут девятки-то есть. Вопросы, дополнения? Ну, тогда я озвучу кучу своих маленьких темок. Я не думаю, что по ним будет много что сказать. Во-первых, в рассылке rlanc-russian опубликована вакансия. Писать надо на Elixir. Представляете, на Elixir. В Швеции. И там с переездом, вот это всё. Так что всем поросятам, которые нас слушают, самое время заправлять тракторы и так далее. Ссылка в шоу-ноутах, как обычно, dovzen.ru. Погоди, а что там писать-то? А я не помню. Ну, на Elixir или что там? Или какой-нибудь сотовая связь. Ты знаешь, судя, я так бегло проглядываю, похоже на вебчик, но я могу ошибаться, потому что, знаешь ли, много букв. Просто интересно, кто Elixir. Это на самом деле не важно. У тебя есть и Elixir, и Швеция. Что тебе ещё нужно? Согласен, согласен. Должен быть трактор ещё и всё. У Швеции же там холодно, и там как в Питере. Ой, ой, холодно. Там же гольфстрим, какой холодно. Ну как там такая погода, не знаю, на тоску будет и депрессию нагонять. Вам бы в Якутию надо. На настоящий холод посмотреть. Так, идём дальше. В Киеве пройдёт конференция, ну или митап под названием «Киев ФПРОК». То есть не путай с FPConf и так далее. Это «Киев ФПРОК». 31 октября. Я так понял, будет что-то про... Не уверен, не вижу здесь списка докладов, поэтому, наверное, это всё ещё не до конца определилось. Но явно это будет функциональное что-то. Ну, скорее всего, да. Ты же знаешь, как у нас устроено всё в мире FP. Функционально, вот это всё. На самом деле, начинаешь писать, и всё довольно императивно. C-sharp, Java и так далее. И остальные функциональные языки. Да нет, даже Erlang, Scala, они довольно императивные. Но ты пишешь последовательно, типа сделай одно, сделай другое, сделай третье. У тебя нет вот этого, знаешь, декларативного программирования. Но makefile – это главный функциональный язык современности? makefile тоже говорит «сделай то, сделай другое, сделай третье». Ну, то есть, тогда уж HTML – декларативный язык. HTML, декларативный. Ну, SQL считается. Ну, ладно. Согласен. Дальше. Я не уверен, но довольно уверен. Нет, хорошо сказал. Я довольно уверен, что мы рассказывали про метап разработчиков Linux контейнеров в Яндексе, который должен был, ну, и прошёл 19 сентября. Говорили. Да-да-да. Залили видосы. Вот. Всё можно посмотреть. Ссылка в шоу-нотах. Я лично во всю следующую неделю буду по одному видео в день смотреть. К концу недели досмотрев. Я ещё стрейншлуп не начал смотреть. Ты уже должен был закончить. Там всего лишь 70 видео. Кстати, прилепи ссылку в шоу-ноты, что ли. А, кстати, давай. А у нас же будет тема в вопросах слушателей. А, отлично. Хорошо. Потом хочу рассказать, чем закончилась история про игру с Soku One. Она на Kickstarter ничего не собрала. Ну, в смысле, она собрала только 9400 евро из 60 тысяч, которые планировались. Поэтому кампания неудачная. Мне более ценным в этой новости кажется комментарий. Ну, не комментарий. Короче, на YouTube, на канале автора появилось объяснение, почему была именно такая сумма. И почему нельзя было, вот как я предлагал, маленькими шажками. Собрал 5000 евро, написал пару уровней. Во-первых, поясняется, что из 60 тысяч он реально должен был получить на руки 37. Прикиньте, 37 тысяч из 60. Потому что там налоги, фия Kickstarter и так далее. 40%? А это везде так. На Boomstarter тоже конские проценты. Жжжжжж. Потом, и более того, на Kickstarter, оказывается, нельзя сделать такую частичную кампанию-серию. Я сделаю два уровня, а потом двинемся куда-то дальше. То есть по их правилам ты должен либо сделать все, либо ничего. То есть либо я делаю игру, либо я не делаю вообще ничего. А что будет, если ты не доделаешь игру? Вернуть денежку? Я честно не знаю. Но, скорее всего, ничего. У тебя будет плохая репутация. Что там в списке будешь Kickstarter? У меня с микротемками пока все. Я могу добавить еще одну тему, если мы про конференции говорили. Да, давай. Метап по скале, который состоится 11 октября и будет он во Львове. Это уже будет девятая встреча сообщества скалоразработчиков Украины. И, возможно, я туда поеду. Так и доеду. Ссылку не забудь. Сейчас найду и добавлю. Тогда я пока начну рассказывать. В прошлой неделе был Хошеконов, в рамках которого компания Hoshikorp, которая, соответственно, и проводила эту конференцию, объявила кучу всяких объявлений, в том числе два новых продукта. Это Отто и Номад. Я очень внимательно посмотрел про Номад. Я могу многое рассказать сейчас про него. Вкратце про Отто. Они говорят, что Vagrant – это очень клевая система. Количество его использования постоянно растет. Мы следим за ним и так далее. Но он недостаточно хорош для обычного разработчика. И далее они объясняют, что такое обычный разработчик. Обычный разработчик не хочет заниматься ерундой, типа разделения на микросервисы, точное определение, что у тебя в образе есть и так далее. Он хочет просто сказать, что здесь у меня есть приложуха, которая работает на PHP. И я хочу, чтобы она запустилась и работала. И больше ничего знать не хочу. Поэтому конфиг выглядит следующим образом. Ты конфиг вообще можешь не писать. Тогда Отто попытается сам определить, какой язык ты используешь. Какой там какой-то билдпэк надо построить. Билдпэк – это из Хероку. Соответственно, определение такое. Но здесь похоже, видимо, вещи используют. И Отто попытается сам определить, с помощью чего ему нужно запускать. Сам соберет образ, сам его запустит. И вам остаются только исходники. Править и все. Какая-то такая штука. Причем Отто планируется использовать не только для того, чтобы работать на локале, но он будет использоваться и для продакшена. То есть у них вторая проблема, которая там была – это вагрант апп невозможно сделать для большой системы продакшена. Отто можно будет как-то использовать. И какие-то вещи можно будет в этом конфиге дополнительно определять. Например, я хочу использовать Python 2.7.1 обязательно. Или PHP определенной версии. То есть какие-то дополнительные реквизиты вы можете указывать. Вот такая магическая штука. Я не знаю, насколько она будет иметь большую популярность, потому что мне вагрант нравится тем, что я вижу, что я могу сделать и как мне это надо сделать. И я очень часто пользуюсь не так просто «загрузи мне туда исходники и поехали работать», а какие-то сложные «скопируй мне файлы, сконфигурируй мне то-то» и так далее. А вот такую систему я, наверное, не буду использовать. Но, возможно, в мире найдется много людей, которые считают это полезным. Что вы думаете? Мне лично очень нравится, что они не стали все это тащить вагрант, а сделали отдельный инструмент. И смотрят, взлетит ли, не взлетит ли, а может быть нужно будет что-то поменять и так далее. О, да, согласен. Ну ладно, тогда следующая тема – это про Nomad. Nomad – это более серьезная штука. И я вижу, куда они ее нацеливают. Кстати, и по Otto, и по Nomad мне очень понравились документации на сайте HashiCorp. У них там не на их сайте, а у каждого проекта отдельная страничка. Но очень удобно сделан. То есть, ты сперва заходишь в краткое введение, что это такое. Следующая страничка – это сравнение с аналогами конкурентами и чем оно отличается. Почему они считают, что этот продукт все-таки найдет свою нишу. Очень хорошо написано, и меня прям реально порадовало. Nomad – это такая штука, которая должна работать с кластерами. То есть, это кластер менеджмент и шедулер. Они его позиционируют как очень большой. В плане умеющий работать с большими кластерами. Как это? Тут луза умеющий работать с большими кластерами. Они не говорят точно цифры. Но они, сравнивая с Kubernetes, говорят, что Kubernetes в настоящий момент работает с количеством серверов около сотни. Мы работаем на несколько порядков больше. То есть, видимо, 10 тысяч как минимум. Либо 10 тысяч, либо 100 тысяч они имеют в виду. И это в любом случае круто. У него есть свои концепции. То есть, у вас есть джобы, которые объединяются в таски. Таски объединяются в таскгруппы. Таскгруппы объединяются в джобы. И вот эти джобы вы специфицируете в своих файлах. При этом это работает на... У вас есть сервер клиент-архитектура. Сервера объединяются в кластер, который по рафту синхронизирует свое состояние. Выбираются лидеры. Работаете вы всегда через лидеры. А клиенты, с которыми вы работаете, которые вы оркестрируете, они, соответственно, подсоединяются к любому из серверов. При этом в одном дата-центре у вас, в каждом дата-центре, с которым вы работаете, должны быть свои сервера, объединяющиеся по рафту. И они между собой, вот эти дата-центры, тоже взаимодействуют, коммуницируют, обменивают своим состоянием. Именно из этого они позиционируют себя как мульти-дата-центр. То есть, репликейшн. То есть, если у вас один дата-центр ляжет, то второй может схватить его работу, и все будет продолжать работать. У них вся концепция шедулинга основывается на двух пейперах Гугла. Это Омига и Борга. Борговская концепция. То есть, у них там есть шедулеры, у них есть эваливейшн-брокеры, у них есть куча всего. Они разрабатывают план, и потом выполняют этот план. План синхронизируют на сервер, для того, чтобы он был в persistent layer, где-то хранился. Даже если у тебя какой-то шедулер упадет, то следующий, который вместо него встанет, он подхватит работу, и ничего не поломается. В общем, там довольно красивые все концепции, и мне очень хочется попробовать поиграть. При этом они позиционируют себя как универсальное решение с точки зрения того, что лежит под низом. Скажем, кубернет работает только с докером, и докер с вором работает только с докером. Это большинство систем сейчас, они пытаются работать с контейнерами. А сам номод позволяет работать с любыми драйзерами, как они называют эту вещь. То есть, если вы хотите, вы будете запускать докер-контейнеры на этих машинах. Если вы не хотите, вы можете запускать обычный экзек, это значит, любой бинарник запустить. Если вы хотите, вы можете запускать джарники, то есть вы говорите, что у меня драйвер это Java, и я там буду что-то джавовское запускать. При этом можно свои собственные кастомные драйверы писать, для того, чтобы управлять любыми типами рабочих на клиентах. И как-то так все красиво работает. Как обычно, все написано на Go. Все это единый файл, как и в консуле. То есть, вы запускаете либо минус-агент, либо минус-сервер, и в зависимости от этого вы будете на клиенте или на сервере работать из этого бинарника. Все так вот красиво. Вопросы? Дополнения? Мне хочется поподробнее узнать про эту систему Омега, Google Paper. Про Borg мы рассказывали раньше, а про Омегу мы, по-моему, ничего не упоминали. Слушай, я саму эту Омегу не читал, я сейчас на скидку сказать не смогу. Жаль. Но ссылка на Nomad будет, они в своем описании ссылки дают на эту Омегу. Хотя я могу и саму Омегу ссылку положить. Просто, скажем, интересно, как они с Borg соотносятся, что дополняет, и как они вообще связаны. А, кстати, там вы, причем, для каждой задачи еще можете специфицировать все ресурсы, которые вы на этой машине даете этому ТАСКу. То есть, CPU в единицах, у них там все в интеджерах, то есть, CPU в интеджерах, сколько вы CPU ему даете. Сколько памяти даете в интеджерах, тоже это в единицах мегабайт. И каким-то образом, это вор там определяется, то есть, довольно так неплохо они подошли к менеджменту ресурсов. При этом, если у вас остальные рабочие на этой машине, скажем, CPU не используют, то этот шедулер видит, что у него нет больше нагрузки, и дает этому рабочему работать в полную силу. Если кто-то приходит еще, они начинают уже уменьшать количество ресурсов, доступных этому ТАСКу. Я немного не в тему, но я вспомнил, как называется второе проложение для создания мобильных прототипов, то ли Цепелин, то ли Цаплин. Второй инструмент. Зря они, кстати, интеджер взяли. Считай, через лет 10-30, памяти можно будет выделить всего лишь 2 миллиарда. Это сейчас о чем? Ваня же говорил, что все в интеджерах сдается. На будущее, ребята, не посмотрели. Я думаю, это несложно поменять. Если мы про сиршный интеджер, то, если я правильно помню, у него есть ограничение на минимальный размер, но не на максимальный. В нем минимум 2 байта, а максимум может быть сколько угодно. Вот поэтому мы и не пишем на сей мобильный проложение. Нет, но если нужно знать точно, сколько байт, то у тебя есть Uint32, подчеркивание T, например. Ваня как-то быстро отстрелялся. Опять моя тема. Заключается она в том, что есть такая игра, называется Army Krog. И вот была другая игра, называлась Neverhood. Она была примечательна тем, что целиком сделана графика, анимация пластилиновая. Это квест. Я, например, в детстве, или в институте, я играл в эту игру, она действительно очень здорово сделана.",
    "result": {
      "query": "ACCA 2.4 Java 8 Scala 2.11 compatibility"
    }
  }
]