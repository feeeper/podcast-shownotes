[
  {
    "segment_id": "06f7c165-9086-4b47-9461-8aaaf77b0819",
    "episode_id": "6b62cda8-4e23-4d94-9c34-dfae402c08bd",
    "episode_number": 135,
    "segment_number": 6,
    "text": "Я, честно говоря, не помню уже, какую задачу, если вы помните. С файловой системой работа, он открывал файлы, а потом боялся, что они закроются. Он закрывал файлы, да, на самом деле он пытался их закрыть. Вот, ну он работал с файловой системой. И первое его решение, по-моему, это была у него на работе такая задача возникла. Он её написал на работе очень просто, императивным способом. И потом он захотел написать правильным, функциональным способом. Исказывает свой путь, как у него происходил процесс переписывания императивного кода в исключительно функциональный, некларативный. И в конце концов он пришёл к очень громоздкому решению с большим количеством строчек, с очень неочевидной логикой и говорит о том, что это всё очень сложно, непонятно, но ему в целом понравилось. Я добавлю, что, ну во-первых, мне статья совсем не понравилась. И статьи не следует, что он это уже реализовал на императивном и ему заняло очень много времени реализовать то же самое на функциональном стиле. Насколько я понимаю, он просто делал дополнительную just-for-fun работу на функциональном стиле писал. И вот эта вся реализация, она не была готова на императивном, потому что те проблемы, которые он затрагивает при реализации функционального стиля, они фундаментальные. То есть это не проблема функционального стиля или императивного стиля. Насколько я поняла, идея в том, что он императивно смог это очень быстро и легко сделать, он пытался на функциональном стиле сделать это правильным функциональным образом. И у него возникли проблемы. В языке, который для твоего немножко непредназначен, в рантайме, который для твоего немножко непредназначен, в языке, где нет нормальных типов этого всего. Знаешь, это как это... Пойдём, короче, найдём полечко, полюшко, поле, где у нас максимальная плотность граблей, навяжем себя максимально плотную повязку на глаза и побежим кросс. Что может пойти не так? Поддерживаю Валеру. Это всё попахивает каргокультом. То есть, ну, как функциональный подход хорошо и очень хорошим в меру в таких языках, как JavaScript. То есть очень замечательно у них получился React, Redux и прочие вот эти вот библиотеки, которые очень сильно испытали влияние функционального программирования. Вот. А здесь получается какая-то ерунда. То есть он сел переизобретать все best practices, которые есть там в JavaScript по поводу управления ресурсами в Node. Вот. И сел писать свой огромный велосипед и, конечно, он получил паралич. Если хочешь писать на функциональном стиле, то лучше сядь и пиши на Haskell, где всё это уже сделано, или на Scala, где уже есть библиотеки для этого. И будут у тебя и монадки асинхронные, и управление ресурсами, и всё что угодно. Вот. Сразу из коробки, быстро, без какого-либо паралича. То есть он попытался написать на JavaScript монады с garbage-коллектором, с менеджером ресурсов и удивляется, что у него почему-то больше, чем два дня это заняло. Ну... Вот так сюрприз! Помоги Даше найти продолбанное время! Как я понял эту статью, здесь вообще немножко другая задача решалась. То есть не открытие файлов и даже не закрытие. Как мне показалось, тут товарищ поставил себе цель написать какой-то язык совершенно новый, чисто функциональный, вложенный в JavaScript, но совершенно самостоятельный. Вот в этом-то и проблема. Это как-то noble pursuit. Ну, я понимаю, что то, что он делает, это очень хорошо для обучения себя. Но даже для обучения себя он выбрал херовую платформу, чтобы это делать. Он мог взять хотя бы TypeScript и потом уже сверху оборотить. Да нет, пусть даже так, но почему вывод такой, что, ребят, на функциональном языке писать сложно? Смотри, идея такая, человек пошёл, хотел написать правильно, функциональным образом свою задачу. Потом он понял, что в языке не хватает очень многого, чтобы написать правильным функциональным образом. И он пошёл ещё дальше. Он хотел переизобретать язык, он хотел переизобрести много-много всего, чтобы в конце концов получить ту самую функциональность на всех уровнях. Извини, я сейчас перевеваю, но ты сама сформулировала его основную проблему. У него проблема не с тем, что функциональный код писать сложно, а в том, что новый язык писать сложно. Сюрприз. А, давай я скажу, основная проблема, почему здесь вообще проблема возникла. Проблема возникла в том, что он слишком сильно упоролся по ФП. И вместо того, чтобы решать какую-то проблему, которая у него есть на работе, либо ему там дали какую-то задачу, вместо того, чтобы решить эту задачу самым эффективным способом, он пошёл заниматься какой-то фигнёй непонятной. Это он до этого принимал не вместо, да. У меня есть кулстори. Когда-то в 2010 году я заинтересовался Хаскелем и решил посмотреть, о чём общаются люди в Хаскел-сообществе. И пошёл в группу рассылки какую-то по Хаскелу. И на самом верху, последнее письмо, последний тред был заглавлен так. Дескать, лучший способ изучить Хаскел – написать для него компилятор. Вот, типа, мой. И дальше, значит, соответственно, описание того, как человек писал компилятор для Хаскела в качестве изучения. Мне кажется, очень похоже. Да. То есть, ну, хочется добавить, что для… То есть, почему-то функциональное программирование многих людей отпугивает. И это может быть одной из причин, что оно вот так вот… Хочешь решить задачу в функциональном стиле, всё друг за другом цепляется, и ты вместо того, чтобы… Ну, конечно! …записать свою задачу, ты начинаешь изобретать, как будто, знаешь, подталкивает… Нет, блин, ну вот… Вообще странный вывод. Да, это странный вывод. Ещё раз говорю, опять-таки, у тебя… Я уже объяснил, в чём проблема. Чувак пишет свой язык. Это не функциональный стиль, за собой всё тянет. Это как бы задача написать свой язык и свой рантайм, за собой тянут написание своего языка и своего рантайма. Блин, да, это сложно, много работает. А почему он к этому пришёл? Потому что он хотел полностью делать функционально правильно, как положено. Да, он хотел сделать полностью правильно функционально. Он мог взять TypeScript! Он мог взять PureScript. Он взял и даст. Да, и сразу всё работает. Вот, то есть, как бы для меня, действительно, если не решать задачу написать свой язык, непременно внутри JavaScript, короче, не знаю, истекая кровью и имея проблемы с пищеварением, потому что слишком много JavaScript, так, пушуешь. Ну вот, как бы, почему нужно страдать? Ну, то есть, человек поставил себе цель страдать. Не, ну вот реально, Свет, посмотри. Он делает garbage collector, он делает менеджер ресурсов, он делает… Чё там ещё он делал? Он ещё делал систему типов и монады, да? Ну, то есть, как бы он это всё решил сделать. И крючки. Да. А что сподвигло этого человека к такому решению? Упоротость! Я думаю, что это… Да, упоротость по функциональному программированию. Нет, упоротость по функциональному программированию приводят в PureScript, приводят в TypeScript, приводят в Yelm. Это только фронт-энд. То есть, это просто упоротость? Да, это просто упоротость. Притом в хорошем смысле, это нормально писать свой язык программирования. С многими так бывает. Не все потом… Их потом обычно вылечивают. Но это не значит, что тут при чём-то… То есть, он всё-таки с тем же успехом мог обсмотреться, я не знаю… Как это? Объектное интервью на программирование в Java, и пойти делать наследование как в Java. Свой язык программирования правильно объектно ориентировали. У нас уже, кажется, есть такой человек, который это делает. Никто не спорит, что упоротость к чему-то сложному ведёт. Просто у него получаются странные выводы из этой упоротости. Мы единственные с этим спорим, насколько я понимаю. Кстати, упомянутый правильный объектно ориентированный язык, мне лично кажется действительно правильным. То есть, Света, правильно ты говоришь про Егора Бугаенко? Конечно, это же самый известный человек в мире ООП. Мне кажется, то, что он делает, это гораздо более здоровая вещь, чем то, что происходит в Java. И то, что называют ООП в Java. То есть, это прям бальзам на душу. Если бы я увидел ООП таким, каким его предлагает Егор, у меня были бы гораздо более хорошие отношения с ООП, я бы не сплевался и не ушёл бы в функциональщину. Ну, я бы здесь прокомментировала таким образом. Что касается... Любая упоротость и любая крайность и категоричность, будь то функциональное программирование, будь то ООП, неважно, она приводит к несколько превращенным результатам, когда мы получаем язык, в котором он идеальный, он прекрасный в теории, но на практике он даёт очень много такого оверхеда, который, в принципе, не нужен. И, в принципе, всё программирование — это на самом деле про трейд-оффы. Это, собственно, для чего нам нужны инженеры, чтобы они делали правильные решения по трейд-оффам. Где-то там будет функциональное программирование, где-то там будет ООП. Оно должно быть в нужном месте всё, правильно сочетаться, чтобы у нас работала какая-то система и приносила нам в итоге какую-то деньги, прибыль, не важно, решала поставленную задачу. И вот то... Просто не нужно забывать, для чего это всё делается. Ресёрч — это одна тема, это прекрасно, это нужно, но это не про решение прикладных задач. Когда речь идёт про решение, про промышленное программирование, то здесь нужно брать такие разумные, рациональные... Просто делать рациональные решения. Мне кажется, в этой статье речь про промышленное программирование даже близко не идёт. Ну да, здесь ярко выраженная поротость и по какому-то конкретному... То есть здесь вот это увлечение ФП доведено до какого-то безумия, и вот этот сон разума родил такое чудовище. Представляете, если человек сейчас слушает Дюзен и слушает такой упоротый-упоротый, их вылечит... Из моих уст слово упоротый не должно иметь негативного контекста, потому что я себя часто упоротым называю. Если что, я ничего плохого в виду не имел. Ну что, тема себя исчерпала? Да, я предлагаю двигаться дальше. Тут какой-то другой язык есть, может его заодно обсудим? Я понятия не имею, что это такое. F-Lang. Да, собственно говоря, об упортости. В общем, есть такой язык, называется F-Lang. Суть в том, что это, насколько я понял, прочитав то, что там написано, это язык с контролем эффектов, как First Class Citizen. То есть это прям встроено в язык. И выглядит это следующим образом. То есть мы можем перехватить эффект в любом месте. Например, у нас есть функция Println. Мы можем взять и перехватить Println и выполнить этот Println каким-нибудь образом. Например, вместо того, чтобы записать в sddout, записать это дело в сеть или записать в файл. Или мы можем выполнить это дело асинхронно. То есть мы можем взять... При перехвате тебе передается continuation от того вызова. И ты можешь это положить в thread pool и выполнить это дело асинхронно. То есть это развитие идеи Free Monad и Freer Monad. То есть в таких языках, как Haskell, как Scala, это реализуется с помощью Free Monad. Такие вот вещи. А здесь это сделано прямо на уровне языка. Давайте обсудим это дело. Для чего это нужно и как. Я могу попробовать поотвечать на вопросы. Я не очень понимаю, что это за перехваты. Можно пояснить? Ну, Free Monad. Вот так перехватывается. Ну, не знаю. Я не знаю. Я сейчас дам слово, но мне кажется, Free Monad в рамках подкаста объяснять сложновато. Я просто не столкнулся. Можно как бы вообще про цели. То есть зачем это нужно. Какие проблемы пытаются решить программисты, используя Free Monad и опускаясь до такого, в хорошем смысле, безумия. То есть какая есть беда. То, что нам приходит бизнес и говорит. Мяу. Да, он говорит мяу. Он говорит, сделайте нам вот это. Раз, два, три, четыре, пять. Он говорит это нам в своих бизнес терминах. Мы такие, есть. Сейчас сделаем. И мы начинаем писать свои классы, функции, объекты, процессы, чего-то там девопсить. И мы это делаем на некой смеси из вот этих бизнес объектов, из бизнес сущностей, написанных, выраженных в языке бизнеса. И каких-то наших инженерных сущностей, которые живут только в тот момент, когда это дело выполняется. Например, у нас есть некий бизнес объект под названием реквест. Реквест это когда один человек запросил что-то у другого. И он называется реквест. А еще у нас есть реквест, когда, например, HTTP-реквест. И когда читаешь, например, такой код, когда ты принимаешь HTTP-реквест и диссерилизуешь из него реквест, оно становится странным. И любая, по сути, программа это такая смесь машинерии, инженерных сугубо вещей. Приняли реквест, записали в сокет, записали в файл, чего-то там сделали. И бизнес объектов, бизнес логики. Вся история развития, разработки программного обеспечения, если посмотреть через призму общения бизнеса с инженерами, то можно увидеть, как с помощью неких культурных ограничений, с помощью некой культуры кодирования, Solid, DDD, VC, все что угодно, пытались решить эту проблему. То есть разделить каким образом программу слои, выделить какие-то сущности, абстрагироваться, сделать абстракции таким образом, чтобы выделить бизнес-логику в одно место, а машинерию в другое место. Ну и минимизировать количество бизнес-логики, конечно, при этом. Естественно. Но в конечном счете оно так или иначе смешивается, потому что вот эта машинерия, она все равно пролезает. Хороший пример, это вся современная различка, когда мы пишем условно говоря, там MVC, и мы пишем некий сервис-модель, которая там выходит. Прости, но все очень плохо. Так делается бизнес-логика. Что еще? Прости, но все очень плохо, тебя очень плохо слышно. Ты в прошлый раз это починил когда-то? Давай еще раз почини, если сможешь. Окей, я тогда замолчу и чиню. Давай. Кто подхватит флаг? Ой, сложно его подхватывать. Очень сложно. Я понимаю, что такое свободные монады, но мне тяжело это объяснить в подкасте. Я не буду даже пытаться, потому что обычно, когда я пытаюсь объяснять концепции, которые я не пользуюсь каждый день, получается не очень. Поэтому я не буду. Я просто буду болтать языком, не занимать время. Ты уже починил? Я вот тоже про эффекты не очень хорошо могу рассказать. Я не очень хорошо понимаю, но... Да ладно, не стесняйтесь, я еще не починил. Не стесняйтесь. Я думаю, вот... А после... Вообще непонятно. Вообще непонятно. Я имею в виду, когда ты говоришь, тебя не слышно. Почини. Давай почини дальше. Это вообще забавно, то есть можно как это... Короче-таки, как это... Инопланетная цивилизация, которая нас хочет захватить, взвещает из космоса, и вот так будет звучать, наверное. Оно предупреждает нас, чтобы мы не говорили про фримонады, потому что они что-то знают. Да, фримонады разрушили их цивилизацию, поэтому они прилетели на наш глобус и хотят его у нас отобрать, потому что у нас еще фримонады не разрушили цивилизацию, они только разрушили некоторые неокрепшие умы. Но появляются первые языки, которые, возможно, помогут нам разрушить нашу цивилизацию, если связь будет восстановлена. На самом деле я посмотрел сайт, и на сайте есть 4 пайпера и еще несколько ссылок на посты. На самом деле было бы интересно почитать. Тейвилл. Так, вроде подчинилось. Сколотов. Нет. Тейвилл. Нет? Не может такого быть, я вас отлично слышу. Хорошие пи***ы всего. Да, но ты иногда открываешься. Тейвилл. Давайте другую тему, а я потом, когда у меня все отвеснит, продолжим. Давай, так и сделаем. Сложнота, но ок. Если ты захочешь еще продолжать эту тему, вдруг мы что-то интересное найдем. Я предлагаю пока что-нибудь такое, ну да, например, холиворище. В общем, мы периодически пинаем Go. Сегодня уже немножко попинали. Можно еще, да, правда? Давайте еще попинаем Go. В общем, тут довольно часто выходят статьи вроде Go глазами Растамана, Go глазами Элиста, Go глазами Скалиста. И в общем, всем этим людям по понятным причинам не нравится. Ну вот, в качестве как-то очередной представителей серии статей Go глазами Хаскилиста. Хаскилист пошел в компанию Pusher, по-моему, и писал там за ним как-то стажером на гон. И, в общем, по результатам работы... Потом на гон он писал там не то, что обычно люди на гон пишут, а он писал там какой-то tool внутренний для, я так понимаю, то ли для какой-то генерации, то ли еще для чего-то такого. То есть он как это, пользовал год для того, для чего хаскали обычно лучше. Что как это... Ну в общем, дальше по тексту, наверное, посмотрим на это. Ну, собственно, понравилось ему то, что обычно всем нравится. То, что язык очень простой. Не нужно учить монады. Это прямо так в тексте. Хороший гарб... Точнее, не то, что хороший, другой гарбочеколлектор у Хаскиля. Гарбочеколлектор решительно не подходящий для приложений, которые интерактивные, потому что он оптимизирован под throughput. Коллектор там один. Никаких тебе в JVM поигрываний с коллектором сопроводить нельзя. В Go наоборот, у них throughput... Ну, у них никто, я так скажу, никто особо не пытается использовать Go там, где throughput важен. Человек пишет про разрывы и про снижение битрейта. До всех или, собственно, до гостя, который подчинивает себе звук? Это важно, точнее было бы. Ну, Фомкин, я знаю, что Фомкин, но просто как это... Чтобы однозначно идентифицировать. Ладно, вернемся к обзору Go глазами Хаскиля. Хаскилиста. Так вот, да. В Go коллектор наоборот заточен под интерактивные приложения, и с каждым разом все лучше и лучше. А вот, в частности, в 1.8 выкатили довольно существенные улучшения, которые мы уже обсуждали. Ну и, конечно же, стиль здесь припят гвоздями. Есть GoFMT, кто не использует GoFMT, тот тут дурак. Есть вещи, которые окей, жить можно, но в Хаскили якобы лучше. Во-первых, можно никогда генерировать на любой случай, и дальше ниже по тексту автор делает предположение, что возможно это потому что нет генериков. Язык строгий. Я даже наоборот считаю это хорошим поинтом, но автор находит его окей, так себе поинтом. И автор утверждает, что стандартная библиотека не такая хорошая, что ее все превозносит. И он как-то... Именно подчеркивает, что он вообще в принципе этот пункт написал, потому что все очень хвалят стандартную библиотеку. Но вот стоит шаг лево, шаг вправо от типичных визгейсов, которые используются, так сразу она перестает быть отличной. Ну и собственно, что дико не понравилось, это культура обратной совместимости любой ценой, которая во многом, как я говорил, при поменении автора, связана с тем, что depend принято тащить тупо с гитхаба из мастера, что, надеюсь, скоро починят. Системы типов, можно сказать, нет, потому что не просто генериков нету, но на самом деле там вообще как бы статический гарантий, кто бы там что ни говорил, языке мало. И ним повсюду болтается, и генериков нету, и кастуем к пустому интерфейсу часто. В общем... А дальше вот интересный пункт. Тулы — говно. Готов к говно. По причинам. Нету heap-профайлинга, и нету Threadscope. Это такие тулы, которые позволяют... Ну, Threadscope — это такая штука, которая позволяет смотреть, как спарки хаскеля, в случае Go это были бы гарутины, как они размазываются по ядрам, кто чем занят, кто собирает мусор, кто встал, чего-то ждет и так далее. Это очень крутая тула, я ей даже пользовался пару раз. Хип-профайлингом я не пользовался. Но, в общем, обычно считается, что хаскель отложивать сложно. Ну, в частности, потому что ленивость. Но у хаскеля при этом есть тулы, которые действительно очень крутые. У Go можно себе, наверное, что-то в HTTP вывести. По поводу Threadscope, автор утверждает, что на голландский кейм-этапе был какой-то доклад про какую-то штуку, которая похожа на Threadscope, но он не смог на нее никак конкретнее сослаться, к сожалению. Вот. Еще автора дико выбешивает, что несмотря на отсутствие... ну, несмотря на то, что все инициализируется, инициализируется обычно не тем. И это утверждение автора не сильно лучше, чем рандомный мусор. И, конечно же, куча bullet-plate. Ну, еще потому же, потому что нет генериков и потому что эрроры проверять нужно каждый раз через не пойми как. И автор заключает, что на Go он будет писать только если за деньги придется. Вот. Такие дела, такой наброс. Ну, в принципе, он за деньги и пишет. Ну, да. Ну, то есть он писать будет. Вывод такой. Ну, звучат шутки, что генериков нету, еще раз нету. Ну, как бы да, это у многих основная претензия к языку, и больше всего это такая вещь, от которой другие проблемы языка есть, которые просто растут. Есть только для специальных системных типов, это значит, что авторам языка, на самом деле, они понимают, зачем они нужны, но не хотят делать это для общего случая. И вот, как бы, дальше начинается все это. Почему для сих пор не на библиотеках стандартных способов закрывать кучу грутин, потому что это нужно параметризовать через тип и в библиотеку фиг засунешь. Почему того нету? Потому что, опять-таки, нужно, ну, по-хорошему, нужно сделать это параметризованно через тип чего-нибудь, а не через тип, нельзя. Это уменьшает количество того, что можно вынести в библиотеке, это уменьшает безопасность, это уменьшает... Все это делают хуже, и как бы ради того, чтобы компиляция была быстрее. Все это отсутствие генериков. Мне кажется, да, что единственная проблема, которая не растет из-за отсутствия генериков, это, короче, депенды, но депенды чьи нет. Ну, на мой взгляд, мои личные ощущения от Go — ох, мне там не хватает только генериков, и только в таких случаях. Почему автор так много и часто ругался на генерике, на их отсутствие? Потому что он писал то ли кодегенератор, то ли что-то похожее, и я могу представить, что там оно сильно нужнее, чем в типичном вебном ворклоуде каком-нибудь. То есть я вполне себе могу представить, что какую-нибудь распределеночную можно спокойно писать, ни разу про это не вспомнив, что вебный ворклоуд можно писать, ни разу про это не вспомнив. Я точно помню свои ощущения и свое пригорание, когда я, ну я помню, даже рассказывал про это в подкасте, когда я пытался делать плагин для Terraform'а, и у меня просто полыхало в это, потому что, блин, когда тебе нужно манипулировать с деревом конфигурации, и оно все типизировано через каст к пустому интерфейсу и обратно, и у тебя тесты занимают по 40 минут, потому что они гоняются через реальный Амазон, то хочется все просто проклясть и поставить все в жопу и больше этим не заниматься. Да, я могу рассказать сейчас тоже, поделиться своими впечатлениями с точки зрения тоже хэскелиста. Я, правда, на Огоне не писал, в продакшене, что-то такое, тем более за деньги. Но почитать пришлось. Там... В общем, я бы подписался под каждым словом этого автора. Статья, кстати, не очень свежая, она, по-моему, лета прошлого года. Тут вышла недавно новая статья другого автора, где примерно теми же словами рассказывается впечатление от альбомиста Нарасти. Можно я добавлю? Можно, конечно. Вот. Не удаляю предыдущих. Там даже автор второй статьи выдерживает примерно такой же стиль, как и автор первой. Там описывает good, bad и ugly. То, что ему свои впечатления разбил на такие эпизоды. Более подробная статья, там больше впечатлений. В общем, вердикт примерно такой же, что Go, конечно, веселый язык, но я бы на нем писать не стал. И вообще со всех сторон я слышу, что и хаскилисты, и и растаманы или как они там называются, любят, ну, приплюются в сторону Go, зато Go нравится каким-нибудь пистопитонистам. Он все-таки делает чуть-чуть больше статической типизации, чем питон. Мне кажется, тулы, которые для питона сейчас пилят в проспекте, они по-хорошему должны просто в силу того, как языке уже есть, они должны уметь в большее количество как это, в более мощную систему типов, которая проверяет эти вот наиболее хорошо подходящие типы, возможно, это оно, оно должно быть по идее мощнее, чем то, что есть в Go. Я могу ошибаться, но то есть, если оно пытается вывести действительно наиболее подходящий тип, оно там, скорее всего, должно иметь какие-то параметры, типы должны иметь параметры, и оно должно пытаться вывести параметры тоже. Потому что иначе мне трудно представить в языке, где есть гетерогенные коллекции и, точнее, где могут быть гетерогенные коллекции и, может быть, всякое наследование прочего бельверда, мне тяжело себе представить, какой ток от SPEC, если у тебя, может быть, гетерогенная коллекция, которая, ну, то есть в SPEC это можно представить, не знаю, тип суммы, который положен в какой-то функтор. А что такое гетерогенная коллекция, если ты не умеешь выражать параметры типов, то мне тяжело представить какой такой ток вообще от таких спецификаций, хотя я их ни разу в жизни, вообще, я пьют не спецификации, я их ни разу в жизни вообще в глаза не видел, я не знаю, что это на самом деле, я спекулирую сейчас. Вот, кстати, да, в Python тип суммы есть, а в Go нет. И, ну, там, правда, в Python надо, мне кажется, сильно постараться, чтобы эти спецификации проверились и действительно отработали. То есть это не компилятор делает, то есть это дополнительный тулинг? Да, ну, просто к тому, что дополнительный тулинг, скорее всего, опять-таки, я его в глаза не видел, то есть я просто видел в глаза похожие тулинги, а похожие тулинги обычно имеют более выразительную систему, чем вот то, что есть в Go. Но это мы опять возвращаемся к разговору про Scala и Java, то есть... Я вот... Но нет, в Java же есть генерики, ты что такое говоришь? Да я не про это, я про то, что когда у тебя компилятор поддерживает и не даёт работать с неправильными типами, как, например, позволяет Haskell, там, я не знаю, Rust, или, возможно, чуть-чуть позволяет Go по сравнению с Python, да, вот, и другое дело, когда у тебя есть линтер, который у тебя будет проверять это на, не знаю, там VDE, или когда ты дополнительные штуки какие-то запускаешь из консоли, и он будет выдавать, а вот ты знаешь, что ой-ой-ой, ну ты нехорошо тут сделал, ну вот так вот. Вань, ты же писал на Erlang, да? Да, писал. Ты же помнишь, что такое Dialyzer? Конечно. Ты же помнишь, насколько он охренительно иногда находится? И насколько он точно бывает находить вот эти типы суммы? Если не дай бог, где-то есть какой-то параметр, который, ну, тип суммы, или, не упаси его же педерогенная коллекция, оно найдет... Я бы плакал от счастья, если бы эта функциональность была в компиляторе. Ну, я с тобой, скорее, согласен, но мне кажется, это к Максу Сахацкому, они там что-то такое пилили для Гима. Коферы любят говорить, ну все равно же, код проходит через Continuous Integration, все равно ты все тесты прогоняешь, и тесты, и проверки, и статические, или не статические. И я сразу вспоминаю слова Света о том, что в реальной системе вы, скорее всего, никогда не столкнетесь с нулабл в скале, в смысле, как там, НПЕ, но они иногда бывают, но чаще всего никогда нет. Ну, то есть, здесь ты будешь тоже сам иметь. То есть, вроде как, у тебя есть какие-то гарантии, но сто процентов зуб ты не дашь, короче. Я бы хотел сто процентов. Ещё мне кажется, что... Сто процентов не будет никогда, если вот, я не знаю, ну, я могу соврать, но мне кажется, если... Да, ну, вроде работает. Иногда пропадают пакеты. Я вот сейчас смотрю на пинг. Я хотел сказать, что да, я хотел что-то сказать, что например, если обернуть какую-нибудь сишную библиотечку в Хаскел, да, то можно словить вполне себе Сигфолд и всё что угодно, что есть в сишной библиотечке. Вот, ну, правильно я говорю? Товарищи раскилисты, это то же самое, что в скале словить Синал. Да. Даже больше, пример Ваня такой, мы же периодически рассматриваем пейперы и примеры, когда диски ненадёжные, диски ломаются, биты меняются сами по себе из-за космического излучения. То есть, как бы, где сто процентов гарантии? Нет? Нет, это всё понятно. То есть, я имею в виду, что я даже на Хаскеле, когда я только начал программировать, я писал программы, которые падали в эксепшен. Хотя теоретически они не должны, да? То есть, я писал все стили на Хаскеле, и у меня почему-то ничего не получалось. Это потом я только разобрался, что там вместо одних типов надо использовать другие, и не стоит использовать хэ от списка, потому что ты не уверен, есть ли там хоть один элемент. Ну, то есть, как бы, это всё понятное дело, но компилятор должен это делать, компилятор. Ладно, это мечты-мечты. Ну, это для праной, скорее, компилятор. Хочется какой-то гарантии, документально подтвержденной. Хотя в компиляторах тоже бывают баги. И вот тут шах и мат параноики. Такая ещё тема есть, что чем хуже в языке статические гарантии, тем сильнее адепты этого языка кричат про тесты и про то, что мы всё покроем тестами, и у нас всё свалится, потому что мы написали тесты, и вообще отстаньте от нас, мы написали тесты. Сто пунов. Когда что-то сложное... Вот это, кстати, оба автора. Обе их рассматриваемые статьи, по-моему, сходятся к тому, что там очень часто возникает пустой интерфейс. И это на самом деле то же самое, что в старом добром Си. Ну, какой старый, до сих пор используется. Если вы писали на Си, то там «войдзвёздочка», если вы видели в дженерике на Си какой-нибудь стандартной библиотеке, поиск бинарный или сортировка, они все на входе и на выходе «войдзвёздочка». То есть какой-то совершенно абстрактный указатель на непонятно что, и потом ты должен верить в том, что он указывает именно на те данные, которые ты хочешь. И это на самом деле элемент совершенно динамической типизации в языке, казалось бы, статической типизации. Если так вот честно посмотреть на это. И вот хотелось бы, чтобы эти проблемы где-нибудь за пределами языка Си были решены, но оно плохое решение представляет. А еще мне нравится, что в этом списке стандартных ответов гоферов на все претензии, они любят говорить, ну, стандартный вопрос гоферам, где генерик и стандартный ответ на это. Но есть же код генерации и многие почему-то на этом останавливаются. А мне кажется, что это очень странно, что пытаются код генерации покрыть, причем генерацией текста кода, если я правильно понимаю. В других языках такого я не видел, чтобы генерация текста кода, ну, кроме Си, конечно, предлагалась как стандартное решение. То есть есть макросы, там, в Lisp или в Haskell, но они генерят все-таки какое-то относительно честное синтетическое дерево, относительно корректное. А тут предлагается прямо текст писать, прямо генерировать текст, и это как раз в очень неправильной позиции, что в языке, что это предлагается как стандартное решение, такой адовый костыль. Просто они прагматичные, да? То есть в конечном счете, наверняка, что в Haskell-темплейте, что там в Scala-макросах, в Scala-Meti, все сводится к тому, что сначала мы разбираем деревья, а потом мы уходим в квазицитаты, когда, ну, вот, скале мы, например, пишем Q, и пошел там, короче, уже код на Scala, то есть мы генерируем тот же самый текст. Вот. А они просто пропустили этот шаг с ST, сказали, зачем нам все вот эти заморочки, мы сейчас просто возьмем, будем текст генерить. И, в общем, живут с этим прекрасно. Прагматичный подход. И статья заканчивается тем, что там автор говорит, какой хороший будет язык Go 2.0. Это, видимо, с намеком на то, что, ну, гоферы, я слышал, любят говорить, что Go 2.0 никогда не будет, это такая... Ну, в смысле, что никогда не будет, не сломает совместимость, это имеется в виду. И автор, видимо, намекает, что сломать совместимость все-таки придется, чтобы сделать нормальный язык. Скорее, как Perl 6, назовут его по-другому просто. Перл 6? Нет, это скорее как Перл 8. Ну, раньше просто... А, ну да, Perl 6 же вроде как вышел, но раньше про него все время так вот говорили, ну, вот когда Perl 6 выйдет, тогда и поговорим с Илой. Ну, если помните, был такой сайтик, он, по-моему, год прожил, потом сдох. Перл 8 назывался. Он ссылался почему-то на сайт скалы, но все поняли, что такое Перл 8. Вот с Go 2.0, видимо, такая же история. Идеальный язык. Зная идеологию Ларри Волл, мне кажется, что ссылаться на скалу словом Perl 8, это очень неправильно, это очень не оно. Ну, то есть Ларри Волл, он лингвист. Есть, конечно, отдельно странные... То есть, есть лингвисты, которые упарываются по теории категории, они реально есть, но, в общем, мне не кажется, что... Из тех токов, которые можно послушать на ютубе, где-то еще Ларри Волловских, мне не кажется, что оно... В общем, да, мне совсем не кажется, что он бы взял и сделал скалу, ну, что-то похожее даже на скалу в качестве очередного перла. Ну, вот совсем не кажется. Фомкин, пока у тебя хороший интернет, давай свою мысль закончи про F-Lang. Да, я не уверен, что он хороший, на самом деле, потому что таки пакеты пропадают периодически, но пока хороший, да. Собственно говоря, что такое Free Monado, это подводя к F-Lang, да, то есть, это возможность написать некий там, некий DSL, вот, некий набор инструкций, который будет полностью про бизнес-правила. И написать интерпретаторы к этому DSL, которые будут полностью ну, как бы, абстрагированными, да, условно говоря. Мы пишем, да, у нас есть программист специальный бизнес-логик, который пишет на этом DSL и пишет с помощью вот этих вот выражений. Там, не знаю, взять документ из хранилища документов, перевести ему статус там, не знаю, в работе и там, не знаю, назначить на него меня. Вот, и, короче, ждать, когда, там, не знаю, свистнет рак на горе. Вот. И в это время, да, интерпретатор делает там совершенно какие-то невероятные вещи. Он запускает какие-то движки, что-то там, короче, GTL там данные гоняет взад-вперед, там, короче, в BI складываются там какие-то метрики, Spark джобы запускаются, считают большие данные, в общем, все это асинхронно на ThreadPool и, короче, вот все в таком духе. То есть, получается, есть две команды, да, программисты, которые пишут обалденную бизнес-логику, очень проверенную, хорошую, не заморачиваются совершенно в машинерии. И есть другая команда, которая пишет чисто в машинерии и не заморачиваются в бизнес-логике. Они просто делают разные работы. И это очень такой хороший, прагматичный, но сложный подход к решению вот этой проблемы отделения мух от котлет. Бизнес от машинерии. И, собственно говоря, FLANC решает, ну, то есть, эксплуатирует этот подход как часть себя, как часть языка, а не как какая-то там библиотека, которая там на монадах все это делает. Мы реально можем перехватить любой вызов, мы знаем контекст его выполнения, мы можем передать этот контекст куда-нибудь в другое место, мы можем получить все аргументы этого вызова, да, и сделать что-нибудь еще. То есть, вот, ближайшая аналогия, наверное, к этому, чтобы вот совсем было понятно. Представим себе, что любой метод – это бросок исключения. Вот. И всегда есть возможность затравить это дело, да, обернуть в какой-то try-catch по-pattern-match-ить по вот этим исключениям и сгенерировать какие-нибудь, например, новые исключения, которые мы по-pattern-match-им в try более верхнего уровня. Вот. Единственная такая вещь, которую нужно понимать, что мы pattern-match-им не исключения, да, а мы pattern-match-им tuple из continuation и исключения. Continuation нам позволяет, например, continuation – это что такое? Это такой callback, типа «работай дальше», да, вот «верни то, что должна вернуть вот та функция», да. То есть с помощью этого мы, например, можем сделать обычный код, который выглядит как синхронный за счет перехватов, мы сможем, например, его исполнить на thread-пуле, если мы сделаем такой перехватчик. Вот. То есть мы принимаем все и кидаем контекст выполнения в, соответственно, thread-пулу. То есть вот такая вот штука. Кому интересно, посмотрите, пожалуйста. Мне кажется, это хороший подход, очень достойный упоминаниям и достойный посмотреть хотя бы, попробовать написать пару строчек. Сколзинский. Но это надо опять голову немножко свернуть, я правильно понимаю? Тейвилл. Они как раз хотят сделать это доступным. То есть ты пишешь простой оперативный код, ты не заморачиваешься с кучей типов. Это просто интуитивно понятно как исключение. То есть в их интерпретации. Под этим лежит глубокая теория, но у них это сделано просто. Когда мы начинаем ковырять free monad или freer monad, как развитие free monad, там может случиться взрыв мозга, потому что там реально сложная магия на типах. То есть этим тяжело пользоваться и это тяжело определять. Тяжело определять эти DSL, тяжело определять для них интерпретаторы и компиляторы выдают совершенно безумные ошибки, которые там типа что-то опечатался и какая-то чушь собачья лезет в командную строку. То есть этим тяжело пользоваться. А тут ребята пытаются сделать это наоборот, как бы человекопонятным. То есть я думаю, любой, кто знает ML, сможет вполне себе попробовать что-нибудь написать на этом f-ланге. С. — Ну понятно. Всем интересующимся, вот ссылки есть в шоу-нотах. Ну а тут какая-то интересная холиварная тема. Как сделать то, что надо сделать. Сыр, ты добавил? С. — Да, да, да. Ну это, не знаю, это еще одна холиварная тема сравнения хаскила и гои. С. — У тебя прям... Ты явно хочешь перейти на гои. С. — Возможно. Подсознательно. На самом деле я сопротивляюсь. Латентный гофер я, возможно. А тот товарищ пишет о том, что попал в очень странную, просто дикую ситуацию. Там, похоже, что ли все хаскилисты из какой-то фирмы уходились, а пришел человек, который ничего не понимает в этом хаскильном коде, пытается его с ним как-то совладать, пытается что-то в нем починить, и у него это не получается. Он прикладывает все усилия, чтобы изучить хаскил, но у него не получается. И он пришел на реддит и рассказывает, как все плохо в этом вашем хаскиле. С. — Хаскил за два дня на продакшене, я правильно понял? С. — Ну да, да, да. И, пожалуй, заканчивать пост словами, пожалуй, я перепишу это все на ГО. Просто какой-то удивительный выбор. Не знаю почему. Ну, видимо, ГО — это то, что он лучше всего знает. Тогда это единственная разумная версия. С. — К слову, о привычных инструментах, да. Юрий — Ну, в качестве минусов хаскиля он здесь упоминает кабал хел, конечно же. С. — После ГО, после ГО. Юрий — После ГО, это очень смешно. С. — Черт, реально. Слышь, я все вендерил, а теперь у меня кабал хел, да. С. — Пришли реддиторы ему в комментах и, конечно, рассказали, что он все неправильно делает. Юрий — Что он неправ. С. — Да, на самом деле, там, как бы, нужно было потратить еще чуть-чуть немножко усилий. То есть кабал хел не можно найти, если использовать более какие-то простые инструменты. Ну и, короче, на все его претензии нашли ответы и, в общем, как я понял, резюме такое, что надо просто общаться, надо просто искать помощи у добрых людей. И, кстати, хаскильное сообщество, оно очень доброе, очень помогает. Юрий — Одна из претензий. У вас везде используются однобуквенные имена переменных. Вы чё, сумасшедшие? С. — Ну надо даже хаскель поменять, а то везде, всю дорогу гопинаем. За что его так бедного? С. — А, кстати, вот интересная штука. Вот, отвратительно ли... Смотрите, я думал, почему люди используют длинные имена переменных? Почему они используют короткие, это понятно. А почему используют длинные? Ю. — Мне, наоборот, не очень понятно, почему используют короткие. Я понимаю, что писать, может быть, лень, но есть же редакторы кода IDE, то есть в Vim'е, даже, по-моему, в GolemV есть комплит по просто похожим словам, которые встречаются в тексте. С. — Ну, смотри, короче, мне кажется, единственная причина коротких имен — то, чтобы не заморачиваться с названиями. Если ты пишешь достаточно какой-то короткий код, там, функцию на 3 строчки, то логично всегда называть любую коллекцию XS, а любой там value X. И ты прекрасно с этим живёшь. Если у тебя, понятно, методы на 50 строк, ты начинаешь разворачивать это дело. И к чему я? Я подумал, что много случаев, когда длинные названия проистекают из того, что мы хотим нагрузить вот эту переменную к какой-нибудь семантике. Например, ну, я не знаю, есть у нас функция, которая принимает имя, да, какую-нибудь строку, но вот это имя как строка, да, и вот это имя конкретно в эту функцию, оно должно попасть уже там, я не знаю, в Base64. И программист называет это переменную, этот аргумент Base64 name encoded Base64 encoded, например. Потому что он передаёт семантику то, что это было закодировано в Base64. В языках, где есть возможность что-то ну, как-то выразить это с помощью типов, такого не нужно. Мы можем назвать это просто name, а тип этой функции, этого аргумента сделать, соответственно, там, string с тегом Base64 encoded, да, а функция Base64 encode будет у нас возвращать string Base64 encoded, да, то есть, ну, я имею в виду type tagging, например, в скале с помощью sheperd из библиотеки. Вот. То есть это, ну, то есть привычка называть длинно во многом происходит из-за недостатков систем типов традиционных языков. Да, из-за слонов. Ну, нет. Это, на мой взгляд, происходит из-за того, что если есть две переменных, они ещё могут быть x, y или a, b. Если тех 3, или 4, или 5, это уже тяжело в голове держать. Просто им нужны какие-то смыслы названия. Не имеет ничего общего с типами, на мой взгляд. Ну, всё правильно. А у тебя в как бы императивных языках получаются большие методы, там, по, там, не знаю, ну, 10 строк, это уже много. Ну, не знаю, у меня и в Ирландии, собственно, получается, длинное. Много. Ну, а ирландский не очень уж функциональный язык, прям, что-то прям пипец функциональный. Согласен. И система типов слабенькая, это всё понятно. Но я здесь согласен с этим, то есть, как бы, если тебе, например, насколько у тебя говорящие должны быть имена, то есть, скажем, возьми ту же функцию фолды, то есть там надо 3 элемента, и если ты напишешь a к одному из них, другому это второе имя, там, да, и список, там, лист третий, l нажмёшь, тебе непонятно будет, что оно делает? Ну, то есть, как бы... Ну, на мой взгляд, aqq это уже достаточно понятное название, потому что это аккумулятор, и все, кто пишет на этом языке, они будут знать, что aqq — это аккумулятор. А также они будут знать из-за того, что они фолды используют часто, и того, что у тебя в спецификации функции типами обозначено что где что. Вот ты не поверишь, но я регулярно забываю порядок. Я никогда его не запоминаю. Я согласен с тобой. Я к тому, что... А зачем тебе здесь длинные имена давать? Ты же не будешь называть это b64 string на входе? Я не говорю, что длинные... Для меня длинное имя — это, не знаю, хотя бы одно слово, которое... То есть для меня короткий вариант — это 1-2 буквы. Я думаю, для маленьких функций типа лямбд, это подходящий вариант. Когда мы пишем функцию, и там что-то неочевидное, не по конвенциям, к которым программисты обычно привыкли, то там нужно давать осмысленные имена, потому что пройдет время, и ты банально забудешь. Жависты не привыкли к конвенции xxs, ak, и этот самый rek, там какой-нибудь aux. Вот. В общем, все это немножко холиварно, немножко субъективно, и надо... Имя должно соответствовать правильному уровню абстракции. А правильный уровень абстракции не должен... Определяется читатель в чьем числе? Ну, да. Программист должен правильно найти правильный уровень абстракции, а это очень сложно. Очень легко перегенерализовать или переспецифицировать. То есть слишком общую абстракцию придумать или слишком частную. Вот это. И почему-то хоскелисты часто скатываются в проблему слишком преждевременного обобщения. То есть немножко язык располагает к этому, мне кажется. Но это не очень большой проблем. Вот, кстати, есть еще тоже похожая проблема с венгерской нотацией. Если кто-то помнит что-нибудь... Вот, да. Была попытка решить проблему типизации с помощью имен, фактически перекладывая имя на человека. Предлагалось называть, допустим, числовые переменные должны начинаться с буквы N. Например. И тогда, если у нас меняется тип переменной, то мы сразу увидим, что у нее тип 1, а имя не соответствует типу. Тип не продублирован в имени, тогда мы сразу увидим ошибку. Во всех местах, где это используется. Тогда мы переменуем переменную и тогда в тех местах, где это переменно используется, мы сразу видим ошибку. Я надеюсь, она ведь нигде не используется уже, эта венгерская нотация? Чего знаю, где-нибудь в Майкрософте. Чат, кто-нибудь использует венгерскую нотацию? Я использовал венгерскую нотацию 10 лет назад, когда писал на MAMS. У нас были дулые разработки, ужасные. MAMS, динамически типизированный язык. И мы использовали венгерскую нотацию, чтобы понимать, что у нас тут в этой переменной лежит число или строка. Самое интересное, что я очень прям молился на эту нотацию, я считал, что это гениальное изобретение.",
    "result": {
      "error": "API request failed: Error code: 400 - {'error': 'Trying to keep the first 12305 tokens when context the overflows. However, the model is loaded with context length of only 12276 tokens, which is not enough. Try to load the model with a larger context length, or provide a shorter input'}",
      "stack_trace": "Traceback (most recent call last):\n  File \"/home/andrei/Projects/podcast-shownotes/scripts/build_search_eval_dataset.py\", line 193, in generate_search_query\n    response = await self.client.chat.completions.create(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/resources/chat/completions/completions.py\", line 1927, in create\n    return await self._post(\n           ^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1767, in post\n    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1461, in request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1562, in _request\n    raise self._make_status_error_from_response(err.response) from None\nopenai.BadRequestError: Error code: 400 - {'error': 'Trying to keep the first 12305 tokens when context the overflows. However, the model is loaded with context length of only 12276 tokens, which is not enough. Try to load the model with a larger context length, or provide a shorter input'}\n"
    }
  }
]