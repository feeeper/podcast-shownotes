[
  {
    "segment_id": "66b6a0c6-a899-4440-aec1-48880a684b09",
    "episode_id": "c282a006-7c78-4c5a-b729-7a0877214c6a",
    "episode_number": 1,
    "segment_number": 4,
    "text": "Чтобы поддержку XML написать на макросах. Завернуть в библиотеку. И у тебя будет отдельный библиотека для работы с XML. Они в итоге так и сделали. У тебя в текущей скале, которая 2.11, XML это уже не часть языка. Но вынесено в библиотечку отдельно. И я так понимаю, эта библиотечка активно паразитирует на макросах. Но я, впрочем, не специалист. И вообще макросы это не такая бесполезная штука в целом. То есть их, конечно, не нужно лепить налево и направо. Но вот проектик наш на Haskell, который я писал, там кое-какие макросы используются. Для чего? Поскольку проект на Haskell, а в Haskell вообще очень удачно генерится экзешник. У тебя все приложение это один большой бинарник. С точностью до всяких библиотек типа libgmp. От нее, я так понял, Haskell на RTS зависит. И библиотеки... Например, в нашем случае это был libpq, которая для Postgres. Потому что биндинги Haskell к Postgres, они ее используют динамически, слинкованно. У тебя получается бинарник, и он от пары библиотек зависит. И я говорил о макросах. Например, я их использовал для того, чтобы определить во время компиляции версию приложения. Сказав git tag, чего-то там, бла-бла-бла. То есть ты по тегам определяешь. Ты тегаешь приложение, типа 0.1.0, 0.2.0. И во время компиляции запускаешь гид, определяешь версию и вклеиваешь определенную версию в твое приложение. Почему так сделано? Чтобы не таскать какой-то файлик. Ты когда делаешь деп-пакет, тебе нужно... Понятно. То есть тебе нужно какой-то файлик куда-то положить, написать, что версия такая-то. Потом, когда приложение запускается, тебе нужно в какой-то мониторинг сообщить свою версию. Тебе нужно этот файлик прочитать. И у тебя возникает проблема, что когда ты, разработчик, компилируешь программу и запускаешь, ей этот файлик нужно искать в локальном каталоге, там где ты с исходниками. Когда ты ее задеплоил на сервер, тебе этот файлик нужно искать где-то там в ЕТК. Все это неудобно. Аналогично можно вклеить прямо в бинарник миграцию схемы базы данных и другие вещи. Иногда просто есть шаблонный код, который... Ну, там, не знаю, у тебя 10 функций, они довольно похожи, но там отличаются совсем чуть-чуть. И ты не можешь это как-то обобщить, передав лямбочку или еще как-то. Тоже очень удобно. Ты делаешь шаблон и нужные значения подменяешь в AST и генеришь этим код. То есть для таких небольших вещей макросы очень полезны. И я с большим удовольствием использую. А вообще, насколько это корректно с точки зрения парадигм? То же функциональное программирование. Ну, исторически функциональное программирование это у нас что?",
    "result": {
      "query": "макросы Scala XML библиотека 2.11"
    }
  }
]