[
  {
    "segment_id": "060bb4aa-ec0d-4a8b-86c7-0c517067eaa4",
    "episode_id": "68bc8d37-85ef-4757-920f-2a6d8ec2ea5f",
    "episode_number": 128,
    "segment_number": 4,
    "text": "То есть, например, часть гору тин лодчатся взаимно и ничего они не будут делать. Вы никак это не поймаете в рентайме и ничего не сделаете. И вот это была, я так понимаю, у них основная цель проверять. И они, значит, набор утилит, который они написали, первый в этом наборе, это гоинфер, который пытается извлечь, как это, behavioral types из гошной программы. Behavioral types, я ссылку кинул, это другой пейпер другой команды, и они вводят, как это правильно на русский перевести, типы, которые определяются поведением, наверное, для системы акторов. Это отдельная система типов, которая была введена, она помогает анализировать акторов и типы сообщений, которые они выводят. И вот как раз основная идея, чтобы… Интересно, хоть сколько-нибудь похоже на session types или что-то совсем другое? Я не успел во второй пейпер посмотреть, извини, Валер. Значит, идея в чем, то есть у них две утилиты, одна утилита перегоняет гошную программу во внутренний язык и из внутреннего языка пытается построить какое-то дерево для своих собственных целей, а вторая производит анализ на этом построенном дереве. Первая, значит, вот эта go-infer как раз, она использует static simple single assignment пакет, который как раз переводит во внутреннее представление, и использует, потом в дальнейшем из этого внутреннего представления строит систему типов, которую они назвали mini-go, это, я так понимаю, модель языка go в миниатюре, которая просто показывает, самое главное, что она показывает, это она показывает, какие есть горутины, и какими типами сообщения эти горутины между собой обмениваются по каким каналам. Фактически они здесь строят дерево зависимостей тип горутины от типов сообщений в каналах, в которых они обмениваются. То есть, если ты говоришь, что у меня вот создается горутина типа А, то ты однозначно знаешь, что она будет создавать каналы, в которые будет создаваться сообщение типа Б, и каналы, которые будут создаваться в сообщении типа С, передаваться в одну сторону или в другую сторону, и таким образом ты однозначно специфицируешь полностью свою программу с точки зрения взаимодействия между актерами. Это как раз все сделано на языке mini-go, который они там сами написали, они его кратко назвали mi-go. Имея вот этот mi-go и этот язык взаимодействия между актерами, они могут строить какую-то логику уже поверх этого и доказывать корректность или некорректность программы. Понятное дело, что они не докажут полную корректность или полную некорректность, то есть они ловят какие-то типа ошибок, они строго описали это в своем пейпере, какие типа ошибок они ловят, но я боюсь, я сейчас не смогу это сказать, я там невнимательно читал.",
    "result": {
      "query": "go-infer анализ Go goroutines типы сообщений"
    }
  }
]