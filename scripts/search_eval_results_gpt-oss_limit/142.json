[
  {
    "segment_id": "9a9b2f54-e14a-466a-a1f8-6ec10b126837",
    "episode_id": "825064f9-fe09-450c-b3f4-491a381bd679",
    "episode_number": 142,
    "segment_number": 2,
    "text": "Я не уверен, это стоит посмотреть по истории на GitHub, там первый коммит когда-то был. Не, ну первый коммит и, я не знаю, объявление о том, что ребята пользуетесь, это немножко разные вещи? Или вы это совместили? Нет, там вот, когда проект выкатился на GitHub, это был ровно тот момент, когда ребята пользуются. А, понятно. А ты, соответственно, присоединился попозже? Да, точнее как, я сизколлер, начал делать Дмитрий Вьюков, и начал его делать еще когда я был на стажировке, по-моему, на третьей стажировке. И, собственно, к концу моей стажировки, насколько я помню, это был вот как раз момент релиза, то есть его выкатили, и он уже начал находить ошибки какое-то безумное количество. Я закончил третью стажировку, видимо, в конце 2015, а вот в сентябре 2016 я пришел на фуллтайм, к этому моменту сизколлер уже был такой раскрученный тулзой. И, собственно, в этот момент я присоединился к разработке сизколлера. У меня такой вопрос. А ты не мог бы поподробнее описать, как выглядит твоя работа в Гугле? То есть, ну ты такой приходишь утром, завариваешь себе кофе, садишься за комп, ну там, почту проверяешь, понятно, потом садишься и начинаешь ввозить ядро Линукса, или же у вас есть какой-то project owner, который вам там время от времени, не знаю, собирает вас на стендапы, там вы обсуждаете, кто что сделал, кто сколько зеродев закрыл и так далее. Ну то есть поподробнее, как это вообще выглядит. А еще, наверное, у тебя есть KPI, сколько там ты за неделю сделал. Я понял вопрос, хорошо. Во-первых, собственно, тут два вопроса, наверное. Первый — это как выглядит в целом рабочий день, когда я на работу прихожу и что я делаю, и второй — как выглядит вообще процесс разработки и поиска ошибок. В Гугле очень свободно, как это называется, в общем, часы работы, они очень свободны, то есть я могу приходить и уходить в офис в любое время до тех пор, пока я делаю свою работу. Я обычно, у меня режим дня такой, что я просыпаюсь где-то к полудню и к концу обеда прихожу на работу. Я действительно сначала читаю почту, проверяю найденные ошибки. Здесь такой важно отметить, что сисколлер — это файзер, который... Зло в том, что он у меня все время крутится и все время находит что-то, поэтому я утром прихожу и, грубо говоря, проверяю репорты, которые он нашел за ночь. Если нужно, я там репорт их разработчикам ядра или делаю что-то еще. Ну, блин, там сколько их он целых зарепортил? 200 штук? Там, по-моему, уже около 500, ну, в общем, безумное количество. А из них много ли из них false positive? Это все true positive, то есть это все настоящие ошибки. Так, все, я, короче, валю на Mac, не на BSD. А насчет самого рабочего процесса... Во-первых, у нас в действительности, у нашей команды раз в неделю происходят митинги, где мы рассказываем, кто что сделал, кто что собирается сделать и всякие такие обсуждения. А то, собственно, у меня есть какой-то план, который я собираюсь осуществить, то есть который мне нужно осуществить, например, сейчас, чем я занимаюсь. Я занимаюсь тем, чтобы научить сисколлер лучше фазить сетевой интерфейс как изнутри, то есть со стороны юзерспейса, так и снаружи. И у меня там есть задача, что нужно описать какие-то сисколлы, или там нужно найти такое количество ошибок, допустим. То есть KPI есть? Что такое KPI? Я думаю, ты уже ответил, на самом деле. Здесь, понимаешь, как я уже сказал, то, что я там найду 100-500 ошибок, это не так важно. То есть если какой-нибудь другой человек придёт и найдёт 100-500 ошибок с помощью нашего инструмента, вот это очень круто. У меня такой вопрос. А когда... ну то есть вот ты нашёл баг, ты, допустим, разобрался, можешь предложить патч, я правильно понимаю, что написание Proof of Concept это очень сильно опционально, или тебе, чтобы патч протолкнуть в ядро, нужно именно Proof of Concept сначала сделать? Да. Смотрите. Во-первых, когда я нахожу ошибку, обычно я пытаюсь сначала оценить какой-то импакт, насколько это серьёзно. Большая часть случаев это какие-нибудь осёрт где-нибудь срабатывает, и в этом случае я просто репорчу эту ошибку и присылаю репродюсер. Кстати, сисколлер, у него очень важная фишка в том, что он для ошибок умеет генерить репродюсеры, то есть это фишная программа, которую ты запускаешь, и она триггерит ошибку в ядре. Вот. Потом, если я вижу, что этот баг действительно... действительно что-то не очень хорошее, например, он там привносит какую-то уязвимость, то я могу написать Proof of Concept. Здесь дело в том, что почему-то сообщество вообще вот этих безопасников, людей, которые занимаются безопасностью, оно работает таким образом, что если ты им скажешь, что вот у меня есть инструмент, который нашёл 500 ошибок, им это неинтересно. А если ты скажешь, что вот у меня есть инструмент, он нашёл ошибку, я там написал exploit, то неожиданно это вызывает хайп, там репосты в Твиттере, в новостях пишут и так далее. Имена имена дают, и сайт открывает багу. Да, типа того. Соответственно, написание вот этих вот Proof of Concept, это действительно такой способ копиарить. Это первая причина. Вторая причина — это то, что мне это нравится, потому что мне интересно в действительности не просто находить какую-то ошибку, которая может привести к каким-то последствиям, а может и не может, а разобраться, понять, как это сделать, разобраться, как оно работает и написать exploit. По-моему, это очень интересно. Ну вот из этих 500 реально уязвимостей, которых можно использовать, я не знаю, через сетевой стек или ещё как-нибудь, насколько много было? Большая часть из них, они локальны, и мне кажется, как минимум половина — это те, которые называются типа local DOS, denial of service, то есть если ты запускаешь программку, то у тебя крашится ядро. Удалённых уязвимостей, которые именно можно удалённо через Network Stack, там буквально штук 5. Мне кажется, самая последняя была недавно. Недавно Android выкатил очередное обновление, в котором он описал одну из уязвимостей как Remote Code Execution, и вот это была одна из уязвимостей в UDP, с помощью которой можно удалённо покрашить машину. То есть удалённых уязвимостей пока что не так много, но в текущий момент я в том числе работаю над этим. То есть идея состоит в том, что ядро... Когда ты говоришь, что работаю над удалёнными уязвимостями, это прям звучит не очень. Я работаю над поиском ошибок, которые можно стриггерить удалённо. И что ты для этого будешь делать? Упрощение поиска? Нет, смысл лучше. Смысл в том, что у тебя есть ядро, и ядро принимает на вход некоторые инпуты. Это могут быть инпуты от User Space в виде сисколлов, это могут быть инпуты в виде пакетов, которые приходят по сети. Это могут быть инпуты, например, если у тебя есть машина, ты воткнул в неё USB-девайс, и девайс начинает общаться с драйвером USB, соответственно, это тоже инпут. Сисколлер на текущий момент, буквально месяц назад я его научил, научил тому, что он теперь способен имитить пакеты в ядро, как будто бы они пришли снаружи. Таким образом, мы можем фазить его интерфейс, то есть мы можем фазить сам процесс парсинга пакетов ядром, как будто бы эти пакеты прилетели снаружи. То есть не задействует сеть на самом деле? Да, на самом деле сеть не задействуется, это делается просто через Tuned Up интерфейс, который есть в Linux. Но это по сути триггерит те же самые пути, как и для реальных пакетов. Просто упрощение процесса получается. А можешь поподробнее рассказать про методы написания эксплойтов, которые еще не потеряли актуальность в 3-м тысячелетии? Вот я сейчас смотрю на твою статью, там перечислено три технологии в ядре, это KSLR, SMAP, первая SMEP, а вторая SMAP. То есть вот, например, я знаю, что ROP-цепочки вроде бы еще работают, но вот маленькая проблема, что тебе для ее использования нужно знать адреса, по которым передавать управление, а ты их не знаешь, поэтому тебе еще нужно иметь возможность читать память в дополнение к переполнению буфера, например. То есть какие сейчас методы еще актуальны, а какие уже совсем-совсем умерли и можно про них забыть? Ну, SMEP, SMAP и KSLR – это не столько методы эксплуатации, сколько техники защиты. Да-да-да, я, наверное, плохо выразился. Нет, имелось в виду именно, какие техники атаки позволяют обойти эти методы защиты. Ну, это зависит, собственно, от того, какой баг ты эксплуатируешь. То есть вот, например, баг в стиле последнего того, что был в packet-socket'ах, это по факту переполнение буфера в heap'е произвольного размера с произвольным offset'ом и контролируемыми данными. От него не спасает ни SMEP, ни SMAP, и, скорее всего, KSLR тоже не спасает. Ну, подожди, ну хорошо, ты можешь записать в... То есть верно ли мое понимание, что этот баг позволяет тебе записать по произвольному адресу произвольные данные? Сам по себе этот примитив не позволяет тебе это сделать, он позволяет тебе лишь переполнить некоторый определенный буфер. Но если ты сумеешь... Ну, то есть там что баг заключался? Что копируются данные в буфер, который лежит на heap'е, и можно некоторым образом обойти проверки на размер этого буфера, в результате скопируются данные за пределами выделенного буфера. Хорошо, окей, не по произвольному адресу. Ну, значит, вот, например, за этим буфером у тебя лежит какая-то структура, в которой есть поинтер. Пока в правильном направлении мыслим, да? Да, все верно. Хорошо, ну, допустим, мы в этот поинтер указали... Мы туда можем какой-то адрес указать, да? Но откуда мы знаем, куда надо указывать? У нас же все адреса перемешаны. Да, это правда. То есть тебе недостаточно только... Ну, да и смотри, во-первых, у тебя есть кслр, который делает следующее. Он кладет ядро и кладет там всякие участки памяти, которые используют ядро, по случайным адресам, так что ты не можешь заранее предсказать, где что окажется. Вот. Если ты каким-то образом обошел кслр, ты уже знаешь, где находится ядро, и, возможно, знаешь, где находятся те или иные объекты в памяти. Соответственно, если ты обошел кслр и сумел утечь указатель на эти объекты, ты можешь вот в этот поинтер положить указатель на данные, про которые ты уже знаешь. То есть в действительности здесь одной по себе самой этой ошибки с переполнением буфера недостаточно. Тебе нужно сделать что-то еще. Но! Но! Не факт, что сам по себе вот этот примитив с переполнением буфера не может дать тебе возможности обойти кслр. То есть, например, этот примитив можно использовать каким-то образом так, чтобы ты смог читать там произвольные данные из ядра. Это зависит от конкретной баги, от конкретного поведения программы в районе кода, где происходит ошибка. Понял, спасибо. Слушай, а сколько лет ты уже занимаешься вот этой темой? Сколько лет? Я занимаюсь в целом ядром или эксплоитами? Ну, темой безопасности, я бы так в общем назвала. Я думаю, что... Смотрите, в CTF я начал участвовать года три назад. Конкретно ядром я занимался три стажировки, то есть три лета по три месяца, и вот сейчас еще полгода. Вот, соответственно, можно сказать, что ядром я занимаюсь год, а CTF-ами и чем-то связанным с бинарными уязвимостями года два или три. А не хотелось бы что-то другое попробовать? Ну, в рамках CTF я пробовал другие категории уязвимостей, там категории ошибок, категории задачек в стиле Веба. Веба — это тоже довольно интересно. Но поскольку так получилось, что я оказался в команде, которая занимается ядром, то я занимаюсь бинарными уязвимостями на текущий момент. На самом деле меня еще очень интересует тема с еще более лоу-левелом, типа уязвимостей в прошивках, которым, например, занимается Дима Алексюк. Но до этого я пока не добрался. Мне кажется, немного ортогональные вещи, например, реверсить прошивку и искать баг в ядре Линукса, то есть и то, и другое очень круто, но как-то несопоставимые вещи. Поскольку, ну вот не знаю, например, один из последних блокпостов у Project Zero как раз был про то, как нашли ошибку в прошивке чипсета Wi-Fi в Андроиде. И ошибкой там тоже заключалось, насколько я помню, в переполнении какого-то буфера. И эксплуатация ошибок в этом чипсете, собственно, сам процесс бинарной эксплуатации очень похож на сам процесс эксплуатации ошибок в ядре. То есть это вещи чуть-чуть разные, но идея примерно одинаковая. То есть и в том, и в другом случае ты пишешь какой-то эксплойт, который делает что-то, что ты хочешь, что изначально не предполагалось. Ну слушай, это вообще во всей теме безопасности так. То есть там ограниченное количество проблем, но ты просто используешь их в разных программах, и поэтому каждый раз должен подгонять под эти условия и то, что ты хочешь сделать. Ну там переполнение ты должен записать, знать куда записать, знать что записать, и поехали. А можно я гостя помучаю про этот сисколлер? Мне реально интересная тема. Можно? Чем она тебя так зацепила, если не секрет? Ну, во-первых, я сам сталкивался немножко с ядром, с профилированием и так далее. А во-вторых, я не знаю, вас не потрясает, насколько простая тема, насколько много проблем может найти и сколько лет прошло с начала изобретения ядра, прежде чем приступили к этой теме. Мне вообще кажется, что это удивительно. Я не считаю, что сисколлер — это очень сложная концептуальная вещь. Идея простая, понятная, просто почему-то никому в голову не приходило, а сейчас вот пришла и начали ее делать. Я прав или нет, Андрей? Смотри, идея файзинга ядра со стороны сисколлов довольно древняя. Уже давно существует файзер, который называется Trinity, который все, что делает, он тоже генерирует сисколлы по определенным правилам, исполняет их и пытается триггерить какие-то ошибки. Это первое. Само по себе использование файзера без какого-то инструмента для детекта багов может быть не очень эффективно. У тебя могут быть баги, которые не проявляются прямо-таки явно. Например, в процессе исполнения какой-то последовательности сисколлов у тебя не происходит краша ядра, но тем не менее происходит какой-нибудь выход за границу массива, который ничего плохого не триггерит. Однако если ты чуть-чуть поменяешь аргумент сисколлов, то он может триггерить что-нибудь плохое. Не, но это Valkgrain давно уже ловит. То есть тулинг полностью уже присутствует давным-давно. Да, но Valkgrain ты не можешь использовать для ядра. Соответственно, что первое появилось, что первое мы сделали, это как раз адрес санитайзера для ядра, который позволяет ловить ошибки. То есть это была принципиальная проблема, из-за которой файзер не использовали полноценно для дебаггинга ядра? Файзер использовали, просто это было не так эффективно. Собственно, первый шаг это был сделать еще и детектор ошибок. Сначала адрес санитайзера, теперь мемори санитайзер, дальше будет трад санитайзер и так далее. Это первое. Второй важный факт состоит в том, что сисколлер он coverage-guided. Это означает то, что сисколлер, вообще как он работает? У него есть корпус программ, которые триггерят интересные кусочки кода внутри ядра. То есть сисколлер может отслеживать, какие инструкции, какие точнее basic блоки были исполнены в процессе исполнения определенной программы. Таким образом, он может взять, например, какую-нибудь программу, помутировать ее, то есть чуть-чуть изменить, и посмотреть, триггерило ли это изменение новые пути внутри ядра. Если да, то эта программа интересна, и он ее запоминает. Если нет, то она не интересна, и она отбрасывает. Таким образом, он может генерить все более и более интересные программы, которые триггерят все более новые кусочки ядра, и соответственно, находить там ошибки. Это был второй важный шаг, то что coverage-guided fuzzing, а не просто тупо стреляем сисколлами. Ну это тоже не новая идея. Я студентом был, когда я читал подобные пейперы. Но не про ядро, а про компиляторы и разработку. Да, идея безусловно не новая. Все, что нужно было сделать, это применить ее до ядра. Да, то есть доделать до конца адрес-санитайзер, доделать до конца, чтобы он мог работать на ядре, и совместить все эти кусочки вместе, для того чтобы найти, подумаешь, всего 500 багов в ядре, которые используются по всему миру, и включая сотовые телефоны. Ну как Валера правильно заметил, что все идеи придумали где-то в 70-е. Осталось их правильно реализовать. Да, да. Ну и получается, что, вот скажем, добивая вот эту тему с покрытием, то есть вот я описываю структуру сисколла, фактически семантику, что куда передается, какие возможные аргументы, там получается что-то вроде алгебрического описания, алгебрических типов данных, вида сисколл такого типа, здесь будут параметры такие или такие, а здесь такие или такие, а если там такое, то здесь такое, да, что-то типа такого. А потом запускаешь, ты натравливаешь на этот файзер, который с помощью покрытия все новые и новые генерирует программы, которые покрывают почти 100% или 100% данной функциональности ядра. Я правильно понимаю? Да, в целом все верно. И более того, мне кажется, любой человек, который этим заинтересован, а может и сисколлер, может дописать туда описание какого-нибудь очередного сисколла, или, например, очередного, ну просто бесконечный источник ошибок — это всякие девайс-драйверы, например. Второй бесконечный источник, вот с моей точки зрения, поскольку я занимаюсь сейчас сетью, это всяческие сокеты. Например, там была ошибка в DCP-сокетах, про которую я никогда в жизни не слышал, но стоило написать описание для DCP-сокетов, запустить сисколлер, он за ночь нашел там десяток ошибок. Вот, соответственно, любой человек желающий может написать эти описания, запустить сисколлер и находить ошибки сколько угодно. Но это же потенциально, это генератор уязвимостей, ну я имею в виду тех, то есть скажу, если сейчас кто-то черный хакер возьмет и напишет все описания для всех, скажем, сетевых сисколлов, и для работы с сокетами, и вот это все, и он просто раньше всех остальных найдет все эти ошибки, начнет их эксплуатировать, пока сообщество не поправит. Не беспокойся, у черного хакера уже все давно написано, уже лет 10 как, ему давно не надо. Да, есть подозрения, что подобные инструменты у таких ребят появились уже очень давно. Они на чем-то основу эти подозрения? Нет. Понял. Короче, я не понимаю, почему сообщество не кинулось прям вот для всех сисколлов и всей работы ядра написать для этого файзера описания. Я немножко забегаю вперед, мне кажется, потому что почему вот только сейчас потихонечку сообщество приходит к тому, что «а ведь оказывается распределенные алгоритмы нужно верифицировать». Вот мне кажется, примерно потому же. Когда просто у нас компьютер стал настолько распространен, что оцена ошибки, я не знаю, не просто, то есть критические области, критические применения были всегда, но сейчас, как было замечено, Linux в каждом кармане каждых станов, и вот это уже опасно. Ну, понимаешь, распределенные системы, которые надо верифицировать, они крутятся, я не знаю, на очень-очень маленьком подмножестве. Нет, я про другое, смотри, к тому, что как вот проблемы распределенных систем стали важны и интересны, тогда, когда почти каждая интернет-компания начала по одной, по две, по три, по десять иметь. То же самое проблемы с ошибками в ядре Linux стали настолько интересны, что в них стали вливать ресурсы тот же Google, тогда, когда у Google Linux появился в каждых станах.",
    "result": {
      "query": "системы fuzzing kernel syscalls coverage-guided"
    }
  }
]