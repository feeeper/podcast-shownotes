[
  {
    "segment_id": "b7aef21e-7f18-4c9e-ab61-cb58805275f0",
    "episode_id": "4d7a7148-c76a-429d-a98f-fe7107372c9b",
    "episode_number": 7,
    "segment_number": 6,
    "text": "Ну понятно, да, 100 машин, и это становится неэффективно. Zookeeper это штука, которая нужна для управления конфигурацией, в принципе к ней ходят только машины кластера. А React это база данных, и в нее ходят пользователи. То есть, или по крайней мере, вхождение в нее фронтендом, оно коррелирует с тем, как часто во фронтенд ходят пользователи. Поэтому мы ни в коем случае не можем себе позволить один огромный Paxos на весь кластер. Я подозреваю, в Cassandra тоже Paxos как-то более локализован, но просто я не видел этой имплементации, и это точно не какая-то отдельная библиотека, которую можно заюзать как хочешь. И у них на самом деле по небольшому кворуму собирается на каждый, в терминологии React, winode, то есть там пространство ключей разбивается на фиксированное количество кусочков, которое задается во время старта кластера, и потом можно его поменять. Оно разбивается на фиксированное количество кусочков, и эти кусочки объединяются по n, где n это фактор репликации. И вот в данном случае получаются группки кворумов по n, то есть первый, второй, третий, четвертый, третий, четвертый, пятый и так далее. Вот такие группки Paxos получаются, которые обновляются вместе с тем, как переезжают эти партиции. И каждая группка исполняет независимый экземпляр Paxos для каждого отдельного ключа. То есть это абсолютно уникальная имплементация для open-source, и мне очень приятно, что это сделано в Erlang. Я в последнее время начинаю не любить Erlang за то, что там очень мало по-настоящему классных библиотек, которые используют возможность этого языка, и это одна из немногих библиотек, которые по-настоящему используют возможность языка для того, чтобы выразить такую довольно сложную конструкцию. А у них там именно Paxos, не Raft, например? У них, знаешь, у них уже какой-то синтез алгоритмов, и у них они написали очень подробную документацию, то есть если пойти в repo-историю Reconsemble, там в Markdown написана огромная документация, подробнейшая, со ссылками на многие статьи, они начали с Multipaxos. Понятное дело, что Raft оказал очень большое влияние почти на все современные имплементации Paxos, потому что Raft очень хорошо акцентировал внимание на том, как именно должна быть устроена переконфигурация форума. То есть это на данный момент самый нормально прописанный протокол переконфигурации к форуму в Raft. Соответственно, очень многие имплементации Paxos, поскольку протокол переконфигурации никак не специфицирует, очень многие имплементации Paxos полагают использовать нечто похожее на Raft. Но в отличие от Raft, Raft работает с логом, то есть Raft работает в принципе с логом, он прописан для работы с логом. У ребят Reconsembler работает со значениями, то есть у них как бы независимый Paxos для каждого значения. То есть на самом деле понятно, что они по группе процессов на каждое значение, но у них с логической точки зрения независимый экземпляр Paxos на каждое value. То есть они не пытаются StateMachines реплицировать, они реплицируют прям значение. И у них там же еще есть некоторые вещи, которые вдохновлены так называемым Vertical Paxos, это когда у нас есть Paxos, который рулит другими Paxos. В данном контексте у нас есть большой большой Paxos Ensemble из количества акторов, которое равно количеству машин в кластере, который, понятное дело, не быстро соображает, но этот Ensemble рулит тем, как у нас конфигурированы и сколько у нас других Ensemble, которые вот эти маленькие. То есть этот подход называется Vertical Paxos. И там еще очень много таких вещей, которые на самом деле позаимствованы из очень многих работ, но там очень классная документация, я всем рекомендую это почитать и просто понять примерно как это сделано. Это очень просвещает, если вы интересуетесь подобным. То есть вначале так курнуть Raft, потом пойти и посмотреть на... А, подстрелить вначале просто базовый Paxos, потом посмотреть Raft, потом пойти и посмотреть как устроен Recon Ensemble. Потому что это очень классно сделано и очень классно протестировано. А, еще я забыл сказать, извините, что перебиваю, у них еще одна фича, по-моему, тоже абсолютно уникальная для этой конкретной базы данных. И для этой конкретной библиотеки Recon Ensemble. Дело в том, что Paxos он же гарантирует целостность на момент записи ключа. И в принципе ничего потом не страхует от того, что у нас потом на одном из узлов вылетел диск, мы восстановились из бокапа, ой, у нас неконсистентные данные в строго консистентной системе.",
    "result": {
      "query": "Recon Ensemble Paxos Cassandra"
    }
  }
]