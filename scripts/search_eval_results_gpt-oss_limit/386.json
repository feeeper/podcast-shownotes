[
  {
    "segment_id": "54a2817d-aca3-4e7e-a96f-9b3eb35d0326",
    "episode_id": "d0202ccd-00eb-4b67-a9cd-35dca2609052",
    "episode_number": 386,
    "segment_number": 11,
    "text": "На только читать исходники, только кровь и слезы. Мне кажется, это имеет некоторую ценность в экземпляре. Не, на самом деле, как бы... Если ты, как его человек, который хочешь разобраться, лучше читать всю доступную документацию, потому что даже если она устарела, ты будешь знать, где поглядеть, как это было раньше, и если ты увидишь что-то новое, то оно будет как-то все время связано с предыдущей реализацией, как-то немножко ее улучшать и так далее. То есть, как бы, конечно, подобные книжки, короткие курсы, они всегда полезны. Да, всегда полезны. Мне, как бы, это я шутил, конечно же. В ту же тему про архитектуру компиляторов, это мне напомнило про книжку The Architecture of Open Source Applications. В ней есть глава про LLVM. Она, конечно, довольно поверхностная и не рассказывает тебе про детали кода, но вот архитектуру, как работает современный компилятор, она может тебе описать. Я найду способ приложить ссылочку в шоуноты. Если вы не готовы читать целую книгу про компиляторы, можно прочитать одну статью. Я очень давно читал эту книжку, их, по-моему, две, кстати, про архитектуру Open Source приложения. Ну, она как бы в двух частях, если память не подходит. Да, она прикольная, но честно, вот про устройство компиляторов мне Драконья книга зашла намного лучше. Она прям от и до прям... Понимаешь, она, да, объемная, но она прям объясняет просто понятно. Ты прям читаешь такой, а, ну да, все, логично. Ну, это да, это, наверное, зависит от того, насколько сильно ты хочешь погрузиться в тему. Если ты хочешь просто понять в общих чертах, как эти вещи делаются, то, наверное, лучше прочитать одну главу книги, чем читать целую книгу. Но вообще, Драконья книга это, наверное, одна из тех книг, которые я больше всего хочу прочитать. Это как раз вот чтобы помочь мне в моем квесте компиляции Go в JavaScript. Вот, а еще я продолжаю смотреть курс от Кернегана Мелана, Intro to Database Systems. Я посмотрел еще два доклада. Они были посвящены хранению данных на диске. Опять же, это будет ни пересказ, ни разбор. Здесь просто я выписал некоторые вещи, которые мне показались занятными, потому что в целом мы на протяжении DevZen'ов очень много все эти темы обсуждали. Первый доклад говорит про различия последовательного и случайного доступа к диску, про стоимость обращения к памяти versus стоимость обращения к диску. Такие вот вещи говорят о том, что базы данных на МАП никуда не годятся. И это куром насмех. То, что операционная система в принципе не может знать, что и откуда может хотеть читать СУБД. Поэтому всякие перефеечи и так далее, это все должно делать исключительно в СУБД. Если вы будете смотреть, не удивляйтесь, с 14 минуты пропадает звук. Что-то пошло не так. То есть у докладчика то ли микрофон разрядился, то ли еще что-то. Вторая часть говорит про... Если первая более про классические СУБД, как позгарс работает, как оракл, то вторая она уже про lockstructure хранилища, в этой же части про строковое хранилище versus колоночное хранилище, а также OLTP versus OLAP versus HTAG. Из интересного. Во-первых, я узнал, что есть такая книжка. Называется Non-volatile memory database management systems. Авторы Джой Роу Радж и Эндрю Павла. Тот самый Эндрю Павла. Я не знал, что у него есть книга. Это немножко странная книга. Она из... Тут написано в тайтле, в скобочках. Synthesis lectures on data management. Я не очень понял, что это, но у меня сложилось такое представление, что это вроде журнала. Он выходит периодически. Период какой-то странный. Он не обязательно раз в месяц, но с некоторой периодичностью. И каждый такой выпуск, он не как журнал от редактора, потом рубрика такая, в рубрике несколько статей, каждая статья на пару страниц. Нет, не так. Каждый выпуск это прямо книга, знаете, страниц на 100, 200, 300. И у каждого вот такого выпуска у него один или несколько авторов, которые на нескольких сотнях страницах освещают какой-то вопрос. И вот один из таких выпусков он священ базам данных, построенных на NVM хранилищах. Non volatile memory. По идее есть на Амазоне, также есть на Липгене. И также на Липгене вы найдете другие выпуски вот этого Synthesis lectures on data management. Если вы можете пояснить более подробнее, что это за формат такой интересный, как будто журнала, как будто серия книг, то поясните, пожалуйста, в комментариях. Я не до конца понял, но, честно говоря, мне было не настолько интересно. Вот. Что еще интересного? Выписал я про размеры страниц в разных суббдах. То есть опять же, как в прошлый раз, докладчик сравнивает SQLite, DB2, Oracle, MySQL. Размеры страниц. У Postgresа, как всем известно, размер страницы 8 килобайт, так же, как и в Microsoft SQL Server. У MySQL размер страницы 16 килобайт. И мы, я, честно говоря, не знаю, как конкретно в MySQL. То есть мы несколько раз назад обсуждали, что Томас Вондра провел небольшое исследование о том, какие размеры страниц в Postgresе конкретно лучше справляются с какими нагрузками. И по результатам его бенчмарков, которые ряд нюансов не ущеткуют, но тем не менее, более маленькие страницы, 4 килобайта, например, лучше подходят для OLTP, тогда как большие страницы, 16 килобайта, 32 килобайта, лучше подходят для OLAP. И вот в MySQL используется 16 килобайта. Означает ли это, что MySQL будет лучше справляться с OLAP нагрузками, неизвестно, поскольку вот то исследование, о котором выше говорилось, не обязательно применимо к MySQL, но тем не менее, факт занимательный. То есть 16 килобайта это 4 страницы в памяти, а 4 килобайта, что много. Большинство в куках реализационных sobdi, такие как Skylight, IBM, DB2 и Oracle, используют страницы размером 4 килобайта. Такой вот занимательный факт. Еще в реализационных базах данных есть такая штука, как ID-строки, ID-запись, ID-картежа. То есть это нечто, некая структура, с помощью которой, например, вот у вас есть индекс, индекс надо как-то ссылаться на картежи в куче. Но обычно он ссылается не по смещению файла, потому что, опять же, у тебя, вот если мы возьмем страницу, и в ней картежа, они могут перемещаться. Например, в позграсте это делает вакуум. И если ты будешь ссылаться на смещение файла, то тебе придется перестраивать индексы, когда ты гоняешь вакуум, это дорого и бессмысленно. Поэтому есть вот такие вспомогательные структуры. Например, в позграсте у тебя используется номер страницы и номер картежа внутри этой страницы. Это называется item pointer. И также он известен как TID, T-upleID или CTID. В позграсте он занимает 6 байт. В других релизионных суббитая есть аналогичные структуры, но вот что я нашел интересным, что в SQLite она занимает 8 байт, называется rowID, а в Oracle она занимает аж 10 байт. Мне понятно почему именно 10, казалось бы это лишние ненужные кодные расходы, но тем не менее факт состоится фактом. Еще одно интересное я узнал про то, как позвер сохранит тип numeric. Честно, я не смотрел в сам код, мне было не настолько интересно, поэтому я из доклада пересказываю. Хранится numeric как массив цифр, прям в чарах. И история правда умалчивает это чары от 0 до 256 или от 0 до 10. В докладе это не уточняется. И поверх этого массива ты можешь строить арифметику на самых числах, но используя те же алгоритмы, что в RSI используется. В RSI используется для работы с большими числами, то есть там сложение, вычитание, деление в столбик, всякие такие вещи. Интересно, что например в MassiQL, реализация аналогичная, но используется массив не unsigned от чаров, а массив из IN32, что в первом приближении более эффективно. В принципе это все, что я себе выписал. Мне все очень нравится этот курс. Буду продолжать смотреть вопросы, возражения, комментарии. Мне кажется было бы странно, если бы они хранили это в примволах от 0 до 9. Скорее всего там обычная длинная арифметика на Bs256. Мне странно, что они хранят это в байтах. Почему не в 16-битных числах? Меньше памяти тратить на маленькие числа? Может кто-то когда-то решил, что маленькие числа хранятся чаще, и тогда 4 ГБ была самая большая память, которую только можно придумать? Это хороший аргумент на самом деле, я об этом даже не задумывался. Надо через терни прорваться, через код и разобраться, почему же там unsigned от чаров. А следующую тему добавил Ваня, и там я вижу Ebbf. Мы любим Ebbf. Я очень надеюсь, что Ренат поможет мне в этой теме. И может быть каких-нибудь комментариев добавит. Ренат, ты еще здесь? Еще не уснул? Да, я здесь. В этой теме нам послушатели занесли статью про то, как правильно делать network policy в Kubernetes. Идея статьи в том, чтобы показать, как можно связывать несколько разных вещей. В частности, network policy это декларативное описание, какие соединения разрешены, а какие нет. И в примере здесь приводится то, что поды с метками backend имеют доступ к подам с метками база данных. А все остальные не имеют. И это все хорошо и классно, потому что на уровне кубернетес вы общаетесь именно в этих терминах. Поды, метки и так далее. Но когда вы начинаете реализацию самой настройки, то оказывается, что вы это программируете на уровне сетевых пакетов, находясь уже на машине какой-то. И дополнительной информации о том, где, что и как у вас нет. И вот здесь статья вкратце приводится, каким образом это правильно сделать, как это все настроить с помощью EPPF. То есть EPPF позволяет обращаться низко к ядру. И одновременно здесь программируется, каким образом можно получать информацию о том, у какого пода какой IP-шник, какой тип пода, какие метки и так далее. Это как бы связывается с всего одну табличку. Эта табличка там локально хранится в виде какого-то кэша, хэша. И сетевые настройки тоже превращаются в то, что весь сейшный код занимает, я не знаю сколько, там два экрана. То есть он довольно легко прочитать. И самое сложное это понять, каким образом это все связывается вместе, каким образом это все устроено. И соответственно, мне статья в целом понравилась. Интересно поглядеть, то есть конечно я сам никогда так реализовать скорее всего не буду. Я буду брать готовые компоненты, которые уже существуют на рынке, какие-нибудь open source решения, которые предполагают, что все вот эти вещи я просто установлю и может быть настрою, а дальше они будут сами работать. Но посмотреть, как это все можно сделать самому, это очень классно. И вопрос к Ренату в этом смысле. Я всегда решал проблемы компании, которые работают на каком-то стеке. И с OpenStack я работал в какой-то когда-то давным-давно у нас там был cluster. И я с ним работал всегда на уровне, что вот у меня есть некий аналог AWS, ну фактически. И с AWS я всегда работал, то есть я всегда решал бизнесовые задачи. Никогда мне не приходилось делать подобных вещей, как написано в статье вида. А давайте-ка мы вот эти два уровня абстракции свяжем вместе с помощью C-шного кода и будем во-первых делать это максимально эффективно, потому что пакетов идет куча, ты не должен там на питоне писать этот код. А с другой стороны, это же должно быть и просто, и поддерживаемо, и расширяемо. И вот к Ренату вопрос. Насколько вам часто приходится допиливать то, чего нет в стандартном стеке с помощью подобных решений, как в статье описано? Это постоянная история, можно сказать. Потому что действительно все, что находится за API OpenStack, например, или за API Kubernetes, оно же все равно как-то делается на каких-то линуксовых примитивах, на каких-то более-менее стандартных штуках, например, как тот же EBPF, он сейчас набирает большую популярность. Мы очень часто делаем так, что что-то становится гораздо более эффективное, но при этом для клиента не меняется API, клиент не должен менять какой-то свой код автоматизации, а то, что происходит за кулисами, за этим API вызовом, оно может уже полностью переписано. И такие кейсы есть. Мы делаем это не часто, но такое бывает. Я бы мог еще добавить про EBPF. EBPF это супер классная вещь. На самом деле это можно представить как крошечную виртуальную машину с очень жесткими условиями, с очень жесткими системами какой-то защиты, которая бежит прямо в самом ядре Linux, и мы можем поместить в нее какой-то bytecode, который будет вызываться в случае срабатывания некоторых хуков в ядре. И в ядре Linux очень-очень много разных хуков, и мы можем за эти хуки цепляться, и каждый раз, когда, например, кто-то будет обращаться к вайловой системе XFS к какому-то специфическому iNode, будет вызываться наш bytecode. Таким образом мы можем с помощью этого bytecode мониторить абсолютно все что угодно в ядре Linux и делать это очень-очень быстро, потому что это бежит не в юзерланде, это бежит в самом ядре.",
    "result": {
      "query": "архитектура компиляторов LLVM книга"
    }
  }
]