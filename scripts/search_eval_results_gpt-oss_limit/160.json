[
  {
    "segment_id": "fcb18e44-426e-4ae7-ae98-caad7aee7447",
    "episode_id": "8c9b7b66-f162-4117-b21f-17495a84ebec",
    "episode_number": 160,
    "segment_number": 4,
    "text": "Она рассказывает про баланс, про трейдов. То есть когда у вас есть большая распределенная система, и в этой распределенной системе вы хотите сделать какую-то функциональность, вам надо решить, на какой уровень вашей системы положить эту функциональность. Скажем, основной пример, который там разбирается, это пример передачи файла. Вы хотите сделать, чтобы передача файла была как-то безопасной. То есть тот файл, который вы считали с винчестера одной ноды, записался в таком же виде на винчестер второй ноды. И вот оно разбирает, на каком уровне нужно эти инварианты сохранять. То есть нужно ли на уровень сети полагаться и проверять чек суммы каждого пакета, или все-таки необходимо это проверять на уровне приложения, и можно не полагаться на уровень сети. И на самом деле там проблем много, они разбирают несколько проблем, и в конце концов они доказывают, что невозможно все решить на уровне, ниже уровня приложения, потому что только приложение знает точно все инварианты и знает точно, что оно хочет. И они это называют, как цитата, end-to-end argument. То есть когда у вас application понимает, что происходит между конечными точками вашего приложения, между клиентом и сервером, между двумя клиентами, и только application может принимать решение, и только application может понимать окончательно, как нужно делать инварианты и что именно в этих инвариантах находится. То есть вот этот end-to-end argument, эта цитата, она сквозит вообще по всей статье, и на ней все основано. В частности, там интересные вещи есть, интересные примеры. Я могу погрузиться немножко или могу не погружаться? Я только хотел понять, правильно я понял, что авторы топят за то, чтобы всю криптографию, все чексумы и все сжать, повторять во всех приложениях? Нет, они как раз топят за то, что вы в каждом конкретном случае должны четко принимать этот трейд-офф и принимать решение в каждом конкретном приложении. Но чаще всего application на своем уровне должен все равно делать какие-то дополнительные проверки, без разницы, что находится на уровне ниже. И в качестве примера они там приводят, скажем, два примера хороших. Это то, что когда они делали в МИД-систему хорошую сети с проверкой чексум, с ретраймом, с автоматическими тайм-аутами, отбрасыванием и так далее, у них система гоняла какие-то файлы, какую-то информацию. И из-за того, что приложение, которое гоняло эту информацию, его писали люди, которые точно знали, что сетевая часть построена очень хорошо, с большой защитой, они не делали никаких проверок на уровне приложения. А потом оказалось, что одна из железяк, которая стояла в этой системе, была немножечко сбойная. И одного миллиона запросов он менял один бит. Со временем там накопилась довольно большая ошибка, и из-за того, что данные гонялись зад вперед, она накопилась довольно серьезно. И им пришлось дописывать и доделывать еще дополнительную проверку в системе. Это первая часть, это первый пример. А второй пример – это то, что система, которая гоняет данные, скажем, звуковые, она может, ну, то есть у нее вот этот рейдов смещен с уровня надежности в уровень быстроты, потому что когда ты делаешь телефонные переговоры, если у тебя неправильно пришел бит, это не так страшно, как если этот бит придет правильно, но через секунду у тебя весь разговор собьется. И поэтому тебе само приложение уже диктует немножко другие условия, и, соответственно, ты должен принимать другие решения. И они это как раз очень здорово показывают на многих примерах, и показывают важность понимания вот именно вот этого рейдова. Я помню, извини, что я тебя прервал. У нас, кажется, была тема или даже несколько тем про железки, которые портят чексумы в IP-пакетах. По-моему, там, если память не подводит, была бага, что железка принимала данные, портила их, а потом от того, что оно попортило, считала чексуму. Или какая-то такая бага. И мы приходили к выводу, что в приложении нужно считать там шат 256, без этого вообще не обойтись. Вот-вот-вот, они к тому же привыкли. При этом они говорят, что на уровне приложения, скажем, можно... Так как вообще вам нельзя избежать проверки на уровне приложения, иногда вообще можно довольно сильно убирать проверки на уровне сети. Это позволит вам увеличить быстродействие и так далее, в случае чего у вас на уровне приложения обработка ошибок сработает и переповтор. При этом, скажем, можно точно так же файлы разбивать на какие-то части и делать чексуму оставшейся части, и, соответственно, вы сделаете раннее детектирование проблемы и пересылку предыдущей неправильно посланной части. То есть как бы здесь у вас всегда есть какой-то вот этот баланс, и его надо понимать. Вот, и они очень хорошо разбирают этот пример с пересылкой файлов. Потом они, соответственно, аналогичным образом говорят, что вот посмотрели мы вот эти балансы на пересылке, а теперь посмотрим, какие есть балансы, какие есть действующие части в других примерах. Они рассматривают гарантию доставки, они рассматривают секьюрность трансмиссии данных, они рассматривают дубликаты, то есть exactly once, или несколько, когда доставляется пакет, несколько раз доставляется один и тот же пакет. Они рассматривают гарантию доставки FIFO, то есть как бы очередности, и управление транзакциями. То есть они показывают, вот эти последние примеры, они разбирают меньше, то есть они говорят, вот здесь мы видим, что есть вот такие составные части, мы видим, что есть баланс на основе вот этого, вот этого, вот этого, а дальше вы можете по аналогии сделать все то же самое. Ну, то есть как бы такие базовые принципы, а дальше можно реально все уже самостоятельно додумать. Очень интересная статья именно для тех, кто интересуется построением подобных систем, потому что, ну, я считаю, что это она такая вводная, то есть тот, кто ни разу не строил, скажем, ему это прям must have прочитать.",
    "result": {
      "query": "баланс уровней безопасности передачи файлов"
    }
  }
]