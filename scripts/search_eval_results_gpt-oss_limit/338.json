[
  {
    "segment_id": "f74b628f-05a9-41fe-9c46-c458cb6ecf6d",
    "episode_id": "2e9de864-85fb-4771-b448-5d5299a05e4b",
    "episode_number": 338,
    "segment_number": 7,
    "text": "там, они называются типами, типы обертки делать довольно просто над примитивными типами, вам там, ну, там, буквально-то все ложится в одну-две строчки, и там, возможно, есть мысль делать такие обертки на все property, опять же, не факт, но возможно, в таком языке, как, допустим, C-sharp, там с этим сложнее, или Java, там с этим сложнее вам приходится писать больше код, чтобы сделать класс обертку, и там уже есть мысль подумать, стоит ли делать эти обертки для самых простейших типов, вот опять же, тут trade-off, такой выбор, который зависит, во-первых, от сложности вашего проекта, а во-вторых, от языка программирования, которого вы используете, ну, собственно, этот pattern-value-object, он, опять же, вот, когда писалась эта книга, возможно, просто автор не был знаком с функциональным программированием, потому что функционально программирование, вот эти подходы, они используются довольно широко, ну, либо просто в те времена, наверное, само функциональное программирование было не слишком сильно распространено, вот, вот эти подходы используются функционально программированием очень широко, там даже есть такой специальный термин для этого, который был введен, не вспомню имя, ну, вот, в общем, называется make legal states unrepresentable, то есть, сделать так, чтобы в вашем коде невозможно было создавать объекты ваших классов в нелегальном состоянии, то есть, в неволидном состоянии, и это как раз вот один из этих подходов, который позволяет вам этого достичь, то есть, когда вы делаете класс обертку, либо тип обертку над примитивным типом, вам намного сложнее становится сделать этот тип неволидным, потому что при создании этого value-object, при создании инстанции этого value-object, вы можете автоматически, ну, как, сделать все валидации необходимы, и если этот value-object, этот инстанс не соответствует этим валидациям, то вы можете просто сразу кинуть там fatal exception и рухнуть, вот, то есть, fail-fast principle, такой у вас будет, и, то есть, у вас намного меньше возможности, вот, как я сказал, ошибиться в таком подходе. Не знаю, мне, я не до конца уверен, вот, я понимаю, о чем ты говоришь, я понимаю плюсы, которые ты выказываешь, но одновременно я не вижу разницы, почему, если у меня есть класс вида пользователь, и у него есть конструктор, и я могу все, что хочу проверить в конструкторе, ну, там, e-mail, его ограничения, вот, как ты говоришь, или мне надо создать отдельный класс для e-mail, почему в его конструкторе я должен это проверять, то есть, мне лично читать код проще, Вань, ну, зависит же, смотри, если у тебя e-mail еще у 10 других классов есть, ну, у 10 ты",
    "result": {
      "query": "Value‑Object типы обертки примитивов"
    }
  }
]