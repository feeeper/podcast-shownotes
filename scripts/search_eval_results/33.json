[
  {
    "segment_id": "72c26c57-f2da-4d60-b24a-65a29a4c9da2",
    "episode_id": "96666d70-7554-4299-9fb0-2feba5c20724",
    "episode_number": 33,
    "segment_number": 7,
    "text": "Довольно интересный пример. Я потом расскажу своё мнение по поводу этого всего. У нас есть некоторый класс, который называется Sorter. У этого класса есть метод Sort. И в этот метод мы передаём массив из яблок, например, каких-то объектов. Он его сортирует, возвращает нам отсортированный массив. И дальше нам по бизнес-логике нужно взять нулевой элемент, то есть, самый максимальный, например. Вот так мы сортировали. Или самый минимальный, неважно. Мы берём нулевой элемент. И автор этой статьи говорит, что это вообще неправильно. И получается так, что нам, по сути, для бизнес-логики нужно взять какой-то нулевой элемент. А мы, вместо того, чтобы брать нулевой элемент, мы сначала сортируем, а только потом берём этот элемент. Вместо того, чтобы просто взять этот нужный элемент. Без сортировки, то есть, без накладных расходов. И он предлагает следующее решение. Мы создаём новый класс, который называется Sorted. И мы передаём в конструктор этот список яблок. И потом снова в коде мы берём этот нулевой элемент. И я вообще плохо понимаю, какую задачу мы таким образом решаем. Единственное, что мы не говорим, что мы хотим именно отсортировать эти методы. Мы просто передаём в конструктор. Но идея и проблема остаётся той же, что мы берём нулевой элемент. Вместо того, чтобы просто сказать, дайте нам этот нулевой элемент максимальный или минимальный. Поэтому статья очень странная, с моей точки зрения. Что вы скажете по этому поводу? Я могу сказать, что создание каких-то классов для такой простой вещи, как сортировка, это наследие Java. Потому что для всего нужно создать класс со статик-методами, а на самом деле нужно создавать просто функции. В случае Scala для этого используются package-objects. В случае с Kotlin можно просто в пакете делать функцию. И поэтому не надо называть объекты не Sorted, не Sorter. Объекты вообще не надо создавать в этом случае. Есть проблема у нас в названии объектов. Есть проблема, когда брать какой-то нулевой элемент. Не кажется ли вам, что это немножко разные проблемы, и автор здесь спутал всё совсем? И это какая-то очень странная позиция. Я не понимаю, что он хотел этим сказать. Ты понимаешь, в мире очень много идиотов. И объяснять каждому из них, что он идиот, никаких нервов не хватит. Поэтому, ну да. Странный человек написал в блоге странную статью. Что интересно, в Related Post следующая ссылка рассказывает про декораторы. Что интересно. Мне кажется, декоратор, or и ir, то, что он имел в виду, это то же самое. Он наделяет объект каким-то контекстным поведением. Это то, про что он говорил. Мне кажется, просто неудачный выбран пример здесь. Я примерно понимаю, про что он говорит. Но в большинстве языков программирования, и скорее всего, в фреймворках, валидатор – это валидатор, ридер – это ридер, и райтер – это райтер. Мне кажется, это просто какой-то троллинг. Все знают, что контроллер – это неудачное название. Что в любом MWC-фреймворке оно никакой семантики с собой не имеет. Это просто традиция. Но его пример, конечно, ужасен. Мне кажется, я подобную статью читал, по-моему, у Мартина Фаулера в блоге. И это было, по-моему, лет пять назад. Мысль была примерно такая же, но, видимо, человек излег оттуда мысль и решил добавить какой-то свой пример. Просто сделал это не очень удачно. Ну вот, то же самое мне показалось. Здесь статья называется одним образом, говорит он про одно, а примеры и проблемы он показывает совершенно другие. И решение тоже странное. Поэтому очень непонятная статья. Не все англоязычные блоги одинаково полезны. Но она была в этом группе, джауской. Её порекламировали, мне хотелось почитать. И я вообще не согласна. А ребята, которые обсуждали, они такие, типа, да, да, правильная статья, так что ли? А вот я обсуждение не почитала, я только ссылку себе взяла. Основной плюс таких статьй заключается в том, что её можно в пятницу в Slack или в Skype, в корпоративный чат вбросить и рассчитывать на интересную, конструктивную беседу, спор о острых конечников с тупоконечниками. Найдётся ниша для бесконечных программистских холиваров, которые никуда не приводят, но отвлекают внимание от споров по действительно принципиальным вопросам. Снижают накал в коллективе. Администратору форума на заметку. Если не хватает контента... Вбросьте какую-нибудь статейку. Да, да, 15 страниц уникального текста гарантированно. Ну а что, мы идём к следующей теме. И следующая тема это как раз про чатики. Саша? А? Какие чатики? Про ScalaChat. Понятно. Ну да, я почитываю ScalaChat, и там мы скинули ссылку на статью. Статья очень старая, сентябрь 2012 года, но я её раньше не читал или читал, но забыл. И вот перечитал или прочитал в первый раз, и она мне очень понравилась, мысль интересная. Но мы знаем, что сервисы отвечают за какой-то задержкой. Вот ты пошёл в Кассандру, и она тебя может ответить за 5 секунд, за 7 миллисекунд. Ну, в зависимости от того, что за запрос, что за сеть. И как правило мы смотрим на 95 процент или 99 процент, или говорим, что база данных почти всегда отвечает в течение 6 миллисекунд.",
    "result": {
      "error": "API request failed: Error code: 429 - {'error': {'message': 'Rate limit reached for gpt-4.1 in organization org-xSG9D345gtYlIKC330wCyrEG on tokens per min (TPM): Limit 30000, Used 30000, Requested 2548. Please try again in 5.096s. Visit https://platform.openai.com/account/rate-limits to learn more.', 'type': 'tokens', 'param': None, 'code': 'rate_limit_exceeded'}}",
      "stack_trace": "Traceback (most recent call last):\n  File \"/home/andrei/Projects/podcast-shownotes/scripts/build_search_eval_dataset.py\", line 157, in generate_search_query\n    response = await self.client.chat.completions.create(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/resources/chat/completions/completions.py\", line 1927, in create\n    return await self._post(\n           ^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1767, in post\n    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1461, in request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1547, in _request\n    return await self._retry_request(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1594, in _retry_request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1547, in _request\n    return await self._retry_request(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1594, in _retry_request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1562, in _request\n    raise self._make_status_error_from_response(err.response) from None\nopenai.RateLimitError: Error code: 429 - {'error': {'message': 'Rate limit reached for gpt-4.1 in organization org-xSG9D345gtYlIKC330wCyrEG on tokens per min (TPM): Limit 30000, Used 30000, Requested 2548. Please try again in 5.096s. Visit https://platform.openai.com/account/rate-limits to learn more.', 'type': 'tokens', 'param': None, 'code': 'rate_limit_exceeded'}}\n"
    }
  }
]