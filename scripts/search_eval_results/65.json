[
  {
    "segment_id": "4b94495b-e157-4ef6-992c-ddbf31031b76",
    "episode_id": "e00e9e1b-1097-4d31-b0e5-71d460ff3908",
    "episode_number": 65,
    "segment_number": 6,
    "text": "Из основных изменений они сменили нумерацию. То есть предыдущая версия была 2.6.1 и они поняли, что если следующий большой релиз у них будет 2.7, то все их будут путать с Python 2.7. А поскольку у них там есть ветка, которая поддерживает и питон 3, то они решили, ну давайте мы сразу сделаем четвертую версию, чтобы точно никто не перепутал. Ну и дальше применили большое количество оптимизации. То есть они теперь используют SIMD инструкции для того, чтобы JIT работал быстрее. Улучшили время прогрева кэша и уменьшили потребление памяти, хотя это вызвало и небольшое замедление, где-то в районе 2%. Но при этом кэш продлевается на 20% быстрее и память на 20% меньше. У них есть своя реализация на AMPI, которая, как известно, написана в основном на C, поэтому им приходится большие куски переписывать C на питон, чтобы потом PyPi работал с ним эффективно. Тоже большое количество оптимизации. CFFI обновился до версии 3.1 и теперь поддерживает большое количество конструкций C. Ну и CFFI — это библиотека, которая позволяет вызывать код, написанный на C, из PyPi. Она также работает с обычным питоном и более удобна, чем Ctypes в нашей библиотеке. Вот, это, наверное, все основные новости. В общем, очередной релиз быстрее, лучше, сильнее. Давай так, то есть можно на C не писать, можно писать на питоне, и это будет с такой же скоростью работать, я прав? Ну, вообще говоря, у них довольно давно в блоге была новость на тему того, что PyPi на этом кейсе быстрее, чем C. Если в цикле много-много раз запускать printf, то PyPi быстрее за счет того, что у него есть кэш и джип и все такое, а C об этом ничего не знает в тот момент. Поэтому на микробенчмарках PyPi действительно быстрее, причем уже давно. Ну, на реальных проектах, конечно же, нет. Но, с другой стороны, писать на питоне, на мой взгляд, гораздо удобнее, чем на C. Ну понятно, если у тебя большие программы, которые... ручное управление памятью, вся работа с указателями и так далее, то здесь, конечно, C будет выигрывать, потому что в питоне это сложно делать. А если у тебя какая-то бизнес-логика, не очень много всяких указателей, зато куча всего написанного... как-то сказать, маленьким количеством кода покрывается большое количество бизнес-логики, то здесь можно писать тоже на питоне, и будешь получать большие плюсы. В производительности и по скорости. Мне, честно говоря, даже сложно сказать, где сладкое место PyPi. Давным-давно я PyPi использовал, у нас было приложение на Twisted, и Twisted — это самый худший кейс для PyPi, потому что в нем используются деструкторы питоновские, которые джип вырубают в PyPi, у него используется смесь старых и новых классов, ну, то есть New Style и Old Style классов, которые тоже PyPi не любит и так далее. При всем этом у нас код на PyPi работал раза в два быстрее, что довольно существенно было для нас. С другой стороны, допустим, есть Numpy, которая и так супероптимизированная, написанная на C, при этом они еще ее сильно оптимизируют для PyPi. Пока она, я думаю, все-таки медленнее, но если у тебя есть смесь какой-то логики на Numpy и смеси на обычном питоне, то, наверное, на PyPi она будет быстрее всего. Мне кажется, как я это вижу, действительно не очень понятно применение PyPi, потому что да, в нем есть Jet Compiler, от этого все становится быстрее, но у тебя есть накладные расходы на поддержку этой Jet Compilation, в том числе PyPi, он, насколько я понимаю, я небольшой специалист, он больше жрет памяти, чем обычный CPython. Да, он жрет существенно больше памяти, в том числе за счет того, что в CPython у тебя есть подсчет ссылок, и гробочка Excel используется только для того, чтобы разрывать циклы. А PyPi — это обычный Jet с обычной гробочкой Excel, у него нет подсчета ссылок. Подожди, а в CPython все еще подсчет ссылок? Мне казалось, у них там такой крутой GSE без этого. Нет, у них как раз наоборот, у них все на подсчете ссылок, а GC используется только когда у тебя есть, допустим, несколько контейнеров, один в который входит другой, а второй входит первый, когда есть рекурсия между структурами данных, тогда используется GC. А так подсчет ссылок везде. Все, понял. То есть в плане памяти не очень эффективно. Более того, наверное, если ты уже пишешь на Python, тебе выгодно сначала протестировать какой-то кусок логики, померить, где он тормозит, и там, где он тормозит, написать кусочек на C, оно будет работать лучше, чем извращение с PyPi. Но на самом деле написать кусок кода на C и потом встроить его в Python — это само по себе такое удовольствие. Есть много способов это сделать, и все они не самые хорошие. Если у тебя есть кусок кода, написанный на Python, который в каком-то месте может тормозить, то запустить его на PyPi с большой вероятностью ты получишь большое ускорение, потому что он как раз те места кода, которые узкие на обычном Python, может хорошо оптимизировать. Потом еще странная вещь в PyPi — то, что они не избавились от GIL. Но при этом они пили проект PyPi-STM, который без GIL, но который более тормозной. То есть они пытаются решить проблему использованием Software Transaction Memory, и как-то они ее так странно используют, что все проседает на 30%. — Погоди, а зачем вообще она нужна, Software Transaction Memory? — Чтобы обойти GIL. — А GIL — это кто для людей, не следующих в Python? — Global Interpreter Log. Большой жирный лог на весь рантайм. — Ну, окей. — Вообще ветка STM — это отдельный проект, под который они получают отдельные деньги, и на котором работает только один человек, хотя уже второй или третий год. Я думаю, когда-нибудь у нее что-нибудь получится. Потому что вообще PyPi среди всех подобных проектов, известных мне, — это самые наукоемкие. Там работает очень большое количество людей, которые до этого сделали много схожих проектов для Python, и в итоге они все обнились и сейчас делают PyPi. Это в основном европейская заработка, там большое количество ученых, грантов, институтов и всего этого. Так что я думаю, будущее у нее вполне может быть. — Что-то я еще хотел сказать. Во-первых, если тебе нужно разогнать Python, чтобы у него было круто с многопоточностью, я сейчас про GIL, и чтобы он круто GIT компилировался, наверное, лучше посмотреть на GITone, трансляция по GVM. Потому что там действительно нет GIL, и он вроде как GIT прокачанный. — Я давно не следил за GITone, возможно, он в последнее время стал сильно крутой, но буквально несколько лет назад это был полный фейл. Потому что любая компания, которая делает свой интерпретател Python или Ruby, если уж мы об этом говорим, то, как правило, она делает 80% языка и говорит, какой он офигенный. Так же, например, сделал Microsoft, когда они выпустили Iron Python на Iron Ruby. Они показали, вот, у нас есть интерпретател на .NET, и он офигенный, он рвет всех по скорости. Потом они сделали остальные 20% языка, типа исключений, бэктрейсов и так далее. И разница в скорости в PC Python получилась очень небольшая. GITone был примерно такой же, у него была неполная совместимость и совершенно незначительный выпуск скорости. — Я отмечаю еще раз, что я далеко не специалист по Python. — А я, возможно, уже просто не знаю чего-то нового. — А какой юзкейс вообще у Python, когда нужно настолько производительные многопоточные вещи? — Он совсем не для скорости. — Ну понятно, а когда всплывает необходимость того, что у нас все сложно, все медленно, давайте-ка мы будем смотреть, искать и перелазить на PyPy. — У нас был довольно большое приложение на Twisted, и переписывать его времени особо не было. То есть, грубо говоря, пошла успешная маркетинговая кампания, пошла нагрузка, мы стали доставлять железо, но железо доставляется медленно, виртуальных машин тогда не было, нужно было что-то делать. Переползание на PyPy было относительно быстрым. При том, что у нас были какие-то зависимости, где-то написано и на C, где-то еще что-то, относительно быстро переползли, памяти стало поедаться в два раза больше, но это была не проблема, а скорость в два раза увеличилась, и это было для нас очень существенно. То есть вот у нас был такой кейс. Наверное, потихоньку закрывая тему, мне очень нравится кусочек, который называется R.Python, это то, на чем написан PyPy, Restrict R.Python. Это штука, ты пишешь на обычном питоне, и если R.Python может вывести типы на этапе компиляции, то есть ты написал такой код, что там сразу понятно, что ага, вот тут интеджер, вот тут строка, ты не меняешь типы на лету, он все вывел, и вот из этого и генерируется фишный код, отвечая, Вань, на твой вопрос. Вот это, мне кажется, наиболее интересная часть проекта, но есть такой нюанс, что большинство библиотек на питоне, оно, разумеется, не выведет никаких типов, поэтому тебе придется все написать самому. Ох, вот на тему R.Python я вообще могу много говорить, но раз уж тему закрываем, я постараюсь очень-очень кратко. А зря, мне вот очень интересно. Короче, R.Python — это такое подмножество языка, которое определяется как то подмножество питона, которое PyPy может интерпретировать. То есть на самом деле он очень плохо определен, на него довольно мало документации. Я писал интерпретатор на R.Python, и я, не знаю, наступил, мне кажется, на все грабли, на которые только можно. То есть плюс существенный в том, что ты пишешь на гораздо более высокоровнем языке, чем, например, на C или даже на C++ в чем-то. То есть у тебя есть настоящие классы, у тебя есть настоящие объекты, у тебя есть настоящие исключения. Это офигенно, если ты пишешь интерпретатор. Но минус в том, что это подмножество языка, оно очень неравномерное. Например, ты можешь получать доступ к глобальным диктам, а к какому-то там неглобальному дикту, я уж не помню, что там было дело, кажется, метод у него глобального дикта не вызывается. При этом ошибки компилятора очень странные. Время трансляции даже простого компилятора, интерпретатора, точнее, очень-очень долго. А это часть проекта PyPi? Да, это часть проекта PyPi. Когда говорят, что PyPi написан на Python, он написан именно на R-Python. Причем только они, на самом деле, знают, что сейчас транслиатор PyPi поддерживает, а что нет. Есть же, кстати, интерпретатор Ruby написанный на R-Python и транслируемый PyPi, называется Topaz, его сделал один из авторов PyPi. Но он, судя по всему, не полетел, к сожалению. Подводя итог, как я понимаю, сейчас правильный способ писать на Python это использовать C-Python и стараться находить вовремя узкие места. Я бы сказал вывод, скорее, другой, что если вы пишете на Python, то PyPi, да, используйте, он вполне хорош. Но еще у вас памяти много. Да, ну, нет, что значит много. Ладно, смотря какой есть, конечно, юзкейс, но у нас, допустим, на тех серверах, про которые я говорил, памяти было занято 10%, а стало 20%. То есть на таком уровне. Конечно, все зависит, но PyPi хорош. Если у вас нет каких-то жестких зависимостей на C, которые вам сложно перетащить на PyPi, то используйте PyPi. Я такой детский вопрос спрошу. Оба идут на встречу C-Python и PyPi, и вот оба идут, идут такие, и кто из них победит, значит, когда они встретятся. То есть я начинаю новый проект на Python, все-таки что лучше использовать, на что нацеливаться? Можно нацеливаться на язык Python, и если есть твой код, он может работать по идее на любом интерпретаторе. Ну, это понятно, я имею в виду, там все равно узкие места, смотреть на память и так далее. То есть ты все равно нацеливание на какой-то технологии ведешь. То есть либо это будет C-Python, либо это PyPi. Нельзя уже два одновременно пытаться делать. Бессмысленно это как-то. Сложно мне сказать. Мне кажется, тут немного неправильный вопрос. Если у тебя стоит выбор между PyPython, PyPi и C-Python, тогда тебе нужно сначала подумать, правильный ты язык вообще выбрал. Нужно либо PyPython брать, или что-нибудь более подходящее по производительности. Я хочу писать на высокоуровневом языке, я хочу, чтобы эта разработка шла быстро, на Python вообще реально быстрая разработка ведется. Но я хочу, чтобы у меня чуть-чуть было больше ускорения с помощью вот этих вот либо C-Python, либо и PyPy. Можно выучить C++ и Boost, и будет так же все гибко и быстро. Это вот... Давай, не будем начинать снова этот срочек.",
    "result": {
      "query": "PyPy vs CPython comparison"
    }
  }
]