[
  {
    "segment_id": "af037f6c-805a-4e4c-9f42-887a95ecb1a0",
    "episode_id": "b2eff466-92fb-45cf-a5b8-89d3d8a20961",
    "episode_number": 116,
    "segment_number": 3,
    "text": "Не всякая R-субэдэ имеет нормальные инкрементальные бэкапы. То есть вот у Postgres у него есть PGArman, например, но у него там есть свои ограничения, и судя по отзывам админов, он такой немного сыроватый пока что. Вот, не всякая R-субэдэ имеет в коробке, там, ну, имеет из коробки сжатие страниц, шифрование страниц и там другие вещи, а ZFS это умеет. Вот. И наверное можно еще что-то такое придумать. Я узнал, что ZFS, он там, типа, может реплицироваться по сети, что в контексте R-субэдэ вообще смысла лишено, но вдруг вам надо? Вот. Не говоря уже про софтверный рейт из коробки. Смысл в том, что вот люди говорят, да, у нас пасгрэс, ну, люди это вот на Y-комбинаторе, например, на Hacker News пришел чувак и говорит, да, у меня там пасгрэс на ZFS, чувствую себя отлично, ничего не болит. Вот. И у меня на самом деле вот вопрос к уважаемым соведущим. Как вы считаете, вот у нас есть R-субэдэ, ну, должно ли в ней быть, там, например, инкрементальный бэкап из коробки, сжатие и шифрование страницы из коробки, или это как бы неправильный путь, не Unix, не Faye, и все должно быть модульно, то есть, например, такие вещи должны быть в файловой системе, а нечего их пихать вот все в субэдэ. Я бы за то, чтобы это было в субэдэ как модуль. Ты представляешь себе, насколько это нетривиально? Я представляю, это безумно сложно, но это в этом, в идеальном мире. Я позволю себе свою, как бы, точку зрения описать. Вот как программист, я считаю, что нечего пихать это в R-субэдэ, ну, если это уже есть в файловой системе, если она умеет сжать данные, зачем я буду имплементировать сжатие еще и в субэдэ, и в файловой системе, у меня будет в двух местах сжатие, везде свое, в этом довольно мало смысла. Вот, короче, я, во-первых, хочу заметить по поводу перформанса, ну, тут уже Саша упомянулся, вternrate встроенный, во-вторых, там еще есть такая штука RC, которая позволяет там, как это, более горячие данные переместить на более быстрый носитель, и это все прозрачно с точки зрения системы. Вот, конкретно ZFS, если бы мы жили в мире победившего ZFS, я бы сказал, что в субэдэ это все не нужно. Но мы не живем в мире победившего ZFS, поэтому следующее по не зашкварить решение, с моей точки зрения, это разные дисковые бэкэнды. Опустим на секундочку подгаз, где-то сделать нетривиально, но если мы возьмем, не знаю, какой-нибудь React или Cassandra, или что-то такое, дисковые бэкэнды это уже что-то такое довольно простое, и зачастую это, не знаю, LodlDB, или RoxDB, или что-нибудь еще похожее, вот, сделать дисковый квбэкэнд на ZFS, это довольно простая штука, и он будет внезапно неплохо работать, скорее всего. Больше всего я знаю, вот этот Dolmatin RDB, который мы не так давно обсуждали, он сделан в PowerFire Core, и он как раз в качестве дискового бэкэнда использует, ну, как бы ZFS. Обрати внимание, что там все-таки есть ряд странностей этого подхода, например, если ты, не знаю, положил каждое свое значение в отдельный файлик, это значит тебе его нужно либо постоянно открывать-закрывать, либо любое чтение у тебя это все скол, и так далее. Ну, то есть, есть нюансы. Да, я не спорю, скажем так, я к чему веду, к тому, что заимплементировать дисковый бэкэнд на ZFS это сильно проще, чем заимплементировать дисковый бэкэнд на какой-то файловый систем, который ты не знаешь, что ждать. Вот, поэтому для тех систем, которые поддерживают разные бэкэнды, наверное, имеет смысл иметь дисковый бэкэнд, который полагается на ZFS. Вот, но в общем случае нужно в первую очередь иметь бэкэнд, который будет работать, ну, как бы в продакшене. У людей в продакшене ZFS-а, к сожалению, мало. Поэтому я за то, чтобы это все-таки было в базе данных, потому что иначе... Ну, то есть, можно бэкэнд общего назначения ставить на ZFS, а вот бэкэнд необщего назначения на не ZFS поставить нельзя. Вот, как бы, имеем, что имеем. Ну, вот позиция знакомых админов, она примерно такая же, что у клиентов X4, и мы им никогда не продадим ZFS, но продадим в смысле не убедим их использовать, да, или не ZFS, а BTRFS, потому что, не знаю, только Facebook недавно его где-то внедрил, и то там на этом мало деталей. По крайней мере, я не видел деталей, если кто-нибудь видел, то киньте ссылку в чатик или в комментарии. Поэтому, типа, ну, а поскольку у всех X4, то отжатие нужно, то должно быть в базе сжатия и инкрементальные бэкапы и все остальное. Такие дела. На самом деле, ты же знаешь, такая штука, ты сказал, что вот, ну, как бы, свечи недавно не так... Не выше по тексту сказать, что инкрементальные бэкапы в... сделать модулем в базе данных нетривиально. На самом деле, там есть еще один нетривиальный момент. Если база данных работает на одном сервере, то файловая система нам с инкрементальными бэкапами поможет примерно ни с чем. Кстати, примерно никак. Потому что нужно инкрементально бэкапнуть, нужно сделать консистентный снапшот всего распределенного кластера. ZFS не настолько гениальный. Ты говоришь про случаи, когда у тебя данные снова шардируются, короче. Да, да, да. То есть ZFS здесь может помочь. ZFS за счет того, что она умеет копию, норайту и сделать моментальный снапшот, она может сильно помочь. В смысле, это просто будет работать физически быстрее. Но иметь распределенную какую-то поддержку стороны баз данных, что вот сейчас можно дать команду сделать снапшот, нужно. Больше того, у того же самого HyperDeX они LevelDB расточили, чтобы делать хардлинги на... То есть LevelDB, он же на самом деле как классный левел в плане того, как на диске лежит. То есть там, если что-то меняется на самом деле в файле, оно будет меняться в новой версии, старый файл потом просто будет удален. Соответственно, что они делают? Они кластер делают недоступную запись буквально на какие-то доли секунды, там по-моему на 100 что-ли миллисекунд. За это время они успевают всем машинам сказать, идите сделать хардлинги, и потом наоборот разморозить кластер. Вот какая-то такая штука нужна от базы. Понятное дело, что если у вас есть ZFS, то вместо того, чтобы бегать делать хардлинги, вы можете гораздо быстрее просто копию-набирать на уровне файловой системы. Но при этом все равно нужна будет поддержка со стороны базы, чтобы сказать, что вот сейчас мы делаем кассететный снапшот, пожалуйста, не удаляйте ваши файлы. Тут маленькое дополнение, что не всем с UBD все-таки это нужно, например, RAI какой-то не нужен, потому что он на PAY и eventual consistent. Это не совсем так, потому что смотри, у тебя eventual consistency как бы гарантия системы, но дается с той точки зрения, что если у тебя durable диски, они все записали, все хорошо, то у тебя рано или поздно все сойдется.",
    "result": {
      "query": "incremental backups in databases"
    }
  }
]