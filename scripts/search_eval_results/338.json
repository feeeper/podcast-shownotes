[
  {
    "segment_id": "210a99bf-8a7e-43b8-80aa-e30d11efdc65",
    "episode_id": "2e9de864-85fb-4771-b448-5d5299a05e4b",
    "episode_number": 338,
    "segment_number": 8,
    "text": "его в отдельный класс, если у тебя e-mail только пользователь, делай пользователей. Конечно, конечно, да-да, но тут вопрос как раз в том, что... Ну, это как раз причина, то есть, если этот концепт используется не только в customer, но еще где-то, то это как раз, опять же, используется, ну, dry principle, don't repeat yourself, то есть, вам привез повторять все эти валидации в customer, потом в другом классе, и так далее, причем не только в конструкторе, но, допустим, если вы там меняете этот, ну, допустим, у вас в customer есть функция, там, смена e-mail, там, вам нужно будет и там тоже это все сделать, то есть, у вас получается сам customer, будет перегружена эта логика, и при этом эта логика еще будет продублирована, не только в customer, но еще где-то, поэтому просто становится вынести эту логику в отдельный класс и уже в customer работать на более высоком уровне, то есть, оперировать самими e-mail-ами, e-mail-инстанционами или там, каким-то еще, не важно, каким-то. Да, это все понятно, мне непонятно, почему это DDD, ну, то есть, как бы, это логичная штука, которая вообще мало относится к... Очень много принципов в программировании пересекают, то есть, я не думаю, я не утверждаю, что вот эти все принципы были введены конкретно DDD, то есть, domain-driven design, как я сказал, вот, например, вот это подход, он широко применен еще в функциональном программировании, вот, то есть, тут эти паттерны, они называются tactical patterns, есть strategic patterns, есть tactical, такие более низко уровневые, они, в принципе, да, они пересекаются с другими дисциплинами, вот. Ну, то есть, фактически, это просто сборник best practices, то есть, мы в одной книжке сказали, вот так вот вам надо работать с бизнес-моделью, а вот так вот, вот такие практики нужно использовать, если вы будете их использовать, вам шерсть будет мягкой и шелковистой. Тут скорее нужно это рассматривать с точки зрения того, что сам DDD говорит о том, что нужно фокус делать над domain-моделью, а конкретно эти паттерны уже просто говорят, как это можно сделать, то есть, можно это сделать по-разному, но вот эти паттерны позволяют начать с чего-то, если у вас там не было опыта до этого фокусирования над domain-моделью, собственно всего. Ну, опять же, когда вот эта книжка выходила про domain-давин, не знаю, сейчас, может быть, это действительно кажется таким, само собой, разумеющимся, но в те времена, я вот довольно хорошо помню, это было такое новаторство, то есть, очень мало кто использовал в коде… Ну, подождите, те времена это какой год, все-таки, чтобы мы понимали? 2001-2002 где-то, может быть. Ну, там в коде, например, не знаю, кому как, но вот я, когда начал работать, как раз в эти времена, в коде у нас, в проектах моих очень редко можно было встретить, где у вас там, допустим, юзер выделен в отдельный класс. Такая простейшая вещь, как, например, внесение юзера в отдельный класс и внесение логики, относящейся к юзеру, тоже в этот класс. Там довольно-таки было, ну, такого не было, то есть у нас, например, было, я помню, использовалось, по-моему, какой-то встроенный тип в ISP-NET, который отвечал за аутентификацию, вот, и мы пытались там навесить эти все методы в этот встроенный тип, то есть там такие вещи были, которые сейчас, конечно, кажется, может быть, совсем такими неразумными, но в те времена… Я программированием чуть-чуть позже стал заниматься, профессионально еще позже, но где-то так, типа года с 2005 для себя, плюс-минус, и, да, я отчетливо помню, что писались просто процедуры, иногда код даже не разбивался сильно на процедуры, если мы говорим, например, про веб-программирование и PHP, у тебя вот просто есть скрипт, это вот просто такой поток кода, и, да, вот, то есть я подтверждаю, что все эти идеи, они были прям очень новаторские. Да-да, это как раз называется Transaction Script, про это еще Фаулер писал, что это вот есть такой подход, и вот он этот подход DDD выделил как отдельный Domain Module, и вот в его книжке Enterprise Pattern, там как раз он тоже про Domain Design подход тоже писал, то есть он писал про то, что можно выносить эти классы, не просто лойку в них делать в виде скриптов отдельных, то есть применять Transaction Script, но вот можно выносить в отдельные классы. Я отчетливо помню, что когда я читал про это, я думал о том, что, боже, это просто бог, то есть, да, в те времена с этим было сложно, сейчас, может быть, да, это же не очень такое controversial. Я тоже просто говорю, что сама идея ООП была, знаешь, немножко новаторской, то есть в PHP классах в принципе не было, ходили холивары, имели смысл писать на C++, когда есть нормальный C, в Perle классы вроде как есть, но с приседаниями, Питон и Руби появились вообще, ну, в смысле, они появились раньше, но они стали популярны позже, по Роджаву ходили такие же холивары, что типа, о боже мой, на моем первом пне это тормозит, ну то есть... Ну подожди, ну с другой стороны, при этом же у нас тот та же BANDA4, это книжка 1994 года, у BANDA4, конечно, не обсуждается вопрос от доменного моделирования, но сама, мне кажется, сами разговоры о том, что у нас есть ООП и домены нужно моделировать уже велись, или мне кажется? Я думаю нет, потому что даже если посмотреть на саму книжку, что это Генгофор, там все примеры даже приведены в виде... Генгофор, прав по примеру, согласен, да. В виде просто UI-контролов, и вот они все примеры пишут в виде того, есть у вас какой-то контрол, либо Windows, либо еще что-то, и вот они от этого отталкиваются, даже они, мне кажется, тем временем мыслили в рамках больше технических вещей, а не домену моделирования. В контексте C++ я вспоминаю то, что C чистенькая, без классов, и BNP, наше все, но вот такая история. Я еще заметила... Какого года появился Rational Rose, вот это все? Не знаю, не вспомню. Когда я начал работать, он уже был, когда он появился, наверное, в 90-х, точно не знаю. Вот тоже 94-й год, Rational Software, они 94-е-2000 какой-то год начали все это делать, и вот возникает вопрос, а если оно было, они же как раз таки занимались всем моделированием всяких доменных штук или нет? Не знаю, как остальные, но я в те времена использовал Rational Rose, не помню, видел был или нет, но использовали их только для моделирования не домена, а базы данных. Это, собственно, единственное, для чего мы его использовали. Домен тогда не моделировался, по камере у нас. Я еще заметила, что вот вообще DDD, оно очень часто идет вместе с .NET, и такое чувство, что именно в .NET Community оно получило большое распространение, в то время как в других языках и платформах, как-то поменьше я слышу. Можешь рассказать подробнее об этом, замечал ли ты такой нюанс? Я хотел бы представить, что это не обязательно привязано к языку, то есть когда мы... Саша, я это понимаю прекрасно, но я очень вижу часто, что именно в .NET Community об этом много говорят, сильно больше, чем в других Community. Я только хотел сказать, что в предыдущем проекте на ГУО у нас там прям серьезно архисектора угорал по DDD, например. Это когда было? Ну, два года назад. Три. По поводу... Да, это язык не зависит. Сама, кстати, книжка Эрика Эвансона, по-моему, написана была с экзамплами на Java. По поводу того, в каких Community это больше распространено, наверное это правда. Я, то есть, не могу сказать, потому что я больше варюсь в .NET Community, а не в остальных. Но по отзывам остальных, например, в том же самом ГУО у меня есть хороший знакомый, который работает с ГУО. И он говорит о том, что в ГУО эти вещи пришли позже, чем в .NET. В Java... На счет Java я тут сложно сказать. То есть, с одной стороны, синяя книжка, как я сказал, примерно на Java, но с другой стороны, не факт, что они применялись активно в те времена. Ну, может быть, я ошибаюсь. И в .NET Community там еще сложились некоторые паттерны. Точнее, как они вышли из .NET Community паттерны, и потом они распространились на остальные Community, такие как, допустим, CQRS. Это в принципе не имеет отношения к DDD, если так вот технически рассуждать. Но при этом сама практика эта вышла из DDD Community. CQRS это паттерны, которые говорят о том, что вам нужно разделять команды и commands and queries. То есть это Command Query Segregation Principle. Потом тот же самый Event Sourcing, когда вы говорите о том, что у вас источник правды о состоянии вашего приложения. Это не текущий слепок ваших данных в базе данных, а это ивенты, которые произошли, которые сымитировала ваша доменная модель. То есть вы в базе данных хранили еще своем хранитель не состояние ваших доменных объектов, как есть, а ивенты, которые случились, произошли по мере жизни этого приложения. И потом, если вам нужно слепок от текущей составить, вы прокручиваете ивенты еще раз и получаете этот слепок. Но опять же здесь нужно учитывать, что область применения этого паттерна не очень широкая. Это есть смысл только в тех областях, где вам необходимо поддерживать такую... Вам необходимо знать, какие ивенты привели к текущему состоянию. Например, в финансовых учреждениях, в том же самом банке это может быть применимо. Но в остальных вещах, где вам нужно просто отреагировать, допустим, email customer, там, возможно, это не так применимо. По поводу комьюнити сложно сказать, я знаю только насчет Go. А ну и в PHP, в PHP тоже, наверное, это пришло чуть позже. Но в тех чатах, в которых я ворюсь, там довольно активно сейчас ведется обсуждение, в том числе и кода на PHP, в которой соблюдает эти Domain-Drawing-Design принципы. Расскажи какие-нибудь примеры, когда DDD не имеет смысла. В этом примере скорее это не приведет к желаемому результату, скорее даже наоборот. Есть ли такие примеры? Да, такие примеры есть. Ну вот один пример мы немножко обсудили. Это то, когда у вас в проекте больше не бизнесовое комплекс, это присутствует, а больше техническое. Допустим, если вы пишете, опять же, приведу сейчас пример с игрой, с рискуя не сделать это неправильно. Но тем не менее, по-моему, у вас все-таки всяких engine, которые позволяют вам отрисовывать, там вы точно не сможете применить DDD. Как считаете, господа игроделы, я прав или нет? Я прав или нет? Ну, наверное, сможет, наверное, довольно бессмысленно. То, о чем мы сейчас говорили, мы не договорились про применение DDD, мы поговорили про value-type, но не поговорили про что-то еще. То есть value-type, наверное, можно притащить. Это будет невозможно производительно местами. Но с другой стороны, где-то на границе интерфейса с кодом, который уже не рисует, а взаимодействует с каким-то внешним миром, может быть, и можно, может быть, даже что-то приятное из этого выйдет, но нужно, наверное, к репу почисать хорошо. Ну да, возможно, такие низкоуровневые паттерны, они все еще применимы, но, наверное, там вы будете создавать какие-то сущности и еще что-то такое делать. Ну, хотя кто знает. Ну, на мой взгляд, там же просто есть сильно больше одной школы мыслей еще про все это тоже, только как игрописать. Ну, наверное, в какой-то там одной школе мыслей, может, это, не знаю, в Австризмдеке, как тот же самый Unreal написан, например, там в большей степени принято явно какие-то сущности описывать, чем, скажем, в какой-нибудь Unity, где сущности собираются всегда вообще из набора ортогональных кусков, которые обычно просто какой-то отдельный аспект описывают и не являются сами по себе какой-то, ну, типа игровой сущностью. Ну да. Ну, вот, собственно, первый пример – это когда у вас техническая комплексити в основном присутствует, а не бензовая. То есть бензовая имеется в виду, ну, вот как в enterprise приложениях вам нужно… типично такое enterprise приложение, как правило, в нем не слишком сильные performance требования, там, как правило, комплексии технической тоже нету, потому что, ну, там, при шести случаев у вас есть база данных, есть какие-то UI какие-то написанные, не факт, что там слишком сложные, вот, и вам нужно их соединить вместе. То есть здесь сама комплексия уже находится между этой базой данных и UI, то есть в вашей бензовой. Вот, в других проектах такого может не быть. И там DDDD – нет смысла применять. Другой пример – это когда у вас очень сильные performance требования. То есть, опять же, там чуть ранее обсудили, что следование DDDD вот этим принципом, они приводят в некоторых случаях к тому, что у вас performance страдает. Потому что вы, за счет того, что вы выделяете бинус-лойку в одно какое-то место, вам необходимо сначала… Ну, типичный пример такой, вам нужно сначала из базы данных вбрать какие-то необходимые данные, потом их собрать в кучку, диссерилизовать их в вашей сущности, и потом с ними какую-то операцию провести и сохранить это обратно в базу данных. Вот такой подход может быть неприменим, если у вас прям очень сильные performance требования, допустим, в трейдинге, в, там, не знаю, на Нью-Йоркской стоковой бирже, там, где каждый миллисекунда очень сильно влияет на user experience, там такого вы просто не сможете сделать. То есть, там может быть комплексит сама по себе довольно-таки высокая, но, тем не менее, слишком большие жертвы будут в плане performance. Там, как раз, есть смысл, как раз, да, эту лойку держать как можно ближе к данным, то есть, в видеохранимок там, или еще чего-то. Вот. Но во всех остальных, в принципе, там, где у вас нету сильной технической комплексити и нету прям очень сильно заоблаченных performance требований, там, я думаю, DDD применим. Мне еще интересно, как, вот, есть подход MVC, и вот есть паттерны и принципы DDD. Расскажи, как эти два подхода, эти два паттерна сочетаются друг с другом, где пересечение может быть неортагональное, можешь вот про это поговорить. Ну, тут такой топик, немножко, возможно, холиварный, то есть MVC, Model View Controller, да, я думаю, он, у него есть четкое пересечение с DDD, там, как раз, вот этот модул, она должна быть вашей доменной моделью, то есть, классами вашей доменной модели. Есть мнение о том, что это должно быть не вашей доменной модели, должна быть еще, должен быть еще отдельный слой, который работает поверх вашей доменной модели, то есть, вы должны сделать отдельный набор классов для этой модельки в MVC, и потом делать маппинг между вашей доменной моделью и этой буквой M в паттерне MVC. Ну, я считаю, что это перебор, такого делать, ну, нет смысла особо, вот, и в MVC, там есть смысл делать, то есть, у вас View, понятно, View Controller, Controller должен работать между View и классами вашей доменной модели. И то же самое в паттерне MVVM, то есть, Model View, View Model, там, где, ну, примерно то же самое, что в MVC, там, только разница в том, что больше маппинга, больше, так сказать, декларатива прочь, там, так сказать, применяется, где с помощью маппинга вы маппите там UI на ваши View модельки. Вот там тоже вот эта вот View моделька, она работает как такой прокси между вашей View и моделью, но при этом сама модель должна быть тоже доменными объектами. То есть, если вы пишете, это какой-нибудь там ангуляр, ну, хотя, не знаю, с ангуляром я точно не сталкивался, много не сталкивался, но вот я знаю, что в том, где C Sharp и WPF, там активно используют паттерн на MVVM, и там, да, там, я считаю, что нужно использовать напрямую вот эти модели, модельки из доменной модели, и View модель должна работать напрямую с этими классами из вашей доменной модели, точно так же, как MVC. Ну, вот для меня это тоже, то есть для меня MVC это M, это модель, и она должна соответствовать тем принципам, которые мы видим в DDD. Вот, но ты же сказала, что бывает еще маппинг, а можешь подробнее, то есть, зачем это нужно делать? Мне кажется, это какой-то, ну, как-то дополнительный слой, который, ну, какого-то смысла несет, но при каких случаях он имеет смысл, и почему люди так делают? Да, маппинг я имел в виду, вот, если делать букву M не доменной моделью, а отдельным слоем, тогда необходимо будет делать между вот этим отдельным слоем и доменной моделью. Я тоже считаю, что в этом смысла нет, потому что... Ну, а в чем разница? То есть, почему, то есть, вообще, почему я могу захотеть иметь два слоя домена и модели? То есть, может быть, пример какой-то подскажешь? Потому что для меня-то в принципе одно и то же, но, видимо, есть люди, которые думают иначе, мне интересно понять, почему. Примеров у меня нет, и я считаю, что это, ну, так делать не надо. То есть, моя вот такая стронг-опиня в том, что слоев вообще в приложении должно быть как можно меньше, иначе у вас получается, ну, слишком, опять же, лойка будет размазана между этими слоями, и сложно будет фокусироваться на доменной модели. Вот, я думаю, единственная причина, ну, может быть, одна из причин, почему люди могут так делать, это потому, что, ну, вот есть желание изолировать ваш доменную модель от контроллера и от вьюх больше, еще больше, чем вот с помощью самого паттерна MVC. Я, опять же, смысла в этом не вижу, потому что у вас контроллер, это и есть, по сути, вот этот вот медиатор между вашими вьюхами и моделью, который и отвечает за координацию между вьюхой и моделью. И дополнительно какой-то слой вносить здесь нет смысла, это только будет вносить дополнительный overcomplication, то есть, пересложение ваш код. Еще такой вопрос. Я помню, когда, давно-давно, когда я только начинала карьеру в программировании, я очень часто слышала слово вообще бизнес-логика, и для меня это была совершенно непонятная абстракция. То есть, я понимаю, что такое модель. Вот я могу сделать набор классов и смоделировать какую-то доменную область. Это понятно. Я понимала, что такое data access layer. То есть, я понимала, вот мы работаем с базой данных, вот здесь я буду вытягивать мои данные из какого-то, какой-то страхохранилища, я их преобразую в классы или объекты моей модели. И это понятно. То есть, это вот хорошо. И там работа с connection, это понятно. И потом появляется какая-то бизнес-логика, и я всегда имела трудности с пониманием, как это бизнес-логика, ну, то есть, что это на практике представляет собой. И сейчас для меня бизнес-логика, это скорее набор сервисов каких-то. Вот у нас слушатели очень разные, у нас есть очень опытные, у нас есть очень неопытные люди. Как бы ты объяснил бизнес-логику так, чтобы люди, которые, возможно, имеют очень-очень мало опыта, поняли что-то такое? Да, это тоже хорошее наблюдение. У меня примерно такие же были мысли, на самом деле, когда я тоже начинал карьеру. Сейчас вопрос, вопрос, который тоже из чата, ну, от Алексея Шашева, что, ну, я, в общем, тоже, собственно, до этого же выше, по тексту докапывался, что, ну, вот чем вот она не бизнес-логика, если мы пишем там игру или какое-то требовательное к производительности приложения. Она же все равно логика, она все равно может быть сложной. Почему мы не считаем ее бизнес-логикой, которая достойна к DDD моделированию? Не, не, она достойна. Вопрос в том, сколько ей этой бизнес-логики, если ее много, то, да, нужно желательно моделировать это в виде DDD. Неважно это где находится эта логика в игре или нет. Просто мой поинт был в том, что в играх этой бизнес-логики мало. Но, как вот уже сказали, этот поинт был неверен, потому что в играх ее довольно много может быть. То есть просто мой ассамбль был неверен по поводу игр. Так, по поводу бизнес-логики. Я считаю, что это синоним доменной модели. То есть Domain Logic, потом Business Logic, Domain Model. Все это вот одно и то же, просто разными словами произнесенное. И я нигде не видел контрпримеров того, что бизнес-логика может быть чем-то другим, кроме как доменной логики, ну, либо доменной модели. По поводу того, что именно это себя представляет. Но это вот конкретная абстракция того, как ваше приложение должно вести себя. Хороший такой thought experiment здесь будет. Мысленный эксперимент в том, что, ну, допустим, если вы уберете все остальные консерны из вашего приложения, допустим, вам не нужно будет, если мы рассматриваем типичный enterprise приложение, то, допустим, если вам не нужно будет сохранять ваши объекты, данные в базе данных, то есть все, что вы делаете, можно будет сохранять в in-memory. И вам там, допустим, не нужен будет какой-то UI. Вот все, что осталось после этого, это вот ваша бизнес-логика. Это вот такая абстракция над проведением вашего приложения. И это как раз стоит рассматривать как абстракцию. Ну да, это вот стоит рассматривать как абстракцию, в том числе, например, когда вы меняете какие-то данные в вашем приложении. И вот эта смена состояния доменных классов, доменных объектов, точнее, это вот абстракции над предстоящими изменениями в базе данных. И с этими абстракциями, как правило, намного проще работать, чем с нижнежащими консернами. То есть, например, тестировать те же самые абстракции проще, потому что намного проще протестировать абстракции, чем вещи, которые они абстрагируют, например, в той же самой базе данных. Потому что вы можете это сделать в памяти, не затрагивая эту базу данных. Ну, не верю, что я понятно объяснил, но примерно так я себе это представляю. Вот в этом объяснении у нас есть домен, у нас есть какая-то... Ну, мы моделируем этот домен. И мы знаем, что у наших сущностей есть какие-то валидные значения параметров. И когда мы создаем какую-то сущность, мы проверяем, что мы правильное значение присваиваем, что они в каких-то границах. И вот даже когда вы программируете эту логику, эти проверки там в конструкторах, либо еще где-то, то есть для меня это часть доменной логики. Но при этом эти проверки я делаю в доменной логике, в модели. И то есть, не смешение ли это абстракции получать, не смешение ли это уровней. И вот для меня, я помню, всегда это был очень такой странный вопрос. То есть, как бы мы хотим делать какую-то слоистую архитектуру, чтобы у нас было разнесено... Разнесены вот эти уровни, но при этом я делаю проверку бизнес-логики в модели. Правильно ли это и как ты... Что ты думаешь по этому поводу? Например, какие проверки? Что бы просто были проверки? У проверки, когда мы создаем какой-то объект, мы проверяем, что каждое поле имеет значение каждого поля в границах дозволенного, например. То есть, это же бизнес-логика, не так ли? Да, это бизнес-логика, да. Но у нас будет в ноте проверки, если мы их засовываем в конструктор, например. То есть, правильно ли это место для этих проверок? Я считаю, что да. То есть, у вас, так как эти проверки являются бизнес-логикой, то им место в доменной модели. То есть, в классах, которые моделируют эту конкретную сущность. То есть, допустим, если вы создаете кастомера, и у кастомера по правилам вашего приложения должно быть имя какое-то, то правильнее как раз поместить эти проверки в сам кастомер, чтобы они находились в вашей доменной модели. Тут небольшой холивар еще есть такой на тему того, куда вообще валидации относятся. К какому слою относятся сами валидации? Можем немножко позже поговорить про это. Вот опять же, я не хочу, чтобы это было вопросом. Ну давай, мне кажется, это хороший холивар. Куда я видела, когда валидаторы это вообще какая-то отдельная сущность, то есть, это какие-то, не знаю, набор статических методов, которые валидируют другие объекты. Иногда это часть просто модели, в конструкторах есть вот эта валидация. Где им правильное место? Да. Представлять эти валидации в виде отдельных методов это нормально, но эти методы должны находиться в доменной модели. То есть, к примеру, ну опять же, какие могут быть варианты? Здесь могут быть варианты такие, что да, у вас есть, допустим, отдельные классы, которые валидируют входящие данные, то есть input data, и они валидируются там, допустим, отдельными классами валидаторов. Либо еще как вариант контроллеры могут сами проверять, что все поля были правильно заполнены, ну или просто заполнены вообще. То есть, тут у нас уже еще два варианта возникло. То есть, отдельные классы, которые не относятся к доменной модели, потом контроллер. И еще третий вариант может быть такой, что там в вашей базе данных тоже есть находятся проверки. То есть, к примеру, ну там такие простейшие проверки, как нал в каких-то полях. То есть, база данных, допустим, может не принимать нал в customer name. То есть, если вам нужно, необходимо будет какое-то имя обязательно туда прописать. И там, возможно, еще в базе данных можно там указать максимальную длину этих полей. И в некоторых базе данных, наверное, еще можно минимальную тоже указать. То есть, тут вопрос, в каких слоях вашего приложения эти проверки должны находиться, вот эти валидации. И, опять же, мой понятный в том, что они должны находиться в доменной модели. Это единственное место, где они должны находиться, опять же, в идеальной ситуации. Тут могут быть какие-то edge-кейсы, где вы просто не сможете их поместить в доменную модель, и вам приходится, будет необходимо идти на уступки. То есть, делать concessions. И, как пример, такой concessions. Ну да, один из примеров такого concessions был в том, что, вот если у нас поля какие-то простые, допустим, в custom, то есть там просто строка какая-то, то, наверное, нет смысла делать метод в custom, который будет валидировать эти поля. Возможно, есть смысл просто сделать валидацию отдельным классом. Ну, не знаю насчет остальных языков программирования, но вот C Sharp там есть такие библиотеки, как, например, Fluent Validation. Там довольно-таки удобно набрасывать правила валидации на разные поля в датоконтрактах. И, когда вы валидируете эти поля, эти правила валидации будут деплоративным образом валидироваться и автоматически будет возвращаться ошибка, если что-то было сделано не так. Вот, вот эти правила. Это пример такой уступки, на которую мы идем для того, чтобы не переусложнять доменную модель. Потому что если у вас доменная модель будет сдержать кучу таких мелких проверок, то они довольно сами по себе несут мало пользы, но при этом вам необходимо будет писать много кода для таких проверок. Поэтому такие маленькие проверки, возможно, есть смысл вынести из доменной модели. В общем, в виде вот эти валидации, они принадлежат бизнес-логике, то есть вашей доменной логике, и должны находиться внутри вашей доменной модели. В качестве вот еще такого примера, где вы не сможете так сделать, это, допустим, проерка на уникальность имейла пользователя. То есть когда вы садаете имейл, либо когда вы меняете это имейл у кастомера, вам, допустим, необходимо проверить, что такое имейл не был присвоен другому кастомеру в вашей базе. В домене такую проверку сделать можно, но это будет приводить к тому, что вы теряете пьюрити, домен модел пьюрити. Потому что ваш домен, то есть как это можно делать? Можно просто передать какой-нибудь интерфейс либо репозиторий самому кастомеру и сказать, вот мы тебе меняем имейл, проверка ты сделала, как ты там все сам. Этот кастомер будет, мы делаем отдельный метод в этом кастомере, куда мы засовываем новый имейл и ссылку на репозиторий, либо там на интерфейс этого репозитория. И делаем так, что этот кастомер сам обращается к базе данных, смотрит, что там нету кастомеров других с таким же имейлом, и потом все эти валидации проводит, либо возвращает ошибку, либо говорит, что все окей. Вот, это такой подход приводит к тому, что мы теряем домен модел пьюрити, то есть у нас доменный модель становится не чистым, не обращением к вне процессным зависимостим. И из-за этого мы теряем некоторые полезные свойства этой доменной модели. То есть мы теперь не можем протестировать эту доменную модель просто как в in memory, то есть без обращения к этим вне процессным зависимостим. Нам нужно будет теперь получается сделать либо проверять вместе с базой данных эту функциональность, либо замещать эту базу данных mock'ами, а это приводит к тому, что там в общем свои проблемы есть. Либо как вариант мы можем эту проверку оставить в контроллере, то есть контроллеры сам будут выбирать имеющихся кастомеров с таким же имейлом, и таким образом мы оставляем нашу доменную модель чистой, но при этом мы теряем это свойство доменной модели, где вы не можете создать вашу доменную модель в невалидном состоянии, называется инкапсуляция. Вот мы теряем инкапсуляцию, то есть мы теперь можем в теории допустим забыть проверить имейл уникальность и поменять этому кастомеру имейл на вот этот вот, который уже был в базе данных. И таким образом у нас наша доменная модель становится невалидной. Вот это опять же один из примеров таких трейдовов, то есть выбора между одним и другим вариантом, в котором мы не можем одновременно выбрать оба варианта, то есть мы не можем достичь одновременно полной капсуляции и частоты нашей доменной модели. Ну и да, еще я говорил про проверки на уровне базы данных. Эти проверки полезны, но их стоит рассматривать как просто такое safety net, дополнительное safety net, что если допустим вы пытаетесь сохранить ваш объект в невалидном состоянии, то вы должны упасть. Но это при этом не валидация, то есть вы не должны, например, exception, который кидает базы данных, потом отлавливать и показывать пользователю как ошибку в валидации. Вы должны при этом просто упасть и такой fail fast principle, вернуть там 500-ую ошибку. И то есть сама при этом валидация будет на уровне базы данных, но при этом вы должны рассматривать эту проверку, которая вам позволяет провести такой sanity check, которая говорит о том, что если она сработала, это говорит о том, что вы что-то не так сделали на уровне вашего контроллера или на уровне доменной модели, то есть вы забыли добавить какую-то проверку. Это уже будет баг и этот баг будет в том, что вам нужно добавить эту проверку, чтобы ваше приложение работало корректно, чтобы оно возвращало не 500-ую ошибку, а правильно, там, какую-то 400-ую ошибку. Ты немножко затронул про то, как обрабатывать ошибки и на каком уровне что бросается. Можешь подробнее об этом поговорить и какие принципы нам диктует DDD при обработке ошибок, на каком уровне их обрабатывать, что правильно, что нет? Основной принцип это то, что вам необходимо поддерживать вашу доменную модель в полной инкапсуляции. В идеале, опять же, не всегда это возможно, но идеал такой. То есть вам нужно строить ваш код таким образом, чтобы сделать illegal states unrepresentable в ней, то есть нельзя было создать ваши доменные объекты в неволидном состоянии. Это основной такой принцип, который нам говорит DDD. Навсегда же можно в базу кого-нибудь дерьмо написать. Особенно в валидации нет, потому что они все в приложении. То есть предполагается, я думаю, что если у тебя база данных, если вы живете в модели микросервисов, то твои базы данных никого другого не пользуются и только твой сервис, а в эту базу данных что-то пишет. Ну, из ПК поподнялся и все. Из ПК поподнялся. То есть предполагается, такого стоит у тебя не должно быть, то есть вот это должно где-то упасть. Ну, экзакли да. То есть в вашей базе данных это по сути часть приложения и к ней никогда не должно быть доступа, кроме самого кода приложения. То есть если кто-то имеет к ней доступ в другой, то это уже совсем плохо. Нет, ну смотри, мы сняли бэкап, поменяли валидацию, поднялись из бэкапа, там было что-то, что не проходит валидацию. Ну оно должно же было проходить раньше, то есть каким-то образом. Ну мы миграцию написали, а она уже как бы типа откаталась, не знаю, что это такое. Это тоже отдельный топик такой, есть такое понятие как усиление прикондишнв и ослабление прикондишнв. То есть допустим, если у вас поменялось какое-то бизнес-требование и вы теперь должны делать какую-то проверку в вашей доменномодели, которую вы раньше не должны были делать. Ну вот, конечно, примеры такого простейшего. Ну вот допустим у вас у кастомера есть какой-то юзернейм, и раньше вы туда могли записывать любую строчку, которая отвечала, допустим, от A до Z и цифры. Вот сейчас вы говорите о том, что, ну вот, такой контрафт экзампл, но тем не менее. Сейчас вы говорите о том, что цифры теперь в юзернейме писать нельзя. Вы должны писать туда только буквы, там, допустим, либо русский, либо английский, без цифр. Вот, тут возникает, то есть это пример как раз прикондишнв стрэнттинг, то есть это усиление прикондишнв. И тут вопрос возникает, что делать с данными, которые у нас уже были сохранены в базу данных. Мы не можем их просто взять и удалить, потому что мы это живые юзеры, и нам нужно с ними как-то работать. Вот это как раз хороший пример того, как здесь нужно подходить к валидации. Здесь подходить к валидации лучше всего путем того, что вы делаете какой-то explicit transition между этими двумя состояниями. То есть если у вас раньше там был юзернейм, value object, которые были свои правила валидации, который позволял вносить цифры в юзернейм, то для нового юзернейма желательно сделать просто отдельный value object, в котором уже эти правила валидации будут более строгими, чем в старом юзернейме. И как вы можете сделать в этом случае на уровне доменной модели, вы можете в классе user само property, этот юзернейм, моделировать в виде старого value object. То есть старый мы назовем user name old, ну или user name with digits. А новый, но при этом в конструкторе в качестве параметра вы должны принимать уже новый value object. То есть это будет там user name, либо user name without digits. И таким образом вы на уровне моделирования вашего домена показываете этот transition период в явном виде. Вы говорите о том, что потенциальному читателю вашего кода вы говорите о том, что старые кастомеры могут иметь user name со старыми правилами валидации, но при этом для того, чтобы создать новые кастомеры, вы должны придерживаться новых правил валидации. И здесь по мере того, как юзеры, допустим, меняют свои user name, хотя, не знаю, наверное, никто не будет их менять, но не менее, допустим, когда юзеры заходят на сайт, вы им выдаете там warning, что вам необходимо поменять user name, поменяйте, пожалуйста. И по мере того, как эти пользователи меняют user name на валидные, ну в том плане, что на новую версию user name, у вас в базе данных сохраняются все больше и больше user name в новом виде, то есть потенциально когда-нибудь, когда все юзеры поменяют свои user name, вы можете удалить уже старый user name, value object, и оставить только новый user name. Но, как правило, конечно, с таким примером вряд ли это произойдет вообще, то есть, скорее всего, вам придется жить с двумя этими value object-ами всегда. Но все равно это лучше, чем иметь такое неявное правило, где вы где-то там в контроллере записали, что, а, вот для имеющихся юзеров вы можете там иметь такой user name, а для новых юзеров вы не можете юзер name такой иметь. Вот, а лучше такие вещи выражать в явном виде в коде и лучше иметь все-таки два value object для такого use case. В некоторых случаях может быть... Это удивительно, но это не решило проблему из базы данных, потому что когда мы читаем из базы данных, мы типа в базе данных держим вообще два разных поля, то есть у нас там будет два user name, user name 1, user name 2. Не, почему? Когда читаете из базы данных, вы это все десерилизуете в старый user name. То есть там вы точно не можете знать новые правила валидации или старые были, поэтому там нужно делать assumption, что все юзеры имеющиеся имеют старый user name. Вот, собственно, то, о чем я говорил, что само поле у юзера нужно моделировать в виде старого user name, но при этом в конструкторе в виде параметра нужно принимать новый user name, при этом у них там будет конвертация, то есть из нового user name можно сконвертировать были object в старый user name, просто потому что правила валидации у нового user name более строгие, и поэтому мы можем без проблем сделать конвертацию в старый user name, но в обратное это неверно. То есть из старого user name вы не можете сделать конвертацию в новый user name, потому что там могут быть падения, ну, из-за того, что там старока в неправильном виде сохранена. Ну, и, собственно, это решает проблему в том плане, что когда там, даже если вы накатили backup старой базы и пытаетесь материализовать объекты, в смысле данные из этой базы в user, то у вас они будут материализованы в старый user name, то есть там падений не будет. Ну, это похоже на правду, я молчу, потому что я ожидаю перехода выше по stack. Мы там, кажется, начали обсуждать, было какой-то свете на вопрос про бизнес-логику, а потом мы куда-то в ребре ушли опять. По-моему, ответили, мы по-моему ответили на этот вопрос. Ну, можем поговорить про другие еще паттерны, которые есть в DDD, например, тот же самый агрегат. Да, давай, потому что так получилось, что мы в AliObject уже обсудили, потому что AliObject это, наверное, самая такой, наименее DDD-шная такая штука, потому что, ну, это можно вообще куда угодно притащить. Что еще там? Что там еще? Да, ну, такие три основных паттерна вот в плане моделирования домена – это entity, сущность AliObject и агрегат. Есть еще там всякие репозидоры, но они точно относятся к DDD, потому что репозидоры, паттерн сам, он был и, ну, раньше, короче, до вот этой книги, и там есть еще какие-то паттерны, например, спецификация, которая тоже, на самом деле, к DDD малые отношения имеет, просто этот автор, Эрик Эванс, он написал про него в своей книге, потому что, я думаю, мое мнение личное, потому что он просто до этой книги писал пейпер с Мартином Фаулером про этот паттерн, ну, и решил, наверное, заодно внести информацию в книгу саму. Вот, то есть, опять же, в DDD есть стратегические паттерны и есть тактические паттерны. Основные тактические паттерны – это entity, AliObject и агрегат. Стратегические паттерны – это то, как лучше разбивать ваше приложение на bounded context. То есть, bounded context, как мы обсудили, это примерно так можно рассматривать, как аналогы микросервисов, но, опять же, там не всегда один к одному соответствие. И в стратегических паттернах Эванс приводил то, как могут заводействовать между собой эти bounded context. К примеру, они могут иметь какой-то shared kernel, то есть, общее ядро, которое будет шариться этими двумя bounded context. Я считаю, что это плохой подход. То есть, тут имеется в виду, что если какая-то бинслойка у вас используется в обоих bounded context, то есть смысл эту бинслойку пошарить. На самом деле, это плохой подход, потому что шарить бинслойку между bounded context и микросервисами – очень плохой подход, так что вы таким образом завязываете ваши микросервисы друг на друга. Вы не можете поменять эту бинслойку общую между ними, так что вы не поломаете другой микросервис в потенциале. Поэтому тут лучше подходить к моделированию с позиции того, что если есть какая-то общая бизнес-слойка, то лучше ее просто продублировать. Здесь, опять же, вопрос между dry principle и decoupling. Здесь decoupling намного более важнее, чем dry principle, потому что dry – это don't repeat yourself, то есть не повторять себя, потому что работать с завязанными друг на друга микросервисами либо bounded context очень сложно, особенно если над этими bounded context работают разные команды. То есть с координацией будут очень большие проблемы. Это то же самое, считайте, что мы возьмем одну базу данных и будем над ней вместе работать. То есть, к примеру, есть две команды, они строят свои bounded context и свои микросервисы, и они работают с одной и той же базой данных. Это тоже очень плохой подход, потому что тогда база данных – это связующее звено между этими двумя микросервисами. Она завязывает эти микросервисы друг на друга таким образом, что вы просто не сможете рефакторить эту базу данных таким образом, что вы не заденете другую команду. Вам придется коммуницировать с ними активно насчет этой базы данных и прочее-прочее. Поэтому здесь лучше всего коммуникацию между микросервисами делать строго через API, где вы сможете довольно просто настроить какой-то backward compatibility, версионность, а через и не позволять связываться bounded context на уровне базы данных, на уровне бизнес-логики и держать их полностью отдельно. По поводу агрегатов. Это паттерн, о котором мы тоже немножко поговорили в начале. Он нам говорит о том, что если в вашей доменной модели существует несколько сущностей, которые работают друг с другом активно, то есть которые связаны между собой по смыслу, то лучше их моделировать тоже как единое целое. И это единое целое как раз называется агрегат. В книжке Эрик Эванс приводил пример в виде такой грости виноградной, где все ягоды на этой грости связаны между собой. И за сама грость она по сути агрегат, который агрегирует все ягоды на себе. И также можно рассматривать сами классы в доменной модели. Какая-то часть этих классов будут всегда работать друг с другом, и поэтому их лучше моделировать тоже как единое целое. Не ведет ли это к монолиту? Почему их просто не написать как-то такую одну большую штуковину? Почему это вообще отдельные классы? Ну потому что по смыслу это все-таки будет отдельными классами. Ну то же, например, если у нас есть кастомер, и у кастомера есть адреса. Вот эти адреса, их в теории конечно можно было бы в виде, ну просто внести в сам кастомер, но лучше все-таки это репрезентить как отдельную сущность, ну либо там value object. Ну вот мы говорим сейчас про сущности. Ну то есть получается у нас сущность и ее value object это агрегат. Так что ли? Нет, там не совсем так. То есть value object, они всегда принадлежат сущности. То есть тут это вы считаете вот value object, это просто такой glorified string или integer. То есть value object он не может жить сам по себе, он всегда принадлежит какой-то сущности. Например, customer name это value object, он всегда принадлежит сущности. Агрегат это скорее больше про entities, про сущности, которые связаны между собой по смыслу. Вот тот же самый кастомер, у него может быть ну либо адрес, либо billing info, с которым мы в приложении работаем всегда вместе с этим кастомером. Либо еще как вариант там, не знаю, purchase, можно рассмотреть. То есть допустим есть ордер у вас и в нем order lines. Вот эти order lines это тоже будут сущности, которые всегда работают, с которыми вы всегда работаете вместе с самим ордером. Либо еще вот тоже в книжке Rick Evans приводил пример, что если у вас есть машина, то это четыре колеса, вы всегда их будете рассматривать вместе с машиной, потому что у вас машина всегда будет с этими колесами. То есть рассматривать отдельно эти сущности друг от друга нет никакого смысла. Окей, у меня возникает два вопроса. Первый вопрос. Если мы решили внести какое-то изменение, теперь у нас есть какая-то другая штука, с которой нужно такая же сущность, что делать с существующим агрегатом. Второй вопрос. В чем выражается вообще агрегатность агрегата? Ну окей, у нас классы, они просто встраиваются в другие классы. Почему это прям отдельный паттерн? Потому что таким образом вы явно выделяете границы между разными областями вашей доменной модели. То есть вы можете просто их делать как отдельные сущности, но при этом тогда не будет понятно, какие сущности работают друг с другом более тесно, чем с другими сущностями. То есть это просто чисто для такая аннотации вашего кода, то есть для того, чтобы потом с этим кодом было проще работать, было его проще читать и так далее. Вот и здесь из этого агрегата, сам паттерн агрегат, он предусматривает некоторые гайдлайны по работе с этими сущностями, которые находятся внутри самого агрегата. То есть сам причина вообще, почему мы вводим этот паттерн в код, для того чтобы уменьшить количество сущностей, с которыми вы работаете в коде. То есть вот таким образом, это называется такой типичный, короче называется чанкинг по-английски, когда вы общие вещи собираете в одно и вам просто проще с этими общими вещами будет работать. И тут, собственно, точно такой же принцип, то есть если у вас существует меньше единиц кода, за которыми вам нужно следить, то вам становится намного проще с этим кодом работать. То есть вам не нужно, ну опять же, короче, правило простое, чем меньше у вас единиц в коде, тем проще. Вот и агрегаты вам позволяют сгруппировать, так сказать, собрать в кучку общие, те вещи, которые работают вместе с собой и рассматривать их как едино целое, опять же, для того чтобы уменьшить когнитивную нагрузку при чтении этого кода. То есть вы можете просто, ага, вот у нас есть три класса, рассматривать их как просто единое целое и там абстрагироваться от конкретной детали имплементации, не важно как именно эти три класса были реализованы, что они там внутри делают. Я знаю, что это вот отдельный агрегат, которым, если мне нужно будет, я могу просто в него посмотреть и понять, что он работает, но так как он мне сейчас не нужен, я могу просто на него не обращать внимания. Гайдлайны, которые вводит книга по работе с агрегатами, сами агрегаты, они являются такой единицей в нескольких смыслах. Во-первых, это такая концептуальная единица, то есть с точки зрения кода, с точки зрения чтения кода и с точки зрения понимания кода, они позволяют вам сделать такой разбивку ваших классов на кучке разной, потом эти кучки рассматривают друг от друга по отдельности. Вторая, вторая, так сказать, сторона этих агрегатов, это то, что они являются, они вам дают транзакционал баундерис, то есть они очерчивают границы ваших бизнес-операций, бизнес-транзакций. Есть такое правило в ДДД, что сам, точнее как, у вас есть инварианты в вашем коде и у вашей инварианты проще становится с ними работать, если у вас есть какая-то единица в коде, то есть агрегат, в который вы можете эти инварианты поместить, то есть ваши правила валидации. Вы можете с помощью этих агрегатов намного проще настроить валиирование, потому что вы можете проверить не только данные, которые относятся к самому классу, но и те данные, которые относятся к child entities. То есть, да, это я про это, по-моему, не сказал, что в агрегате есть aggregate root, это корень агрегата, это та сущность, которая является, так сказать, главной в этом агрегате. И есть child entities, это те сущности, которые находятся, так сказать, в подчинении от этого агрегата root. И когда вы работаете с агрегатом, вы всегда работаете с корнем этого агрегата, и все операции выполняете, в том числе и на child entities, через этот корень агрегата. И это удобно, потому что вы можете, вам проще настроить валидацию этих операций, потому что вы все изменения над этой группой сущностей, вы их все проксируете через корень агрегата. И там вы можете поместить правила валидации необходимые, которые касаются не только самой этой сущности, но и child entities. То есть вы можете, допустим, проверить, что, допустим, у вас у customer может быть не более трех адресов, по какой-то причине, неважно, какой. И вы можете эту валидацию поместить прямо напрямую в класс customer, и у вас невозможно будет создать customer с более чем тремя адресами. Если бы вы такого разбия не делали, то вам пришлось бы эти валидации выносить на уровень контроллера уже. Потому что у вас не было бы такого четкой границы над этими связанными между собой сущностями. Не верю, что понятно объяснил, но дайте знать, если что-то требует пояснений. Я предлагаю ходить дальше. Подожди, прежде чем ехать дальше, может быть знаешь, что... Меня несколько раз спрашивали, и вот здесь очень хорошее место, чтобы обсудить этот вопрос, как раз вернуться к более конструктивному, применимому, практичному руслу. Ты можешь на своем опыте дать, из своего опыта дать несколько примеров, когда DDD тебе по-настоящему помог? И если бы ты не использовал DDD, не знал его, не читал про него, тебе бы пришлось тяжелее. Какие-то из своего собственного опыта? Да, в начале особенно карьеры, вся архивная слойка находилась в UI, либо в базе данных, либо в каких-то фреймворках. Очень сильно помог DDD, потому что это очень сильно помогло упростить процесс разработки. И по моему опыту, вообще вот сейчас я без DDD никаких приложений на интерпразе не делаю, потому что это сводится в итоге к пересложенному коду, с которым потом очень не просто работать и поддерживать. Можно уточнить, ты говоришь упростил разработку и сложнее поддерживать. Это произошло из-за того, что ты фактически, вот то, что в самом начале говорил, складывать все в одно место, в смысле вся бизнес-логика сконцентрирована в одном месте, ты разбиваешь это на какие-то области, которые мало пересекаются с другими областями, то есть разбиваешь всю доменную область на какие-то кусочки, и эти кусочки независимо друг от друга разрабатываешь, что позволяет тебе быстрее развивать продукты, быстрее фирить ошибки. Да, именно так. Если есть какая-то операция, которую нужно подправить, мне теперь не нужно лазить по коду UI, по коду храним процедур, я точно знаю, что у меня есть сущность, в которой эта бизнес-логика сконцентрирована, я просто могу посмотреть в эту сущность и понять, как она сейчас работает, и что мне нужно сделать, чтобы эту логику поменять. То есть вот этот подход, где явно в виде бизнес-логику выносили в отдельные классы, вот эти самые сущности, он просто для меня, по крайней мере в начале моей карьеры, был просто как небо земля. То есть все мои проекты после этого стали намного более простыми в разработке. То есть здесь два на самом деле фактора. Первый – это то, что читать такой код удобнее и проще. А второй – это то, что бизнес-модель, доменную модель можно сделать полностью инкапсулированной, ну либо почти полностью инкапсулированной. То есть делать так, что если вы внесете какой-то баг в приложение, то этот баг просто будет проявляться в виде эксепшн, и у вас он не достигнет базы данных, где с ним довольно сложно будет работать потом разбираться. То есть полная инкапсуляция – это тоже очень хороший плюс подхода в ДДД. То есть любые… Ну опять же, тот Гайл, про который я говорил, что мы делаем legal states, unrepresentable в нашей доменной модели – это тоже очень большой плюс. Это помогает упростить работу. Вам не нужно, например, беспокоиться о том, что если вы работаете с email, с объектом класса email-адрес, то вам не нужно беспокоиться о том, провалидировали мы этот email-адрес до того, как мы его начали использовать или нет. Потому что если вы используете просто строчку, то вам нужно в коде, ну вот при чтении кода, понимать, а мы вообще эту email провалидировали или нет. То есть, допустим, если он используется этот email в виде строчки, где-то там внутри бизнес-логики, ну или не email, не знаю, там order-quantity. И мы смотрим, мы пытаемся понять этот int, который репрезентует order-quantity, мы его вообще провалидировали или нет. И вот доменная модель явная, она убирает все вот эти потенциальные проблемы в том плане, что вы точно знаете, что если вы создали объект класса order-quantity, то этот объект будет находиться в валидном состоянии всегда, потому что вы не сможете просто создать этот объект в невалидном состоянии, потому что он у вас кинет ex-uption. То есть, вот эти два принципа, explicitness в подходе моделирования ваших домен и потом полная капсуляция, они очень сильно помогают в разработке. Это очень классно, спасибо, это правда помогает. А второе практическое применение, которое лично мне помогает, я бы хотел сюда поглубже окунуться, если это возможно. Даже не знаю, как это правильно сказать. Я не уверен, что всем слушателям это прямо сразу пригодится, но в любом случае смотреть на это очень полезно бывает. Можешь по пунктам пройтись, как ДДД считает нужным делать дизайн большой бизнес области. Как можно кратче, для того чтобы доходчиво дошло. Вот, к примеру, мне надо сделать на практическом применении, даже не знаю, давайте сделать Twitter. Вот, к примеру, да. И, каким образом разбить, то есть, самая сложная часть, когда вы делаете в начале, вам нужно понять область, вам нужно разбить ее на составляющие, вам нужно понять, сколько человек понадобится, сколько команд будет, сколько будет всего. И вот вы начинаете делать Twitter. Начни делать Twitter, расскажи, как ДДД говорит, надо начинать делать Twitter. Ну, Twitter на самом деле не очень хороший пример, потому что там как раз любой дойкий. Ну, допустим, какой-нибудь enterprise, допустим, делаем ERP, и там ERP будет отвечать нам за менеджменты наших кастомеров, за покупки и прочее. ERP это плохая система, она не всем бывает сразу понятна. Те, кто не работал с ERP-системой раньше, они не поймут этот пример. Давай какой-нибудь более приближенный к реальности. Ну, поправьте, если не прав, я, у нас был очень давно курс по ERP-систему, но мое понимание, что ERP это просто любая автоматизация документа оборота. Ну, скорее предприятие даже, не только документы оборота. Да, это, то есть, ваше предприятие что-то делает в реальном мире, и вам нужно фабранизировать эту деятельность, чтобы помочь этому предприятию масштабироваться. Вот, собственно, это и есть ERP-система. Ну, то есть, к примеру, ну, это опять же из моего опыта, допустим, компания занимается продажей hardware оборудования, и это вот оборудование уходит клиентам, и есть несколько областей. То есть, во-первых, нам нужно каталог поддерживать этих, этого оборудования, потом нужно учитывать количество этих вещей на складе, потом нужно заниматься перевозками, потом чарджингом клиентов, то есть учетом платежей этих клиентов, и так далее, и тому подобное. То есть, тут как раз много областей, которые связаны с продажей hardware оборудования, которые нужно каким-то образом связать воедино. Нет, все-таки Twitter лучше. Давай Twitter. Мне кажется, ERP плохой пример в том смысле, что его, по моим скромным знаниям, никто не пишет с нуля, и его генерируют в конструкторе. Тут точно не пишут с нуля полностью, то есть, скорее, тут используют какие-то готовые приложения для того, чтобы заоцорсить части этого ERP-приложения. То есть, да, это, например, в бухгалтерию никто не пишет с нуля, там все используют 1.S. Тот же самый, допустим, складской учет, там тоже вроде есть какие-то готовые модули, которые можно использовать. И тут нужно понять, какая часть этого приложения будет являться корневой, и ее писать уже руками, а со всеми остальными делать интеграцию с помощью внешних систем. Тот же самый 1.S или, не знаю, sub какой-нибудь. То есть, ну, опять же, в DDD есть такое понятие, как core subdomain, то есть, если мы делим нашу задачу domain на подзадачи subdomains, то вот эти subdomains, они по-разному важны для бизнеса. Есть core subdomain, это та часть бизнеса, которая отвечает за, которая дает конкурентое преимущество вашего приложения, вашей компании. То есть, то, что вы не можете отдать на UTSOS, потому что нет таких готовых решений. Есть какие-нибудь там generic subdomains, допустим, в таже бухгалтерии, и нет смысла писать generic subdomains с нуля, проще взять какой-то коробочное решение. Ну и потом настроить интеграцию. Но опять же, с Twitter тут пример просто потому, что не очень хороший, потому что бизнес-логи там особо нет никакой. То есть, там нужно просто следить за тем, чтобы у вас, там, не знаю... Ну какая-то есть, мой доверий, вы можете... Я уверен, что инженеры Twitter просто придут и что-нибудь откусят. Когда ты говоришь, что нет никакой бизнес-логики, да, согласен. Ну там, в самом деле, не только бизнес-логики делал, но и в том, что там в Twitter, допустим, по перформансу намного более серьезное требование, чем у типичного интерпресс-преложения. Я уверен, что там вся куча бизнес-логики про то, как открутить рекламу. И про то, как ее потом показать, что ты ее хорошо открутил. Тут скорее, ну, откручивать рекламу нет, скорее, менеджмент это реклама. То есть, если человек пытается подать эту рекламу, он, видимо, использует какой-то бэкенд. И вот в этом бэкенде, да, там уже будет много бизнес-логики. Потому что откручивалка рекламы, но там просто аукцион, счетчик, и там особой бизнес-логики, наверное, нет никакой. Ой, ой, ой, ой, ой, ой, ой, я работала над этим аукционом. И не в Twitter, конечно, но там очень много бизнес-логики. То есть, там даже, ну, то есть, даже банально посчитать, то есть, опросить всех бидеров, кто бидит на какой-то слот рекламный. Понять, кто из них победитель. Ну, в общем, мы, как бы, мы хотели убедиться, что победитель подходит под требование какого-то конкретного слота, какой-то конкретной страны. И там получается довольно много таких вот нюансов, которые, ну, то есть, это та самая бизнес-логика, которая есть. Ну окей, значит, я тоже не прав. Так же к своим. Весь выпуск убеждаем, что везде есть бизнес-логика. Вот, знаешь, вот поэтому я и хотела, чтобы мы прояснили понятие бизнес-логики, потому что это такая вещь, такая вот абстракция, которая, мне кажется, этим можно назвать много чего. И поэтому, мне кажется, бизнес-логика, она есть, она может быть, то есть, как бы, для внешнего наблюдения может казаться, о, мы должны по бизнес-логике просто показать правильный баннер. Но чтобы это сделать, там появляется очень много нюансов, и они, как бы, не то чтобы очень детально важные, но они, то есть, ну, для конечного результата. Мы в чину показываем просто баннер. Но чтобы понять это, требуется много-много, грубо говоря, этих if-if'ов написать. Вот, ну, я так это понимаю. Да, да, это именно так. То есть, если ее много, то, опять же, здесь правило такое, что нужно ее выносить в отдельное место, с четко определенной границей, и потом делать, ну, интеграцию между UI-ем и вот этой бизнес-логикой. Ну, то есть, в смысле, не интеграция, а, то есть, взаимодействие между UI-ем и вот этой бизнес-логикой, оно уже должно там делаться с помощью медиаторов, ну, контроллеров. Вот, то есть, здесь принцип тот же самый. Да, если эта бизнес-логика есть, то нужно ее вынести в отдельное место. Вот, по поводу вопроса о том, как моделировать с нуля большую систему. Есть разные подходы с примоделированием. То есть, во-первых, тут, опять же, тот же самый DTT, он пропагандирует активную работу с доменными экспертами. То есть, программисты не должны просто там сами писать код по каким-то спекам. Они должны активно коммуницировать с доменными экспертами, со стейкхолдерами и, желательно, не через посредников. То есть, очень часто можно видеть, что коммуникация с такими доменными экспертами или стейкхолдерами идет через аналитиков. Тут нужно привлекать более активных программистов к таким дискуссиям. То есть, аналитики сами по себе могут существовать в проекте. Тут они приносят пользу, в этом ничего плохого нет. Но при этом сами программисты тоже должны стремиться понять доменную модель настолько, насколько это вообще возможно. Иначе будут сложности с... Так сказать, коммуникационный барьер будет такой, между доменными экспертами и программистами. То есть, программисты там пишут код на каком-то своем языке, используя своими терминами. Доменные эксперты говорят на другом языке. И каждый раз, когда нужно сформулировать какие-то требования, вам необходимо делать трансляцию между этими двумя языками. То есть, один принципов ДДД это называется единый язык. И этот принцип говорит о том, что как раз нужно использовать единый язык при... Во-первых, при общении на темы о домене с доменными экспертами. И, во-вторых, при программировании. То есть, это то же самое, что мы обсуждали, что если у вас есть понятие «customer», то в коде это должно быть... Тоже выглядит как «customer», а не как «user». И в базе данных тоже должна быть табличка «customer», а не «user». Если там у вас вы видите, что доменные эксперты используют какой-то термин, называют его по-разному, то вам необходимо коммуницировать с доменными экспертами для того, чтобы привести эту технологию к какой-то единый вид. То есть, этот единый язык тоже требует постоянного рефакторинга, точно так же, как ваш код требует постоянного рефакторинга. Если вы видите, что вы используете в общении язык неконстантно, то лучше это дело сразу обсудить и привести к какому-то единому термину. То есть, первый принцип – это общение активно со стеколдерами. Второй принцип – есть такой подход, как называется «event storming». Это когда вы делаете сессию с стеколдерами, и они рассказывают вам о том, как вообще работает их бизнес-процессы. И вы записываете эти бизнес-процессы в самый распространенный способ. Это вы берете бумажки и их на доску какую-то, и между ними настраиваете связи. То есть, допустим, ваш бизнес-стеколдер рассказывает, что когда у нас делается покупка, мы делаем оповещение по email о том, что у нас произошла покупка. И должны при этом запустить процесс чарджинга кредитной карты этого юзера. И вы прямо на доске рисуете штуки. У нас такое событие, что покупка произошла. Это событие привело к возникновению следующих процессов. Первый – это отправка email, а второй – это чарджинг кредитной карты юзера. И там эти процессы тоже могут иметь несколько шагов. Допустим, мы делаем какие-то ретрои чарджингой. Потом, если у нас не получается зачаржить, мы переводим статус ордера в failed. И начинаем шиппинг только тогда, когда у нас чарджинг прошел успешно, к примеру. То есть, это в общих чертах, как обычно подходит к моделированию таких больших систем. Ты очень просто рассказал про на доске стикеры и связи между ними. Я делал это несколько раз, и каждый раз это головная боль на несколько недель. Потому что у каждой области свой владелец. И с этим владельцем нужно очень четко обсуждать, как именно они стыкуются с остальными. И все это постепенно превращается из простого рисунка. Мы обычно рисуем на белых досках. И обычно это превращается из простого рисунка, когда добавляются, добавляются, добавляются детали. Потом ты одну доску развиваешь на несколько досок. И так оно все глубже и глубже уходит, чтобы понять, что происходит. И каким образом это взаимодействие работает. Да, здесь, к сожалению, какого-то единого рецепта нет. Тут надо смотреть по ситуации. Возможно, в случае, когда сложность слишком сильно возрастает, возможно есть смысл выделить отдельные подпроцессы, просто рассмотреть их отдельно. То есть, опять же, поместить их там концептуально в отдельный bounded-контекст. И сказать, что мы требуем, то есть сказать, что мы ожидаем от этого процесса в общих чертах, какие у нас предусловия и какие у нас постусловия. И потом уже отдельно промоделировать этот bounded-контекст с этими экспертами в отдельной сессии. Тут, опять же, да, тут очень сильно зависит от того, что за проект. И какие требования к проекту. И насколько он большой, по сути. А вот у меня еще один вопрос очень практический. Сейчас попробую описать проблему. Есть доменные области, есть предложения, по которым ты можешь по-разному разбивать эти контексты. Ты можешь делать их горизонтально и вертикально. И вот оба варианта, в принципе, нужны для пользователей. Вот сейчас там конкретный пример, я думаю, достанет более понятным. Например, у нас есть разные девайсы. Например, там, не знаю, switch, router, какая-то точка доступа, камера. То есть вот, как бы, кажется, предположительно каждый девайс это будет каким-то, представлять собой, доменный объект, который мы хотим смоделировать. Но в то же самое время для пользователей, когда мы показываем, мы можем показывать их на UI, можем показывать по каждому девайсу какие-то отдельные параметры, настройки. Но в то же самое время мы хотим показать UI, которая объединяет, например, не знаю, IP для всех этих девайсов. То есть такие вот, то есть я хочу сказать, что мы можем разбить это вертикально и горизонтально. И мы хотели бы показывать и так, и так для наших конечных пользователей. И возникает вопрос, как вот такие ситуации модерировать, когда мы можем и так, и так разбить, и какие, не знаю, best practices для этого делаются. Я не знаю, насколько это получилось у меня объяснить проблемную сферу. Я так понял, это вопрос в том, как отображать пользователя где-то там на UI или... Ну, то есть понимаешь, оно можно... Это не только про UI скорее, это про то, что мы иногда хотим показывать для, например, какую-то, не знаю, настройку или какой-то агрегированный формат для всех типов устройств. А иногда мы хотим по устройству, то есть детали. И вот мы хотим такой вот... Для меня в голове ресурсия, такая матричная структура, я хочу иногда вертикально показать, а иногда горизонтально. Я могу домен вертикально выделить, я могу горизонтально. И для каких-то вариантов использования мне более удобно вертикально, а для каких-то более удобно горизонтально. Ну, это скорее вопрос работы с... Как пользователям удобнее, чтобы мы представляли наш домен? Тут, я думаю, есть смысл моделировать это в виде отдельных объектов, но при этом при показе пользователю может быть выделить либо отдельные доменные объекты, которые будут агрегировать данные с других доменных объектов классов, либо просто на UI это захендлить и сказать, что это у нас логика относится чисто к логике презентации, а не относится к домену логики. Хороший вопрос здесь будет, могут ли юзеры менять при этом эти девайсы в виде таких же агрегатов, либо они только смотрят на них... Могут менять, могут менять. Да, тогда это лучше сделать в виде отдельных доменных объектов. Тут хорошая лакмусовая бумажка, это может, могут ли юзеры наносить изменения в домен... в какие-то вообще любые изменения в данные. Если да, то для этого нам нужно моделировать наш домен для этих изменений, потому что эти изменения должны проходить через все проверки, там нужно правильно настраивать инкапсуляцию и так далее и тому подобное, и поэтому это необходимо моделировать. Если же юзер это просто видит, то есть смотрит в качестве репорта или еще что-то, то тут доменной модели нам не нужна, мы можем напрямую там запрашивать данные из базы данных и показывать эти данные пользователю. А потом уже когда пользователь там переходит в details и там уже может менять, мы уже делаем это использованием наших других доменных объектов. Так как здесь пользователь может менять это дело в виде разных агрегаций, то здесь лучше сделать отдельный доменный класс для этих двух представлений, так сказать, для юзера. То есть я не уверен, что я правильно понял домен, но из того, что я понял, я думаю, что лучше всего смоделировать эти девайсы и их IP-адреса в виде отдельных классов изначально, но потом сделать еще над ними еще один доменный класс, который будет их агрегировать в нужном для пользователя виде и который будет позволять менять эти доменные классы тоже в этом же агрегированном виде. Я думаю, что получается у нас будет для каждого... То есть я дальше думаю по поводу архитектуры, например, такого приложения. То есть для каждого домена, например, девайс, роутер, у нас будет какой-то микросервис, который отвечает за это, и потом у нас появляется какой-то агрегирующий сервис, если нам нужно поменять какую-то настройку для девайсов разного типа. То есть такого плана или ты что-то другое имел? Нет, микросервис, я думаю, для отдельных девайсов делать нет смысла, не нужно, потому что это будет слишком мелкое разбиение, пока не из того, что я понял. Я имею в виду, что будет просто отдельный доменный класс. Еще раз можно сказать, как именно будет агрегация проходить? То есть девайсы, какие там два варианта? Да, получается, для пользователей хотелось бы предоставить две такие возможности, то есть две варианта изменения настроек для девайсов. Они могут для каждого девайса, например, кликнуть на какую-то страничку, которая ведет их к определенному типу девайсов, например, это, не знаю, роутер. И мы видим там все роутеры, потом кликаешь на свой конкретный роутер, разбиваешь, ну, ты можешь поменять какие-то настройки для какого-то специфического роутера. Это вот один вариант использования, и пользователи некоторые такое предпочитают. А есть другой вариант, когда мы предлагаем агрегированный формат, где показывается одна и та же настройка, например, IP-адрес либо имя для девайсов разного типа, там роутер, switch, камера, и пользователи могут поменять, например, название по какому-то шаблону для всех устройств, которые относятся к этому конкретному пользователю. То есть вот и разные пользователи предпочитают разные UI для каких-то целей им удобнее для какого-то девайса вглубь завернуться и там что-то менять, а некоторым удобно поменять раз и для всех девайсов, например, которые они купили. Возможно, мне не очень хорошо получается это объяснить, потому что я такой вот, но если какой-то есть вопрос, могу как-то детальнее рассказать про use case. Да-да-да, понятно, да. Смотри, короче, я бы сделал так, что у нас есть девайс, один единичный девайс, который пользователь может менять отдельно и просто вот, то есть это не отдельный микросервис, это просто отдельный класс. И также есть группа девайсов либо девайс type, девайс type не очень хорошо, просто группа девайсов, которые сгруппированы по какому-то типу. И это тоже будет отдельным классом, в котором мы вносим какие-то правила, там шаблоны по изменению названия и тому подобное. Вот и вот эти два use case по смене параметров девайса и по смене параметров группы девайсов они просто будут обрабатываться отдельно, ну, то есть, собственно, таким ямным образом смоделировать вот эти два use case с использованием двух отдельных деменных классов. Окей, спасибо. Ну, просто мне кажется, вот этот подход, когда хочется вот вертикально и горизонтально разбивать твою доменную модель и что-то менять горизонтально, что-то вертикально, я такую штуку видела довольно часто в разных доменах, и кажется, что такое это довольно распространенно должно быть паттерн. Да, да, паттерн это довольно... Я могу искать на эту тему. Короче, там это как раз вопрос о том, что мы предпочитаем. То есть здесь у нас получается такое Bulk Updates, будут проходить в базе данных там на сразу группу девайсов, либо у нас будет происходить апдейт только одного девайса. И DDD хорошо ложится на use case, где мы работаем с небольшим количеством объектов, а не с кучей сразу разных объектов. Ну, то есть, в общем, это называется All Up versus All Tp. Вот All Up это когда мы работаем с множеством объектов, и All Tp это, по-моему, All Tp, если я не ошибаюсь, это когда мы работаем там с одним либо с небольшой группой объектов. И, как я сказал, DDD лучше всего ложится на второй use case, когда мы работаем с небольшим количеством объектов, потому что мы здесь можем подходить к этому с точки зрения... ну, используется наш стандартный паттерн. То есть мы выбираем какие-то данные для этой группы объектов, диссерилизуем их в наши адменные объекты и потом сохраняем обратно в базу данных. Потому что с Bulk Updates так и не получится, потому что там нужно будет либо кучу объектов выбирать, то есть мы теряем performance, либо мы должны делать update с использованием средств нашей базы данных, ну, какой-то революционной базы данных, но при этом получается мы это делаем в обход нашей доменной модели. Доногащенно в твоем случае, я думаю, тут стоит это делать через Bulk Updates, все равно какие-то инварианты можно будет поддерживать, помню еще вот этого отдельного доменного класса, то есть группа девайсов. То есть, допустим, там можно будет проверить, что шаблон соответствует каким-то правилам. Вот, и эти правила валидации можно будет поместить в этот доменный класс группы девайсов. Но при этом сам update, да, будет проходить уже средствами базы данных. В целом здесь плохого ничего нет, то есть, как правило, когда такой обшникает use case, да, тут лучше использовать просто средства самой революционной базы данных. И не выбирать эти объекты из базы данных предварительно. Просто кажется, что это в реальном мире, я думаю, у нас будет сочетание и use case, когда нам нужно какую-то транзакцию над одним объектом совершить, и когда у тебя будут какие-то Bulk Updates. Поэтому я думаю, что в реальности у нас будет какое-то сочетание, и ты говоришь, что DDD больше подходит для транзакций, но в реальном мире у нас будет какой-то mix двух случаев. И мне интересно, насколько тогда DDD применим, когда у нас mix? Они вряд ли будут существовать в одной бизнес-транзакции, это редко довольно-таки такое случается. То есть, когда нужно, допустим, про-update-ить один девайс и сразу группу девайсов в одной бизнес-транзакции или дейтабейс-транзакции. Правила-то все-таки отдельные use-кейсы, и тут таких Bulk Updates тоже, как правило, все-таки не так много, как Updates единичных объектов. Я говорю, что Domain Dominating здесь не так хорошо применим, как с единичным объектом, но все равно какие-то инварианты, то есть какие-то правила эволюции все равно можно вынести в доменную модель даже с таким подходом. Опять же, тот же самый шамлон названия девайсов, который мы будем применять с помощью нашего Bulk Updates, их тоже можно вынести в доменную модель. Еще есть такой подход, называется pattern-спецификация. Я писал на эту тему статью. Сейчас я попробую ее найти. Да, вот прямо так и называется DDD and Bulk Updates. Там как раз рассматривается ситуация, когда мы хотим проапдейтить какие-то, например, там task'и были, что мы хотим проапдейтить execution date в зависимости от каких-то условий. В твоем случае, когда там, допустим, апдейтить нужно просто все, и условия это просто, допустим, просто device-type, там, я думаю, такой pattern нет смысла применять. А если же есть более сложный случай, когда мы хотим апдейтить группу девайсов, следуя какому-то фильтру, этот фильтр может меняться в зависимости от use-case, это там есть смысл рассмотреть pattern-спецификации. Смысл этого pattern'а в том, что мы моделируем не саму операцию апдейта, а мы моделируем условия для выполнения этого Bulk Updates. И эти условия их помещаем в наши доменные классы. То есть это примерно то же самое, что когда мы делаем template в доменном классе device-group, но там только это относится не к template, а там это относится к условиям, по которым будет проходить этот Bulk Update. Просто довольно большая тема, да, я бы просто поместил ссылку на статью. Да, обязательно ссылки на статью. Да, я вижу, что Валера нам в чатик закинул эту ссылку. Спасибо, Валера. Я не знаю, мы, наверное, уже наговорили очень много времени, возможно, я не знаю, как бы, мне кажется, мы что-то не обсудили, но с другой стороны, мы уже вылезли за весь возможный хронометраж. Мы хотим что-то еще дообсудить. Ну, в принципе, многие вещи, которые я хотел рассказать, я рассказал, там есть какие-то детали, которые можно было облубиться, но там можно про это говорить еще часами. У меня остался последний вопрос, мой любимый, про то, что пошло не так. Была ли какая-нибудь ситуация, когда вы внедриали DDD, и вроде как подходящий use-case, и все должно сработать, но вот никак это не сработало, и если такое было, то почему? То скорее зависит от экспиринса команды. То есть я не думаю, что, ну, вот, опять же, вопрос применения с DDD, это если у вас есть какая-то сложность бизнес-логики, и при этом нету каких-то очень сильно больших требований по перформансу. То есть если вот эти условия соблюдены, и у вас есть сложность именно такая, а бизнесовая, то DDD здесь применим. Вот, вопрос о том, будет ли это применение успешным или нет, тут уже скорее зависит от опыта команды. Вот у меня довольно много было, ну, может, немного, но, да, было несколько случаев, когда применение было не очень удачным, во-первых, потому что я был не очень опытный в те времена, а во-вторых, ну, вот, когда уже более поздние там примеры, там была ситуация, скорее, когда команда не была анборд с этими DDD практиками, и при этом я там не был льдом, вот, и, собственно, если что-то использовался, такой какой-то микс, который, ну, по сути, ни к чему хорошему не приводил этот микс, в общем, не следовали каким-то базовым принципам DDD. Вот, и в этом случае, да, тоже ничего хорошего не получалось, то есть тут скорее вопрос в authority, то есть если людей, которые хотят этим заниматься, достаточно authority, и в опыте этих людей тоже. В тех проектах, где я был уже льдом, и мы следовали от этим всем практикам DDD, там я уже не помню, чтобы у нас было какие-то серьезные фейлы, все довольно-таки хорошо проходило.",
    "result": {
      "error": "API request failed: Error code: 429 - {'error': {'message': 'Request too large for gpt-4.1 in organization org-xSG9D345gtYlIKC330wCyrEG on tokens per min (TPM): Limit 30000, Requested 33257. The input or output tokens must be reduced in order to run successfully. Visit https://platform.openai.com/account/rate-limits to learn more.', 'type': 'tokens', 'param': None, 'code': 'rate_limit_exceeded'}}",
      "stack_trace": "Traceback (most recent call last):\n  File \"/home/andrei/Projects/podcast-shownotes/scripts/build_search_eval_dataset.py\", line 157, in generate_search_query\n    response = await self.client.chat.completions.create(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/resources/chat/completions/completions.py\", line 1927, in create\n    return await self._post(\n           ^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1767, in post\n    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1461, in request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1547, in _request\n    return await self._retry_request(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1594, in _retry_request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1547, in _request\n    return await self._retry_request(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1594, in _retry_request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1562, in _request\n    raise self._make_status_error_from_response(err.response) from None\nopenai.RateLimitError: Error code: 429 - {'error': {'message': 'Request too large for gpt-4.1 in organization org-xSG9D345gtYlIKC330wCyrEG on tokens per min (TPM): Limit 30000, Requested 33257. The input or output tokens must be reduced in order to run successfully. Visit https://platform.openai.com/account/rate-limits to learn more.', 'type': 'tokens', 'param': None, 'code': 'rate_limit_exceeded'}}\n"
    }
  }
]