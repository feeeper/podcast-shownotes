[
  {
    "segment_id": "e24d8e70-7bb6-4aee-ab57-9ad5221960fe",
    "episode_id": "76f3ac89-3c21-4b0f-94c6-b36736d11f7a",
    "episode_number": 45,
    "segment_number": 2,
    "text": "Но вот именно для того, чтобы писать прикладной софт, особенно в начале, когда я занимался фронтендом, этих знаний не нужно было. Но постепенно они набираются, и, соответственно, можно что-то... Ну, то есть своих алгоритмов у нас не разрабатывается почти что. И даже если разрабатывается, то разрабатываем не мы, не IT-отдел, не программисты непосредственно, а специальные люди, которые работают на грани информатики и биологии, эти биоинформатики. Они пишут скрипты на перле или на питоне. На перле в худшем случае, на питоне в лучшем случае. А потом мы, смотря на их код, который зачастую... Кеннадий? Кажется, мы потеряли гостя. Да, я предлагаю, пока он восстанавливает свое соединение, или что там у него, к следующей теме. Она условно помечена как Валерина, но на самом деле я там тоже немножко причастен. Валера, чем ты нас порадуешь? Валера в панике открывает документ в глоток, потому что он забыл открыть глоток в самое время. Я боялся, что мы и Валера потеряли. Я могу дать тебе подсказку. Там буква S первая. А, вы про язык программирования. Да, такая компания Яблоко недавно зарелизила. Всякий такой язык. Ну, что я могу сказать? Я на сам язык не особо смотрел. Я примерно знаю, о чем он. Но что именно такого в 2.0 появилось, немножко исключение, немножко тут посластили, здесь посластили. Самое главное, что в этом интересного, они наконец поклялись сделать его open source в течение ближайшего времени. Что меня в этом плане интересует, так это то, что Objective-C, например, не особо смысленно использовать, ежели у вас нет его стандартной библиотеки. Потому что сам Objective-C, конечно, язык гибкий, но накручивать все то, что там есть на нашей библиотеке, можно до бесконечности. Мне интересно, вместе со SWIFT немножечко NS Foundation нам отдадут, или снова нужно будет open source на реализации NS Foundation и выбирать из них, точнее, как-то... Она вроде одна даже сейчас осталась, но, по-моему, была еще про альтернативных. Но суть в том, что, короче, open source на реализации NS Foundation, как любая open source на реализации чего-то аппаратурного, вечно остается. И я очень надеюсь, что вместе со SWIFT яблоки немножечко отдадут нам NS Foundation. Это, типа, самое сердце стандартной библиотеки для Objective-C. Меня в этой новости немножко веселит и печалит одновременно то, что крупнейшая новость. Apple сделала новый инновационный язык, положил его в open source. Он уже почти кроссплатформенный. Ну, что он там умеет? Linux и iOS, по-моему, как-то так. А тем временем идея не такая уж новая, как выяснилось. То есть языков, похожих на SWIFT, как оказалось, уже есть. Уже есть, типа, лет 8. И вот к этой новости я хотел бы добавить пачку статей на Хабаре. Это то, что весь интернет обсуждает. Обсуждает на этой неделе прям горячо. И мы не хуже. Есть такой товарищ, уважаемый господин Платов. И он зарядил на этой неделе серию статей на Хабар, как я нашел лучший в мире язык программирования. Притом, нескольких частей. И я думаю, что господин Платов, его нужно удостоить звание тролль всия интернета. Потому что это выглядит так, что он публикует статью, типа, как я нашел лучший язык программирования, часть 1. Там идет такая простыня текста на пару экранов. Интересного текста. То есть там всякие истории жизни. Там много всякого наброса. И в конце, ну, в следующей части мы узнаем, какой же язык программирования самый лучший. В третьей части опять такая простыня текста на 10 экранов. Там вентилятор вращается быстро. Говно в полете. И в конце, ну, в части 3 мы уж наверняка узнаем, какой язык программирования самый лучший. И в конце выходит, вот буквально сегодня, за пару часов до записи подкаста, вышла часть 2.75, по-моему, он ее так назвал. То есть не третья. В которой еще очень много простыни. Кстати, третья часть мне больше всего понравилась. Она была... По-моему, она самая интересная была. Я ее единственную не прочитала. Я вот ту же самую не дочитала. То есть предыдущие были такие своеобразные. Я бы сказал, третья. Она такая... Ну, короче, почитайте. Она хорошая. Мне очень понравилась. И в ней в конце уже раскрывается интрига. Там был спойлер, по-моему, во второй части в комментариях. Что самый лучший язык программирования это NIMA. Вот Валера наверняка его пробовал. Нет, я его еще не пробовал. И, честно говоря, между NIMA и RUST мне больше нравится пока что RUST. Потому что NIMA это такой, ну, короче, питончик. Ну, то есть я не сильно для себя вижу разницы между питончиком NIMA и GO. Ну, ладно, между NIMA и GO питончиком я вижу разницу, но GO и NIMA для меня примерно одно и то же. Ну, то есть у NIMA чуть попроще с биндингом ксишечки голой. Ну, то есть он все-таки менее всякой фигни наружу вытаскивает. То есть, насколько я понимаю, NIMA у него, по-моему, НИМА можно позвать и СИ, а не только наоборот. Потому что GO, насколько я помню, очень тяжело позвать и СИ. А в целом он вроде примерно ГОшечка с невыключаемым ГГЦ и вот этим всем. Я, может быть, что-то неправильно помню. Ты как-то странно сказал, сначала ты сказал, что ты его не пробовал, а потом объяснил, насколько он хуже RUST. Ну, в смысле, я сейчас говорю, что я его не пробовал, я говорю о том, что я про него почитал, так бегал. Ну, то есть для меня, я не вижу большого смысла его пробовать, потому что мне пока что больше. Я все это начинал... Я начинал все это в контексте того, что SWIFT, он очень похож на NIMA, если я ничего не путаю. SWIFT он хорош тем, что он для яблок. То есть, был старый добрый obj.tfc, но у него в этом есть свои недостатки, потому что он был задизайнен еще во времена царя Гороха. Кстати говоря, он появился раньше крестов, я имею в виду obj.tfc. И там особенности при всей его гибкости, было предостаточно. И SWIFT он в первую очередь направлен на то, чтобы можно было писать под яблочные платформы с наименьшим количеством особенностей от obj.tfc. То есть он никогда не дизайнировался как язык для того, чтобы быть на других платформах. Хотя то, что он там работает, уже спасибо, короче говоря. А разве они не готовые взяли? То есть он разве дизайнировался под какую-то платформу? Ну, в смысле, они дизайнировали в первую очередь под свою стандартную библиотеку. Мне казалось, они взяли уже готовый язык, в смысле, он был до того, как они его выбирали. Ты про obj.tfc или про SWIFT? Про obj.tfc. Нет, obj.tfc они взяли готовый язык и навернули стандартную библиотеку. Но obj.tfc, поскольку он был придуман еще во время нацаря гороха, яблоки его немножко допиливали, но в итоге все равно поняли, что слишком много в нем боли, и чтобы дальше еще расширять developers' комьюнити, нужно что-то такое, что не так больно. То есть для меня obj.tfc более приятен, чем C++. Но местами он сильно больнее, потому что если ты хочешь одновременно объект ориентированности и производительности, то obj.tfc это вообще не для тебя. То есть obj.tfc, он офигенный, удобный, что-то такое, не знаю, производительный Ruby, наверное. То есть там можно делать всю ту же самую фигню, что в Ruby, метод не определен, а пофиг, сейчас какое-нибудь параксирование сделаем. Или метод не определен, сейчас мы его тут вам определим, прям пока нас вызывают. То есть все такую фигню делать об obj.tfc очень просто. Соответственно всякую динамическую делегацию, поэтому на obj.tfc очень просто писать гуйню. Потому что делать биндинги к гуйне можно полуавтоматом, как это собственно в случае с настольными маковскими приложениями происходит. Но в случае с айфоном там меньше магии, потому что магия стоит на CPU. При этом... Да, к чему я тогда... Но при этом Swift сам по себе, ой, не Swift, а obj.tfc, при всей его гибкости он довольно... Со всеми недостатками C-шечки при этом. И Swift он вроде как чуть более безопасный, чуть более приятный, а также некоторые вещи, которые в obj.tfc приходится постоянно писать, в ними для этого сделан Sugar, если я правильно помню. Ой, не в ними, в Swift. В голове перепуталось уже. Неспроста перепуталось языки одинаковые. Извините, что я тебя перебью. Я тебе советую все-таки посмотреть на ним еще раз, потому что язык казался исключительно интересным. Мое субъективное мнение, что он на порядок лучше RUST, хотя бы по той причине, что он за меня в состоянии понять, что надо в стык положить, а что в кучу. Потом у него garbage collector он не то, что совсем не отключаемый, он идет в рантайме, я не уверен, можно ли сказать, собери мне программу без рантайма, но есть ручное управление памятью, если ты хочешь. Если ты хочешь без GC, ты делаешь без GC. Сам по себе GC при этом устроен очень похоже на то, как сделано в RUST. Во-первых, он с локальными кучами, и до релиза 1.0 они обещают сделать то, о чем ты всегда мечтал, это группы процессов с общей кучей. И... он умеет... то есть он на счетчиках ссылок, при том, как бы это называется, на отложенном подсчете ссылок. То есть немножко заоптимизированный. И он умеет находить циклы, он при компиляции определяет, что вот в этой структуре у тебя могут быть циклы в теории, и поэтому для него я еще специально буду обходить эти структуры, искать в них циклы. А так обычно он просто на счетчиках ссылок. На самом деле сделано очень интересно, по синтаксису действительно напоминает типизированный Python. Вот. И... Но он компилизован. Он интересно сделан, он, смотри, транслируется на выбор либо в C, либо в C++, либо в Objective-C, поэтому он работает под что угодно. И плюс у него есть транслейтер в JavaScript, прямо из коробки. Да, это сейчас модно. JavaScript. Я хочу обратить внимание, что язык создавался в году 2008. Тогда это было не так уж модно. У него, кстати, очень много библиотек. А кто за ним стоит? За ним стоит один чувак из сообщества, больше никого. Вот. Поэтому... Ну да, он не такой... не такой молодежный и популярный, потому что за ним не стоит классный Google, потому что за ним не стоит классная Mozilla, и поэтому о нем мало кто слышал. Но язык сделан очень хорошо. Я действительно всем советую на него внимательно посмотреть. Документация, кстати, как ни странно, вот этот чувак, Андреас... Андреас, забыл фамилию, Руфт или как-то так, он реально фигачит документацию на сайте. Можно прочитать все, как работает GCE, как потоки устроены, можно зайти в IRC и задавать вопросы. Тебе там очень быстро отвечают. Мне прям очень понравилось. И у них дофига всяких бизнесов. Есть, например, кмонг-тб, кпас-гре, кмоск. У них есть веб-фреймворк уже рабочий. В отличие от поделки Mozilla. У Mozilla есть рабочий врау-движок, в отличие от поделки кого-то. Они не пытаются сделать убийцу C++. Чувак делает просто хороший язык под многие задачи. Еще мне понравилось всякие бизнинги под OpenGL. Кстати, еще интересная тема. Я думаю, Валер, тебе понравится конкретно. Там есть некая система эффектов. Можно, например, сказать, что вот это процедура, но они там называют все процедурами, потому что функция там, то, что без побочных эффектов, ты можешь сказать, что кусочек кода гарантированно не имеет побочных эффектов. Или вот этот кусочек кода гарантированно никогда не бросает исключения. Или там бросает, но только такое-такое-такое-такое, а других никогда не бросает. И у тебя компилятор все это проверит. Ну, действительно, очень хорошо звучит, потому что я вот такие штуки люблю навестить на что-то, что вот эта херня, она никакой фигни не делает, кроме того, что там буквально написано. Вот, я бы на такое, да, такое я ценю, и может быть даже, да, ты возобновил мой интерес к этому языку. Я тебе очень советую посмотреть, язык очень хорошо действительно сделан. Когда я первый раз на него смотрел, там была какая-то статья на Хабре, типа, давайте мы там как-то круто чего-то там распараллелим, и как-то она плохое впечатление у меня языке создала, что это какой-то такой матан, когда там нужно там все там очень параллельно думать. Вот, да, совершенно обычный такой функциональный, оперативный, немножко объектный язык, при том в равной степени. Прям там, типа, 30 на 30. А, еще там есть, кстати, макросы, при том они там чуть ли не с namespaces, в отличие, опять же, от Rust. Слушай, Саша, у меня к тебе единственное вопрос. Ты недавно так реально говорил, что Rust никому не нужен, потому что, ну вот же, никто за ним, короче, нет. Никто же его, в общем, adoption'а ж пока еще никакого нет. А, ну, adoption'а еще меньше, а ты его вдруг рекламируешь. Чем он тебя так зацепил? Ну, во-первых, он действительно похож на нормально сделанный Rust, без вот этого, знаешь, программисту нужно обязательно там указывать, что вот это у меня счетчик с атомарными ссылками, это у меня ссылка с обычными счетчиками, и так далее. Ну, Саш, блин, ну вот мне лично это, наоборот, нравится, что я могу явно сказать, как вот этой штукой рулить памятью. Третье тысячелетие инкапсуляция? Не, не слышали. Вот, мне нравится... Ну, что это инкапсуляция? Ты можешь за Type-10 прекрасно жить с Type-F'ом? Это деталь реализации, то, как у меня устроена сборка мусора, она в языке торчит вот прям во все щели. Саш, ты когда куда-то передаешь что-то с каким-то типом сборки мусора, ты это просто передаешь, короче, типа как нечто, вот, что где-то в памяти там есть у тебя вариант ссылки, которая просто, ну, какая-то ссылка, где-то есть такая штука. Тебе нужно конкретно тип указывать, когда ты объект создаешь, либо когда ты хочешь его прям передвинуть в другое место, то есть ты указываешь явно тип ссылки в одном из двух случаев. Либо когда ты объект создаешь, либо когда ты хочешь принять объект конкретного типа, конкретного типа ссылки. Вот. А то, что ты говоришь, что, типа, нарушается инкапсуляция, это неправда. В какой-то момент, может быть, так было, но в реализованном языке это не так. Ты просто говоришь, что вот здесь я хочу борову сделать на какой угодно тип ссылки, и неважно, что там за тип. Я предлагаю заодно поднять еще одну тему, которая есть в темах слушателей, но она прям подходит. То, что ребята в Rust решили что-то там поменять у себя в реализации этого RCTrata. Правильно? RCTrata? Нет, там не RCTrata, там не RCTrata. ARK и Ebox. Слушай, если это та ссылка, про которую ты говорил, то там дело совершенно в другом. Там дело в том, как... Давай для слушателей поясним, что речь идет о том, что ребята в Rust хотят чего-то там сломать, какую-то обратную цель. Давай попробую объяснить. У них есть вывод... Как называется это по-русски? Короче, вот эти вот скопы, которые у них есть именованные или неименованные, неважно. Области жизни, в смысле, время жизни? Там же есть вывод этих скопов, и для некоторых ситуаций вывод скопов работает вполне определенным образом, но то, как они его сделали, это, оказывается, для людей неочевидно. И, в общем, они решили поменять его на более очевидный вариант, который люди чаще подразумевают, когда они явно неименуют скоп, как они на самом деле, скорее всего, подразумевают, что на самом деле код должен делать. И это не имеет никакого отношения непосредственно к RCTrata или к какому-то указателю. Просто в самом верхнем посте Россия, как пример, пробегает, неважно, что там будет на самом деле Россия или не Россия. Во-первых, это не то, что мы пойдем ломать, это реквест в комменты, типа, ребята, есть такая проблема, что мы с ней делаем? Вот таким вот вариантом мы это можем сломать. Никто еще не побежал начал ломать, это во-первых. Во-вторых, прежде чем вообще это предложить, ребята, во-первых, проверили, не ломает ли это ничего на крейдс, но крейдс не ломает вообще ничего. Крейдс, что, система пакетов местная? Ну, ты имеешь в виду, что она компилируется. Да, то есть как бы все совершенно компилируется и ничего не ломается. А не факт, что она при этом работает. В смысле? Это чисто смена семантики проверки кое-чего компилятором, оно никак не может влиять на работоспособность. Грубо говоря, тип поменялся у некоторых переменных. Притом, это никак не влияет на ронтайм. Во-вторых, я бы хотел договорить, в-третьих, там предложение такое, что давайте сделаем не breaking change, а опцию, которую ты прописываешь к компилятору. И если ты ее прописал, у тебя будет новое поведение. И там еще предложили вариант пограничный, мы вводим breaking change, потому что он все равно, у нас нет примеров кода, который бы этот breaking change хоть куда-нибудь сломал. Но если это вдруг для кого-то что-то ломает, у нас будет флаг, ты его ставишь, и у тебя получается старое поведение, и у тебя ничего не ломается. Так что это... Я хотел всего лишь сказать, что в языках вроде NIM или SWFTA такой проблемы не будет вообще в принципе, потому что то, как у тебя там ссылки, счетчики, боксы, ну, неважно на самом деле что, у тебя есть просто семантика языка, вот просто переменные, и ты просто им значение присваиваешь. У тебя в принципе проблем возникнуть не может. Саша, дело не в боксах, не в счетчиках ссылок, ты вот missing the whole point. Там вопрос о выводе области видимости, то есть, грубо говоря, управления тем, когда у тебя объекты лежат положенные на стеке, нужно выкидывать. То есть проблема в том, где лежат переменные, о том, что об этом знает программист, но проблема не в том, что у тебя инкапсуляции нет. Саша, блин, ты вот опять missing the whole point. Речь идет не о том, где лежат переменные, а о том, когда у тебя заканчивается скоуп. Тебе не важно, где он у тебя лежит, у тебя область видимости и размещение переменной это два совершенно несвязанных аспекта. Изменение касается области видимости. Даже не области видимости, а вывода области времени жизни. Это не имеет никакого отношения к деле лежит объект. Ну, хорошо, допустим. Во-вторых, ты обращал внимание, что вот в предыдущем выпуске мы все вместе так дружно гнобим Python 3, и D2, а вот сейчас ты так защищаешь, раз что они молодцы, что ломают обратно совещание. Нет, я не защищаю, раз ни в коем случае. Я за тот вариант, когда они дают опцию, ты ставишь в компилятор флажок, включается новое поведение. Я вот за такой вариант разрешения проблемы. Но я не знаю, как они это в итоге сделают. Я не читал thread сегодня, thread читал вчера. Может быть, за сегодня еще каких-то комментов появилось, но вчера это было еще совершенно не определено, что они с этим будут делать. Ну и все-таки хочу заметить, что Python, они сделали breaking change, и этот breaking change реально ломает код. А здесь ребята проверили почти весь известный open source, который позаботился о том, чтобы оказаться на крыльце. А, да мне в моем закрытом проекте это очень удобно, конечно. И при этом предлагают флаг, который тебе в твой закрытый проект вообще нет. То есть это не так, что у тебя будет полностью несовместимо. Если у тебя есть какая-то несовместимость, ты включаешь флажок, и у тебя все совместимо. Либо наоборот, ты включаешь флажок, у тебя несовместимо, а без флажка совместимо. С третьим Python здесь сложно сравнивать. Поглядим, как выйдет 1.2.0, и там посмотрим, что они сделают. Я бы тоже с этим скорее сравнивал. То есть, сравнивать тяжело. У тебя Python 3 ломает полностью все. Но в смысле я имею в виду, они меняют концепцию очень сильно. А здесь это поменяли чуть-чуть, которое ничего не ломает, даже в библиотеках своих же. Ну хорошо. Я напоминаю, что предыдущий вопрос у Валеры был, о чем мне так сильно нравится ним по сравнению с Rust. Еще он мне нравится тем, что там, например, есть нормальные человеческие исключения. Для меня это важно. Ну не знаю. Вот мне как раз нравится подход Rust, потому что, как правило, с меня вылетело исключение. Мне в том же треке вообще его обрабатывать не очень хочется. Мне нужно где-то повесить обработчика. Меня вполне устраивает, что там весь тот трек, в котором что-то так поломалось, отстрелится. Во-вторых, в Rust там же нужно вспомнить, что там нормальные алгебрические типы, когда есть нормальные алгебрические типы, тебе обрабатывать ошибки просто на месте. Гораздо проще. Потому что ты можешь просто нормальный кейс написать, который при этом будет еще проверить. Который компилятор же за тебя проверит, ты обработал вот там ту ошибку, которая из него могла вывалиться или нет. Тот факт, что у тебя основной код с кодом, обрабатывающим их включение смешивается, тебя не смущает? Не смущает, потому что там для этого есть как это... Подпорочка. Скорее библиотечный сахар, который... Маленький коктырек. Ну блин, Свет, ты Rust вообще в глаза видела? Да, видела. Ну вот ты конкретно то, о чем мы сейчас говорим, видела, как это выглядит, этот паттерн использования и обработки ошибок? Я видела, я смотрела на обработку ошибок Rust. Ну я бы не сказал, что это выглядит как костылек, это выглядит как нормальное решение в статическом языке. Они только для этого макросовый язык добавили. Только для этого. Ну не только для этого, если Саша... Целые макросы! Саша, макросы там были с момента появления языка. Ну понятно, для чего. Тогда вы языкоконцепция была еще другая, вообще-то. Не знаю, я вообще против глубокого использования исключений, я здесь больше с Валерой согласен. Когда у тебя есть хорошие алгебрические языки, поддержка в компиляторе, алгебрические типы, тебе в принципе глубоко использовать исключения полностью во всем коде смысла не имеет. Ваня, толкни-ка следующую тему, связанную. Да, давайте бампнем эту тему. Это пост на... Как его зовут-то, я забыл. Eao197. Евгений Охотников. Вот видишь, как здорово. Я навсегда запомнил, потому что я два года думал, что это просто какая-то тарабарщина, потом я понял, что... Для меня это до сих пор тарабарщина. А почему стоп? Японское имя из аниме. А потом я понял, что это обычное имя, просто написанное в белорусской транскрипции. И я смог ее прочитать, не знаю как. Просто я как-то с похмелья зашел к нему на сайт, и у меня в голове буквы сложились. Я сразу понял, что он Eao197. А вот что он Охотников, вот это для меня пока ты не сказал, я не мог понять, что это Охотников. Может, это его отчество? Ну, неважно. Я еще могу прочитать это, когда это написано кириллицей. То есть, вот этот белорусский вариант произношения имени, я еще могу прочитать, когда он написан кириллицей. Но когда он еще латиницей написан, то есть, ну... Eo1n я все-таки понял, но вот как я уже сказал, фамилию вообще не могу проспраствовать. На белорусском это звучит вообще по-другому. Eo1n. Eo1n? Eo1n, да. Так что должно быть первым вообще. А почему не читается И? Ну, Eo1n на белорусском. Все, понял. Давайте к себе. Так подожди, а Су-97, то есть последний, это по идее дата... Ну, год рождения должен быть? Обрезанный год рождения. Это он как раз вот из тех, кто про загадку, у него в минус сначала шло. Автор рассказывает про то, что exception это добро, и нужно всегда использовать exception, где это удобно. И правда, он не так рассказывает. Ну, я упрощаю. Могу я с тобой не согласиться? Конечно. В статье, которую я читал, говорится примерно следующее. Что исключение это очень хорошо, и надо всегда их использовать. Коды возврата. Это очень хорошо, и надо всегда их использовать. Что не надо делать, это использовать их одновременно. Когда у тебя есть библиотечка одна, которая делает так, а есть другая библиотечка, которая делает иначе, и ты их начинаешь вместе использовать, вот тогда у тебя геморрой. Одновременно при этом он говорит, что если у вас есть выбор использовать то или это, всегда используйте exception. Да, он такое говорит. Поэтому я однозначно делаю вывод, что он за exception, это добро, и это надо всегда использовать. Ну, я в принципе согласен. По простой причине, что как Валера предлагает, типа, давайте все явно проверять, это хорошо, окей, в Rust это подперли. Но в общем случае у тебя получается такой лапшекод, что типа, а если ошибка сделать одну, иначе вызвать другую функцию, проверить нетляжа. В общем случае на языке, которому 40 лет ты имеешь EDC, да? Да на любом языке, где нету подпорки, видите, вот у Макроса. И где нет подпорки, где Макроса. Но там, правда, мне больше нравится подход в Erlang, там где тебе надо, чтобы оно упало, потому что ты считаешь, что оно здесь падать не должно, и здесь ошибка обрабатывать не стоит, кроме тех случаев, когда там совсем какая-то фигня полная. Ты просто прям мачешь результат, и считаешь, что здесь... И получается вызов функции. Я вам расскажу историю. Историю про то, с чем мы столкнулись. То есть в скале есть такая штука, называется DisUnce, а, Eizer. И ты можешь передать два типа, либо этот, либо это. Есть два типа, когда есть два стула. И ты можешь отвечать от функции либо одно, либо второе. Поэтому в принципе это хорошо ложится на идею, о том, что давайте мы не будем использовать exceptions, и давайте-ка мы будем... Left значит, что-то пошло не так, right значит, все окей. И в left мы сделаем свой тип, в котором будет код ошибки каким-то образом зашифрован, какая-то еще строка, допустим, поясняющая, ну еще что-нибудь. Вот. И была такая идея, давайте делаем такой проект, и проект такой работает, и у нас действительно нет никаких exceptions, кроме тех, которые там, например, какие-то левые библиотеки выбрасывают, но мы их опять же оборачиваем своим результатами. Вот. И потом пришло какое-то время, когда захотелось сюда добавить, ну надо было добавлять асинхронность, и все это делалось на фьючах. Но фишка в том, что во фьючах есть встроенные механизмы, когда ты их фейлишь, например, то есть ты говоришь, что... Да, там exceptions. Да, там оно построено на throwable, то есть даже не на exception, а на высшем интерфейсе. И поэтому вот эта вся красивая иерархия из вот этих наших типов, и там действительно было красиво, оно очень хорошо читаемый был код, очень понятный, но как только появилась вот эта история с фьючами, оно всю эту концепцию очень сильно надломило. И был такой большой долгий разговор, давайте-ка мы переделаем все на exceptions, и уйдем от того, что у нас было с возвращаемым типом either. В итоге была ветка сделана с таким рефакторингом, и поняли, что это, скажем, того не стоит, и решили оставить как есть. Но так или иначе просто появились преобразования в коде, то что если у нас то-то, то-то, то мы действительно фейлим в фьючу, потому что по-другому, оно у тебя не зафейлится автоматически, ты же возвращаешь нормальное значение, не exception у тебя вылетает. И этот момент нужно учитывать. То, что было на практике. Сказал момент, я недавно с тем же шамом столкнулся, когда месяца два назад писал вундеркал свой, я столкнулся с примерно тем же самым, я честно очень люблю option и either, особенно в коде, который не имеет никакого отношения с вводом-выводом. Просто есть вход, есть выход, в таком случае я exception пользовать вообще никогда не буду. И у меня была более-менее чистая функция, которая что-то переваривала, дальше мне надо было ее ввести в фьючу. Я попытался понять, как мне так сделать, чтобы фьюча сломалась, или как мне так сделать, чтобы ловить сломавшуюся фьючу. Я понял, что на самом деле все сделал на exception, я смирился, что если какая-то синхроничная или побольше эффекты, то в скале принято бросать exception, но в общем, я примерно на том и остановился, что если код с эффектами, то принято бросать, если код чистый, то принято возвращать exception или either. Ну или возьми те же актеры, они же построены на том, что ты бросаешь exception, и в зависимости от типа exception, ты решаешь, что с этим актером делать, убивать его, перестартовать или что-нибудь еще. И есть нюанс, хотя мне лично очень нравится вариант с either и option, я тоже фанат вот этих типов, это замечательно, с этим очень приятно работать, хотя не все, скажем, мои коллеги это выбирают, и много вопросов возникает на этот счет. Мне вообще чем это нравится? Чем мне очень нравятся такие типы? Что вот когда ты его видишь, ты видишь функцию, которая возвращает option, например, ты совершенно точно понимаешь, как она работает, то есть ты точно понимаешь, что она должна возвращать либо вот это, либо говорить, что ой, не ж могла. Это прекрасно. Да, ты смотришь на тип и видишь, что у тебя, что там происходит. Но понимаешь, есть еще момент, когда у тебя, например, твой either, он может быть либо ошибкой, либо каким-то валидным случаем, но в валидный случае у тебя может быть option, и получается такая, знаешь, вложенность. Несколько уровней. И тоже не всем это нравится. Я недавно с таким сталкивался кейсом. Вот расскажи свою историю. Коллега у меня спросил, почему я написал функцию, которая возвращает optional, но также может еще и бросать исключение. Там была ситуация следующая, что у тебя в CouchBase есть некие сериализованные данные в JSON. И кейс примерно такой, что ты кладешь данные, точнее не так, ну вот у тебя есть какой-то кейс-класс, ты его сериализуешь, на выходе у тебя строка, кладешь в CouchBase. Потом возвращаешь за этими данными, считываешь из CouchBase, у тебя строка, и на выходе нужно получить структуру. В этой структуре, ну как бы в кейс-классе, который ты децерализуешь, там одно из полей, она optional string. И у тебя есть метод, который, ну, хелпер небольшой, типа, вот возьми AST JSON, который ты получил, и достань из него по такому-то пути по такому-то пути optional от стринга, да? Типа называется метод optStringFromJSON. Как-то так. И действительно получается странная ситуация, что с одной стороны ты должен достать optional от стринга, с другой стороны, а что если его там нет? Тогда получается, тебе нужно возвращать optional от optional от стринга. Но что означает, если ты вернул такой None в этом случае? Это означает, что ты сериализовал данные в CouchBase, потом вернулся за ними, достал данные из CouchBase, а у тебя там не нул, не строка, а какой-то другой объект по ключу лежит, или какая-то чиселка, да? И в этом случае это явно означает, что что-то пошло очень сильно не так. Ты там сделал опечатку в ключах, еще что-то такое. И в таком случае действительно бросается исключение у нас в проекте. Ну не знаю, я бы сделал как раз вот either с optional. А понимаешь, у тебя исключительная ситуация. У тебя произошло что-то, что никогда не должно происходить. Это исключение. Это как бы... Не для этого и сделано. У тебя должно все разорвать, актеры должны рестартануться, в логе должны быть брошены стектрейсы. Это что-то, что никогда не должно происходить. Саша, а поможет ли тебе вообще рестарт актера в такой ситуации? Ну вот хорошо, актер у тебя свалился, но снова запустился. И что? Ну разумеется, рестарт наверное не очень сильно поможет, вот конкретно в этом случае. Но идея в том, что ты не можешь корректно обработать эту ситуацию. Я не могу проверить, что если мне пришел нан, то там сделай какое-то умное действие. Понимаешь? Нет, такие вещи нужно просто писать в логе, и ты видишь на какой-то своем дашборде, а вот у меня пошли какие-то красные логи, ну-ка посмотрим, что-то не так. И у тебя, допустим, таких логов стало много, тебе пришло уведомление, там чего-нибудь, дата дога, не важно. И ты на телефон это смотришь, ага, вот тебе там логи сыпется, вот такая эта штука, надо бы пофиксить. А именно это и произойдет. Мне кажется, Геннадий просил слово, но мы его как-то... Да, Геннадий, мы... Подождите, а мы с статьей-то, может быть, закончим сперва? То есть, я... Вы все читали статью? Мне казалось, Геннадий просил слово в этом контексте. А в этом контексте? Склиниться сложновато. Давай, давай. Ты нас не бойся, перебивай. Я просто хотел сказать, что ключевое слово тут принято, как мне кажется. То есть, всё очень сильно еще зависит от каких-то командных и субъективных взглядов на исключение коды возврата. Я присоединюсь еще к экосистемным взглядам. То есть, как Света привела, пример с Искалой и Аккой. Да. То есть, например, в Питоне, при том, что я не любитель, на самом деле, исключений, то есть, я любитель чистых функций, алгебраических типов, но в Питоне принято всё решать исключениями. Даже окончание итерации. Если есть генератор, окончание итерации решается специальным исключением Stop Iteration. То есть, это на самом деле не исключение, это штатная ситуация. Но тем не менее, вверх по стэктрейсу это идет именно в качестве исключения. Да, вот такие вот чудеса. Ну и, как принято в C++, кто у нас специалист по плюсам? Нет? Саша. Саша специалист по плюсам. Мне кажется, из того, что на C начинается, ты у нас самый большой специалист. Я на C, я на плюсах мало работал. Я только компилировал эти плюсы. Но в целом, я вот глядя на... Евгений у нас самый большой специалист. В Гугле исключения не разрешаются. Это я слышал на эту тему. Просто глядя на этот код, я понимаю, что это просто привычка человека писать в таком виде. То есть, глядя на вот этот код с исключениями, которые написал автор, я не считаю, что он сильнее, читабельнее того, что в комментариях ему там написали, что нужно сделать фактически FSM. У него там есть переход от одного стейта к следующему стейту с выбрасыванием того стейта, на котором мы поломались, а потом ты с этого стейта откатываешься назад. То есть, можно сделать одно и то же очень разными вещами. И это просто дело привычки, как ты организуешь код для того, чтобы сделать одно и то же. Слушай, вот честно, я когда посмотрел на этот код, мне захотелось заплакать, куда-нибудь забиться и чем-нибудь накрыться во много-много слоев, потому что не быть у меня программистом на C++ это точно? Это точно, я согласен. Да, кстати, тоже ощущение было. Вот я понимаю людей, которые говорят, что надо писать на C, а вот там кусочек из C++ используют только от очень-очень большого горя. Ну, оно, кстати, очень сложно читается. И так вот, ну... А я думаю, что автор был бы с вами не согласен. Да? Он бы увидел код скалы и заплакал. Или на Erlang, скажем. Нет, может, действительно, это просто дело привычки, и глаз наметан. Как люди на клоуже пишут, у них автоматические скобочки парсятся. От кода на Rust мне точно так же хочется плакать, как от кода на C++, потому что там вот постоянно эти запятые, точки запятой, прям хуже Erlang. И вот эти угловые скобки с областью видимости жизни там очень тяжело. Пока ты не понимаешь, как его парсить глазами, пока ты не привык это делать, это реально тяжело. Это не в плане набросить. Я возвращаюсь к вопросу, чем мне так нравится NIM. Потому что реально на язык хоть похож. Саша, вот как ты можешь сравнивать NIM, у которого обязательно горочеколлектор, а у Rust, у которого нет его? Мы же каждый день операционные системы пишем. Я не к этому. Я к тому, что ты, если сравниваешь, сравнивай одинаково. Сравнивай с Python. И у тебя получится одно и то же. Но это, блин, это всё равно, что с ассемблером воспраздновать. А знаешь, на ассемблере код сложнее выглядит. Да, реально сложнее. Там приходится с регистрами работать. Вообще-то на ассемблере код намного проще, чем на Rust, по моему мнению. А я на ассемблере много писал. Точно нет. На ассемблере код действительно простой. Ты понимаешь из этого кода, что там действительно происходит, скажем, глобально. Это сложно. Смотря как напишешь. Нет, ты никак не сможешь написать, чтобы у тебя... Обычно очень тяжело понимать глобальную картину. То есть у тебя очень такая... Низкого уровня. Да, большая такая полоса кода. И ты вот здесь хорошо... Вот здесь у меня границы вот этого. Потом мы вот это делаем. Вот этого мне сильно не хватало, когда писал на ассемблере. Ты фолдер сделай там на ассемблере. Кто же делает фолдер? Нет, тоже процедурный. Знаешь, мне кажется, нужно на код лева посмотреть. Мне кажется, лев периодически пишет в C-фолдере. Я ведь прав, Ваня, да? Мне кажется, он их тут даже... Он старше. Ну, короче, такой же процедурный код, как на C. То есть в каких-то задачах даже удобнее писать на ассемблере, потому что у тебя там не нужно типы приводить. Ну-ка, оставайся в мыслях. Кстати, возвращаясь к C, у нас там есть тема. Может быть, поднимем ее. Это... Есть такое, оказывается, соревнование. Я совершенно случайно наткнулся. Проводится раз в год на тему «Давайте мы спрячем уязвимость в C-коде, чтобы он выглядел при этом максимально приятно. И кто сделает это максимально невинно и максимально незаметно, при этом уязвимость позволит вытаскивать данные, портить спектр или еще что-нибудь типа такого, тот и победил». Вы не сталкивались с этим? Нет, я с такой не сталкивалась. Я напомнила одну лабораторную работу в университете. У нас, мне кажется, задача была... Мы тогда как раз на ассемблере писали, и это была последняя лаба. То есть, ты скомпилировал свою программу, потом ты можешь ее прогнать через декомпилятор и увидеть все, вот все, что у тебя хранится. То есть мы использовали IDA IDA Pro, по-моему, так она называлась. И задача была следующая. Давайте-ка сделать такую программу, чтобы вот она просит на вход какой-то пароль. И преподаватель должен ввести правильный пароль. Вы даете ему ваш экзешник, и он этот экзешник пропускает через декомпилятор и из вот этого всего пытается понять, какой у вас пароль. Если он понял, то лаба вы не сдали. Не понял, значит лаба вы сдали. Слушай, шикарно, почему у нас таких не было? Вот такая была история. Я помню, это действительно очень интересная задача. Потому что, по сути, ты декомпилировал, ты видишь все. Если ты просто там где-то будешь напрямую сравнивать, то это все будет заметно, мгновенно все увидишь. И вот, хорошая тема. А здесь тема была следующая. У вас есть социальный сервис PiuPiu, который работает с маленькими сообщениями 140 символов. И вам необходимо каким-то образом их то ли прочитать, то ли попортить предыдущие, каким-то образом поменять предыдущий поток. И при этом нужно сделать какую-то очевидную функцию вида. То ли логи написать, то ли посмотреть. В общем, какую-то простейшую вещь. И разбирается толпа решений, вида самых простых. Когда вы начинаете работать с указателями и разыменованием указателей занимаетесь, хотя в этом месте нельзя его делать. Которые находятся сразу, их взгляд легко цепляется. И заканчивая совершенно неочевидными вещами, когда люди специально форматированием например, одно из решений надо сравнить округление. Там делается меньше 500, больше 500. Но там 500 тысяч. И когда ты делаешь их, сдвигаешь строчки друг от относительно друга, то 500 тысяч и 5 миллионов выглядят достаточно похоже. Куча ноликов и так далее. И с помощью этого они достигали то, что в одном месте можно было залезть в память. Очень хитро, очень интересно посмотреть. Я рекомендую. Все. Давайте дальше. Давайте мы сейчас дадим слово гостю. Потому что мы его так прервали. Может, после рекламы? Реклама. Да, реклама на нашем канале. Хочет рассказать про замечательную вещь. Это конференция. Конференция happydev.ru Она приглашает докладчиков. Если вы имеете солидный опыт в разработке, тестировании или сопровождении проектов, готовы не только рассказать доклад, но и провести мастер-класс по технологии или методологии, то мы будем рады видеть вас 5-6 декабря 2015 года на базе отдыха имени Стрельникова недалеко от Омска. Бывалые докладчики знают, что именно для них пользуют конференции максимально. Приезжай, заведись, получи новый опыт. happydev.ru Действительно полезная конференция. И слово гости? Гость, да. Я только... Мне одному всегда слышится, что проходит это в Томске. Омск. Недалеко от Омска, да. А так-то когда далеко, друг дружка. То есть, дорогие слушатели, это Омск, не Томск. Надо там исправить. Писать, что возле Омска. Следующая тема связана с Питоном. Это редкий гость в этом подкасте. На самом деле, касаясь предыдущего разговора, Питон отличается... У него есть огромное количество минусов, как и у всего в мире. Но есть огромный плюс, он очень читаем. То есть, многие люди, которые переходят с других языков, удивляются именно читаемости Питона. Тому, как быстро можно понять, что же там написано. Следующая наша тема связана с выходом Питона 3.5. А именно его второй беты. В общем-то, обычный релиз, но в нем добавили аннотации типов, вписанные в язык. Теперь можно писать на Питоне с проверкой типов. Причем, там есть генерики, там есть алгебраические типы. В каком-то роде. Так сказать, юнумерейшены. Ну и, соответственно, кроме того, это gradual typing. То есть, можно запустить туда свою программу в таком виде, в каком она есть. И он уже что-то может найти. То есть, скоро можно будет писать на Питоне с полной аннотацией типов. Но есть проблема, как всегда, ложка дегтя. А именно то, что это Питон 3.5. Например, у нас на работе используется Питон 2. И переходить на Питон 3 в общем-то, пока что никак не собираются. А большая кодовая база? Да, достаточно. Особенно болезненным может быть переход биоинформатического кода. Потому что многие тулзы не обновлены на Питон 3. Именно связанные с тем, как обрабатывать специфические форматы файлов. Я не знаю, какие-нибудь есть файлы мутации, варианты и так далее. Они обрабатываются программами, которые на самом деле поддерживаются, но очень редко. То есть, все они работают под Питон 2. То есть, куча устаревшего кода, который никто уже не поддерживает, и оно как работает, так работает. Да, да. Теоретически вообще можно писать в таком стиле, чтобы код работал и в Питоне 2, и в Питоне 3. Для этого даже есть специальная библиотека совместимости, которая позволяет это делать. Но, естественно, все эти библиотеки написаны не в таком стиле. Ну, то есть, большие фрейморки, вроде, я не знаю, Джанго или Фласка, они написаны в таком стиле, что можно использовать любую версию Питона. То есть, вот. Но они целенаправленно это делают. Они целенаправленно это делают. Это совсем другое дело. У них там в Питон 3.5, я заметил, есть опшнл. Мне прям так захотелось на Питоне пописать. У меня два вопроса, Геннадий. Во-первых, очевидно, можно весь этот код, который больше никто не поддерживает и не меняет, вернуть в докер. Докер, докер. Докер, докер, докер. А во-вторых, мне казалось, в Питоне есть какая-то утилита, которая там чуть ли не транслирует Питон 2 в Питон 3, или как-то так. Да, это утилита есть, но она несовершенна. Без ручного, так сказать, без ручной обработки не обойтись. Кроме того, по поводу докера, есть еще такая вещь, что у нас сфера связанная с медициной. И у нее есть один такой громадный недостаток, связанный с тем, что она очень консервативна. То есть, протащить докер, это уже дело, я думаю, уже полгода. Вот мы с моим коллегой Алексеем бьемся на этот счет. Вот. И если используется какая-то технология, она должна быть включена в специальные документы и каким-то особым образом проверена. Так как у нас наша программа сертифицирована как медицинское устройство, если там используется какое-то так сказать, третье стороннее ПО, то это все должно быть специальным образом проверено. Вот. Питон, как ни странно, таким образом проверен. А введение докера затягивается. Хотя эта идея, она уже витает в воздухе некоторое время. Ну а чем докер-то поможет? Ну, завернулся вторым питоном и забыл. Не, ну ты завернул библиотеки, а тебе развивать надо свое же. А, я так понял, там целый проект, который можно завернуть, нет? Да, там монолит, к сожалению. Ну вот, проект завернул. Как раз, ну, к сожалению, тут такой момент, что этот проект тесно связан между собой. То есть, вот, отвязать вот эту часть кода, которая требует питона второго, тоже требует каких-то усилий. Но, в общем-то, к этому все и идет. То есть, мы одновременно пытаемся отвязать этот код, соответственно, сделать модную нынче вещь, а именно микросервис, который будет работать на питоне втором, соответственно, инкапсулирован в каком-то роде, а все остальное перенести на питон третий. Но, опять-таки, все достаточно консервативно и неизвестно, когда до этого дойдет. Вот. Я хочу поделиться такой небольшой... Извини, что перебиваю. Хочу поделиться такой небольшой историей. Не знаю, у вас, наверное, не так, но чем в таких ситуациях может помочь, например, докер? Ну, или, на самом деле, любая контейнеризация, какая только есть. Вот, жила, была инсталляция, там, субунту 1204, например. И в ней жила, была версия Redis и версия Rubik, которые там, как бы, каким-то образом были поставлены. Прекрасно, вот, они из РВМ или из че... Откуда бы, откуда-нибудь, откуда-нибудь, откуда-нибудь, откуда-нибудь, еще бы не было. Прекрасно доставились. И если машину нужно было перенакатывать, ну, там, все прекрасно сделалось с той же версией Buntu. С теми же версиями софта, потому что они на ту версию Buntu прекрасно заводятся. Потом хостер перестал давать такие тачки, железные. И стал давать более новые тачки, железные. Эти более новые железные тачки у Buntu 1204 не встает никак. Она даже не грузится. Инсталлятор не грузится. Вот. И тогда мне пришлось накатить 1404. Проблема в том, что в 1404 есть проблема поставить ровно такую же версию Redis и Rubik. Ну, дальше вы поняли. Будь это все в контейнере, этих проблем не было бы. Да. Значит, надо контейнеризовать. Вы в итоге контейнеризовали? Нет. Мы в итоге вывернулись так, что мы нашли 2 версии версии. Два варианта сочетания версий. Один, который мы используем на более старом стеке, и другой, который мы используем на более новом стеке. У нас нет чего такого, чтобы это ломалось. Просто сам факт того, что будь оно уже контейнеризовано, проблем не было бы вообще. Понятно. В нашем случае контейнеризовать было дороже, чем просто подходящую версию найти для новой операционки. Докер, оборачиваем Легасе говнокод в уютники и песочницы с 2013 года? Йеп! На самом деле LXC. Оборачиваем уютники говнокод с 2008 года. Нет, я его видел там с 2010 года. Оборачиваем говнокод с 2010 года. Значит, если речь зашла о говнокоде, то переходим к следующей теме. Значит, это in-memory базы данных, а именно... Гигантский переход! Врача этому господину! А именно база данных с Сапхана. Недавно мне посчастливилось с ней пообщаться. Значит, это такая база данных. Она работает, она достаточно быстро, она column-based. Она полностью все держит в памяти, поддерживает... Подожди, что за бред? Колумб-бейст в памяти? Колумб-бейст, насколько я понимаю, это как-то компромизировать базу данных, чтобы она так эффективно и компактненько помещалась на диске, чтобы твои прекрасные ALAP-запросы... Но вольтдб — это тоже колумб-бейст, тоже в памяти. Я тоже не понимаю, что тебя смущает, но у тебя одно дело — модель данных, а другое дело, где ты их хранишь. Вольтдб — колумб-бейст. Вольтдб — она для ЛТП. Ты путаешь одно с другим. Ты, может быть, с вертикой путаешь, Ваня? Нет, нет. Вольтдб — он точно такой же колумб-бейст. Он оптимизирован для всего, но в том числе и поколонночный он хранит. Не можно хранить поколонночный, он тебя не будет тогда... У тебя при поколонночном хранении все упало сразу. Я вот пошел проверять. Давайте дальше обсуждайте. Нет, подожди, у меня вопрос. Колумб-бейст, не колумб-бейст — это как бы модель данных. А где ты ее хранишь, в памяти или на диске, это ортогональная вещь. Объясни, Вальдер, что тебя смущает. Модель данных тут ни при чем. Колумб-бейст или не колумб-бейст — это как раз способ хранения данных у тебя на сторидже. Оно у тебя к семантике и тому, как ты эти данные запрашиваешь, не имеет никакого отношения. То есть SQL-запрос будет абсолютно одинаково выглядеть, что к MySQL, что к какой-нибудь колонночной базе данных. Этот запрос потом исполнит. Идея колумб-бейст в том, что у тебя действительно какая-то аналитика, у тебя очень много очень похожих значений, которые скорее всего в одной колонке, больше у тебя бывают колонки, в которых, не знаю, 50 раз вот это значение, потом 100-500 раз вот это значение, потом еще раз 50 раз другое значение. Мне кажется, если я не прав, и извини, что я перебиваю, что SQL — это еще одна ортогональная вещь, которая колумб-бейст, которая способа хранения. Потому что колумб-бейст, это что означает? Я так проще об этом думаю, что у тебя есть какой-то primary key, и по нему хранится хэш-табличка. Вот и все. А там поверх этого SQL накручен не SQL, это совсем не факт. — Но это не то, что называется колумб-бейст. — Я напомню тебе, что на что Cassandra является колумб-бейст, и в первых версиях там никакого SQL не было. — А Cassandra — это вообще не колумб-бейст. — А колумб-бейст. — Блин, там колумб-фемилис. Блин, колумб-фемилис Cassandra и колумб-бейст RSUBD — это вообще две разные области, которым повезло называться похоже. — А в чем разница? — Они имплементированы по-разному, это разный... Ты знаешь, как consistency-evasive и consistency-evap. Это просто одно и то же слово, которое означает разные вещи, пришло из разных областей. — То есть давай проясним ситуацию. У нас есть два каких-то свойства базы данных, об колумб-чего-то там, и они означают чего-то совсем разное. — Да-да-да. — Объясни тогда, в чем разница? — Смотри, была такая база данных Bigtable у Гугла. Они придумали, что у них по одному ключу в хэштаблице колонок может быть до жопы. И называли это семейство колонок — колумб-фемилис. Это вот колумб-фемилис Cassandra. А есть колумб-бейст — это когда у тебя обычная таблица с фиксированной схемой, которая кверится обычным SQL или каким-то твоим любимым революционным алгебритом. Запрашивай, не важно. У тебя есть революционная таблица, а данные совершенно обычные революционные. Эту модель данных можно оптимизировать для OLTP. Когда у тебя хранится каждая строка, у тебя хранится как можно плотнее. Потому что, как правило, ты обращаешься к строкам сразу. Ты меняешь сразу целиком строку. А бывает так, что тебе, наоборот, нужно писать, писать, писать. Ты почти никогда, скажем так, ты почти никогда данные не апдейтишь. Ты почти всегда просто дописываешь в конец какую-то новую информацию. А потом ты делаешь какие-то запросы, которые чуть ли не по всем данным шарашат. Типичные для аналитики. То есть для OLAP. И вот такие штуки... Такие штуки, они типичны для... Как раз они не уверены точно, как это работает. Но суть в том, что там существенно отличается имплементация. У тебя хранится как бы... У тебя не так, чтобы максимально плотно одна колонка лежала. Ой, одна строка лежала. А, наоборот, чтобы у тебя максимально плотно одна колонка лежала. У тебя вот идёт немножко наоборот. У тебя есть, например, таблица. В каждой записи есть какая-то колонка. И вот эта вся колонка для каждой записи, она хранится отдельным блоком. И поэтому для аналитики тебе ты очень быстро вычитываешь всё, что касается этой колонки для разных записей. И быстро строишь аналитические запросы. Они действительно летают просто. А модель данных здесь вообще не при чём. Модель данных при этом получается обычная революционная. А, я такой глупый. Ну, собственно, такая же идея в паркетформате файлов. За счёт чего получается огромное ускорение. Такая же история. Просто я сейчас как раз именно с этим работаю, в частности с вертикой. Я отгребаю по радости, потому что с этим мало кто работает. И когда гуглишь и видишь один запрос, точнее один ответ в гугле, становится так грустно. Добро пожаловать в клуб. Я правда не с улапом трахался. Бывают такие ситуации. В общем, добро пожаловать в клуб в ситуации, когда не можешь найти ответы в гугле. Геннадий, так что там? Вот сапхана как раз это и есть такая ситуация. Документации минимум, но очень много маркетинга. Первые, я думаю, пять страниц в гугле это маркетинг по любому запросу. Фактически. Соответственно, сама база данных достаточно сырая, как мне показалось. При этом САП ее очень активно проталкивает. То есть любая возможность использовать, если какая-то фирма может использовать хоть каким-то боком сапхану, они ее предлагают всеми доступными методами. Примерно так. Поэтому говорю слушателям, если кто-то сейчас хочет, думает о том, чтобы использовать ее, не используйте. Она очень сырая. Кроме того, корпорация САП это очень странная фирма. Может быть, я как фрилансер мало работал с корпорациями, но она окружена каким-то, можно сказать, странным духом бюрократии и интерпрайза. То есть даже зарепортить баг сапхану оказалось очень непростым квестом, который мне пришлось проходить через нашего финансового директора. Чтобы зарепортить баг, нужно было как-то обратиться, обновить мой аккаунт в САП-девелопер-нетворк, и иметь какое-то специальное право репортить баги. Соответственно, тем не менее, я уже месяц прошел, я так и не зарепортил. То есть там все погрязло в какой-то внутренней бюрократии корпорации САП. Может быть, они не хотят, у них так маркетинг построен, что это идеальная база, она вам подойдет в абсолютно любом случае. Вот. Они, может, не хотят думать о плохом и принимать баги. Не самый позитивный отзыв. К сожалению. Что вообще тебя угрозило с САПом связаться? Это же ужасно, надо бежать, только видишь это слово — беги. К сожалению, наша фирма как-то сотрудничает с САПом в последнее время. Вот. В основном. И у меня тоже возникают такие позывы, можно сказать, к бегству. То есть в моем рейтинге это еще хуже, чем IBM. Это единственное хуже, чем IBM. Да, что-то в этом есть. Да, ну, в общем, я думаю, все. Мы поговорили о чем-то связанном с In-Memory. Кстати, что вы думаете о In-Memory в базах данных в принципе? Это действительно стоящая вещь или это узкая ниша, узко-нишевое решение? У меня такое отношение. Если что-то In-Memory называется базой данных, а не кэшом, потому что сейчас даже многие In-Memory кэши типа Redis или типа Couchbase, которые, в общем-то, Couchbase, собственно, претендует быть базой данных, они такие сохраняют диск. Это зависит от того, что ребята подразумевают под In-Memory, потому что, насколько я понимаю, то же самое HANA вполне может на диск писать. Для меня вообще странно, что такое In-Memory, колоночное хранилище. Мне кажется, ребята просто прилепили туда красивый маркетинговый термин. На самом деле, это просто какой-то обычный колоночный баз данных, который просто неплохо использует оперативную память при вычитывании. А может быть и плохо, я даже не представляю себе, чем она такая хорошая или нехорошая. Она идет, извиняюсь, она идет в комплекте с hardware. На hardware стоит 1 терабайт оперативной памяти. Соответственно, при таком количестве памяти она чувствует себя просто отлично. А если у тебя больше, чем терабайт данных? У нас были предложения. Больше, чем терабайт, делай несколько машин, шардируй, реплицируй и помогай себе сам. У меня есть некоторый опыт работы с In-Memory базами данных. Притом не только с CouchBase, но я с CouchBase начну. Он не совсем In-Memory, там так устроено, что у тебя горячий набор данных в памяти, а если есть какие-то данные, которые давно никто не трогал, то они складываются на диск. То есть нормальная база данных, как в любой нормальной базе данных сделана. Ну не совсем, потому что там предполагается, что у тебя твой горячий набор данных, например, если у тебя 100 тысяч пользователей онлайн, а всего миллион, то твои 100 тысяч должны целиком поместиться в память, остальные должны поместиться на диск. Если у тебя все не поместилось в память, то во всех документациях они пишут, что вы понимаете, вы будете постоянно вгружать, выгружать, и все будет тормозить, поэтому так вам не нужно. Они как бы In-Memory, но такие. Не совсем. В целом у меня с CouchBase исключительно положительный опыт, и я всем рекомендую. Единственное, что меня в нем до сих пор печалит, это то, что там нет таблиц. В смысле, там есть бакеты, но бакеты играют роль базы данных. Ты не можешь там создавать больше 10 бакетов, насколько я помню. Или там он начинает тебя как-то плохо вести, если их больше. Но смысл в том, что у тебя все документы, они валяются в одном пространстве в перемешку, и ты разбиваешь их только по окружениям. Условно говоря, вот это у меня Dev, это Stage, это Prod. И это не совсем то, чего я хочу, честно говоря. Но в принципе с этим можно жить, да. Можно я скажу? Или ты еще не закончил? Я по-вторую хотел рассказать, что в Mail использовалась In-Memory базы данных Torrental. Там в ней хранились, а я честно говоря не помню, что. То ли сами контакты, то ли какие-то индексы для адресной книги. Но смысл в том, что это реально прямо в In-Memory база, которая... Зачем она сделана в In-Memory? Чтобы работала быстро. У тебя все данные, на диске они тоже персистятся, но работают, что все равно с памятью. Идея в том, чтобы выполнять запросы просто очень быстро, всегда. У тебя ты упираешься в сеть на третью миллисекунду, и ты получил данные. Это действительно удобно, когда у тебя есть такие данные, которые нужно получать быстро. Иногда дешевле за память занести. Полностью согласен. Во-первых, я проводил DB, я проверил, реально не знаю, что мне в голову взбрендило. Она нисколько не колом. Во-вторых, относительно In-Memory, у меня был такой опыт. У нас в компании был небольшой довольно объем данных, то есть скажем 200 гигов реальных данных. И мы очень сильно страдали, потому что количество индексов, она полностью могла залезть в память. Но количество индексов, которые, скажем, добавляла в постграм, и все в постграм хранило, увеличило объем данных в несколько раз. И это очень страшно. Это заставляет использовать неоптимальные технологии. Если у нас было нормальное хранилище, которое умеет полностью в памяти располагать данные, хорошо их искать в памяти, очень быстро. А память намного быстрее, чем все эти ваши данные, которые лежат где-то на диске. Это было бы намного все лучше и идеальнее. И я считаю, что из-за того, что память все больше дешевеет, будущее все-таки за In-Memory хранилищами. Как правильно называются вот эти девайсы с интерфейсом, как у диска, но внутри у них память оперативная? Все время забываю. Если кто-нибудь из слушателей знает, напомните. Окей, Света. Так, да. Следующая тема, она моя. Я вот недавече почитала книжку мемара PhD студента. Мне очень хочется поделиться, потому что очень интересные мысли были вынесены оттуда. Собственно, очень рекомендую тем, кто хоть как-то связан с наукой, кто хочет поступать на PhD, кто хочет вообще поступать в магистратуру, особенно в вузы Европы, Штатов. Дает хорошее понимание, представление, чем же эти люди занимаются. И становится понятно, нужно ли это вам. Вот, собственно, книжка написана очень классно. Это порядка PDF-ка скачивается. В принципе, можно и другие форматы. И там чуть больше 100 страниц. И они заходят просто на ура. Это вот 6 лет страданий и учений одного студента, как он, закончив магистратуру в MIT, пошел в Стэнфордский университет. И идея его была такая, что я хочу делать какие-то тулы, которые позволяют программистам работать более эффективно. Он проработал некоторое время, но во время летних стажировок в разных компаниях понял, что работать просто по найму ему не интересно, а хочется делать чего-то большее. Он решил это все воплотить в своей диссертации. И в книжке рассказывается про то, как он искал себе научного руководителя, как он целый год занимался тулом, который ему был не очень интересен, который тул был очень забагованный, хотя как ни парадоксально, тул сам искал баги среди разных программ с открытыми исходниками. И, в общем-то, потом он очень сильно во всем этом разочаровался, и у него была сильная депрессия. Потом он пошел на стажировку в Google в какой-то момент. Его отпустило. Он начал искать себе руководителя как-то на стороне. Но, по сути, он не переходил к ним, просто он общался, и какие-то идеи давали. И это очень интересно. После вот этой книжки я стала совершенно по-другому смотреть и относиться к пейперам. Вот если раньше, знаешь, так берешь, читаешь, а сейчас я понимаю, что за этим стоит, и насколько вообще сложно получить степень, и насколько это сильно отличает от того, что, например, у нас в Беларуси. И взять, что касается IT, человеку, который хочет защититься, защитить себе PhD, он должен, в зависимости, конечно, от факультета, от университета, но в Стэнфорде принято, что ты должен там две публикации сделать на конференции первого уровня. А конференции первого уровня они принимают порядка 10% всех публикаций, которые им засаднители. И как они эти публикации делают, как они их потом выверяют, и сколько итераций проходит. И это очень увлекательно, и как видишь, как люди не бросают то, что они начали. И это очень интересно. Я очень рекомендую эту книжку, она классная. Всё. Мои 5 центов, так сказать. У меня друзья говорили, что университеты в Европе и в Соединенных Штатах отличаются достаточно сильно. Кроме того, книжка именно про Стэнфорд, про МИТ, то есть про топовые, можно сказать, университеты. То есть это так далеко не везде, а в лучших университетах, можно сказать. Ну, скажем, да, по сути это лучшее, что есть, и какие требования. Очень интересно. Глобальная идея такая, если вы точно не знаете, чем вы собираетесь заниматься, у вас нет каких-то там четко определенных целей, нечего вам туда идти. Да. Следующая тема, она будет твоя, Гена. Да, значит, следующая тема это... А теперь кое-что совершенно другое. Следующая тема... Идеально умеешь переводить формирование стоя. Мы недавно приехали в... Гена, извини, я тебя перебью, ты просто довольно часто пропадаешь. Попробуй как-нибудь поближе к Wi-Fi-точке, выключить торренты. Шапочку из фольги надеть. Да, вот я сел поближе. Значит, программирование стоя. Мы недавно переехали в новый офис, и у нас там появились такие удивительные девайсы, как столы, у которых регулируется высота. Все сразу начали им пользоваться для того, чтобы поднимать их. Это оказалось очень удобным, и я вот в данный момент примерно стараюсь примерно раз в два часа менять положение. То есть сначала я начинаю день сидя на стуле, как обычно, потом программирую стоя. Оказалось, что это совсем не сложно, а даже позволяет поддерживать тонус в каком-то роде. Это для ног не очень полезно, потому что у меня есть знакомый, который и работал, работал стоя, и в итоге заработал свой рикос. Это сильно зависит от того, как ты работаешь стоя. Ну, я же тебе предлагаю... Есть методики, когда ты делаешь это не постоянно зафиксируясь, то есть если ты будешь стоять и не шевелиться, там будут какие-то проблемы. Если ты будешь, скажем, встал, постоял, немножко поработал, сидел, встал, постоял, или делаешь какие-то разминки, то это все нормально. Да, вот суть как раз в том, чтобы менять положение, а не в том, чтобы все время работать стоя. То есть это оказалось... Но, во всяком случае, сейчас у меня проходит экспериментальный период на этот счет. Я так делаю только последние две недели. Если я что-то заработаю негативное, я обязательно всем сообщу. Годика через два. А вот скажи, поясница не болит, когда стоишь? Сколько, например, у тебя длится сессия, стояние? Ну, где-то часа два, может чуть меньше. А вот не болит поясница по стечению часа, например? Нет. Кроме того, я, на самом деле, вдаваясь в детали того, как я работаю стоя, я на самом деле шевелюсь, когда работаю стоя. Ненавязчиво. Я не прямо сильно шевелюсь. Но, может быть, слегка раскачиваюсь или что-то в этом роде. То есть я не совсем стою, как соляной столб, а, в общем, как-то совершаю какие-то движения. Я вот не понимаю, как так работать стоя? Я не могу себе представить, чтобы у меня там клавиатура, передо мной стояла мышка, чтобы я там ими двигался стоя. Это как вообще? Слушай, а какая разница тебе? Ты точно так же находишься перед столом. Нет, нет, окей, хорошо. Я имею в виду, что ты же... У тебя постоянно какая-то нагрузка на ноги, ты не можешь расслабиться, подумать, понимаешь? Нет. А смотри, Саша, думать обычно хорошо. Вот ты ходишь по комнате и думаешь. Наоборот, она помогает, да. Да. Вот это как раз метод подумать для меня, например. Я выхожу на террасу и хожу из угла в угол. Соответственно, у меня мыслительная деятельность сильнее всего разогревается при ходьбе. Поэтому это совсем не так. Стоя тоже можно думать. Я очень хочу на работу тоже, поднимая стол. Я мечтаю когда-нибудь попробовать. А зачем? Какую проблему это решит? Это решит проблему... Во-первых, ты никогда не чувствовал, что, скажем, спустя не знаю, часа 4 после начала рабочего времени у тебя бывает такой период, когда ты теряешь внимание в фокус, либо ты пытаешься на стуле. У меня бывает так, что если я сижу на какой-нибудь задаче, я постепенно съезжаю по стулу вниз. То есть, в этот момент мне помогает, ладно, сходить пообедать, если это попадает. Если это не попадает, не знаю, пойти прогуляться или еще что-нибудь. Но иногда надо сидеть и что-то делать дальше, потому что, не знаю, проблема или еще какая-нибудь беда. И в этот момент, скажем, встать и постоять будет очень полезно. Во-первых, я на работе не сижу 4 часа подряд. По той причине, что поскольку я увлечен спортом и правильным питанием, то я как минимум поесть отхожу 3 раза. Ну, потому что у меня 5 приемов печи в день. Потом я пару раз еще дополнительно отхожу налить кофе. Потом пару раз дополнительно в туалет, например. И у меня получается так, что я больше часа один раз подряд не сижу. А если еще нужно коллеге подойти, а еще у нас стендап в 12 часов и так далее. Я говорю больше не про то, сколько ты подряд сидишь, а то, что у тебя к концу рабочего дня накапливается усталость все равно от неподвижного сидения. Нет, нет такого. Вообще никогда. В общем, я нашел для себя, что я, скажем, посидев какое-то время, а потом встав, постояв, и походив, и подумав, у меня получается прилив не то чтобы энергии, а мыслей или что-то, я не знаю. Музы. Если я буду не просто ходить бесцельно по комнате, а я в этот момент буду стоять у компа, это, возможно, поможет. Я хочу попробовать. Я не уверен тоже до конца. Да, наверняка это подойдет далеко не всем. То есть это от каких-то индивидуальных особенностей зависит. Саш, ты спортсмен, тебе поможет. С чем? Со штангой приседать буду больше? С чем-нибудь, да. Потом найдешь для себя плюсы. А, ну потом, да. Ладно, окей. Нет, в любом случае, если ты долго сидишь за столом, то это не очень полезно. Так я же говорю, я не сижу постоянно за столом. Даже, допустим, по часу ты ищешь все равно. Это много. Подожди, вот из 8 рабочих часов, сколько ты сидишь за столом? Ты что, все время за кофе ходишь? То есть у тебя все равно получается часов 6 времени чистого за столом по-любому. Ну вот, и если эти 6 часов ты будешь половину сидеть, половину стоять, у тебя уже какой-то динамизм и непостоянное сидение. Так я не понимаю, какую проблему это решает. То, что вы мне сейчас скажете, что это время жизни закрочает или еще что-то. Это вообще все так левыми номерами. Нет, здесь не время жизни, здесь твой позвоночник и твое качество жизни. Поверь, Саша, и когда болит позвоночник, и ты вынужден сидеть, это очень неприятно. Ну, то есть я не могу сидеть постоянно, то есть я постоянно чувствую, что мне ноет спина. Это все время ощущение не пропадает. Оно есть постоянно. При сидении это очень заметно. А все из-за того, что человеческий организм не приспособлен сидеть длиннобольшие промежутки времени. Нет, я с этим согласен абсолютно. Я именно поэтому и спортом начал заниматься. У меня другая просьба. Когда в прошлой кампании можно было проводить каталогические проработки с дома, я в такие дни очень любил лечь на диванчике, полежать с ноутбуком, подписать код на диванчике, лежа. Как вам такой вариант офигительный? Кстати, на голове. Да-да, у меня дома получается самое удобное положение, вот я нашел для себя, я экспериментировал очень сильно. Знаете, я на диван кладу ноутбук, а сам на коленях сижу на коврике рядышком. Вот самое удобное положение. Это бред, это вообще ни о чем. У меня удобнее ничего нет. У меня тоже так пару раз делалось. Подтверждаю, что это может быть довольно удобно. У меня самое удобное положение, это на кроватке, но сидя, ноги прямые, ноутбук лежит на специальном таком столике, у меня есть столик для ноутбука такой специальный, в нем еще и кулер даже есть встроенный. И при этом ты сидишь, потому что там под спину подложены подушки, так много они сложные, так удобно. Они жесткие подушки. И ты фактически сидишь с прямыми ногами перед тобой ноутбук. Мне это самое удобное положение. Подтверждаю слова Саши, это действительно удобно сидя на кровати. То же самое у меня есть диван, на котором я все эти курсовые, все дипломы, именно он так был написан. Это вот садишься, подушки под спину и вот сидишь. Но надо столик. Там обычно у меня такая, скажем, у меня есть такая коробка из-под принтера. Вот на эту коробку я кладу ноутбук, это заменяет мне столик. И становится очень удобно. Я просто не чувствую вот этой усталости, и знаешь, так очень продуктивно работаешь. Может дальше? Да, идем дальше. Саш, вперед, жги. Ну да. На этой неделе была опубликована статья в блоге advancedweb. hu Что это за доменная зона такая? Венгрия. Окей. Честно говоря, меня заголовок зацепил, потому что называется Scala Development in Vim. Но когда я прочитал статью, я немножко расстроился, она меня разочаровала, потому что чувак пишет примерно следующее. Ну, короче, у меня тут есть Vim, в нем есть подсветка синтексис для Scala, в нем есть плагин Nerd3, и короче, я тут... А, ну с Git'ом я работаю там понятно, как обычно командами, и в общем, я тут пишу код, а в соседнем окне у меня делается инкрементальная сборка и прогон тестов, я вот там смотрю в два терминала, и вот так я пишу код в Vim. Ну, офигеть теперь. То есть, как бы, чувак по сути ничего не сказал. Я думал, он скажет, как он там настроил себе автокомплит, как он там переход к определению, там рефакторинг и всего нахрен начал. Нет, нифига, чувак просто пишет, а мне ничего этого не нужно, я просто пишу Vim на Scala и мне нормально. Там он Scala Specific Extensions, это он что там пишет? Да там какой-то один плагин он дополнительно еще назвал. Я, честно говоря, не понял, как что-то там... А, он позволяет там выводить как-то удобно... Диагностику в окно этих... QuickFix. Но, честно говоря, это не думаю, что прям очень сильно ему помогает. Ну вот. Я честно... Так вот, а я это к чему все-таки добавил в тему, несмотря на то, что статья оказалась очень унылой, я не понимаю, зачем люди это делают. То есть, чувак, он реально до этого писал в идее, насколько я понял, из-за статьи. И... То есть, у меня в свое время сложилось такое впечатление о Scala и идее, что они довольно такие тормозные. Но я не знаю, с чем было связано, может они тогда действительно были тормозные. Все-таки там больше года прошло, когда я первый раз пробовал. Недавно я достал из ящика стола свой ноутик старенький такой, ему уже 2,5 года. Ну, там. .. Че, сейчас старенький ноутик у тебя? Ну, вот. Там... Ну, он такой по характеристикам. Там, типа, двухъядерный процессор, 6 гигабайт памяти. Он такой, ну, средненький. Ну, по нынешним меркам. Я промолчу про свои старенькие ноутики. Ну, так вот. И я поставил на него... Я в свое время его совсем чистил, там вообще ничего там не было, кроме оконного менеджера. Так вот, поставил на него Scala, поставил идею и открыл наш проект. Вот прям тот, над которым мы работаем на работе. И удивился, потому что, во-первых, Scala совсем оказалась не такой тормозной, насколько я помнил. Может быть, потому что тогда я пробовал 2,10, а сейчас она 2,11,6 или 7. 2,11,6, по-моему. И, типа, они ее ускорили дофига. Во-вторых, идея с дефолтными настройками, она прямо хорошо работает, не тормозит. В проекте никаких особых проблем нет. Справедливости ради. Потом я еще пописал код на работе и изменил дефолтные параметры по памяти. То есть, я сначала сбросил их на дефолтные, пописал, понял, что нет, когда там серьезный рефакторинг, полпроекта переписываешь, начинает немножко тормозить. Я там чуть больше памяти выделил, после этого проблема ушла. Так я это все к чему? К тому, что вот можно взять готовую IDE, поставить бесплатно. На твоем компе она отожрет не так уж много ресурсов, не будет тормозить, все будет хорошо из коробки. Но вместо этого люди начинают прикручивать к чего-то к вему, получают намного худший функционал и при этом еще так хвалятся, в блоге кипятят, смотрите, какой классный я пишу там на скале в блокноте. Зачем? А я знаю, почему. Я знаю, почему. Потому как люди как на наркотик подсели на модальное редактирование, как например я. Ты что имеешь в виду? То, что у тебя два режима там типа? Ну, не два, может быть больше, кроме того вызов наличия командной строки в редакторе тоже бывает очень удобным. Вот понимаешь, а вот после этого еще там некоторые товарищи обвиняют некоторых других товарищей, что они там типа по сторонам не смотрят. Ну, тот, о ком я говорю, он понял отсылку. Во-первых, у тебя в идее точно так же есть консоль, очень удобная. Я говорю не про консоль, которую я репал, а именно вот прям терминал. Эта консоль умеет гребнуть весь текущий файл и выдать только список строчек, которые по-твоему Regux по подходит. Да, конечно, это называется Ctrl-F. А потом, скажем, провести фильтр, и какие-то дополнительные штуки, которые ты можешь в консоли сделать, тоже можешь сделать? Да, конечно, это называется открыть терминал прям в EDE и сделай то, что ты сделаешь в Vim. Понял, окей. Кроме того, у тебя есть плагин для идеи, при том, кстати, я удивился, я когда ставил вот эту идею на свой слабенький ноутик, она прям там такой диалогик такой, типа привет, чувак, ты поставил идею в первый раз, тут у нас есть всякие плагины, какие ты хочешь, и она прям предлагает сразу Scala и сразу Vim плагин. Прям, типа, это два самых популярных плагина, я удивился, что Scala плагин самый популярный. Честно говоря, я думал, что на Scala, ну, не так много людей пишут. Ну, так вот, и то, что вот Ген ты сказал про то, что там привыкли к Vim моду, ну, пожалуйста, поставь себе Vim плагин, то же самое будет. Не то же самое, к сожалению. Я на самом деле попробовал PyCharm с Vim модом, какая-то что-то не то. Все время не хватает каких-то мелочей. Но на самом деле я не против людей, которые... я не призываю всех пользоваться Vim, это чисто условно говоря историческое событие. То есть я давно пользовался Vim, у меня есть все, что нужно для Python, автокомплит, прыжки по коду, там он подсвечивает все ошибки и так далее. То есть в принципе у меня в данный момент просто нет нет мотивации переходить. Ну вот для меня я для себя открыл только одну мотивацию, это рефакторинг. То есть вот я тоже пользуюсь Vim, и я понимаю, что если я, скажем, какой-то код буду делать рефакторинг, то Vim не предоставляет оптимальные штуки для этого. А я вот наоборот, я как раз понял, что рефакторинг мне не такой уж важен, потому что ну честно говоря, там сделать замену по всем файлам можно довольно удобно и с консоли. То есть это не то, что ты делаешь каждый день, и это не то, что прям вызывает самые большие проблемы. То, что у меня лично вызывает самые большие проблемы, это то, что я не могу документацию в Vim посмотреть без прикручивания ее дополнительно из коробки. Поясни, не понял. Ну ты вот наводишь курсор на метод, нажимаешь Ctrl-Q, и у тебя там документация по методу. А документация откуда берется? Это JavaDocs. Она дополнительно, у тебя это E, она дополнительно скачивает, ну у тебя в Java есть пакет с компилерными классами, есть архив с исходниками, и есть архив с документацией. Я к Erlang-у прикрутил подобную штуку из Erlang-mana, он умеет делать. Это я тоже прикрутил, это ерунда. А чем отличается от JavaDocs? А ты вот попробуй прикрути его. Ну то есть он для тебя в любой, как сказать, то есть ты открываешь Java, нажимаешь комбинацию клавиш, и на эту комбинацию для данного файла он будет выполнять определенную команду. То есть нельзя на эту команду найти нужную документацию, что ли, или как? То есть я, если нажал... Нет, ты не понял. Дело в том, что вот эти архивы с документацией или с исходниками, потому что я могу и захотеть в исходник перейти, тоже такой ход есть. Вот, их, во-первых, нужно дополнительно скачать, а во-вторых, их нужно еще чем-то там распаковать и посмотреть. Вот ты к нему утомишься такой прикручивать. Ну понятно, у них это уже есть в коробке, а к ВИМу тебе надо ручками это все делать и настраивать. Да, и ну ладно бы, просто нужно было прикрутить, я не понимаю, зачем, если есть готовое. У всех свои развлечения. Еще один момент, который хочется добавить по поводу ВИМа. Есть языки программирования, вот, наподобие Scala и Java, и с ними очень тяжело в консоли работать. Они достаточно многословные, и надо помнить, где, что, в каком пакете у тебя расположено, чтобы его импортировать. И эти вещи, ну, мы привыкли, что у нас эффективность высокая, мы ожидаем подсказок от ИДЕ, что она дополнит мне правильное название метода, и она изменит методы, если я буду там его переименовывать. И просто я очень не хочу терять вот эту эффективность работы. Автоимпорт, это, кстати, важная фича, я подтверждаю. И плюс... Да-да-да, договорились. Я обратил внимание, просто часто говорят, что там, типа, пишите код в ВИМе, тогда вы там посидите лишние 10 минут, подумаете, но у вас проект будет более структурированный, более правильный. Я обратил внимание, что есть еще и контраргумент на это, то что у нас недавно добавляли пару низких хелперов в проект. Был вопрос, как их правильно назвать. Потому что это функции, которые возвращают... Ну, когда ты с футурами работаешь, тебе иногда нужно написать if else, и в некоторых случаях тебе нужно вернуть какое-то дефолтное значение, например, успешную футуру с пустым множеством внутри, такого рода вещи. Мы обратили внимание, что пишем это слишком часто, добавили низких хелперов. Был вопрос, как их правильно назвать. И долго-долго обсуждали. Точнее, не так. Мы это обсуждали секунд 5, наверное. Потому что мы поняли, что поскольку у нас есть крутая EDE, нет вообще никакой разницы, как называть переменные, методы. В смысле, нет большой разницы. Кому-то нравится mtset, кому-то нравится eset, кому-то нравится nil. Но всем пофигу абсолютно, как мы их на самом деле назовем, потому что переименовать занимает буквально одну секунду во всем проекте. Проблема не в переименовании, а в чтении. Я понял, что когда... Если бы мы писали во всяких EVMах, у нас был бы такой срач на полдня, как правильно назвать метод. А тут... Я даже иногда вижу полреквест, там какая-нибудь переменная называется типа L или O. Я лично считаю, что это ужасно, называть переменные буквой L. Но я до этого не докапываюсь, потому что я понимаю, что у меня это переименовать в следующий раз, когда я буду в это место смотреть, я переименую за секунду. То есть это вообще становится неважно. Вот за это я обожаю IDE, и никогда ни на какие Vim'ы больше не вернусь. Вообще все эти штуки очень хорошо видно. Мы как-то обсуждали проект, показывание видео, как люди кодят. И очень интересно посмотреть на разные среды, на разные языки программирования. Скажем, пишешь ты на C в Vim'е, или ты пишешь на Scala в IDE, ты можешь в любой момент посмотреть, а как это делают другие люди на других редакторах. И если человек продвинутый, то есть он это делает быстро, качественно, ты можешь посмотреть, насколько ему это удобно делать, насколько он это быстро делает так же, как ты, лучше, чем ты, хуже, чем ты. Мне кажется, в этом смысле, вот это как раз проект с видео очень хорош. Хотя я ради справедливости обвиняюсь. Ради справедливости на тему Scala, я вообще не поклонник Emacs, но ради справедливости нужно упомянуть, что есть Scala Mode под названием NZIM для Emacs, который умеет авто-дополнять, прыгать, рефакторинг и документацию. То есть для поклонников терминала есть выход. Я хотела сказать, что просто зависимость от количества времени проведенных там либо в ВДЕ, либо в ВИМе, либо в другом редакторе, ты просто там с какого-то времени у тебя будут хорошо набиты пальцы, и ты будешь и там, и там эффективно работать. Но изначально, скажем, если посадить два человека, этот, оба они ни с тем, ни с тем не сработали, и эффективность работы человека в ВДЕ будет больше. Я думаю, это чем можно мусолить очень долго. Да, и мы очень часто на нее переходим, поэтому Ваня, тебе слово. Что там про визуализацию хочешь рассказать? Виртуализацию. Виртуализацию, да. Вышла статья на pagetable.com о том, что запилили легковесную виртуализацию на OS X на базе гиперевизора Framework, который добавили в 10.10 в USemmity, и они взяли проект BHive, назвали его XHive, и портировали его для macOS, он имеет BSD-лицензию, и все хорошо работает. Теперь они могут под этой виртуализацией запускать Linux, и вроде как все летает, они прямо в статье привели пример, как они очень простенький Linux засунули туда, а потом показали, как, скажем, засунуть туда Ubuntu и открыть VNC, и по VNC законнектиться туда и поработать. Все это работает локально, по домокосию, никаких проблем. Я с нетерпением жду, когда они туда, будто докер, на эту штуку переделают.",
    "result": {
      "error": "API request failed: Error code: 429 - {'error': {'message': 'Request too large for gpt-4.1 in organization org-xSG9D345gtYlIKC330wCyrEG on tokens per min (TPM): Limit 30000, Requested 35247. The input or output tokens must be reduced in order to run successfully. Visit https://platform.openai.com/account/rate-limits to learn more.', 'type': 'tokens', 'param': None, 'code': 'rate_limit_exceeded'}}",
      "stack_trace": "Traceback (most recent call last):\n  File \"/home/andrei/Projects/podcast-shownotes/scripts/build_search_eval_dataset.py\", line 157, in generate_search_query\n    response = await self.client.chat.completions.create(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/resources/chat/completions/completions.py\", line 1927, in create\n    return await self._post(\n           ^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1767, in post\n    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1461, in request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1547, in _request\n    return await self._retry_request(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1594, in _retry_request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1547, in _request\n    return await self._retry_request(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1594, in _retry_request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1562, in _request\n    raise self._make_status_error_from_response(err.response) from None\nopenai.RateLimitError: Error code: 429 - {'error': {'message': 'Request too large for gpt-4.1 in organization org-xSG9D345gtYlIKC330wCyrEG on tokens per min (TPM): Limit 30000, Requested 35247. The input or output tokens must be reduced in order to run successfully. Visit https://platform.openai.com/account/rate-limits to learn more.', 'type': 'tokens', 'param': None, 'code': 'rate_limit_exceeded'}}\n"
    }
  }
]