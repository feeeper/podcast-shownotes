[
  {
    "segment_id": "9da42e58-e34e-4a52-a4ff-10787074f1d4",
    "episode_id": "db4723b7-a33b-4c9e-b45d-a72015a2a050",
    "episode_number": 23,
    "segment_number": 3,
    "text": "Да, давай, давай. Нам уже, там, чуть ли не в январе обещают ACK 2.4, уже совсем релиз. Пока что оно в состоянии Milestone 2. То есть, весь код, все готово, все есть. Сейчас ребята занимаются тем, что пишут документацию. Собственно, Milestone 2 заключался в том, что появилась какая-то более-менее подробная документация по ACK Streams и ACK HTTP. То есть, там, с примерами, все такое. Прямо на сайте ACK.io. Все честно. И, соответственно, сейчас ребята правят баги. В принципе, оно уже вполне юзабельное. И в январе нас ждет релиз. Я считаю это прекрасно. Слушайте, а можете вкратце дать, я слежу немножко за АКК, но очень слабо. В каких случаях ее нужно использовать? Когда у тебя какой проект, что ты делаешь? Ну, смотри, как я это вижу. Опять же, я не претендую на знания истины. У тебя есть JVM, правильно? Тебе нужно над JVM писать многопоточные приложения. Какими примитивами, какими средствами это можно сделать? Ты можешь использовать, например, Mutex. Все мы понимаем, почему это плохо. Любой, кто отлаживал код с тремя Mutex, в которые можно входить 4 потока в разных местах, тот понимает, почему Mutex пользоваться нужно только, когда уже больше нет вариантов. Потом у тебя есть, например, атомарные переменные. Ну, понятно, да, там область применения довольно ограничена. И вариантов остается не так уж много. Какой-нибудь STM, но это довольно тяжело. И актеры. И тут к нам на помощь приходит акка. Подожди, Саша, извини, но ты упускаешь такую вещь, как параллел коллекшнс в Java. Это коллекции, которые написаны поверх атомарных операций, которые должны, по крайней мере, хорошо работать. Понятно, что может быть какой-то контеншн, за тем нужно, конечно, ручками следить. Но, тем не менее, общение через параллельную коллекцию, на мой взгляд, это нормальный вариант. То есть у тебя может быть вполне какое-нибудь приложение на нете, где каналы между собой общаются через параллельную коллекцию. И этого будет более чем достаточно. Не нужно, во-первых, ни Mutex, а во-вторых, ни акка. Ты говоришь про коллекцию, которая, например, Q. Ну, не только. То есть это может быть хешмап. То есть ты неявно передаешь владение ячейкой из одной части в другую. То есть мне видится... Можно поподробнее? Я вообще не слышал, что это такое. Нете или параллель коллекшнс? Параллель коллекшнс. Ну, представь себе, что у тебя, знаешь, такой верланг ETS. То есть реализованная на уровне виртуальной машины, хорошо сделанная структура данных. Но теперь представь, что у тебя все структуры данных хорошо заимплементированы на уровне виртуальной машины, либо просто на языке, но с использованием возможности виртуальной машины. Просто библиотека коллекций, которые для параллельного доступа хорошо оптимизированы, которые есть в стандартной библиотеке. То есть ты можешь параллельно из 20 разных потоков писать в атомарном в какие-то ячейки этой коллекции? Ты это имеешь в виду? Типа того. Да, возможно, это неплохой вариант. С другой стороны, ты фактически делаешь какие-то футуры, прикручиваешь к ним какие-то очереди, но тебе АКА делает то же самое. Если не считать распределенные всякие части. Почему не факту? У тебя фактически либо ты делаешь то же самое, что в АКЕ, либо ты переходишь на Mutex и всякие атомарные вещи. То есть это не третий подход, это где-то посередине ты болтаешься. Мое мнение такое, что поскольку АКА это довольно чуждая модель вычислений для JVM, то если задача просто перекладывать байтики из сокета в сокет, то возможно, NETTI достаточно. Да, все так и есть. Другой вопрос, что на этом уровне, когда тебе нужно перекладывать байтики из сокета в сокет, действительно, может быть тебе АКА особо и не нужна. Дальше есть вариант, если ты делаешь какое-то хитрое распределенное приложение. Есть замечательная штука, называется АКА-кластер. Она тебе из коробки дает кучу очень крутых вещей. Например, ты можешь использовать такой, я не знаю, как это назвать, примитиевый, допустим. Вот у тебя есть кластер, в нем, например, 5 узлов, и ты можешь гарантировать, что вот этот актер в кластере ровно один, то есть такой синглтон. Он прям это гарантирует? Ну да. Он это через как гарантирует? Ну в смысле? Я не понял. Ну то есть если у тебя сеть разваливается на 2, у тебя будет не одного, а один, по одному на каждый сегмент? Там есть два варианта разваливания, как ты настроишь. То есть АКА поддерживает два варианта разваливания кластеров. Первый вариант, когда у тебя есть auto down, когда у тебя нода, какую-то часть времени недоступна, то кластер сам говорит, что та нода недоступна, и она ее убирает из кластера. Это плохой вариант, потому что в нем у тебя кластер разбивается на 2 кластера, и в нем могут появиться 2 синглтона. В некоторых приложениях это может быть не так уж плохо. Но это нужно иметь в виду. Другой вариант, когда тебе нужно самому лапками говорить, что вот та нода, она действительно все, ее нет. Вот в этом случае... Нет, подожди, а если у тебя, смотри, извини, что перебиваю, если у тебя есть 2 астровка, сейчас оба работают. Машина из каждого астровка другую часть астровка не видит. Я тебе на этот вопрос отвечаю, что у тебя в этой ситуации, в случае net split, АКА дает 2 варианта управления кластерами. С auto down я понял, да. С auto down все будет плохо, потому что твой кластер разбьется на 2 кластера, будет в этом случае 2 синглтона. Но, опять же, повторюсь, в некоторых приложениях возможно это и нормально. Другой вариант, когда у тебя ты должен сам руками сказать, что вот та нода, она действительно down. Есть утилита, АКА минус кластер, которая для этого. В этом случае у тебя такой проблемы не возникает, у тебя действительно будет 1 синглтон на весь кластер. То есть получается, что синглтон не full tolerant получается. То есть пока ты руками не скажешь down, у тебя синглтон не почешется переехать, я правильно понимаю? Если ты дополнительно ничего не написал, да, но. АКА предоставляет тебе другой замечательный примитив. Я просто как раз недавно все это исследовал, было очень интересно. Ты можешь подписаться на события кластера. То, что у тебя нода стала доступна-недоступна, что она присоединяется к кластеру, что она вроде как в кластере, но вот сейчас вдруг стала не видна, там такие интересные события приходят. И ты можешь реализовать свою логику, которая тебе нужна. Например, ты можешь посмотреть на текущий размер кластера, и если он у тебя меньше половины нод, сказать, что ой, кажется я в меньшинстве, и сказать system shutdown. Не стоит так делать, на самом деле, потому что я не уверен, что ты должен не просто увидеть, что ты в меньшинстве, ты должен за это проголосовать. Но ты сейчас пытаешься придумать идеальное решение для Nodesplit, а его нет. Нет, в смысле, есть просто рабочее решение, есть система с Quorum, и Quorum голосует, это нормально, рабочее, доказанное решение. Все остальное, это такая, знаешь, но мы тут подумали, наверное, это будет работать. А что может пойти не так? В смысле, я вот вижу на конкретной ноде, что у меня пингуется из 15 нод только 3. Какое голосование, зачем она? Я вот думаю, просто то, что ты видишь, является эквивалентом голосования или нет. Может не являться. Просто понимаешь, в чем дело? Может быть, нод сейчас в кластере и стало не 15, а... Не, может быть, и 15 осталось, просто оно частично видимо. То есть с ноды А видно Б, но не видно С, а с ноды Б видно С, но не видно Б. У тебя, например, может весь кластер выключиться, как так-то, да. Если ты будешь решение принимать только локально, у тебя может выключится весь кластер. То есть может быть такая будет началась ситуация. В каком случае? Ну вот тебе Иван только что показал, что у тебя может быть так погибаться видимость в кластере, что у тебя. .. С каждой ноды видно меньше половины всех остальных нод, но все ноды включены. И все ноды в итоге, на самом деле, даже можно путь построить между ними, роутинга. Ну окей, но вам никакое голосование в этом случае не поможет. Ну вообще-то поможет. Как? Понимаешь, если у тебя сообщение может доставить из точки в точку, то у тебя все как бы связано, но просто... А, ну, кстати, в случае с АККО-кластеровским детектором, там не факт, что он определил, что все эти сети, что они все лежат. Я вот не помню, там АККО-кластер, насколько я помню, использует фид-детектор, и, насколько я помню, там используется распространение информации о том, с какой ноды какие другие ноды доступны. Поэтому, в принципе, наверное, в случае с АККО-кластером, говорят, такого кейса, который ты, Вань, привел, он, наверное, не случится, потому что фид-детектор не позволит так сделать. Ну, в любом случае, мы пошли в какие-то дебри, и в случае с той же АКСАНДРой нужно все это просто аккуратно тестировать в конкретных ситуациях. В любом случае, там независимо, реализовано голосование или не реализовано, просто это нужно проверить, что оно хотя бы работает. Но, опять же, это может работать на простой ситуации. То есть, ты не проверишь все такие дурацкие ситуации, у тебя нет доказанного алгоритма. Короче, универсальный совет – используйте доказанные алгоритмы. Потому что даже доказанный алгоритм тяжело реализовать без багов. Вот недоказанный алгоритм у вас будет, во-первых, не факт, что вы сделали концептуально правильную штуку, а во-вторых, вы потом еще и в реализации ошибетесь.",
    "result": {
      "query": "Akka cluster split brain handling"
    }
  }
]