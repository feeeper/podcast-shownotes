[
  {
    "segment_id": "d7a9b1f3-3bea-4775-a26b-89c3a5bf45b7",
    "episode_id": "72b26d82-9103-4d1f-9647-2f10cba98261",
    "episode_number": 48,
    "segment_number": 8,
    "text": "Проблема с трифтом довольно банальная. В трифте нет алгебрических типов данных. Поэтому у нас команды, которые мы посылаем друг другу, это просто такой тип сумма. То есть команда номер раз, или команда номер два, или команда номер три. И в трифте я не нашел хорошего способа это по-человечески закодировать, так чтобы оно транслировалось в Haskell правильно, алгебрический тип, а в Scala в эти ваши case-классы, или что-то у нас есть. И поэтому я пишу свой язык описания данных, который будет транслироваться именно так, как я хочу, и с моими еще именами будет транслироваться. Мне кажется, ты ошибаешься насчет трифта, извини, что перебиваю, потому что там на самом деле есть union, это тот самый, как ты при объявлении алгебрического типа ставишь палочку, вот union, он вот это делает. И более того, даже если бы его там не было, ты берешь обычные, как ты их назвал, ну короче, структуры, и делаешь вместо этого объединения палочкой какую-нибудь структуру с optional полями, это конечно не очень красиво, но это работает. Я именно хочу, чтобы он транслировался в те типы, которые я хочу видеть. То есть в Haskell я четко знаю, какой я тип хочу сгенерировать, какие функции хочу сгенерировать, более того, я не знаю, трифт, наверное, тоже делает. Я хочу документацию писать в этом формате, чтобы он автоматически превращал ее в документацию в этих языках. То есть вот такие штуки. Я, честно говоря, смотрел на это месяца или два назад, и я смотрел в трифт, и я смотрел в protocol buffers, и что-то там было не то. То есть я там не нашел правильных алгебрических типов данных. Может быть, или он как-то не так работает. А не проще написать обертку, которая будет из того, что трифт и протобафт генерируют, делать алгебрические типы? Зачем писать с самого начала полный велосипед, если можно просто приделать к нему седло нужного типа и дальше ехать уже? То есть ты говоришь, что у тебя коллеги пишут на скале, значит, у них уже есть генерация вот этих трифтов, да? Все, что тебе нужно, это написать для вот этой сериализации, теоризацию в хаскельные алгебрические типы. Подожди, вы предлагаете обертку на каком уровне? Кодогенератор или обертку в виде хаскельного кода библиотеки? А у тебя в трифтах есть какое-то описание, что там... Ну вот, как я пример привел, самый тупой вариант. У тебя есть какой-то особый трифт, в котором там 10 опшнл-полей, и ты его как-то помечаешь комментариям, например, что это у тебя алгебрический тип, у которого там 10 видов, да? И ты пишешь дистерилизатор из трифта, который на выходе тебе дает в хаскель алгебрический тип. Ну, смотри, мне же его надо тоже сгенерировать, если я поменяю описание алгебрического типа данных, правильно? Я же хочу, чтобы и мой хаскельный тип обновился. То есть это все равно надо писать кодогенератор. Но вдобавок к тому, я сейчас пишу кодогенератор, вот именно чтобы он был красивенький, потому что смысл делать новый язык, если на нем неприятно писать. То есть именно смысл в таком DSL в том, что там описание именно лучшее из всего, что возможно. Потому что ты сам выбираешь синтаксис для этого языка, ты сам выбираешь фичи, которые там есть. То есть вся идея в том, что именно описание на этом языке, оно идеальное. Я не хочу там в трифт изобретать все эти опшонал поля. Ну, то есть я вообще не представляю. У меня, например, есть 10 команд. У каждой команды по 5 аргументов. То есть это у меня будет 50 опшонал полей. И я буду говорить, что в этом конструкторе вот эти поля, а остальные nothing. А вот в этом конструкторе вот эти, а остальные nothing. Почему 50? Потому что это должен быть рекорд, в котором все поля всех конструкторов. Правильно же? Ну, допустим, у тебя 10 запросов. Да, 10 команд, и у каждого по 5 аргументов. Хорошо, окей. Значит, у тебя каждой команде поначалу соответствует, с точки зрения трифта, одна структура в трифте, потом тебе нужно это объединить в алгебраический тип твоей команды. Ты добавляешь структуру с 10 опшонал полями. И помещаешь ее каким-то флагом, чтобы чисто в хаскеле это было алгебраический тип. А у ребят в скале это будет, ну, как обычно в скале. Ну так а как в хаскеле возникнет этот алгебраический тип? То есть мне надо писать свой кодегенератор для трифтового описания? Сериализатор или сери... Блин, ну ты понял. Идея-то в том, вот то, что мы с Ваней пытаемся сказать, что ты можешь сделать только половину работы. Не написать все целиком, там, в скалу и из скалы, в хаскеле и из хаскеле, еще там партилку формата. А ты можешь сделать только половину работы. Ну подожди, подожди, что значит сериализатор? Сериализатор мне надо писать либо для данного конкретного типа, который зашит в трифт, правильно? И, ну, если я его руками пишу, то описание в трифте обновляется, а мой сериализатор остается сломанным. Либо же я должен писать свой кодегенератор? Ты генерируешь сериализацию и десериализацию из файла .trift? Ну как обычно в трифте. А, то есть мне надо писать, условно говоря, парсер для трифта, да? Ну то есть вставлять свой кодегенератор в код трифта. Ну, генерировать код на хаскеле и с кодом трифта, да. Ну да, да, да. Ну короче, я вот эти все варианты рассмотрел, и на самом деле самое простое, это написать свой вот такой DSA для генерации. Ну то есть, опять-таки, я первый прототип написал там за один вечер. Вот он, то есть я сам язык, да, парсер для языка, и какой-то простенький кодегенератор для хаскеля. То есть там еще не все фичи, и это только для хаскеля, но опять-таки, то есть я думаю, там, за пару недель я добавлю те фичи, которые я хочу там видеть, и я сделаю там кодегенератор для остальных. Ну потому что вот у меня есть четкое видение, как оно должно работать, да. То есть я знаю, а нам же еще надо генерировать код для хаскеля, для скалы, для джава скрипта и для руби, потому что... И ты все это будешь писать на хаскеле? И более того, вам это еще придется, ну например, в случае со скалой тебе понадобится плагин для SBT, который это будет генерировать при компиляции проекта, а иначе твои коллеги, они будут очень несчастными котиками. Ну оно меняется не так часто, я думаю, что можно его просто компилировать, когда оно меняется, и так и использовать. Там какой-нибудь git-сабмодул включить в проект. Вот именно в этих случаях мы смеемся над теми, кто пишет свой собственный элосипед, да. Ну как бы без обид-то, но... Ну, хозяин-барин, но мне кажется, это не самое лучшее решение. Я бы так не делал, но... Окей. Следующий вопрос задает наш слушатель Денис. Он приводит статью на Geek Times про космос и про строчку кода, которая стоила 500 миллионов.",
    "result": {
      "query": "Thrift algebraic data types"
    }
  }
]