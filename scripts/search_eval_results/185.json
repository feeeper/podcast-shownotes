[
  {
    "segment_id": "f187e2fb-969c-45fa-a5f0-90f95db4d7dc",
    "episode_id": "bc53af44-260d-45a7-9fdf-39226f7cf504",
    "episode_number": 185,
    "segment_number": 3,
    "text": "Почему именно на Beam? Можно я за Go с тебя отвечу? Давай. У меня просто сейчас такая боль периодически случается. В смысле, у меня ее не случается, именно потому что у меня на Beam. Это одна из немногих ритуальных машин, которая память собирает, ну, кстати, мусор собирает по процессам, а не глобально все останавливает. Вот есть поле на Go, который вроде как у него хороший коллектор, для интерактивного взаимодействия подходит. Но есть особенности. То есть он хорошо подходит для, ну, по крайней мере из того, что я вижу в нашем продакшене, оно идеально подходит для ситуации, когда у вас такое прям вопросоответное взаимодействие, когда нужно высасать, там, не знаю, гигабайт из базы и отдать его наружу, с этим уже внезапно иногда бывают проблемы. Вот. И я, казалось бы, нежданчик, потому что смотрите, какой классный у него коллектор, но вот все еще бывают проблемы. Да, но это же имеет свои недостатки тоже. Постоянное копирование, постоянные пересылки, и у тебя очень часто для того, чтобы работать с одной строчкой, особенно если несколько процессов работают с одной строчкой, тебе необходимо ее кучу раз копировать. То есть есть свои недостатки в этом, и неизвестно еще, больше ли их или меньше. Я думаю, любой ГЦ это в той или иной степени, ну, для каких-то задач хорошо, и для каких-то других это совершенная боль. Я, например, не так давно с большим удивлением для себя такой кейс понял, ну, там из видео на ютубе. Вот у вас есть программа на десктопе, которая собирает, ну, рисует картинки для логического анализатора, то есть у нее есть сбоку железка, которая записывает сигнал, условно говоря, там, высокий, низкий. И вот ты его должен записывать там очень много раз в секунду. И вот у тебя он записывается, например, с частотой 20 МГц, да, 20 МГц это немного, и вдруг у тебя раз, и ГЦ пришел на 5 миллисекунд, и ты вот это время потерял в своей записи. То есть в таких задачах ГЦ вообще никакой не применим, ну, по крайней мере, тот, который неотключаемый, если его хотя бы можно отключить на пару секунд совсем, но это тоже плохо, у тебя память будет усекать. То есть здесь вот вообще никакой ГЦ в принципе не подходит, ни джавный, ни эрланговый, только без ГЦ. Ну, мне кажется, даже в эрланг, во-первых, можешь с этим работать, во-вторых, сам BIM, он же как раз предоставляет soft real-time, то есть для многих задач как раз виртуальная машина предоставляет средство для быстрого процессинга и как раз возможности не упираться в Stop the World, который есть в частности на других виртуальных машинах. Но речь же не про Stop the World, а про то, что у тебя вот конкретный процесс, он может переостановиться, не важно насколько, не важно, что это будет очень маленькая пауза, которую ты почти не замечаешь, у тебя в принципе любая остановка, о которой ты не партил, она вот в этой конкретной задаче рушит все. Поэтому я просто привожу примеры задач, где никакой ГЦ неприменим, а уж можно придумать еще больше задач, где конкретный ГЦ в чем-то лучше, в чем-то хуже. То есть я как такую иллюстрацию привел. Ну, понятно, возможно, возможно, то есть тут мне сложно спорить с тобой. Ну, то же самое, на самом деле, касается и ситуации с процессами, там карутина или не карутина, или актер и не актер, действительно, BIM клев тем, что легковесные процессы из коробки, прозрачно, не нужно думать про async, await, с футурами как-то писать, как в скале приходится. В каких-то задачах это плюс, во многих это большой минус, потому что на десктопе, на типичном тебе не нужны накладные расходы на поддержку вот этих карутин и так далее, они есть, как на карутине. Понимаешь, Саша, здесь еще такой момент, что, ну, смотри, во-первых, introspection, то есть для многих сервисов ты просто берешь, атачишься к ноде, и ты можешь понять, что там происходит. Это большой win, потому что ты можешь и пропатчить нужный тебе код, и отрассировать нужные тебе вещи. То есть немногие языки, немногие виртуальные машины представляют такие же средства по интроспекции, которые представляет Erlang. Ну, на самом деле, справедливости ради, есть только еще одна популярная виртуальная машина, и это JVM, и у нее там есть Visual VM. Нет, Visual VM, он дает тебе весьма скудные вещи по сравнению с Erlang. В смысле, да, прямо кровопадчить там тяжеловато без какой-нибудь JRabble, но посмотреть, что происходит там, ну, мне кажется, не хуже. Местами, мне кажется, может быть, даже лучше там просто сценить своя. Нет-нет, я думаю, все-таки Visual VM — это как вот аналог Observer, то есть если... Ну, да. Нет, ну я думаю, речь шла не про эту интроспекцию, а про то, что ты можешь прямо подрубиться и код повыполнять. Нет, ну это все-таки кровавый патчинг уже. Нет, не мне это выполнять. Да, прости говоря. Я хотел сказать, что интроспекция — это не про то, что ты изменяешь код, а интроспекция — это ты пытаешься понять, что происходит в системе. Да, но вот эти вот графички, что у тебя там столько-то процессов, а ты отъебешь столько памяти, это довольно скудно. Я как раз соглашаюсь с тобой, да? Это очень мало. То есть я здесь в этом контексте что имел в виду, что я взял, приатачился к ноде, не знаю, у меня пул там ведет себя некорректно, или какой-то коннект, еще что-то. Я взял, я, пожалуйста, могу оттрассировать, какие функции вызываются, я могу при желании залезть в стейт процесса и сделать еще много разных вещей. При этом могу сделать хот-лоут в том числе, да, то есть пропатчить на лету. И как бы с этим тягаться очень сложно. И после того, как начал уже это использовать активно, перейти на какие-то другие языки и средства, то есть ты сразу понимаешь, чего ты теряешь. С другой стороны, я как пример приведу, что если ты пишешь на C, C++, то ты точно так же цепляешься отладчиком и видишь все, что у тебя происходит. Люди этим почему-то не очень любят пользоваться, но то есть они, видимо, боятся отладчиков, я не знаю. Но вообще у тебя есть интроспекция ничем не хуже в коде на C++. Но если я правильно понимаю, отладчик все-таки останавливает код? Отладчик останавливает, ну, как запустишь, ну то есть может останавливать, может нет. Подожди, ты сейчас говоришь про отладчик, а не про средства вроде Dead Race, которые прям трассируют. И такие средства тоже есть. Ну то есть, во-первых, ты действительно можешь вообще не останавливать и трассировать eBPF. Во-вторых, ты можешь, например, подрубать отладчик, который выполняет бач скрипт, то есть ты подрубил, выполнил быстренько командочки и быстренько отрубился. Это все равно будет, это все еще посылка сигнала процессу, насколько я понимаю. Это все еще абсолютно незаметно. Ну то есть, возвращаясь к скандалу, пришел средний пауза ГЦ. Ну, пожалуй, да. Поправьте меня, если я ошибаюсь, но правильно я понимаю, что в случае с использованием Dead Race это по сути или системные вызовы, или те вызовы, которые ты изначально добавил возможность их дополнительной трассировки. Если это C-шная программа, то там довольно произвольно. То есть специальное инструментирование нужно, если у тебя есть в системе какие-то интересные события, либо если ты пишешь другую виртуальную машину, как в случае с Erlang, то, конечно, нужно ее инструментировать, потому что Dead Race ничего не знает про Erlang-код, который внутри нее крутится. Но при этом произвольные функции своего кода я могу все равно просматривать, если я не пишу виртуальную машину. Ну, смотри, если честно, если ты не пишешь виртуальную машину, у меня нет супербольшого опыта пользования Dead Race. Но если я правильно помню, честно, я вообще ни разу не пользовался eBPF, просто вообще ни разу. Потому что, ну, как-то не довелось. Локально на маке я несколько раз пользовался Dead Race, и если я ничего не путаю, он позволяет просто C-шную символ, вот, сказать, хочу выдать... Вы видите, каждый раз когда C-шный символ трогается, и такого рода вещи делать, то есть там не сильно отличаются трассировки в Erlang. На самом деле, продолжая про интроспекцию, я что вспомнил, вот есть какой-нибудь Netflix, да, у которого куча денег, и проблема с тем, что в JVM недостаточно много интроспекции для них. Но они берут эту кучу денег и решают свою проблему, добавляя прям поддержку JVM в eBPF, и она сейчас там есть. И ты получаешь не C-шные стектрейсы, а ржавые. Так что всё не так уж по бокс-интроспекции, я бы сказал. Ну, то есть, в основном, понимаешь, у C виртуальная машина, это не виртуальная машина, это ОКС. Я не понимаю, зачем это, да. Ну, потому что вот у Erlang есть виртуальная машина с мощечной интроспекцией, а у C есть операционная система. Она, в общем-то, тоже, ну, как бы, даёт довольно интересное средство заглядывания под капот. Да, это правда. Ну, я хочу акцент тоже сделать. Редже не идёт о том, что Erlang незаменим, или все бросайте писать свой код, ну, в смысле писать сервисы на всех других языках, переходите на Erlang. Вообще нет, просто, как мне кажется, нужно использовать язык и инструменты в зависимости от задачи. И для ряда задач Erlang очень неплохо справляется с ними. Да, я к этому, пожалуй, присоединюсь. И первое, что мне приходит на ум, это для задач типа давайте напишем распределённую базу данных, давайте напишем message broker, опять же распределённый, и вот тут с Erlang довольно непросто тягаться.",
    "result": {
      "query": "Erlang Beam vs Go performance"
    }
  }
]