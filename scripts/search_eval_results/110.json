[
  {
    "segment_id": "2b78fb46-51e9-4308-9b65-8c8001f8f7cb",
    "episode_id": "4d50af58-9789-40ae-86ac-c6e36ebf24e2",
    "episode_number": 110,
    "segment_number": 6,
    "text": "То есть это можно собрать там любым компилятором, совместимым с C99 и получить программу, которая будет уметь HTML и CSS. Вот, насколько я понял, из статьи у него сейчас реализована только парсинг HTML и CSS. И вот он сейчас приступает уже к layout и прочим вещам, которые нужны для того, чтобы сделать картинку. Вот, он утверждает... Секундочку, мне вот интересно, куда он рисовать собрался? Он рисовать просто куда-то в память собирается? В БМП что ли? Ну да, видимо да. Это же как-то бессмысленно беспощадно. Ну почему бессмысленно беспощадно? В принципе так все и делают на самом деле. Ну или нет же, ну как бы рисует хотя бы в бэкгуфер или там еще как-то. Они рисуют текстуры, потом это грузят в память, потом у нас получается так, что в половину случаев эти текстуры постоянно перерисовываются и постоянно перекладываются в память. Все это начинает жрать батарею. Ну в общем, частенько бывает так, что очень эффективно вообще просто рисовать это самое в память и отлично. Ну то есть не важно, у него не цель, я так понимаю, сделать браузер. Я так понимаю, у него цель сделать переносимый рендерер статический. Ну, по крайней мере, он этого не пишет развернуто. Вот, тем не менее, к рендерингу, я так понимаю, переходят только сейчас. И вот важный момент, то что, насколько он пишет, ему работодатель полностью оплачивает это время. То есть он занимается этим фулл тайм, то есть это настоящий проект, который имеет шансы на жизнь. Вот, такая вот штуковина. Кстати, по поводу беззависимости. Последнее время я вижу много всяких библиотек, например, в Скало. Есть такая проблема, то что Скало разделилась на несколько экосистем, из-за того что разные наборы зависимости. Например, есть Twitter stack, есть TypeSafe stack, есть ScalaZ stack, сейчас ещё появится Cat stack. Подожди, там серьёзно, там уже ScalaZ stack? Ну конечно. Там же есть свои стримы, свои акторы, всё как положено. Да, конечно. Например, есть библиотечка HTTP4S, она зависит от ScalaZ, и там, собственно говоря, когда ты получаешь HTTP request на вход, он в виде ScalaZ процесс. Ты должен вернуть в ScalaZ процесс, ну и, соответственно, ты полностью завязываешься на ScalaZ и должен свою программу выполнить в стиле ScalaZ. И, собственно говоря, в связи с этим приходит на ум то, что библиотеки инфраструктурные должны быть zero-dependent, они не должны тянуть за собой ничего. Они должны представлять полностью абстрактный лейер, для того чтобы это можно было совместить с любой, например, продигмальной библиотекой или любым сетевым леером. То есть я хочу библиотеку, которая реализует HTTP и роутинг, я к этому хочу какой-нибудь сетевой леер, любой. Пускай это будет Amnesty, пускай это будет какая-то там самопальная штука, пускай это будут сервлеты, Tomcat. То есть оно должно быть именно так как-то реализовано. То есть идея о том, что zero-dependency, мне кажется, это вообще хорошее движение. Библиотеки надо писать без зависимости, а делать их леерами, которые легко подменяются. Я с одной стороны согласен, совершенно согласен, с другой стороны, там возникает интересный вопрос, особенно когда мы пытаемся написать использующие нети, то там же колбаки, а колбаки их композить тяжело. Ну то есть сказать библиотеке, вот тебе depend, который нети, который depend тебя позовет. И вот тут начинается такое, что код стыковки HTTP архитектора может, наверное, больше, чем писать HTTP архитектурой руками. Я, конечно, наверное, утрирую, но мне кажется, понятно, о чём я веду речь. Да, безусловно, конечно. Иногда бывает так, что библиотеки, их интерфейс настолько сложен, что стоимость интеграции больше, чем стоимость реализации нового. Да, это понятно, но смысл в том, что суть-то в движении. Если мы начинаем всё разрабатывать с прицелом на вот эту слоистость, меняется просто подход. Мы делаем внешний интерфейс более простым, но цель более узкой. То есть мы разрабатываем какую-нибудь библиотеку, которая занимается исключительно, к примеру, созданием структур. Ну то есть, например, есть JSON, парсинг JSON из каких-нибудь классов, джавовских или скаловских. Вот, и, собственно говоря, то есть, например, классно было бы выделить отдельную библиотеку, которая бы занималась только выделением этой структуры. То есть без JSON, без AST, без всего этого дела. То есть был бы такой чисто лейер, который бы занимался исключительно структурой, который бы выдёргивал там поля. Вот, потом бы на это вешался лейер с AST, и только потом бы вешался третий лейер, который бы преобразовал этот AST в JSON текстовый и обратный с текстового JSON в этот AST. Тогда бы мы могли бы композить это очень красиво и легко. Но вместо этого мы имеем монолитные библиотеки, каждая из которых имеет свой парсинг, свой AST и, соответственно, своё преобразование, свой уже какой-то вот машалинг классов. Слушай, а вот у меня вопрос. Правильно ли я понимаю, что хорошим примером такой реализации слоистой, ну не архитектуры, а скорее дизайна является ситуация с логированием в Java? Или всё-таки нет? Мне сложно сказать. Я не очень понимаю этот стандарт. Я его не изучал, я не пользуюсь как есть. То есть я не писал о реализации, и поэтому мне сложно сказать. Не знаю, мне кажется, если смотреть на интерфейс, который даётся для логирования, я бы не сказал, что он идеальный. И я бы не сказал, что он простой. Ну просто есть всегда такая вероятность, если мы будем добавлять на уровень языка программирования, то появится сложность с эволюцией этих интерфейсов, когда они станут стандартными и всеобщими. Понимаешь, как это сейчас в Java развивается медленно. В Scala, конечно, это немножко не так, но тем не менее. Нет, я не понял, почему это должно вноситься на уровень языка программирования. Нет, я не говорю, что, например, тот же JSON или HTTP нужно вносить на уровень языка программирования. Зачем? Я говорю о том, что библиотеки должны заниматься исключительно тем чем-то очень узким, для чего они предназначены. Если у нас есть библиотека для роутинга, то это только роутинг. Если это библиотека для парсинга, она не занимается сетью. Если это библиотека для сети и там, например, выстраивание парсинг-пайплайнов, то это совершенно третье. Практически все делают комбайны и фреймворки об этом. И из-за этого люди начинают писать такие zero-dependency вещи. Потому что управление зависимостью превращается в боль. Получаются гигантские бинарники, начинаются проблемы с совместимостью, которые вылезают в совершенно неожиданных местах. Я в целом поняла твой поент, да. В этом я согласна, потому что мне показалось, что ты изначально планируешь это добавить на более высокий уровень, и в частности на уровень интерфейсов в языке. Просто в таком случае это было бы очень медленно, очень громоздко. Я думаю, можем двинуться дальше по нашим темам. Про биткоин? Давай. Окей, ну в общем мы тут тоже упоминали немножко про биткоин, точнее Денис упоминал. В общем тут еще довольно давно на самом деле появилась статья, она аж январем датирована. Я ее заметил наверное до выпуска 3 назад, мы все переносили-переносили, но мне кажется настало время поранее поговорить.",
    "result": {
      "query": "zero dependency libraries benefits"
    }
  }
]