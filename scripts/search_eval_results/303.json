[
  {
    "segment_id": "01a20272-a47e-4c6d-b3ac-4d0cbb1d4313",
    "episode_id": "b3e47cf1-5c4b-4731-b46d-d742d142acec",
    "episode_number": 303,
    "segment_number": 4,
    "text": "столкнулись с подобной ситуацией, спросить не у кого, а документация как обычно пишется плохо, и как бы есть ещё третьи это забытые флаги, которые чем-то они отличаются от предыдущего типа, но я так не помню чем, не буду его опускаться сюда, вот, соответственно надо с этим как-то уметь работать, надо как-то их уметь удалять, основная проблема с удалением это с тем, что у вас есть много фактически мёртвого кода, который судя по самому коду вы не можете понять, это мёртвый код или нет, потому что это не чисто и в true и поехали, это if get my parameter true или false, и я не знаю, вы сталкивались с такой проблемой или нет, я такую проблему решал где-то год назад, год назад я просто решил проверить нашу основную большую репу, и мы просто составили таблицу всех фичи флагов, которые у нас в настоящий момент используются, плюс мы посмотрели, насколько давно эти фичи флаги менялись по базе данных, и оказалось, что там сотни фичи флагов, при этом за последние несколько месяцев менялось 5% в середине, что-то типа того, но вы представляете себе насколько сложно установить код, когда у вас фичи флаги на фичи флагах, на фичи флагах в одном и том же файле, в одной и той же функции, читать такой код очень тяжело, но править его достаточно сложно, потому что нет уверенности, что вот этот именно код мёртвый, потому что человек может быть мёртвым, человек пришёл, это называется набеговое программирование, человек пришёл, он правит код, который он мало видел, и тут есть какой-то фичи флаг, стоит его удалять, кто ж его знает, пусть удаляют те, кто его добавлял, хотя этого человека возможно в компании уже нет, звучит знакомо или нет? Ну, сталкивались, конечно, с таким, но мне кажется, не в таких объёмах, что наводит меня на вопрос, а тебе не кажется, что, возможно, вы в компании или в команде немножко слоупотребляете фичи флагами? Ну, потому что у меня это выглядело обычно так, по умолчанию фичи флаги не используются, то есть, как бы, если ты раскатил билд с каким-то новым функционалом, и оказалось, что он там плохо работает, его проще откатить и разобраться в проблеме, то есть, фичи флаг, в принципе, используется как исключительная ситуация, например, у тебя какой-то экспериментальный дизайн в UI, ты пока не уверен, он, ну, я сейчас выдумываю ситуацию, ты не уверен, он там, как бы, хорошо влияет на продажи или плохо, и ты поэтому выкатываешь, что там даже не фич флаг, а на процент пользователей, фича раскатывается, у моего рояда называется джигурда, потому что никто не знал, как это назвать, и тогда было модно шутить про джигурду, и он назвал функцию джигурда, чтобы она возвращает true или false в зависимости от хэша, от пользователей типа того. А там есть джигурда 5, 10, 20, там, знаешь, персентили, проценты? Ну, это, ну, собственно, ты, ну, у тебя, вот ты описал ситуацию, когда у тебя флаг true-false, а когда у тебя много пользователей, и, ну, может быть, такое, что ты включил фичу на всех, да, и у всех все сломало, вообще непонятно, да, поэтому включается, вот, типа, включить на 0.5%, посмотреть, там, взорвется, не взорвется, если не взрывается, включить на 1%, ну и так далее. Ну вот, ну, в принципе, то есть та же самая идея, просто ты вскатываешь на процент пользователей. Ну, это примерно то же самое, о чем я говорю, когда говорю про фичу флага, которая на A-B-Test раскатывается, ну, в общем-то, A-B-Test обычно определяется, как процент пользователей или как-то еще, то есть, может быть, процентов пользователей, может быть, как какой-то признак пользователя. Да, но A-B-Test для другого обычно, все-таки. Вот, но я в целом веду к тому, что… На самом деле, чисто с точки зрения механики, именно сам функционал мы использовали и так и так. Да, да, да, да. И A-B-Test в плане работать не работает, и A-B-Test в плане мы будем смотреть на результаты A-B-Test как, ну, как пользователи. Да, поэтому Uber относит это все к одному, то есть это одно и то же просто для разных целей, использование для разных целей. Я все ввел к тому, если вкратце, что не возникало на моей практике такого, что типа у вас сотни фич флагов, потому что если у тебя есть такой ключ, он включает фичу, и в пределе она все равно будет включена на 100%, то это флаг, он выйдет. Более того, ты там, когда старевого джиря ведешь или что, то у тебя там все равно есть тасочка про выбор и этот флаг, потому что мы его все равно раскатили на 100%. Вот. Ну и просто такого не возникает. Тут начинается интересное. То есть как бы насчет вот раскатки на 100%, вот, короче, у нас не было сотни фич флагов одновременно, потому что у нас, ну, как бы все-таки команда одной игры была достаточно быстрой, и у нас не было необходимости координировать фич флаги между играми. Но в целом я могу понять компанию вроде Uber, где 2000 инженеров. Я не знаю, зачем там именно 2000 инженеров, но вот факт, что у них есть 2000 инженеров, огромный штат, и они все фигачат в общем-то один продукт, продукт, у которого могут быть флаги, которые вам, не знаю, через сервисы пропущены. И у тебя может быть состояние, когда у тебя в одном сервисе уже он готов, все точно работает, а другой сервис сейчас не до этого. Или вот, например, из моей практики, что фича вроде работает, технических племен нет, но типа продукты не уверены нужны ли она до сих пор, потому что вроде обы тесты, как бы, engagement вроде не падает, а вроде лучше не становится. Давайте еще посмотрим. И короче, у тебя фич флаг может, не знаю, год жить. У тебя task of jury уже закрыто, потому что ты все сделал, продукт просто не может решить, а продукт не может решить. Ну я думаю, все-таки надо разделять фич флаги и обы тестировании. То есть в моем понимании, как бы какая-то разработка… Ну, механизм-то работает одинаково. То есть ты можешь называть это разными функциями у себя в коде, но по факту это идет в один сервис. Мое понимание, что если ты делаешь обы тестирование, у тебя есть два полноценных функционала интерфейса whatever. Они два существуют одновременно. Они включены на разных пользователей, находятся в суперпозиции. Вот, но у тебя нет такого, что тебе их нужно включать или выключать. У тебя просто продукт так хитро выдуманно устроен, что в нем одним пользователям подсовывается одно, другим другое. Поэтому у тебя нет проблемы, собственно, с флагом. Нет, ну я про то, что у тебя код… В том плане, то я описываю, что у тебя в итоге продолжительное время у тебя продукт находится в суперпозиции. То есть у тебя одновременно два кодов, один из которых, скорее всего, не нужен. У тебя одновременно как бы… Притом, знаешь, это еще особенно плохо, когда у тебя есть какая-то другая печаль, которую нужно наделать, и она трогает оба пути. Такой, блин, какого хрена этот обы тест еще не закончен, или этот фича-флаг не на всех раскатан. Я нашел в бумаге количество, которое предоставляет Uber, и с помощью пирания они удалили 1381 фича-флаг, и осталось 6601. Так для информации. То есть наши сотни, это прямо рядом стоит с Uber. У меня есть знакомый, который не так давно ушел работать в Uber, и что-то мне сейчас… Я бы не сильно завидую. Давайте так скажем. На самом деле, Саш, оно возникает, это все очень органично. То есть как бы тебе это воспринимается как что-то нестандартное. На самом деле, представь, что есть, не знаю, десятки команд. У каждой команды есть куча экспериментов, которые они одновременно проводят. То есть, не знаю, 15 человек работают в команде, и три работают на тем, как пользователи реагируют на такую табличку, и эти два, как там, зеленые кнопки или красные, третьи. И таких экспериментов идет куча. Плюс аналитики, которые пытаются как-то оптимизировать что-то, плюс еще… И возникает, на самом деле, такая вроде как текучка, когда у тебя постоянно создаются и удаляются фича-флаги. И если еще я правильно понял, это не так, что они все обязательно с друг другом языком одействуют, они все-таки как-то… Независимо. Инкапсулируются в сервис или еще как-то. То есть, мы говорим про вот эти тысячи, это не в одном монолите, а в компании, правильно? Да, да. Тогда это может быть не так безумно. На самом деле, это может быть один большой монолит, просто это будут разные куски этого монолита, которые, в принципе, слабо взаимодействуют между собой. И получается, что каждый маленький сервис может рассмотреть добавление себе фичи-флага для того, чтобы понять, как оптимально использовать что угодно ты можешь тестировать с помощью фичи-флагов. Поэтому эти сотни тысячи выглядят не так плохо. Значит, какие возникают сложности? Я частично это описывал в проблемах, но здесь чуть больше про это. Сложностью возникает следующее. Во-первых, насколько сильно ваш менеджмент этих фичи-флагов может работать с фичи-флагами? То есть, скажем, наша система, которая ведет эти фичи-флаги, она постоянно развивается. Если бы я сейчас ее проектировал с нуля, я бы сразу заложил кучу дополнительных плюсов. Один из выводов, кстати, статьи Uber, это то, что каждый фичи-флаг должен обязательно must have дату, когда он оканчивает работу. Разработчик, аналитик или еще кто-то должен точно поставить дату. И вот если эта дата поставлена, когда доходит эта дата, автоматически возникает аллерт, который ссылается оунеру и команде, которая создала этот фичи-флаг. И с вопросом типа, что-то делайте с этим, давайте, посмотрите, у вас дата пришла. Соответственно, они должны либо удалить, либо если оно еще используется, сказать, слушайте, ну, мы пока еще используем, давайте вот следующая дата. А если удалить, автоматически создается таска, автоматически получается какой-то приоритет и так далее. Ты не можешь просто так избавиться от этой штуки. Это для того, чтобы у вас не появлялась куча мертвого кода. Потому что судя по этим, по... я вот сейчас не могу и найти цифры в статье, но вот эта пирания, она позволила удалить код. 1300 вот этих вот фичи-флагов было удалено с помощью пирания. То есть это не полностью автоматическая система, но это 75 тысяч строчек кода было удалено из-за того, что удалились вот эти фичи-флаги. То есть вы можете себе представить, какая чистка происходит просто из-за того, что фичи-флаги удаляются. Это очень-очень полезная вещь. Мертвый код – это замечательный код. В одном смысле, когда ты его удаляешь. Чем меньше кода, тем лучше. Идеальный код, отсутствующий код. Что там еще было, я забыл? Лучшая программа, та, которая не была написана. Да, да. Вот. Одна из больших проблем, и тут я сразу вспомнил Google, компанию Google, то, что удаление мертвого кода само по себе, оно очень часто не добавляет тебе никаких плюсов в карму в компании. Очень мало компаний, которые тебя вознаграждают хоть как-то за то, что ты удаляешь мертвый код. Очень часто плюсуется, увеличивается карма за то, что ты сделал новую фичу или выкатил новую функциональность. Помните, мы обсуждали то, что Gmail интерфейс меняется каждый год, потому что за это раздают плюшки и бонусы. И ты что-то улучшил, что-то изменил, оно ушло в продакшн, вот тебе плюшка и повышение, и следующий, кто там на очереди стоит, давай Gmail меняй опять. А удаление не дает никаких плюшек. Поэтому либо ты это делаешь обезаловкой, либо ты меняешь культуру компании, чтобы удаление кода, то тоже давались какие-то плашечки. Он великий удалятор, знаменитый Мойда Дэр и вот это все. Вот. И... так, и переходим к пиранию. Пирания это система, которая написана для трех языков. Objective-C, Java и Swift. Это система, которая анализирует код, строит AST и пытается определить, в каком месте используются какие фичи флаги. Ты на вход системе подаешь флаг, который ты хочешь рассмотреть, удалить или как-то поменять. И передаешь владельца этого флага. Я так понимаю, из владельца автоматически вытаскивается команда, которая этот владелец принадлежит. И что ты хочешь с этим фичей флагом сделать? Ну, самое частое использование, конечно же, удаление. Хотя, возможно, здесь есть какие-то другие использования, но я в статье не нашел. Может быть, надо найти в коде. Я не очень понял, как использовать еще можно эту систему. Мне кажется, самое правильное использование это удаление фичей флага. Она, соответственно, строит дерево и пытается понять, в каком месте этот фичей флаг используется. Все использования этого фичей флага она вытаскивает. Вот в этом treatment behavior это второй параметр. Ты определяешь, что показания всегда... Когда мы удаляем фичей флаг, состояние вот этого... Как это правильно сказать? Код клиента, который возвращает значение этого параметра, оно всегда true, грубо говоря. Потому что у вас фичей флаги могут быть разные. True, false, 15, 26, что угодно. И, соответственно, пераняя, анализируя код, строя AST, она автоматически видит, что в случае, когда у тебя true, у тебя код исполнения идет по этой ветке. И, соответственно, вторую ветку исполнения она может удалить. Соответственно, вот эти все параметры, потому что ты должен делать со второй веткой исполнения, ты каким-то образом передаешь в пераню. Я код не смотрел, сказать не могу. Но здесь есть несколько вариантов, что ты можешь удалять. .. Да. Что... Три показателя, что ты можешь делать. То есть, первое, это удалять код, который напрямую окружает фичей флаг. То есть, прямо рядышком находится. Во-вторых, ты можешь попытаться удалить код, который стал недоступен, из-за того, что фичей флаг больше не используется. Ну, например, ты удалил его здесь, а там есть еще какая-то функция, которая, возможно, используется, возможно, не используется. Ты можешь делать агрессивные настройки для того, чтобы удалить все подряд. И третье... То есть, код анализируется, смотрится, что вызова функции, вот той функции, больше нет. Она вроде как верхнего уровня, но вроде больше нигде не используется. Давайте попробуем это удалить, типа такого. И третье, это удалять все тесты, которые были связаны с фичей флагами или с тестированной функциональностью. Ну, например, вы удаляете эту функцию, заодно давайте удалим все тесты для этой функции. Ну вот, насколько я понимаю, это все можно конфигурировать при вызове пираньи. И, соответственно, все сильно зависит от разработчика, как он сам запустит пиранью. В чем здесь проблема? Проблема в том, что... Подожди, подожди, подожди, это разработчика от индивидуального контрибьютора или от всей команды, как они себе пираньи заинтервировали? Это чуть дальше покрывается. Хороший вопрос. Здесь пока в данном разделе они говорят, что пиранья – это тула, которую ты можешь запустить сам. Как они ее предлагают запускать, это в следующем разделе. Они предлагают это интегрировать в CI. И более того, там даже тулую вокруг этого CI они понастроили. В чем проблема данного подхода? Проблема данного подхода в том, что, во-первых, когда ты анализируешь AFT, ты должен быть очень-очень сильно уверен в своем анализаторе, в своих способностях и в своих программистах, потому что, если ты сделал что-то неправильно, ты можешь испортить программу причем так, что ты зафокапишь все. И, соответственно, во-первых, ты должен обладать эту верностью, что ты все сделал правильно, во-вторых, это просто тупо сложно. Тупо сложно, потому что многие языки... Я не уверен насчет этих трех перечисленных. Я ни на Swift-N, ни на Object-VC, ни на Java много не программировал. Но многие языки позволяют обходить и делать всякие либо прыжки, либо... Например, вот у нас одна из проблем, которая была во время анализа того, какие фичи-флаги используются. Чаще всего фичи-флаги используются так. А скажи мне, пожалуйста, значение фичи-флага, тестируем функциональность ABC. Если это true, сделаем то, если false, делаем то. Очень просто это проанализировать. Гораздо сложнее, если делается так. Так, возьмем тип сегментов рынка, сегментов рынков 300. Возьмем тип пользователя, типов пользователя 4. Сконкатинируем их через двоеточие. Добавим слово тестирование, и название вот этого строчка, это будет название фичи-флага. Вытащим значение этого фичи-флага из базы. Попробуйте проанализировать как-нибудь это автоматически. Но это достаточно сложно. Не то, чтобы совсем невозможно. У нас есть полная база всех фичи-флагов. Но автоматизация этой штуки становится не тривиальной затеей. Тем более, что фичи-флаги могут добавляться в процессе. Вы анализируете код и текущее состояние базы, а завтра зайдет аналитик и добавит новый фичи-флаг. Вы что-нибудь поудаляете, а окажется, что что-то не работает. И получается такая сложная задумка. И поэтому они решили, что мы не можем сделать полностью автоматическую систему. Мы сделаем автоматическую систему, которая предоставляет пользователю результат своей работы. А дальше пользователь решает, что с этим делать. И поэтому код пирании на выходе выдает дифф. То есть вы вызываете пиранию с тремя конфигурациями. Пользователь, название фичи и как работать с кодом на стройке. А на выходе получаете дифф, в котором программа удалила использование этой фичи. Удалила, возможно, код, который стал мертвым из-за этой фичи. Возможно, удалила тесты, которые теперь не нужны из-за того, что вы удалили мертвый код. И вот этот дифф, фактически, это и есть результат работы пирании. Что с нами дальше делать, это как бы зависит от вас. Здесь есть некоторое описание того, как производится рефакторинг. В частности, логично, что если мы вызываем ifcondition, либо b1, branch1, либо branch2. И condition, соответственно, если вы говорите, что у меня фичи флаг всегда true, то надо всегда делать b1. Фактически, вот этот if с двумя branch'ами преобразовываете в безусловный переход на branch1. Но и вот таких преобразований достаточно много. 7-8 штук. Объяснение, почему именно так делается. Если захотите посмотреть и подумать об этом, зайдите в пейпер, тут расписано. Но они пошли дальше, они подумали, как бы надо же что-то с этим делать. Как это автоматически использовать и как вообще заставить пользователей это делать. И они это сделали в виде еженедельного запуска пайплайна. То есть у них есть специальный CI-Pipeline, который запускает перанью. И делает это в следующем виде. Во-первых, они имеют базу всех фичи флагов. Во-вторых, у них есть эвристика, которая показывает, насколько данный конкретный фичи флаг уже устарел. Такой stale у них есть описание. На самом деле это сложный вопрос. Как определить, фичи флаг устарел или нет? Что использовать в качестве эвристики? У вас есть какое-нибудь определение? Чтобы немного монологму разборить. Для базов, которые в него ходят, как минимум, самый важный признак будет то, что его вообще не забирают. Скорее всего, его вообще не используют. Или, когда его забирают, получается, каждый раз одно и то же значение. Я бы предложил другую эвристику. Как давно менялось значение true-false, значение процентов? Как давно он обновлялся? Да, очень хорошо. Я согласен. Мы использовали обе эти эвристики, когда мы это работали. И получилась очень удивительная ситуация. Большинство флагов не менялось. Проценты обновлялись за последние два месяца. Все остальное не менялось. Но из этих сотен неиспользуемых, не помененных, stale, на самом деле 4 или 5, они до сих пор актуальны. Да, мы сейчас это не делаем. Но у нас есть 5 платежных систем. И иногда эта платежная система просит нас временно отключить. Это не было 3 месяца. А 3 месяца назад это было. И они, возможно, попросят нас завтра сделать то же самое. И мы в этот момент приходим и переключаем фичу флага. То есть автоматически это сделать достаточно сложно. Так может быть, это в такой момент перестает быть фичу флага? И становится просто фичой? Что там отключаемая платежная система? Да. Но это же хочется, во-первых, иметь возможность как-то аудировать. То, что мы описывали с Валерой, что лагировать, иметь возможность менять через какой-то UI и так далее. То есть чтобы звонок от этой системы продукту не заставлял человека какого-то что-то переписывать. То есть получается, что у нас у фичи флагов получается еще одна дополнительная функциональность. И это просто становится удобным способом работы с кодом. Я бы вообще такие вещи сделал бы частью бэк-офиса. Я не знаю, есть у вас бэк-офис, нет, но мне кажется, должен быть. И там в каком-нибудь разделе офигенные ручки, вот прям для продукта сделан, чтобы он мог заходить и включать и выключать платежную систему хоть 10 раз в день. Да, но ты тогда для этой системы должен делать все то же самое, что ты сделал для системы фичи флагов. Зачем делать это, если у тебя уже есть система фичи флагов, которая все это позволяет? Это реализация обсуждаема. Ты можешь делать фичи флаги с пометкой в своем списке фичи флагов, что это на самом деле не фичи флаг. Да. Раз оно то пошло, у тебя сами фичи флаги наверняка реализованы поверх DTCD или Consul, в котором ты можешь хранить и кучу всего другого. Возникает вопрос, как правильно работать с фичи флагами. Кто вводит эти фичи флаги, должен обязательно поставить эту галочку. А в тот момент, когда это изначально вводилось, оно не было такой типом функциональности, оно этим стало после, когда это началось просто… Ну и короче, возникает куча уже организационных моментов, которые достаточно сложно поменять. Но ты понял идею, я согласен, что можно такое сделать. И, соответственно, Удар пришел к выводу, что надо запускать эту юристику по определению, насколько это флаг stale или не stale. И еженедельно сформировать вот эти диффы для всех stale флагов и отправлять их разработчикам. Насколько я понимаю, их система автоматически генерирует что-то вроде полреквестов. В полреквестах они указывают автора, соответственно, команду и посылают. Возможно, у них там есть проверка того, что мы это уже запускали, и они сказали, что мы не будем там, чтобы не было дубликатов и так далее. Но вот такая система у них работает, и это привело к тому, что они удалили 1300 штук. Ну, мне кажется, это неплохой результат, но оказалось, что это не единственный результат, который они здесь обсуждают. У них в статье есть куча-куча интересной статистики, потому что они помимо того, чтобы сделать. .. Двадцать секундочку, передо мной мы перейдем к статистике. Человеку, который все это придумал, осознал, сколько денег компания теряет на разработчиков, которые в этом легасе ковыряются и так далее, и выкинул все эти кучи-кучи строк-кода, его на перфоманс-ревью оценили, премию дали? Хороший вопрос. Уволили или нет? Давай начнем с такого. Не знаю, здесь не написано. Но дали ему, по крайней мере, статью оформить, это уже неплохо. Ну, мне интересно, как он измерял в деньгах или времени пользу от этого. А может быть, не нужно было делать? Мы это измеряли тем, что мы показали, сколько мертвого кода мы можем удалить, в связи с тем, что мы... Если мы удалим весь этот код. Я оказалась, что это прям существенная часть кода. В смысле, я думаю, почему-то не пофиг. В смысле? Объясни. Можно я чуть-чуть иначе сформулирую. Я думаю, метрика, которую ты озвучил, не очень показательна для бизнеса. Что бы я сделал, как бы я предложил бы, я бы предложил некоторые метрики, что-то реально измеряемое, типа, сколько у нас занимает ревью одного полуреквеста, сколько у нас делается фича. Ну, ряд таких метрик, как бы договорился, что да, они показательны. Сделал бы изменения и сказал бы, смотрите, у нас там время кода ревью, видимо, сократилось на 1 час, например. Мы примерно так и сделали, но на самом деле... Ну, конечно, теперь-то, когда я объяснил, вот так и сделали. Нет, ты меня просто перевел и не дал договорить. Но по факту это, на самом деле, очень сложно доказать бизнесу в любом случае. Пока это не измеряется в деньгах, это доказать тяжело. А вот эта штука очень тяжело измеряется в деньгах. Но, нет, подожди, время разработчика прямо измеряется в деньгах. Ты не можешь привязать время разработчика к этому. Время кода ревью чаще всего не меняется. Ну, или меняется так, что это статистически... В общем, это становится погрешностью. Ну, если у тебя действительно не изменилось время кода ревью, время разработки фичей и так далее и тому подобное, то, выходит, это действительно было достаточно постараться тратить время. Вот такая вот нелогичная логика, которая в принципе доказывает, что Uber все чертям неправильно сделал, и зря они эту систему добавили. Нет, на самом деле, Саш, не получится тебе привязать, потому что здесь... Ну, то есть, по факту, мы вот сейчас после того, как мы, я не знаю, полгода работаем с этой кодовой базой, сейчас это же делаю не я, это сейчас сделает специальная команда, которая по результатам нашего подхода была сформирована, оказалось, что вся вот эта работа очень сильно улучшает... может быть, приведена к количеству денег, которые мы сохраняем. И поэтому бизнес очень радуется. Но в момент, когда ты начинаешь эту работу, очень тяжело это доказать. Так нет, подожди, я вот сейчас вообще не очень тебя понял. Дай пояснить. Ты же предлагаешь ими, зачем ты говоришь, вот я предлагаю изменения, которые позволят сэкономить деньги, я предлагаю, или там время, я предлагаю вам измерять так-так-так-так, как ты ожидаешь увидеть результат до того, как ты сделал эти изменения. Ну, то есть ты сказал, когда ты начинаешь делать эту работу, то как бы результат не очевиден, естественно он не очевиден. Ты, у тебя, он должен, результат, ты делаешь работу, результат которой позволит сэкономить деньги или время, как ты ожидаешь увидеть до того, как ты сделал эту работу. А здесь, я понял твой вопрос, здесь, знаешь, что получается, что это конфликт внутри личной моей головы, возможно и кого-то еще, я лично вижу. У меня это, знаешь, на таком чувственном уровне находится, как человек сильно отвлекается на мертвый код, который мешает ему работать и тестировать. Я даже ради этого специально нашел парочку проблем, ну там, не аутэджи, ну аутэджи низкого уровня, которые были из-за того, что мертвый код присутствует в системе. И только вот эти вот несколько подобных доводов помогли мне доказать это. Хотя вот у меня это лично находится на чувственном уровне и мне очень странно слышать, когда люди говорят, мы не понимаем, как это улучшит время разработчика и время разработки, количество денег сэкономит и так далее. Ну это нормальный вопрос, они не технические специалисты. Да, да, да, да. Они действительно не понимают. Да, я понимаю, ты просто спрашивал в таком ключе, что как бы, для меня это очевидно и поэтому, как я собираюсь доказать, для меня не надо доказывать, для меня это понятно, как бы, из определения. Ну, ты же тебе, как-то продал эту идею. Да, я как-то продал эту идею, да. А с чего мы сюда перешли? Ну, с того, что недостаточно просто продать идею, нужно еще и показать результат ее, да. Да. Ну, потому что действительно достаточно крупной компании тебя спросит, о чем ты последние полгода занимался. Ты такой, а я сделал систему, которая выкинула нам, не знаю, 10 тысяч флагов, типа и чего? Ну, нужно доказывать, что ты сэкономил, то, что ты был очень полезной шестереночкой. Полезной шестеренкой, да. И вот это как-то обидно, то есть я же это чувствую, зачем мне это доказывать, дайте мне просто улучшать. Я верю, а вера доказательности не требует, действительно. Вот, вот. Как хорошо, что мы понимаем друг дружку. Как жаль, что ты не работаешь в нашей команде, в компании каким-нибудь большим-большим человеком. Ой, я не ту кнопку нажал. Итак, пошли дальше. Uber, помимо того, что запустил эту систему, они начали собирать статистику, как эта система используется и каким результатом она приводит. Ну, вот, наверное, для того, чтобы хоть как-то опроводать потраченное время и деньги. И оказалось, что тут здесь на самом деле куча статистики, куча разных графиков, не все из них интересны. Вот, оказалось, что в... Да. Так, так, так, так, так, так, так, так, ага, вот. Количество флагов удаленных из системы больше всего было на Objective-C 782, на Java и Swift 284 315. И здесь есть целая там часть страницы, которая посвящена объяснению, почему вот именно Objective-C так много, а все остальное так мало. Но как-то вот, как-то даже немножечко смешно читать. Ну, у каждой компании есть своя кодовая база, даже просто от размера кодовой базы сильно зависит. Вот, но оказалось, что Objective-C код легче удалять с помощью этих флагов, и поэтому люди, которые смотрели на диффы, которые делает пиранья, с удовольствием начинали работать на Objective-C диффами, потому что они были очень простые к исправлению. Ну, там надо было еще парочку строчек там что-нибудь добавить или удалить, и оно все пошло работать. А с Java и Swift все было сложнее. Вот. Так, так, так. Это вся статистика. Количество удаленного кода. Да, вот. Вот интересная статистика, что вот как раз она хорошо показательна тем, что после того, как пиранья сработала на Objective-C коде, 99,5% из предложенных изменений сразу автоматически проходили весь CI, pipeline. Ну, в смысле, все тесты и все работало. На Java 70%, на Swift 78%. Это как раз объяснение. А до? Ну, предполагается, что до все работало. То есть мы запускаем на работающем коде, 100% тестов проходит, прогоняем пиранию для какого-то конкретного флага. На Java 70% вероятностью после этого оно заработает сразу. А, я тебя не так понял. Я решил, что это разговор по пользу от выкидывания кода. Что, типа, раньше, когда люди комиссили код, он иногда не проходил в CI, а когда мы выпили кучу говнокода, он стал больше проходить в CI. Ну, чаще. Понял. Я неправильно объяснил, наверное. То есть это именно про то, насколько пиранья генерирует правильный код. То есть удаление кода из object.fc на 99,5% хорошее. Поэтому все тесты и так далее проходят. С Java и Swift все хуже. То есть пиранья хуже работает с этим кодом. Или потому, что пиранья так заточена, или потому, что код сложнее, или потому, что языки тяжелее поддаются подобному анализу. Дальше интересная статистика, сколько линий понадобилось дополнительной изменить для того, чтобы этот pull request протащить в систему. И оказалось, что одну линию изменить – это 20%, две линии – это 37%. Я думаю, строчки. Ну да, строчки. Я прошу прощения, мне тяжело переводить и одновременно читать. Короче, меньше трех строчек – это 65%. Для меня это прям хороший результат. То есть я присылаю pull request на довольно большие куски. Я не помню точную статистику. Ну короче, тут прям бывают кило строчек. Изменяются диффы. И надо поменять одну, две или три строчки в 60% случаев. Но это прям офигенно, мне кажется. И у них даже есть дополнительная статистика, сколько дополнительных предупреждений и напоминаний посылала система, прежде чем пользователи начинали исправление по данному pull request. Ну, такая вот странная статистика. Последняя секция – это рекомендации. И вот прямо рекомендации, я как начал читать, я прям плакать начал. Вот это все то, что мне очень хочется сделать, а лучше бы с самого начала в системе введения фич в у нас системе в частности. Я не буду здесь ничего говорить, комментировать. И почитайте сами, посмотрите. Вот. Вот такой интересный тот. Ну, что ты вредничаешь? Какие там рекомендации? Ну, прям вот меня выпытываешь, я не знаю. Ну, вот про эту дату экспирации, когда фич флаг становится неволидным, это прям первым пунктом. Я здесь полностью согласен. У нас такой штуки нет, я хочу ее вести. Я, возможно, сейчас говорю секрет на секрет, поэтому давайте шепотом. Слушай, у нас со слушателями очень доверительное отношение. Мы уже 6 лет записываем подкаст, и ни разу ни один слушатель наш секрет никому не разболтал. Точно, точно, точно. Вот. Второе. Автор. Должна быть система, которая, возвращаясь к развитию фича-флагной системы, должна быть дополнительная настройка к системе, которая трекает, кто владелец данного фича-флага, если владелец данного фича-флага уходит, она должна автоматически кого-то назначать. Ну, например, лидера его команды, откуда он ушел, или лидера команды. Ну, то есть все выше-выше по иерархии, чтобы тот кого-то назначил ответственного. Вот. И ввести обязательную систему в организации, что вот переназначение ответственности это становится как бы рутиной и стандартной практикой. Вот. Мне кажется, довольно интересная идея. Я не думал об этом ранее. У нас как бы владельцы этой команды, и передача фича-флагов от команды к команде существует. Вот. Но то, что отдельно взятый человек будет ответственный, который как бы знает, что это такое, и знает, как с этим работать, это интересная идея. Прилагают разные изменения к API, чтобы API, упрощение API, проверки текущего фича-флага, его состояние. В частности, они рекомендуют, чтобы был только Boolean. То есть, чтобы никаких чисел строк, ничего такого не было. Был Boolean да или нет. Это упрощает очень сильно автоматизацию проверки, это очень сильно упрощает понимание кода. Если ты хочешь проценты, то ты делаешь 7 Boolean, потому что 2 в 7, ну ты понял. Ну, это если ты умный, а потому что если ты глупый, то ты делаешь 99 их. Вот. И, в принципе, наверное, из важных, которые я бы хотел отметить, наверное, все, хотя здесь десяток, даже больше. И запускать периодически проверку и удаление мёртвого кода из-за того, что фича-флаги не используются, потому что они говорят, что мы пытались сделать это периодически, а потом поняли, что если это не делать каждую неделю, то это никогда не будет сделано. С этим я тоже согласен. Вот такая вот система. Я посмотрел код на GitHub, на GitHub доступные исходники. Код написан, как это ни странно, на нескольких языках. Javascript, Swift, C++, Objective-C, Shell, AsiMake. Но очевидно, что на тех языках, на которых он должен работать, он должен быть написан. Плюс какая-то общая обязка. Я надеюсь, что было в этот раз не скучно, хотя Валера что-то отмалчивался. Валера, расскажи мне, пожалуйста. Я вначале активно всё отвечал, а сейчас просто не знаю, как это. Не то чтобы скучно, просто я тебя слушаю, а Саша вон отвечает. Ты на каком сейчас языке пишешь, Валер? Я пишу на языке скала. Скорее просто вопрос в том, что ты под конец обсуждаешь проблемы большой-большой команды, а я никогда в такой большой-большой команде не работал, и мне это немножко чурдой. Я просто думаю, может быть, тебе стоит как-нибудь попросить, ты сделай поддержку скалы в пиране. Мне кажется, это полезно и функционально. Всё-таки Open Source, надо как-то развивать его, улучшать меня. Знаешь, вначале нужно дождемся скала 3. Хочу тебе сказать, что работа большой-большой команды, она выглядит как работа в обычных командах, в которых ты работал, потому что без декомпозиции на отделы, там по 7 человек, которые как-то взаимодействуют, это в принципе не будет работать, поэтому твой опыт в экзанте или ещё где-то вполне применен. Не, ну смотри, просто не бывает в маленьком отделе, когда у тебя большая-большая компания не распилена на маленький отдел, у тебя не бывают трех странных задач, типа давайте мы будем поддерживать тысячу фичи флагов, которые в разных командах, и там типа нужно их передавать между командами, вот-вот, но таких вещей",
    "result": {
      "error": "API request failed: Error code: 429 - {'error': {'message': 'Rate limit reached for gpt-4.1 in organization org-xSG9D345gtYlIKC330wCyrEG on tokens per min (TPM): Limit 30000, Used 30000, Requested 15582. Please try again in 31.164s. Visit https://platform.openai.com/account/rate-limits to learn more.', 'type': 'tokens', 'param': None, 'code': 'rate_limit_exceeded'}}",
      "stack_trace": "Traceback (most recent call last):\n  File \"/home/andrei/Projects/podcast-shownotes/scripts/build_search_eval_dataset.py\", line 157, in generate_search_query\n    response = await self.client.chat.completions.create(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/resources/chat/completions/completions.py\", line 1927, in create\n    return await self._post(\n           ^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1767, in post\n    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1461, in request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1547, in _request\n    return await self._retry_request(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1594, in _retry_request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1547, in _request\n    return await self._retry_request(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1594, in _retry_request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1562, in _request\n    raise self._make_status_error_from_response(err.response) from None\nopenai.RateLimitError: Error code: 429 - {'error': {'message': 'Rate limit reached for gpt-4.1 in organization org-xSG9D345gtYlIKC330wCyrEG on tokens per min (TPM): Limit 30000, Used 30000, Requested 15582. Please try again in 31.164s. Visit https://platform.openai.com/account/rate-limits to learn more.', 'type': 'tokens', 'param': None, 'code': 'rate_limit_exceeded'}}\n"
    }
  }
]