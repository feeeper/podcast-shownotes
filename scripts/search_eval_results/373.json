[
  {
    "segment_id": "56594a45-4466-430a-875d-8f05cbb32c86",
    "episode_id": "7dbfffc3-9d29-44be-b827-3714e7c52eb8",
    "episode_number": 373,
    "segment_number": 4,
    "text": "уже здесь есть, по почте, по почте дошли. Слушай, но у вас там все неправильно, наоборот. Ну да, да, да, вот это левостроение движения, рулина с той стороны, вот это все, да, да, но зато можно ездить на японских машинах без смены руля, тоже плюс. И у меня был еще один пункт, что я узнал, я узнал, что AliExpress поддерживает карты Мир, а виртуальную карту Мир очень легко и просто сделать в приложении Тинькофф. Вот, к сожалению, визу на AliExpress больше не работает, и мне очень нравится eBay как сервис, но они отказываются позволять мне совершать покупки, поэтому я искал альтернативу и был при этом удивлен вот этим фактом, что AliExpress принимает Мир, потому что его принимают не везде. Вот такая интересная информация. У кого еще? Свет, ты что-нибудь научилась за неделю? Я пытаюсь вспомнить, что можно этого рассказать, научилась, пожалуй, в другой раз расскажу, чему я научилась, от такой клипхэнгер. Хорошо. А у кого еще есть интересная информация для поделиться, это Валера. Да, это тоже, в общем-то, то, что я выучил за неделю, но вручания немножко больше, чем на два предложения. В общем... Рубрика «Дед Валера стал нестойной дед», да? Да, ну, рубрика «Дед Валера кричит на слонов». В общем, есть такая база данных Postgres QL, в ней есть такой тип данных – JSON-B. То есть, там есть два типа данных – JSON и JSON-B. JSON – это просто строка, которая семантически, которая Postgres способен проверить, что она содержит в себе синтексически корректный JSON, а синтексически некорректный JSON не положится. JSON-B – это нормальное внутреннее Postgres-овое представление, бинарное JSON-ов. Разница в том, в чем разница между типами. Если вы хотите сохранить оригинальное текстовое представление и просто провалидировать, вам нужен JSON. И он почти никогда не нужен, потому что это вот те редкие кейсы, когда вы просто хотите положить документы, как есть, и с ним ничего особо не делать, не индексировать его, не производить с ним манипуляции, ничего, потому что, конечно, каждый манипуляция с ним – это парсинг. JSON-B – он парсится один раз. Можно еще про... Прости, в защиту типа JSON скажу, что поскольку он хранится как текст, то если он вдруг как-то хитро отформатирован со ступами еще с чем-то, что вам вы хотите сохранить, то JSON тоже для этих случаев. Да, еще есть какие-то странные вещи, типа повторяющихся полей и прочей такой черни. А если вы хотите именно манипулировать с JSON-ом, в частности, по нему индексы строить, вам нужен JSON-B. Он один раз при вставке разбирается и дальше хранится в ком-то встроенном бинарном формате. Ну нет, технически ты можешь сделать функциональный индекс по JSON. А JSON, да, но это будет не очень... Это может не очень быстро работать. Так вот, это все неважно. Я упомянул тип JSON просто для справки, что в Puzzle Gays есть несколько типов, которые делает JSON. Обычно, когда вы храните в Puzzle Gays JSON, вы его индексируете GIN-индексами, потому что вам обычно нужно какие-то отдельные кусочки JSON индексировать. Но когда вы изобращенец, вам может хотеться положить весь JSON, который вы положили в это поле, в B дерево. Это редко, когда такое бывает нужно, но вот нам понадобилось. Почему так? Потому что обычно это очень короткий JSON, который состоит вообще из буквально одного значения, но в некоторых случаях он больше. И тут начинается интересное, потому что в JSON, в тип JSONB можно положить просто столько, сколько в Toast влезает, там кажется 4 ГБ в Toast влезает, может Сашим его правит. Нет, там терабайт ограничение. Терабайт? Окей, вот. То есть, технически JSON... По-моему, я просто сейчас засомневался. Anyway, технически в JSONB поле можно запихать короче, бесконечно много данных. Очень много. А вот в B дерево, в одну запись в B дереве можно положить не больше, чем 2,5 кб, примерно. Там, не помню точно, типа треть страницы по размеру. Я не знаю откуда это ограничение идет, но оно такое. Когда вы пытаетесь положить мегабайтный JSON? Потому что у тебя в B дереве, вот прям в узлах и в листьях прям значения лежат. И там Toast не работает. Ну я да, подозревал, что Toast не работает, но почему именно треть, например, а не полная страница? Ну просто и в листьях такая. Окей. Вот, короче, да. В B дереве Toast не работает, и значит вы хотите положить значение, у вас там типа мегабайтный JSON значение, да пошел ты на хер, короче, не получится тебе такое значение записать в нашу прекрасную базу данных. А значение пришло от пользователя. И выхода как бы два. Даже как бы, то есть нам нужно построить, зачем нам понадобилось B дерево, потому что мы хотим построить, гарантировать уникальность по этому полю. Нам очень важно, чтобы в этой таблице значения в этой колонке были уникальные. И встроенный механизм сделать уникально, он вот через B дерево работает. И поскольку мы не контролируем, что в этом поле находится, то выхода как бы два. Или на валюте, еще там типа до посгреса, очень пристально посмотреть на JSON и обрезать все подполя, которые могут сделать так, чтобы общий JSON был слишком большим. Или как-то так вот это сохранить, чтобы уникальность по-другому получить. Ну, какая первая мысль приходит в голову, как вот нам обеспечить уникальность. Давайте мы возьмем вместо того, чтобы в индекс положим, вместо того, чтобы положить в индекс непосредственно JSON, давайте мы просто к hash JSON положим. И в принципе мы и на запись получим гарантию уникальности, и даже при чтении мы сможем взять hash в for where, поставить типа hash от... Если мы построим индекс как функциональный индекс, где значение, которое мы туда кладем, это hash от поля, и когда мы where clause тоже напишем hash от поля, мы даже на чтение сможем пользоваться индексом данным потом за значением в тех строках, где нам в итоге понадобится, но по настоящему значению нам придется ходить на хип и достать его оттуда, но хотя бы индекс нам хотя бы фильтрацию позволит, особенно производить, не сканировать в таблицу. Вот. Но как можно взять hash от JSON? Очевидный способ взять строковое представление JSON, взять у него hash и положить в базу данных. Но тут мы вспоминаем, что это база данных. И если мы сегодня положим туда hash от текстового значения, вообще говоря, ничего не гарантирует нам, что завтра то, как это текстовое значение формируется, не поменяется. Потому что вообще-то никто нигде не гарантирует, как JSONB превращается в текст. Он пока что всегда более-менее одинаково в текст превращается, но никто не гарантирует. Ну, допустим, даже представим, что в таком изменении нас предупредят заранее. Есть вторая проблема. Слушай, надо, конечно, изучить, но ты уверен, что там порядок полей гарантируется и всякое такое? Я вот совсем не уверен. Я как раз говорю, что он не гарантируется. Это значит, что у тебя просто два преобразования JSONB в текст, и два разных вызова могут разные результаты давать. Ну, сейчас, я смотрел в код, сейчас он будет всегда один и тот же. Он не гарантируется нигде, но сейчас он будет всегда один и тот же. Ну, во всяком случае, насколько я понял происходящее. Но как бы нигде это не написано, что он гарантируется в следующих версиях. То есть, грубо говоря, при переходе там, не знаю, с 14-го, а посгрес на 15-й, как бы сам себе злой Буратин. В<|fi|>коска вообще ничего не гарантирует между этими. Ну, вот да. А если мы положим в таблицу, значит короче хэшек, как в ник индекс. Ну, такое. Но даже если мы представим, что это была бы не проблема, ну там типа окей, при мажорной версии, при переходе с мажорной версией на другую мажорную, ну перестроемый индекс не так страшно. Даже если бы мы на это положили, есть вторая проблема, которая для меня оказалась полным сюрпризом. Это то, как хранятся флоты в JSONB. В посгресе есть такой тип Numeric. Это он нужен для того, чтобы максимально точно хранить численный констант. Например, тут знаете вот эту историю про то, что нельзя хранить деньги во флотах. Вот в Numeric хранить деньги можно, потому что если вы там напишите 100.00000, у вас точности хватит 1, он вот так вот сохранит. Если больше того Numeric, посгресово отличает, 1.01 от 1.010. Это они будут себя вести как одинаковые значения, но будут записаны по-разному. Напомним, пожалуйста, внутри нет представления, как дробь или как настроение? Я не уверен, такое ощущение, что чуть ли не строка. Надо поговорить. Вот, я не уверен. Вот есть такой тип Numeric, он офигенно точно воспроизводит то, как вы положите числа. Теперь внимание, в JSONB числа хранятся в Numeric. Поэтому если у вас пользователь создает значение, короче, объект с ключом A значением 1.01, а потом он хочет записать A со значением 1.010, у вас окажется как бы, то есть на фьюник constraint немножечко сломается, может быть. Не хотелось бы. Не хотелось бы. Вот. Собственно, к чему я в итоге пришел? Сейчас план такой, что я пишу кастомную функцию хэширования, которая... А, да, больше того, на самом деле там уже есть кастомная функция в Postgres, в кишках копаться есть кастомная функция хэширования JSON, которая использует... А, да, собственно, еще один момент, который я хотел сказать. В Postgres у любого типа есть функции превращения его в строку и функции превращения его в протокол, который на проводе. Я ожидал, что может быть протокол, который на проводе, будет какой-то типа более-менее одинаковый появляться. За эту чудо-токе узнал, что там нюмерики лежат. Вот нифига, короче, протокол JSONB на проводе. Это текстовое представление JSONB плюс, короче, пара союзных полей. То есть JSONB в ваеер протоколе в Postgres очень эффективная штука. Короче, Community Postgres, разработчики Postgres резко против того, чтобы вываливать кишки JSONB формата наружу. Я, в принципе, понимаю, потому что эти кишки, они довольно... Там разное представление на диске в памяти, короче. Я думаю, вот проблема в том, что как раз обратная совместимость протокола, она очень сильно... Как это? Там тоже может что-то ломаться, но в отличие от всего остального, ее бдят. Ну, еще я так понимаю, из того, что я в обсуждениях в хакерс-мейл-листе читал, на самом деле JSONB не менялся с 12 версии. Он, в принципе, сейчас очень стабильный. Больше того, там на самом деле, если я верно и понял, используется структура данных, которая имеет определенный порядок полей, потому что это там важно для индексирования и всего остального. В общем, по моему счастью, внутри POSGresa есть достаточно адекватная интерфейс работа JSONB. В частности, можно учить итиратор по всем объектам под объектом. И, собственно, я решил на это присесть. То есть я посмотрел, как реализована встроенная функция хэширования JSONB. Она, к сожалению, имеет очень маленькую точность. Она там нужна для того, чтобы в хэштаблице JSONB класть. Там всего 64 бита. Как это? Хэш? Всего 64 бита. Что для Unique Constraint немножко опасно маленькое количество бит. Слишком велика вероятность коллизий. Вот. Мы решили использовать SH512, но написать его таким же образом, как встроенная функция хэширования устроена. И, в принципе, у меня даже уже есть более-менее работающий прототипчик на Rasty. Это отдельный историк, где я расскажу про свои ощущения про написание решений для Postgres на Rasty. Для другого раза, каким бы сказал, будет тема. Вот. И, в общем, да, хуже даже работает, но я собрал просто очень много неожиданных знаний про JSONB. Надеюсь, здесь никакой морали не будет, просто что JSONB устроен довольно интересно и необычно. Более необычно, чем я бы ожидал. У меня вопросы, дополнения. Вопрос первый. Вот ты пока изучал трейды, всякое такое, вот это ограничение про то, что в B3 можно положить не более одной третьей страницы. Где это упоминалось? Это что-то, что сообщество хочет поменять, просто никто над этим не работал? Или прям это пиццейкое ограничение? Вот такое я не в трейде нашел, а я нашел просто буквально у нас. Мы запустили наш код с чем-то, что создало JSON больше, чем было до с половиной килобайта, и у нас нам выдали ошибку, которая прям написана, что в B дерево нельзя положить больше, чем столько. Вот. А еще у меня есть дополнение про стабильность JSONB. Ты знаешь, что его в пятнадцатой версии сломают? Нет, не знаю, что именно сломают. Ну, по мелочи, но все равно. На этой неделе в Commitlся Patch, как тебе известно, в подгрысье ты создаешь таблицу, да? Когда ты создаешь таблицу, у тебя автоматически создается одноименный тип рекорд этой таблицы, пока возражения нет. Даже два типа рекорд этой таблицы и тип массив рекорд этой таблицы. Вот. Соответственно, ты можешь сделать Selix звездочка from T, правильно? Из таблицы. Но еще в этом запросе ты можешь сделать Selix звездочка from T, потом скобочки, и в скобочках ты можешь переименовать толпцы. Это, ну, типа синтакция такой поддерживается. Казалось бы, причем тут JSONB? А при том, что у тебя есть в подгрысье процедуры Row to JSONB, которая как раз может принимать рекорд. То есть, вот этот тип твоей таблицы. Как оно работает сейчас, начиная с 9 какой-то версии, если ты сделаешь вот этот вот рекорд с алиасингом, то у тебя в JSONB лягут... имена полей в JSONB будут как в твоем алиасе, не так, не то как называются колонки в таблице. Это вот как сто человек бы ожидал. Это спорно, потому что, смотри, что получается, у тебя есть функция, которая принимает определенный рекорд. Этот рекорд, это вот тип твоей таблицы. Понимаешь, у тебя вот тип, он соответствует таблице, и у этой таблицы у нее прям есть конкретные имена столбцов. И вдруг у тебя для этого типа... С другой стороны, я их только что заименовал специально, а потом оно взяло и поменялось. Но тип-то тот же. Получается, у тебя для одного и того же типа, в зависимости от того, использовав ты алиасинг или нет, будет разный возвращаемый результат. Ну я понял, да. Более того, у тебя на самом деле... В общем, был bug report, я сейчас его точно не воспроизведу, но там при хитро выдуманном сечении обстоятельств, что ты в одной сессии удаляешь столбцы, добавляешь столбцы или там айперишь столбцы, а в другой сессии там селектишь или бэкап делаешь. Простите, я пару дней назад читал, я уже забыл. У тебя просто... Вот на почве работы этого алиасинга, у тебя запросы падают со странными ошибками. Поэтому это поправили. У тебя теперь, безотносительно того, используешь ты алиасинг или нет, будут использоваться имена из таблицы. И вот, собственно, получается, у тебя road to JSON-B будет по-другому работать. Но если тебе очень нужно есть ворка раунд, ты можешь весь свой селек, обернуть там еще один в один селек, в нем используешь алиасинг, и тогда это будет работать как раньше. Потому что ты уже типа другой рекорд достаешь не из таблицы, а какой-то рандомный, ну просто рекорд. Я понял, но главное, что порядок по лебедям меня не поломают, потому что я сейчас единственное, что я планирую заложиться, на то, что итератор по JSON-у, по JSON-B, он будет мне возвращать поля всегда в одинаковом порядке. Вот еще вопрос, замечание насчет стабильности. Есть разные фичи в разработке. Федор Сегаев предлагал расширяемый механизм toast, в частности, для JSON-B. У тебя toast может умно пропасть в JSON-B и заложить его с дедупликацией, если ты типа одно поле в JSON-е поменял, чтобы тебе не просто весь новый документ записывалось, а только его какой-то дельта. Это пока все вилами на воде в разработке, но у тебя внутреннее представление JSON-B может в связи с этим как-то меняться. Плюс есть похожая фича про compression dictionaries для JSON-B. От вашего покорного слуги квест поднадлежит к этой фиче.",
    "result": {
      "query": "Postgres JSONB unique constraint"
    }
  }
]