[
  {
    "segment_id": "b3f9dedc-cca6-4b5f-a6e9-e0cc3916a167",
    "episode_id": "16d63b28-de8a-4d5a-9957-d8068a696314",
    "episode_number": 301,
    "segment_number": 11,
    "text": "как это правильно сказать Наверное, это правильно сказать На хранимых процедурках в PostgreSQL На мой взгляд, такое довольно спорное Решение, потому что Да, в базе данных, конечно же, все быстро Процедуры выполняются Прямо рядышком с тем местом, где хранится код Но лично я Не хотел бы, наверное, работать В проекте, в котором Реализовано именно так Потому что сложно сделать Обвязку для тестирования Очень сложно сделать правильное обучение сотрудников Это нестандартная штука Сложно сделать Все И я бы, конечно, хотел услышать Что Саша об этом думает Жалко, его сегодня нет в эфире И для меня Мне очень понравилось выражение На статье Где было написано, что после того, как мы Объявили наши планы, большая часть сотрудников Встала и ушла И я думаю, что я бы был, наверное Среди них В общем, я тут Не знаю, это закончено, я просто хочу свои Двойные докамеки ставить Это сложно В принципе, хранимки или не хранимки Это такая же технология, как Любой другой, не знаю Вы же выкатываете на ваше приложение На ваше сервер-приложение, если у вас сервер-приложение Ява То есть тут тоже считаем, что база данных На сервер-приложении Хранимки это наше приложение Тут главная проблема в тулинге Я работал в компании, где Существенная часть Кода крутилась И база данных, и она была написана как хранимка Во-первых, с тестированием вообще нет проблем Как бы там у нас был свой фреймворк Но даже без него нет больших проблем Вы пишите просто так же, как и напишите любые другие тесты Как бы вы берете какой-нибудь язык Который у меня находится в базу данных Берете его в тестовый фреймворк И просто как бы пишете тесты То есть тут вообще все точно так же делается Как в обычной ситуации То есть вообще ничего не отличается Вы просто То же самое делаете С раскаткой Вам нужен будет кастомный тулинг для этого Но это делается Но справедливости ради я сам лично Предпочел бы возможности Есть мало причин реально делать Что-то прям хранимкой Чаще всего, если это не кастомная функция Для агрегации, если это не кастомная функция Триггер То чаще можно просто написать кучу Тот же самый SQL, написать в приложении Какие-то приложения Для этого уже есть готовые средства Их не нужно делать Я не очень понимаю Я не уловил в статье, что там такого требовалось Именно хранимых процедур А не просто слать в сокет SQL Или даже делать prepare statement Из приложения, а потом его просто вызывать Мне не очень понятно, почему нужно Хранимке Хорошо, я могу адвокатам делать А в чем? Почему ты бы это так делал, если ты сам говоришь Что тестировать проблем нет, выкатывать проблем нет Вот следующая причина, которую я назову Потому что PGSQL, как ты правильно заметил В чем я с тобой согласен, это нифига не стандартная технология Если SQL Еще есть специалисты, которые Знают SQL хорошо И просто написать Хорошо составленные селекты И там, скажем Инсерты обычно не нужно, какие-то сильно замороченные писать То есть просто сделать Хороший транзакционный код С каким-то нормальным SQL Который не нагенерирован дурацким ORM Почему обычно все плохо Обычно все плохо не потому, что У вас код не в базе Выполняется Не потому, что у вас SQL не в базе Выполняется, SQL-то все равно будет в базе Выполняться, потому что у вас код так написан, что у вас ORM делает кучу мелких тупых Запросов, а потом сложную логику Отрабатывает в приложении, тогда как По-хорошему, то есть почему я всегда топлю За подходы вроде ECTO в Elixir, потому что Вы можете в приложении Сформировать какой-то кусочек логики Который потом стерилизируется у вас в SQL Отправляется в базу, база Выполняет код полностью внутри себя Возвращает компактный ответ И приложение продолжает с ним работать И вот как раз вещи типа ECTO Позволяют как бы оставаться В рамках вашего языка программирования, но в то же время Использовать возможности базы Лучше от двух миров Это все и обычное Евангелие Для тех, кто не знает Я сейчас даже в целом про подход И предлагаю именно на Elixir писать Есть другие фреймворки с похожим подходом, насколько мне известно Например, там, не знаю, тот же Самый, если я правильно понимаю, потонячий SQL-алкемит позволяет подобные вещи делать Ну и даже в том же, прости Господи, ActiveRecord Вы можете его использовать как ORM, а можете Наколбасить просто в кусок SQL Да, это не будет красиво, вы не останетесь в парадигме Вашего языка, но вы все равно технически Можете наколбасить SQL, просто отправить его В базу, то есть короче, вне зависимости От вашей технологии у вас всегда есть вариант наколбасить SQL Сделать prepare statement, чтобы у вас не было никаких Как это называется, SQL injection То есть наколбасить SQL так, чтобы Не зависело от вашего входа Используйте prepare statement для того, чтобы Передавать параметры И получаете большую серию тех плюшек, которые Вам дадут Даст работа с Хранимыми процедурами, но при этом Используйте это ваше традиционное средство хастирования И выкатки И используйте, ну, вам придется нанимать разработчиков, которые Знают SQL, но во всяком случае Разработчиков, которые как-то знают SQL Больше, чем те, которые знают специфичный диалект Позгресса, вот тут я согласен С Иваном это реально очень узкая Прослойка людей, которые реально на этом Можут писать. Так это же не только то Ну вот ты говоришь легко с тестированием Да нисколько не легко с тестированием Ну смотри, я просто говорю по опыту То есть, сори, я хочу посмотреть с такой позиции Я работал в такой компании, там Были проблемы, тестирование было Не одной из них Я по тестированию включаю в себя Не только написание тестов Написание тестов это не беда На самом деле можно загнать Кучу данных в базу данных Прогнать специфичные API тесты, как бы удостовериться Работа от нуля не работает Проблема ведь в том, что вот у тебя внезапно что-то Не работает. Отладить в Дебайгере код на любом языке Открываешь в Intel и GAD В SCOD что угодно и поехали Отлаживай. Отладь мне пожалуйста хрени Процедуру. У тебя есть прям куча Легких отладчиков, легких способов Ну смотри, тут дело такое SQL язык декларативный А PL-SQL? А PL-SQL не очень, тут опять же вопрос Как бы если внезапно Кто-то написал что-то и ты такой Блин, что-то я не пойму, оно работает или не работает А вот если сюда вот такие данные загнать Дай-ка я поотлажу, а еще хуже На самом деле У тебя нет прям дебайгера-дебайгера В буквальном смысле этого слова, но ты в принципе Если ты работаешь в консольном SQL клиенте Стандартно по сглесовам Ты можешь просто прям строчно выполнять Copy-paste, да, поехал Я это делал, я поэтому и говорю Что это совершенно не Рабочий метод То есть когда тебе надо сделать один раз в год То еще более-менее. У нас будет довольно сложная Сложная бизнес-логика На хреневых процедурах И как бы После того как ты Не знаю, там, какие-то рекурсивные Структуры данных Обрабатываешь и там, я не знаю С какими-то перекрестными ссылками между разными Таблицами и вот это все И потом в каком-то моменте что-то не работает Это просто ужас как тяжело, это неудобно Если у тебя есть часть данных В хранимке, у тебя две хранимки Это может быть оно и будет работать Но у них все приложение так написано Ну, тут еще, как бы, я тут Все еще считаю, что это вопрос стулинга Если у тебя все",
    "result": {
      "error": "API request failed: Error code: 429 - {'error': {'message': 'Rate limit reached for gpt-4.1 in organization org-xSG9D345gtYlIKC330wCyrEG on tokens per min (TPM): Limit 30000, Used 30000, Requested 3504. Please try again in 7.008s. Visit https://platform.openai.com/account/rate-limits to learn more.', 'type': 'tokens', 'param': None, 'code': 'rate_limit_exceeded'}}",
      "stack_trace": "Traceback (most recent call last):\n  File \"/home/andrei/Projects/podcast-shownotes/scripts/build_search_eval_dataset.py\", line 157, in generate_search_query\n    response = await self.client.chat.completions.create(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/resources/chat/completions/completions.py\", line 1927, in create\n    return await self._post(\n           ^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1767, in post\n    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1461, in request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1547, in _request\n    return await self._retry_request(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1594, in _retry_request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1547, in _request\n    return await self._retry_request(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1594, in _retry_request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1562, in _request\n    raise self._make_status_error_from_response(err.response) from None\nopenai.RateLimitError: Error code: 429 - {'error': {'message': 'Rate limit reached for gpt-4.1 in organization org-xSG9D345gtYlIKC330wCyrEG on tokens per min (TPM): Limit 30000, Used 30000, Requested 3504. Please try again in 7.008s. Visit https://platform.openai.com/account/rate-limits to learn more.', 'type': 'tokens', 'param': None, 'code': 'rate_limit_exceeded'}}\n"
    }
  }
]