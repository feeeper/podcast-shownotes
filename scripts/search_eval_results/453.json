[
  {
    "segment_id": "1648b5f1-8067-4a00-bb6d-9cecbddd2a64",
    "episode_id": "cabd7868-d603-4df3-aea6-21d9d0e7c3d6",
    "episode_number": 453,
    "segment_number": 2,
    "text": "Я узнал одну интересную вещь. Это был блог-пост в блоге команды разработки Go. И он был про новую утилиту, которую они зарелизили, которая называется DeadCode. Вы ее можете натравить на ваш репозиторий, модуль или что угодно, и он найдет потенциально мертвые участки кода. Что мне показалось интересным, в этом посте они немного рассказывают о том, как она работает. Вот. И алгоритм, который они используют, называется RTA, по-моему, Rapid Type Analysis. Идея... Его идея состоит в том, что он... Ну... Как вообще определяется мертвый код? Да, это код, который никто никогда не вызывает. Если у вас в языке есть просто только статические вызовы, берешь там имя объекта, точка, метод и его вызываешь, то это очень легко отследить. Вы просто строите граф вызовов, и все хорошо. В Go есть интерфейсы, которые делают все сложнее. Потому что если подходить к этому наивно, то, грубо говоря, если у вас есть хотя бы один вызов по методу интерфейса, то вам нужно сохранять абсолютно все методы в программе, которые совпадают по сигнатуре и названию. Вот. И это не идеально, потому что если вспомнить про существование таких тривиальных интерфейсов, как стрингер, который в строку умеет конвертировать типы, то, по сути, если вы хоть раз воспользовались... воспользовались пакетом FMT, вы... ну, в общем, ни один из этих стрингеров бы из вашей программы никогда не выкинулся. Вот. Что они делают, чтобы быть немножко умнее по этому поводу? Они отслеживают, какие типы в какие интерфейсы назначаются. То есть, грубо говоря, если у вас есть переменная типа A, и она назначается в... интерфейс типа B, то в таком случае вызовы методов интерфейса B будут также считаться, как будто они вызвались и на методе I. И эти методы будут помечены как живые. Вот. Но при этом, если у вас также есть интерфейс C, часть которого... часть методов которого похожа на интерфейс... на методы типа A, но при этом тип A никогда не назначается в интерфейс C, то... все методы... все вызовы через интерфейс C, они не сделают методы типа A живыми. Вот. Как именно это работает в деталях, там есть ссылка на статью. Вот. Но мне показалась это интересной идеей, что можно улучшить вот ваше определение живости кода путем отслеживания, какие типы конвертируются в какие интерфейсы. В принципе, если подумать, это не специфично для Go, это для любого языка с наследованием или с интерфейсами, это тоже применимо. Вот.",
    "result": {
      "query": "Go DeadCode RTA analysis"
    }
  }
]