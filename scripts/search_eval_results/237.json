[
  {
    "segment_id": "201e62a3-e54b-4c5c-8107-83e8790357a2",
    "episode_id": "c3d99c0e-559f-4b7b-b888-02c94be838c7",
    "episode_number": 237,
    "segment_number": 2,
    "text": "Всё, я вроде бы починил, должно работать. Согласен, поехали дальше. Собственно, 2 года работал на таких играх, после чего, сделав 4 вещи, попал в большую аутсорс, так скажем, галеру, где 5 лет занимался абсолютно разными вещами, начиная программирование JavaScript на десктопе, Python, пресейл активностями, после чего закончил на дутнете, ещё немножко попрыгал и сейчас примерно на такой же позиции, только уже в другой конторе, тоже большая, аутсорс и го. Но суть не в этом, потому что это как бы официальная работа, а рассказать тему моего, скажем так, тут пребывания связано скорее с моим хобби. То есть ещё во времена учёбы в техникуме меня интересовали игры и то, как их делают. И почему-то больше интересовала графическая сторона, собственно, создание 3D графики, начинал пробовать что-то делать в 3D Max, в те времена с диалап интернетом было довольно сложно получить какую-то информацию, поэтому приходилось читать бумажные книжки и надеяться, что версия на каком-нибудь развале дисков с пиратским 3D Max совпадёт с книжной и тому подобное. После чего, скажем так, в какое-то время я занимался 3D графикой профессионально, если считать, профессиональная работа и ту, за которую ты получаешь деньги. Я, собственно, делал проекты в 3D, писал в местную газету некоторые материалы, новости, туториалы по компьютерной графике и внимательно за этой темой следил. Но в какой-то момент это всё стало слишком сложной финансово, потому что 3D требует довольно серьёзных вложений в технику и я это всё дело забил на некоторое время. Прошло лет пять, можно сказать так, и около года тому я начал приходить к тому, что как-то у меня и работа программирования, и хобби программирования — те же самые сервера в качестве хобби, что как-то оказалось весьма невесело. Я начал снова пытаться найти себя, после чего, после некоторого, наверное, даже выгорания я вспомнил, что у меня было хобби, в котором я был довольно-таки неплох, и вручную вернулся в 3D, но немножко иначе. И вот тут мы приходим к теме визуального программирования. Давайте скажем так, кто как представляет визуальное программирование для себя? А, ну это такая тема, когда вот детей в школах учат, там кружочки, квадратики, стрелочки, всякое такое, ну в смысле это программирование для непрограммистов в виде картинок. Наброс засчитан? Программирование кружками, соединением их стрелочками, вот это вот всё такое. Такой вариант, да? Ну да, конечно. Ну в общем, да, оно так и есть. В принципе, это и есть соединение каких-то частей логики друг с другом. Просто иногда слышал такое, что это что-то типа Delphi, где, например, интерфейсики создают в визуальном редакторе, но нет, это именно о создании логики программы с помощью визуальных средств соединения элементов один с другим. И на самом деле я некоторое время назад решил посмотреть, какие есть средства визуального программирования, и было довольно интересно. Например, есть такой язык программирования, система DRAKON, там дружелюбный, русская аббревиатура так сложившаяся, и как оказалось, на ней создавали программы для посадки Бурана или что-то такое связанное с аэрокосмической отраслью. На вид это похоже чем-то на UML, но всё немножко не то. Собственно, причём тут мой весь предыдущий спич о 3D и переход на визуальное программирование. Дело в том, что, наверное, я могу сказать так, что вы все видели, пользуетесь, пользовались и испытывали результат применения визуального программирования в продакшене, скажем так, но немножко не с той стороны, с которой как бы все ожидают. Это не соединение бизнес-логики для каких-то автоматизации бизнес-процессов, хотя и такое я где-то видел. Говорю я о программе Houdini от компании SideFX, которая используется для создания визуальных спецэффектов. И это, по сути дела, скажем так, операционная система для технических 3D художников, если можно так выразиться, потому что она довольно... настолько комплексная, что непонятно с какой стороны в неё подойти и попытаться рассказать словами без визуального подкрепления, но я попытаюсь. Вообще сложно рассказать про визуальное программирование без визуальной части в подкасте. Да, но на самом деле у этой программы довольно чудовищный UI, которому просто такой страшненький, будем честны, и смотреть там особо не на что, к тому же, когда ты смотришь и не понимаешь, что там происходит, обычно у людей взрывается мозг. Я некоторое время, когда 3D было моим основным хобби и чуть ли не профессией, посещал сходки минского комьюнити по 3D графике, осенью собирался так называемый CG-эвент, и мы ехали куда-нибудь за город, делились опытом. И был там один товарищ, который рассказывал непосредственно про Гудини. И по степени импакта на людей это было примерно, как если бы на конференции веб-программистов, обычных гошников, дотнетчиков, джавистов, рассказывающих друг другу какие-то свои понятные дела, вдруг выходит суровый хаски-лист и начинает эндофунктором мемонады покрывать. Вот примерно то же самое. И все мемы, которые рисуются про, например, кривая изучения функциональных языков по сравнению с обычными языками, это один в один перекладываются на людей, использующих и изучающих Гудини. Там довольно сильно надо себе сломать мозг, но когда ты понимаешь суть, становится сильно проще. Ну давайте попробую начать объяснять, какой можно получить профит от так называемого визуального программирования, так же визуальное программирование, это мы понимаем как программистный термин, там художники это называют процедурным моделированием, где все операции над объектами в сцене, это какие-то ноды в графе операций, в графе сцены. То есть в отличие от, например, 3D Max, Blender или других традиционных 3D пакетов, допустим у вас есть кубик, вы хотите его разрезать пополам, вытянуть одну грань и повернуть ее каким-то образом. В большинстве стандартных 3D программах это будут какие-то процедуры, которые вы сделали руками над объектами, и шага назад у вас нет шага назад и возможности что-то изменить в предыдущих операциях. То есть как в фотошопе вы провели кистью слева-направо, после того как провели кистью, вы не можете поправить цвет кисти, тип кисти или другие фактически. В общем, правда, если честно. Да-да-да, я имею в виду про не те кисти, которые складываются как операции, а скажем так, ну ладно, не в фотошоп, но другой более примитивный 3D редактор, который не имеет таких фич запоминаний. То есть проведя в Paint по битмапу кистью, вы поменяли значение и не имеете никакой связи вернуться назад. И поменять какой-то один из параметров, не меняя их. В Houdini же всё наоборот. Когда у вас есть возможность сделать такие операции, но они не приветствуются примерно как сайд-эффекты в функциональных языках, где они позволяются. Надо сказать... Я, наверное, перепрыгнул немножко на другую область Houdini, что комплексность подхода, можно отметить в том, что внутри Houdini используются целых два языка программирования. То есть художнику, пользующемуся Houdini, обязательно знать один и желательно знать второй. Первый язык программирования это VEX, и он используется для операций над объектами в сцене. Второй — Python, который используется скорее для операций с внешним миром. Ну давайте я вам попытаюсь рассказать какой-нибудь пример из того, что можно сделать таким образом. Представьте, у нас есть точка в 3D пространстве. Она у нас в начале координат 0, 0, 0. И больше у этой точки нету никаких данных, скажем так, атрибутов. И тут надо еще сказать про концепцию атрибутов. Я надеюсь, она будет понятна по ходу рассказа. У точки есть, скажем так, intrinsic attribute — это ее ID, который уникально определяет ее, и координата — вектор трех флотов. В графе нодов у нас есть нод, который так и называется add — добавить одну точку. Следующим нодом мы можем добавить, например, нод transform, который эту точку перенесет на какой-то вектор в сторону. Потом мы эту точку, этой точки можем сделать операцию, например, copy and transform, которая с определенным шагом раскопирует эти точки. Затем мы можем добавить ноду, в которой мы будем писать VEX-код. То есть, тут не чистая концепция визуального программирования, скажем так, доведенная до абсолюта, а довольно прагматичный баланс чистоты подхода процедурного моделирования. То есть, когда ты создаешь сцену с помощью комбинации процедур или композиции функций, как бы сказали программисты. Ну и есть возможность взять и написать код, который что-то делает. Опять постараюсь не выходить далеко, но и практически, да по-моему, любой код, который можно написать, можно выразить специальными нодами, но это другой контекст. Я, наверное, всех уже сильно запутал. Возможно, задавайте вопросы по ходу, если они возникают. Да, конкретно, какую проблему решает этот замечательный piece of software? Окей, из последнего. Это, наверное, будет самый правильный пример. Допустим, у нас есть задание, у нас клиент попросил нарисовать сцену, в которой толпа людей бежит по минному полю, и некоторые люди набегают на мины, взрываются, с ними что-то происходит, а другие добегают до конца поля. И тут возникает вопрос. Художник, допустим, расставляет каким-то образом персонажей в изначальные позиции, симуляция толпы их прогоняет по полю, они где-то взрываются, и с ними что-то происходит. После того, как показан готовый результат, обязательно будут какие-то правки, типа переставь этих людей другим образом, убери мины, сделай, чтобы там взрывались, а там не взрывались. С помощью процедурного подхода возможно создать сцену, вот это вот всё, где расположены мины, по какому-то рандомному сиду генерируется толпа, тоже по какому-то рандомному сиду, и они бегут, у каждого своя скорость, и можно перейти на абстракцию выше, и в эти все поля, в эту сцену ввести, скажем так, концепцию таски, что окей, Гудзини, вот эта сцена, вот у неё есть такие параметры количество человек, сид, по которому они расположены, количество мин, сид, по которому они расположены, длина поля, ширина поля, скорость бега, разброс скоростей бега, сгенерируй по 4 значения всего этого и просимулируй все возможные комбинации, это вот например одно. И да, это будет конечно занимать довольно долго времени, но в итоге будет сразу много готовых вариантов для выбора, из которых уже будет выбрать сильно легче, чем перебирать их по одному, вносить вправки, возвращаться в начало проекта, переставлять что-то руками. Другой пример, создание игровых ассетов, например мы создаем какой-нибудь блок бетонное ограждение, и у нас игра про стрельбу, и хотелось бы этот блок, чтобы он был со следами повреждений и тому подобных вещей, поэтому мы можем пойти стандартным, скажем так традиционным путем, и вручную сделать в нем какие-то выемки, например в 3д максе, или в Zbrush, или в Blender с помощью скульптинга художник вылепит в нем какие-то выбоины, трещины, неровности. Потом, нехорошо, когда в игре все такие предметы будут одинаковыми, это будет сильно бросаться в глаза, поэтому мы сделаем 2й, 3й, 4й, и потом будет довольно скучно лепить 5й, 6й, 7й, 8й, 9й. В Гудине с помощью, тут я могу сказать более конкретно, с помощью процедурных волюмов можно блоку нанести неограниченное количество разнообразных повреждений, получив, создав один раз алгоритм, создать неограниченное количество разнообразных айтемов для игры. И это только один из подходов, именно упрощенное создание подобных друг другу объектов, именно упрощение рутины, это, собственно, основной плюс этого 3д пакета. То есть создание различных домиков, когда ты можешь создать ассет довольно простым образом, который параметрически будет создавать дом определенной ширины и высоты, в котором будут с заданным шагом окна, балконы, лестничные проемы, он уже будет готов для симуляции разрушений, он уже будет готов для экспорта в игру и тому подобных вещей. Кроме того, если мы будем говорить об играх, Гудини имеет возможность работать в, скажем так, headless режиме и предоставляет коннекторы, например, к Unreal Engine или к Unity 3D и позволяет вот эти ассеты, созданные, например, созданный дом вставлять в Unreal Engine с интерфейсом вот этих выведенных параметров, например, количество этажей, длина, ширина, высота. И уже в Unreal или в Unity можно тягать эти параметры и оно будет спрашивать Гудини, окей, параметры изменились, перерисуем ассет, и Гудини будет возвращать обновленный ассет в игру. Например, так. Давай я сейчас начну задавать нубские вопросы. Конечно. Я из того, что ты писал пока, я представляю себя Гудини как такой недеструктивный редактор, я так понимаю, скорее трехмерной графики и в основном основанной на программировании, использующий языки программирования как свой основной инструментарий, а не какие-то визуальные штуки. Собственно, Суд, первый вопрос, правильно я понимаю? Почти. Про языки программирования их знать хорошо, но не обязательно. То есть, но всё-таки в визуале не в последнюю очередь? Визуально можно сделать всё то и то, для чего требуются языки программирования, использование языка программирования VEX, но не обязательно. Просто порою VEX получается более лаконичным, чем огромождение большого количества нод. Меня скорее наоборот интересует, могу ли я что-то какое-нибудь вообще, могу ли я как-нибудь упороться и наскульптить языком программирования или это слишком идиотская идея? Смотри. Наскульптить можно. Я недавно смотрел, что там было, в процедурно передвигающиеся осьминогоподобные твари, причём анимация ходьбы также процедурно генерируется на любое количество щупалец. Довольно стрёмное зрелище. То есть, наверное, портрет сделать будет очень сложно, но какую-то абстрактную тварину создать вполне получится. Главное видеть архитектуру, скажем так, существа, потому что одни и те же задачи можно решать очень разными вариантами. И если касаться персонажей, то Гладини не столько для создания персонажа с нуля, сколько для обвеса базового персонажа различными элементами типа одежды и прочих украшений. То есть клонирование с добавлением небольших изменений? Я, кстати, хочу заметить, извините, что перебиваю, он популярный просто как зараза, им пользуется Дисней, им пользуется куча разработчиков игр, им пользуется... Да все им просто пользуются, очень много где используется. И он, походу, ещё и стоит как чугунный мост. Стоит, да, стоит как чугунный мост для студии, но пользоваться им можно бесплатно для ознакомительных целей, для обучения, там ограничения, там запрещен экспорт геометрии, чтобы, соответственно, сложные результаты не выводить в какие-то другие, например, в блендеры не рендерить там. И ограничено разрешение рендера, по-моему, нельзя подключать сторонние рендеры. А так да. Но сейчас мы говорим, скажем так, только о стороне 3D-моделирования, то есть создания персонажей, создания каких-то объектов. На самом деле там очень много всего для создания визуальных эффектов, то есть горение, системы частиц, молнии, симуляция воды, жидкостей, газов, очень сильная работа с волюметриками, с объёмами. Там есть довольно интересные решения, там можно поговорить, что можно сделать, например, имя sign distant field. И возможность взять от него градиента. По поводу персонажей, что ими делали. Например, могу рассказать, что Sea of Thieves, знаете такую игрушку? Ну я да, другие ведущие думают. Ну это такая игрушка, где ты плаваешь по морю за пирата, ввязываешься во всякие приключения, пьёшь уром, и попадаешь в шторма, и иногда на тебя нападает кракен. Так вот, если выпить слишком много рома, то пирату станет, твоему персонажу станет плохо, будет рвота. И вот, например, симуляция рвоты происходила в Гудине. Боже мой! Прекрасно! Да, причём там очень... Они с помощью Гудини симулировали различные шлепки вязкой неоднородной жидкости на поверхности, и записывали их в текстурку особым хитрым образом. Так что получалась обычная чёрно-белая текстурка, точнее просто один альфа-канал, но при этом она получалась как анимированная. Шторма. Там довольно интересные конфигурации облаков, которые принимают различные формы, вполне заданные художниками, включая форму черепа, там над определенными опасными местами. И вот это вот, также для этого использовалась возможность работы с, как это называется по-русски, сказать, Signed Distant Field. Знаковое поле дистанции или что-то такое. Это, представьте себе, объем вокселя, в котором хранят не значение плотности, например, дыма, а расстояние до ближайшей точки поверхности какой-либо, которая в этом объеме есть. То есть то, что внутри оно имеет, по-моему, отрицательное значение, то, что снаружи объема оно имеет положительное значение. Это очень позволяет интересно переводить операции над полигональными объектами. Например, переведя полигональный объект в Signed Distant Field и создав другой объем с трехмерным векторным шумом, можно довольно интересно мутировать 3D-объекты. Так, и что там еще происходило? А, шторма. То есть симуляция молний, это также происходило в Гудини с помощью L-системы, которые обычно выращивают деревья или рисуют фракталы, но пригодилась для создания молний. Также с помощью Гудини строили город в Человеке-пауке, в игрушке, которая на PlayStation. Тут можно, наверное, попытаться меня опять уточнить, задав более уточняющий, наводящий вопрос. Я пока не понял, как это делается с точки зрения интерфейса. То есть я понимаю все эти модели, которые используются, но это как в программировании сказать. И тут я ему навесил интерфейс. Что за интерфейс? Как на данном конкретном языке его навесить? Хорошо. Окно программы. Обычный вид, это у нас окно разделено на три большие области. Слева большая область полностью по вертикали. Это 3D viewport, то есть отображение трехмерной сцены, визуальное отображение объекта. Справа внизу у нас обычно панель, на которую мы размещаем ноды операций и соединяем их между собой. Ноды обычно выглядят как такие прямоугольнички. У них сверху слоты входов, у разных нод может быть количество входов, снизу выход. И так строится дерево сверху вниз. И над нодами обычно окошко, панелька с параметрами нодов. То есть если это нода трансформации, то там вектора смещения, вектор поворота и масштаба. И тут надо сказать, что в Houdini есть несколько контекстов. То есть можно работать с контекстом геометрии, так называемой SOP, Surface Operations. Можно работать с динамикой, то есть создавать различные физические объекты, на которые воздействуют какие-то физические силы. И это все каждый кадр пересчитывается. Есть контекст работы с изображениями, можно все те же операции проводить с картинками, операции с изображениями, операции с каналами, которые в принципе предназначены для работы с анимациями, для, например, правки кривых анимаций каких-нибудь персонажей или чего-то такого. Я тебя перебью сейчас, извини, потому что мне кажется, люди, которые никогда не работали вообще с какими-то либо 3D-редакторами, ты сейчас уходишь в такие дебри, которые скорее всего, ну то есть набор бессвязных слов. То есть что такое кривая анимация, если люди не открывали ни Unity, ни 3D Max, ни My.U, ни Blender в своей жизни, скорее всего для них абсолютно пустой звук. Я хочу тебя по-другому немножко начать спрашивать. Вот смотри, ты очень клево все описал, давай ты его посравниваешь с какими-то такими вещами, которые, ну не знаю, я в своей жизни трогал 3D Studio Max, это еще было давно в школе, потом я пытался трогать Blender, потом как немножко подзабил, потому что в тот момент у меня не было хорошего жилья, заблэта. Но вот может ты посравниваешь его с какими-то другими известными пакетами, тем более что с Blender было бы особенно интересно послушать, потому что в Blender тоже есть Python, и потому что Blender стоит ноль денег, а Houdini стоит бесконечно денег. Да, хороший подход. Собственно, основное отличие, ты в самом начале правильно сказал, это не деструктивный редактор. То есть любой стейт, который был получен выше под дерево, он всегда у тебя сохраняется, ты можешь от него продолжить работу. То есть, если в Blender у нас есть, как я уже говорил, стандартный кубик, недеструктивным образом на него можно навесить какое-то количество модификаторов. Например, модификатор Array, который создаст из одного кубика десяток кубиков, так или иначе расположенных относительно другого пространства. Например, 10 кубиков размером в один абстрактный юнит с шагом 2, и вот они по одной ассе стоят. И если ты вернешься и начнешь, вернешься на шаг назад и как-нибудь отредактируешь 3D-сетку этого кубика, подвигаешь какие-то шины таким образом, что он перестанет быть кубиком, он станет каким-то абстрактным многогранником, то вернувшись потом на модификатор Array, ты увидишь массив уже этих измененных многогранников. Но если, например, ты делаешь не массив, а какую-то деструктивную операцию, например, с помощью скульптинга сделал из этого кубика лягушку, а потом удалил половину вершин вручную и осталось от лягушки только две лапки, то кроме как Ctrl-Z до какого-то шага назад ты вернуться уже не можешь. Тем более не можешь создать вторую, второй бранч модификаций и сравнить, например, два подхода. То есть это что касается принципа работы и это касается не только 3D-моделирования, но и обработки изображений, обработки анимаций и чего-то еще. По поводу сравнения с Blender более приземленно, они в принципе очень похожи. И там, и там есть средства для моделирования, для моделинга. Разве что в Houdini, я бы сказал, полигональный моделинг сильно попроще, потому что он не для этого. Попроще в смысле менее фичаст? Менее фичаст, да. Но гораздо более разухабист в области различных симуляций. То есть симуляция жидкости, причем нескольких видов, несколько различных вариантов подходов к симуляции мягких тел, твердых тел, одежды, комбинаций этого всего. То есть да, в Blender есть несколько симов, несколько вишков физики твердых тел, физики мягких тел. Но, скажем так, в Houdini у тебя есть возможность просто зайти в непосредственно Solver, в ту штуку, которая занимается расчетом следующего кадра на основании текущего, на основании ситуации сцены в текущем, и сделать там какие-то свои хаки в текущем месте, смешать симуляцию мягких тел с симуляцией твердых тел, все это обернуть еще в симуляцию жидкостей и тому подобное. То есть в область симуляции Houdini сильно впереди, потому что это один из основных его селинг-поинтов. Что у нас еще? Потом рендеринг идет. Рендеринг идет в Houdini, есть встроенный рендер Mantra, есть возможность подключения сторонних в Blender. В Houdini нет, как я не пытался, не смог завести GPU-ускорение для рендеров, физикал-бейст-рендеринга. Когда в Blender, в принципе, уже есть замечательно работающий Cycles, который ускоряется и на GPU, и на CPU гибридно, и работает хорошо. По поводу наличия языков программирования. Опять же, в Blender используется Python, и используется Python для всего. То есть с помощью Python в Blender можно и загрузить в него файл, и проводить операции над объектами в сцене, включая даже, можно что-то сделать, типа процедурного моделирования, написать алгоритм, который создаст какие-то точки по определенным алгоритмам, создаст какую-то модельку. Но я такое пробовал делать, и настолько низкоуровневые операции над сценой в Blender делать просто сложно, потому что интерфейс довольно... интерфейс именно как API программный довольно тяжелый и многословенный. Ну и, скажем так, получается все очень громоздко. Когда Houdini позволяет тебе использовать... В принципе, тоже можно использовать в Blender для таких же операций, но не рекомендуется, потому что это, во-первых, будет медленнее, во-вторых, сам API не предназначен для операции непосредственно над объектами в сцене. Для этого используется VEX, который чем-то похож на C, чем-то похож на JavaScript, работает быстро, параллелится, и ты можешь просто создавать маленькие ноды с маленькими кусочками операции, соединять их определенным образом, и таким образом гораздо более удобно итерироваться по процессу. В Blender, что в Houdini, Python больше для взаимодействия с внешним миром. Например, загрузить откуда-то данные, какие-то файлики стянуть откуда-то с ассетами или какой-нибудь CSV с данными для моделирования, не для моделирования, а для генерации чего-нибудь. Окей. Есть ли что-то, о чем тебе непременно хотелось бы рассказать, потому что мы как-то немножко ограничены во времени, нам нужно перейти аккуратненько и на другие темы. Вот, может быть, что-то, о чем еще стоит упомянуть? Я могу, наверное, лишь порекомендовать взглянуть на Houdini людям, которые, в принципе, как в моей ситуации, были... которыми программирование нравится, программирование, возможно, хотелось бы иметь как хобби, но делать примерно то же самое... но хотелось бы делать этим что-то категорически иное. И, собственно, тут есть и довольно сложные, и интересные... возникают алгоритмические задачи при попытках сделать... реализовать какую-то свою идею. И, в принципе, довольно сильно расширяет кругозор. Я могу порекомендовать Houdini как такой кубик Рубика для мозгов, который совершенно переключает контекст, и в то же время можно вполне попрограммировать в нем. Окей, принимается. Тогда мы, наверное, аккуратненько перейдем к остальным темам. Я более чем уверен, что ты на них останешься, учитывая, сколько остальных тем ты добавил.",
    "result": {
      "error": "API request failed: Error code: 429 - {'error': {'message': 'Rate limit reached for gpt-4.1 in organization org-xSG9D345gtYlIKC330wCyrEG on tokens per min (TPM): Limit 30000, Used 30000, Requested 11463. Please try again in 22.926s. Visit https://platform.openai.com/account/rate-limits to learn more.', 'type': 'tokens', 'param': None, 'code': 'rate_limit_exceeded'}}",
      "stack_trace": "Traceback (most recent call last):\n  File \"/home/andrei/Projects/podcast-shownotes/scripts/build_search_eval_dataset.py\", line 157, in generate_search_query\n    response = await self.client.chat.completions.create(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/resources/chat/completions/completions.py\", line 1927, in create\n    return await self._post(\n           ^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1767, in post\n    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1461, in request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1547, in _request\n    return await self._retry_request(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1594, in _retry_request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1547, in _request\n    return await self._retry_request(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1594, in _retry_request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1562, in _request\n    raise self._make_status_error_from_response(err.response) from None\nopenai.RateLimitError: Error code: 429 - {'error': {'message': 'Rate limit reached for gpt-4.1 in organization org-xSG9D345gtYlIKC330wCyrEG on tokens per min (TPM): Limit 30000, Used 30000, Requested 11463. Please try again in 22.926s. Visit https://platform.openai.com/account/rate-limits to learn more.', 'type': 'tokens', 'param': None, 'code': 'rate_limit_exceeded'}}\n"
    }
  }
]