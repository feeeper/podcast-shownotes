[
  {
    "segment_id": "e39e92d4-2cbc-4418-b5d2-483b25c51f4c",
    "episode_id": "a84115d2-2d8e-4231-9d14-8aaffa0edf3d",
    "episode_number": 397,
    "segment_number": 8,
    "text": "Доклад соответственно и называется, что как-то диск-бейза-система с производительностью in-memory. Дальше докладчик уходит немножко в кишочки, говорит, что у нас большие буферы большого размера. То есть здесь на скриншоте изображается, что от 64 килобайт. И размеры буферов увеличиваются экспоненциально, то есть 64 килобайт, 128, 256 и так далее. И работает система по принципу слабого кейтера. Таким образом система борется с фрагментацией данных, потому что у тебя для любого куска данных будет выбран ближайший по размеру буфер, размер которого красит двойки. Зачем они делают буферы? Например в POSGRES и в большинстве классических СУБД буферы они все фиксированы в размерах. То есть в POSGRES у тебя 8-килобайтные страницы, как пример. Зачем делать буферы разного размера? То есть вот как было отмечено, буфер могут иметь разный размер. Сделали они так, чтобы не реализовывать аналог TOAST из POSGRES. То есть когда POSGRES нужно сохранить данные большого объема, ну в большом смысле больше размера страницы, то они нарезаются на более маленькие куски, чтобы они влезали в страницу. Это достаточно, ну как сказать, у этого механизма есть свои слабые стороны, потому что, ну например у тебя были данные, ты… нет, это… короче у него есть больше одного ограничения, давайте так, не уходя в детали. И в этой системе они пытались сделать так, чтобы TOAST или его аналог не был нужен. Дальше докладчик переходит к BADIREV. У них в системе есть индексы. Индексы представляют собой BADIREV. У них в BADIREV умные, ну не так, волшебные указатели, они называют SWIP. И, когда ты знаешь этот указатель, какие-то флаги в нем, ты понимаешь, что этот указатель он ведет в память или это указатель в данные, которые на диске. При этом таблицы у них в системе являются индекс-органайз. Поэтому, вообще-то говоря, все является BADIREV. Для кортежа вводятся синтетические 8-байтовые идентификаторы. То есть, когда у тебя индекс-органайз таблицы, то тебе нужен какой-то промерики, вот они приняли решение сделать их 8-байтами. В системе в этой, которая Umbra, новая система, интерфейс это SQL, синтексис и протокол Postgresовый. Они могут в MVCC. И реализовали cost-based оптимизатор со статистикой. То есть, все довольно серьезно. Запросы, они умеют компилировать. У них есть JIT-компиляция. Пока мы не перешли к остальной части, по сказанному до этого момента есть какие-то вопросы или комментарии? Мне немножко сложновато говорить, поэтому буду признателен. Я посмотрел этот доклад перед выпуском и понял, что я ничего не понял. Так что, все, что ты объясняешь, вроде бы хорошо. Ну, если что-то нужно пояснить, вот по ходу ты спрашивай, не стесняйся, я думаю, что кому-то из слушателей это тоже будет интересно. Ну, нет, это больше там, что надо ставить на паузу, идти гуглить, если пытаться прям глубоко понять. Так-то в общих чертах, в принципе, хорошо все объяснено, и ты достаточно неплохо это пересказываешь. Спасибо. Одно наблюдение, которое не связано, собственно, с содержанием доклада, но которое мне бросилось в глаза, это интересно смотреть, как чувак проектирует базу данных, когда это уже не первая база, которую он проектирует с нуля. Большая часть базоданновых проектов, которые я знаю, они либо что-то вроде Пасгреса, которая развивается десятками разработчиков в десятки лет, и это уже далеко не с нуля созданное, и там много годовых колец и всего такого, либо это просто новые проекты, которые вот у кого-то есть классная идея, о, мы сейчас сделаем, я не знаю, суперклассный Data Lake, или реплицируем что-нибудь здорово, и это их первый проект в базах данных, на котором они тоже все еще учатся и делают ошибки. Вот в отличие от всех этих случаев, тут чувак, который, с одной стороны, профессионал в базах данных, а с другой стороны, это уже не первая попытка, и чувствуется некоторая взрослость что ли дизайна, я не знаю, видно, что много прошлых ошибок было учтено.",
    "result": {
      "query": "Umbra database architecture features"
    }
  }
]