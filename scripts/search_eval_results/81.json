[
  {
    "segment_id": "33036bfc-fc56-4b7a-9e59-b46228b2d761",
    "episode_id": "de395476-914b-41b4-a832-0b19cdab7f8d",
    "episode_number": 81,
    "segment_number": 6,
    "text": "И в частности она дает, насколько я понимаю, несколько больше классов этих феноменов, и Hermitage как раз опирается на классы феноменов из этой статьи. Вот мой коллега интересуется, а можно ли доказать, что у нас не бывает других феноменов и других уровней изоляции? Наверное можно. Или это просто человек сидит и все, что он придумал, это вот есть, а другое может есть, может не есть? Слушай, мне тяжело сказать, они достаточно специалистов в этом вопросе. Получается оно сейчас не изучено, возможно у нас есть какие-то хитрые феномены, про которые мы не знаем и которые может быть даже проявляются в современных системах, просто про них еще никто не подумал. Понимаешь, да? Слушай, возможно даже эта статья как раз это и содержит. Нет, она, насколько я знаю, как раз не про замкнутые сетевые... Не исчерпывающие. Да. Дело в том, что ты можешь сколько угодно увеличивать количество параллельных транзакций и у тебя этот граф растет до бесконечности. Еще там такой момент, на самом деле эта статья, которая критика of NC SQL Isolation Levels, там есть какие-то теоремы, которые я уже очень давно читал, не могу точно сказать. Точно помню, что в обзоре в блоге опущен момент, почему эти уровни такие, какие они есть, почему они именно такие в стандарте. Эта статья очень хорошо расписывается. А я так понимаю, стандарт опирался на тогдашние реализации. На имплементации, да. Но в статье это гораздо точнее описывается, и в частности там есть интересная теоремка по поводу, сейчас скажу, по поводу сериализуемости, по-моему. В общем, есть такая фундаментальная теорема сериализации, что хорошо сформированный, хорошо имплементированный алгоритм двухфазных блокировок, он гарантирует сериализуемость. И я не уверен, но по-моему там же где-то есть или в соседних пейперах есть результат о том, что сериализуемость это гарантированно самое хорошее, что может быть и что нужно к ней стремиться. Еще благодаря вот этой пачке статей и ссылок в них я наконец-то кристально осознал различие между сериализуемостью и линейризуемостью. Например, почему? Там проблема заключается вот в чем. Что сериализуемость это такое понятие больше из традиционных реалиционных баз данных, а линейризуемость это понятие больше из распределенных систем. Но там даже можно еще по-другому сказать, что линейризуемость она про один регистр. Да, да, да. То есть сериализуемость она про множество регистров локальных на одной машине, скажем так. Да, и больше того, она учитывает предикаты, которые существуют в базе данных. Да, линейризуемость она про множество регистров в распределенной системе на разных машинах. И что такое линейризуемость? Линейризуемость это когда у тебя изменение, вот ты делаешь, например, запись, оно у тебя атомарно. У тебя все последующие операции чтения будут видеть это изменение и все последующие операции записи будут применяться поверх уже примененной. Сериализуемость она означает, что у тебя есть транзакции, идет транзакция 1, транзакция 2, транзакция 3. И если ты сделал успешный коммит на транзакцию 1, то транзакция 2 она будет гарантированно применена, как если бы уже была применена транзакция 1. Даже не так. Существует такой порядок выполнения транзакции, который ты запихал, такой, что с точки зрения системы, которая выполняет все это в один поток, он был бы возможен. Насколько я понимаю, это неправильное понимание. То есть, именно вся фишка в том, что если ты сделал коммит первой транзакции, у тебя гарантированно перед ней не появится какая-то транзакция т2, которая вот внезапно... А вот нет, понимаешь, если т2 не трогает ничего из т1... Нет, имеется в виду, что трогает. Окей. Но там тоже она может таким образом трогать, что это можно переставить. То есть, на самом деле, сериализуемость допускает реордеринг такой, который не меняет инвариантов. Вот то, что ты описываешь, это, похоже, strict serializability. Как раз наоборот, то, что ты описываешь в strict serializability. Сейчас я думаю. То есть, ты описываешь более сильную гарантию, чем я. Согласен. Соответственно, ты говоришь про strict serializability. Ладно, давай опять спишем на вечер пятницы, потому что тут много текста и... Ну да. Нет, вот тут есть в блоге Питера Бейлиса подробная статья, что такое линеаризуемость, что такое сериализуемость, что такое strict serializability. И как они с друг другом вообще связаны. И вот, по-моему, Валер, все-таки то, что ты говоришь, не совсем соответствует этой статье. Я не знаю, может, оно более общепринятому мнению, тем не менее, соответствует. Но я, когда читал эту статью, я вот для себя пометил, что то, что ты говоришь, не совсем соответствует. В любом случае, я понимаю, что то, что мы сейчас говорим, оно довольно трудно для восприятия на слух. Я очень рекомендую всем, кто хочет кристально осознать разницу между линейаризуемостью и сериализуемостью, и вот этим всем, прийти в шоу-ноты, прочитать ссылки. Там действительно короткие статьи, действительно очень понятные. И, ну, не знаю, у вас это займет максимум один час времени, но вы потом об этом не пожалеете. Ну, на самом деле, я вот справедливости... Да, да. Говори, Вань. Да, справедливости ради я хочу сказать, что все эти знания, если вы их не используете, они довольно быстро выветриваются из головы. То есть у меня... Ну, потому что... Вот в итоге я все эти статьи читал, ну, в смысле, вот оригинал, на который они ссылаются, я для себя разобрался, что это такое. Это было где-то года полтора назад. Сейчас я вкратце помню, что сериализуемость – это немножко другое, чем линейаризуемость, но в детали я вот сейчас уже не скажу, в чем отличие. Скажем так, если ты пишешь какой-нибудь более-менее сложный нагруженный вебчик, скорее всего, этими знаниями периодически нужно пользоваться, чтобы понимать, а что же твоя система делает, чертовозьми. Да. Если ты применяешь, и если ты понимаешь, чего ты хочешь добиться, ты понимаешь, какие гарантии ты собираешься давать своим пользователям и все такое. Ну, довольно странно этого не делать, если у тебя все-таки миллионы пользователей, то довольно странно полагаться на 8, с моей точки зрения. На самом деле, это то, что я хотел сказать. Я открыл статью Питера Беллиса, и, Саш, как раз тут очень четко прописано, что чистая сериализабилити без слова strict перед, она как раз, что unlike linearizability, она не налагает никаких ограничений на порядок выполнения операций. Она лишь творит о том, что оно будет эквивалентно некоторому последовательному выполнению, которое корректно с точки зрения наших инвариантов. А вот strict сериализабилити, Саш, это ровно то, что ты говоришь. Угу, хорошо, окей. Кстати, про вебчик и про странные желания, тут из Hacker's News прилетело нечто вообще умопомрачительное. Я когда узнал, ну, я реально думал, что это какая-то первоапрельская шутка, но нет. Есть такая штука, называется ZeroDB. Вы ознакомились? Я услышал, но не успел ознакомиться, притом я услышал даже еще до того, как ты принес в тему. Это очень странная штука, которая делает базу данных с end-to-end шифрованием, понимаешь, от пользователя до пользователя. Более того, это база данных, которая написана на бетоне, что уже очень странно. И насколько я знаю, опять же спасибо коллегу Стасу, который все это мне рассказывал, надо его в гости звать, 100%. Оно чуть ли не шифрует твои данные таким хитрым образом, что если у тебя были возрастающие IDшники, то они зашифрованные все еще возрастающие, поэтому ты можешь делать рейнджсканы по зашифрованным данным и иметь, тем не менее, end-to-end шифрование. То есть база данных, не знаю, с чем она работает, но свойство упорядоченности, оно остается. Как-то так. Довольно странно. Это пипец какая странная штука. Мне вот интересно, оно каким-нибудь образом опирается на так называемые подходы, где multi-party computation, когда каждый выполняет операцию только над своим кусочком данных или это что-то другое. То есть мне реально интересно, на что там внутри. Ну, оно на гитхабе, оно открыто, и есть обсуждение на Hacker News, я думаю. Так-то оно так, но я бы хотел хотя бы просто пару ссылочек на то, ну то есть просто верхнего уровня, на что, какие пейперы там нужно прочитать, чтобы примерно понять все остальное. У них, если я не ошибаюсь, есть собственный пейпер про ZeroDB. Вот, можно его прочитать. А что мы без пардона Ваню перебили? Ваня? Я уже забыл, что я хотел сказать. Вы опоздали. Вообще, у них в статье написано, что они опираются на ZOOP Object Database. Это объектно-ориентированный баз данных для прозрачного хранения питоновских объектов. И она работает как часть ZOOP Application Server. Вот, может использоваться и отдельно. Я не добавил ясности, да? А что еще может использоваться отдельно? Кто у нас главный специалист по кластерным стэкам? По Nomad? Хошекорп сказал, что они выпустили в версию 0.3 Nomad. Наверное, Nomad. Я каждый раз забываю, как надо правильно говорить. И на самом деле изменений очень много. Добавили периодические джобы, которые можно выполнять на... Напомню, Nomad – это шедулер, который запускает ваши задачи на предопределенном кластере, понятное дело. И в версии 0.3 они добавили, что вы можете делать периодические задачи, которые будут как а-ля крон выполняться. То есть, вы прямо пишете в манифесте, что у меня есть такая задача, которая должна выполняться. И там дальше строчку прямо из крона можете вставить. И они будут где-то, когда-то выполняться. То есть, сам шедулер будет следить, чтобы они работали. И добавили возможность делать ротацию логов. Отдельно взятых задач вы можете представить, какое количество файлов для данного лога ведется, какой максимальный размер и так далее. Плюс добавили очередь джобов. И, наверное, все. Это основные фичи, да. У них еще есть подробный ченджлог, где куча исправленных багов. Напоминает, что это все еще версия 0.3, и до версии 1.0 они не рекомендуют это в предакшене, как обычно. Вот это все. Я не знаю, что еще добавить. То есть, написано на GO, ваш любимый GO, один файл скопировал себе, все заработало. По-моему, интересная штука, но Валера вот в чем-то не одобряет. Что-то там про кубики и то, что мало кубиков. Или кубик маленький, я все время путаю. Зависит, на самом деле. Я в целом одобряю весь HashiCorp стек. Я просто, возможно, говорю что-то в духе, что HashiCorp нельзя взять и пользоваться. Я имею в виду HashiCorp стек. Например, Kubernetes можно взять и пользоваться. У него много проблем, которые нужно будет самому решать. У HashiCorp стека меньше проблем, в основном потому, что они не делают готового решения. Они дают кубики. Кубики классные, с аймсек по качеству я их очень одобряю. Вообще, мне кажется, пользоваться можно только сасом. Все остальное ты должен допиливать в любом случае. Толстый не полетит. Валера, ты про то, что, например, консул сам по себе хорош, и намат сам по себе хорош, а когда их надо как-то вместе, то тебе нужно костылить. Почему костылить? На самом деле, смотри, если у тебя есть типовое веб-приложение с типовыми проблемами и решениями, Kubernetes для тебя подойдет. Если у тебя очень левая резьба какая-нибудь, например, у тебя вообще не веб-приложение, то, или, например, если у тебя Big Data, тебе Mesos подойдет, потому что почти все Big Data фреймворки, они умеют на Месосе крутиться. А Numat, как раз тогда, когда тебе ни то, ни другое, нет прям готового решения, то ты берешь Numat и консул, берешь, пишешь количество кода сам, и оно позволяет делать похожие вещи, как и Kubernetes, или как Mesos, но оно будет решать именно твою проблему. Ну, то есть, расточить Kubernetes или... Ну, Mesos попроще растачивается, но там в этом-то и проблема тоже, что его... он очень замороченный, именно потому что он весь такой расширяемый. А Kubernetes вообще очень тяжело растачивать, просто потому что он очень опионейтед, у них есть свое мнение, как что нужно делать, и если твое приложение на это не ложится, ну, как бы, сакс-то бью. Я вот не соглашусь с тобой. Я считаю, что Numat, консул и вообще все крышекорпорские штуки, они просто рассчитаны не на большие конторы, не на большие, не знаю, клостера. То есть, ну, Kubernetes не имеет смысла использовать, если у тебя 5 машин. Так нет, подожди. А вот Numat можно уже использовать, и консул. С другого отличия. Мне кажется, и то, и другое можно использовать на одинаковом масштабе, больше того, конкретно про консул, они делали тесты на гораздо больших клостерах, чем Kubernetes сейчас способен обслужить. Ну, мне кажется, то, что они могут, и то, на что они рассчитаны, основная у них задача. Это как раз наоборот, понимаешь? У них как раз аудитория тех, кто перерос в Kubernetes или что-нибудь такое, им нужно самим строить. И они предоставляют качественные кубики. И консалтят по тому, как эти качественные кубики собирать. Ну, а в Numat версии 0.3 будет кто-то использовать тот, кто уже перерос в Kubernetes? Почему нет? Ну, потому что... Ну, смотри, тебе нужен шедулер. При этом у тебя приложение такое, что оно... Еще раз говорю, если ты перерос в Kubernetes даже не в плане масштаба, а в плане того, что у тебя приложение делает много таких вещей, которые в Kubernetes... Ну, там нет концепции в Kubernetes, которая бы это поддерживала. Ну, давай скажи мне, что можно поддержать в Numat? То сходу банально... Заскедылю мне контейнер, пожалуйста. Когда он умрет, пожалуйста, не убирай за ним данные. Он и так не убирает Kubernetes. Ага. Он сразу гарантирует, что он подчистит. Он его выключит, но сам контейнер, он останется у него. Он гарантирует, что подчищает данные. Он гарантирует, что подчищает данные. Смотря, как у тебя Kubernetes настроен. Но там есть такая опция, как гарбочколектить твои убитые контейнеры. Ты можешь выключить его, и тогда он будет оставлять их все. Заходи на ноду и забирай все данные. Это другая проблема. Понимаешь, мне не нужно все. Мне нужно, чтобы, например, если у меня почему-то машина с Cassandra ребутнулась или с React, не нужно мне мигрировать этот контейнер никуда, если я не скажу обратного ручками. Понимаешь, о чем я, да? И больше того, когда он ребутнулся обратно, не нужно сносить контейнеры и все гарбочколектить. Потому что там могли быть какие-то данные, которые я, возможно, не хотел. Но ты, чтобы это в Numat сделать, ты должен тоже все вручную запрограммировать. Если ты готов программировать вручную... Ну, то есть, Numat тебе дает блок отличный, скедулер. А консол дает тебе другой отличный блок. А докер дает тебе третий отличный блок. Ты берешь, собираешь их вместе, как тебе нужно. Сомневаюсь. Вот реально, я сомневаюсь. Знаешь, почему? Потому что те, кто перерос в Kubernetes, это чаще всего очень большие компании с очень большими кластерами и сложными задачами. Ну, не пойдут они на Numat. Ну, вообще не пойдут. Почему нет? Ну, потому что это масштаб уже такой, где у тебя... Валера, это серьезные компании. Серьезные компании с Enterprise. Если это Enterprise, то я верю, что Enterprise на Kubernetes не пойдет, мне кажется. Ну да, я скорее всего какой-нибудь, я не знаю, Java... Я говорю именно о тех, кто пошел на Kubernetes, а потом перерос. Возможно, они туда целятся, но пока еще не дошли. Ну, скажем так, судя по тому, что они говорят о консоли, что типа консул у нас масштабируется намного лучше, чем многие другие решения, ну, я склонен думать, что они тестировали и, в принципе, ориентируются на такой размер кластера, типа десятки тысяч машин, именно потому что у них, видимо, есть кастомер, у которого десятки тысяч машин. Но представь какой-нибудь Netflix, который еще не такой Netflix, как Netflix, но им тоже нужно билдить инфраструктуру свою, собирать из чего-то и иметь готовые куски и компанию, которая готова оказывать консалтинговые услуги, гораздо лучше, чем совсем все с нуля писать. И давай вот, как раз отличный пример Netflix. Вот Netflix, они хотят разрабатывать свой стэк нуля, свои программки и так далее, они доверятся какому-то номеру. А ты веришь, что они хотят с нуля это делать? Они хотят свой приложение. Они, понимаешь, у них, какой-нибудь Netflix, у них первоочередная задача отдать видео пользователям, отдать пользователям такое видео, которое пользователи хотят, и собрать с пользователями денег. И иметь поменьше риска. Когда у тебя свои рабочие пишут свой собственный код, ты намного меньше риска имеешь, чем ты используешь внешнюю команду, которая... Скоро, потому что, если твои рабочие, они не суперэксперты конкретно в данной области, есть ту, которая написана прямо экспертами в конкретной данной области, то, ну, честно говоря, я бы доверял общепризнанным экспертам, чем какому-то нанятому кодеру Пете, который в детстве, не знаю, один раз написал систему, которая что-то такое делает, и никогда ее в продакшене не оперировал. Ладно, господа, я чувствую, вы не придете к консенсусу, а я вмешиваться не чувствую мотивации. Я чувствую мотивацию рассказать последнюю маленькую темку. Тут вышла игра под названием Mini NIMH, вот так вот. Это клон Принца в Персе, и прям очень похоже выглядит. И open source, и прям запускаешь, работает, и GPL. Вот, может, кому-то будет интересно. Вань, наверняка ты резался в Принца в Персе прям без остановки. Да, играл. А на чем она написана? Ты меня вот прям озадачил этим вопросом. Не, ну это самое интересное же. Оригинальный Принца в Персе написан, конечно же, на ассемблере той платформы, под которой он делался. Тогда ничего другого не было, насколько я понимаю. А на чем Mini NIMH написан, не знаю, скорее всего на C. Так, есть я на Shell, сейчас скажу. C, TEX, ну который тех, и Shell. Shell, и Shell. И Other. Отлично. Конечно, старый добрый C. Тогда надо поиграть. К вопросу, на C не пишут игры, и все на C++ уже давно. Не, ну мне кажется, это как раз те... Это же очень маленькая игрушечка. Согласись, у нее движок оперирует гораздо меньшим числом сущностей, чем какой-нибудь Unreal. Что еще... Даже не game objects, а вот именно типов сущностей, скажем так. Что еще Unreal, это тема наших слушателей. Так, слушатель... Никто не против, да, перейдем? Да? Да? Нет? Да, давай уже. Слушатель Алексей Богданов говорит, что TypeSafe закончил ребрендинг, и теперь компания называется LightBand. И сразу шутка из твиттера. Ваша скала стала такая жирная, что свет ее теперь огибает. Да-да-да. Кто-нибудь разбирался вообще? А на хрена? Ну нет, на хрена, они вроде как там как-то пытались объяснить, все равно очень странно. Я тогда еще следил за блогом TypeSafe и пытался понять, я не смог. То есть там было из разряда, ну мы такие вроде как не про типы, мы там про... Как они там любят это... Distributed Reactive Microservices. Бинго! Ну да, про Reactive вот это все, да. И поэтому они вот решили переименоваться в LightBand, потому что он больше отображает суть. Ну... А, реактивная платформа, вспомнил. Реактивная платформа у них, поэтому LightBand. Я честно говоря не знаю, что Алексей от нас хочет услышать. Да я тоже, ну то есть там еще можно, не знаю, осудить или не осудить лагом, который по-шведски означает, что just the right size. Такая платформа для того, чтобы превратить ваш Java EEMonolith в микросервисы. Я честно говоря... Ну то есть это вообще что такое? Это просто штука, которая отрезает вам ненужные роуты или что это? Я очень с гипотетикой к этому отношусь, и мне кажется это какой-то Snake Oil. И то есть компания вдруг сделала ребрендинг и начинает продавать что-то похожее на Snake Oil, у меня сразу возникают большие подозрения касательно того, стоит ли продолжать доверять этой компании. Стоит ли продолжать пользоваться скалой или срочно нужно бежать ногой. Следующую тему принес послужитель Ашинск. Это статья... Подожди, подожди, Саша, ты же у нас скалист бывший. Неужели тебе нечего сказать относительно того, как ты ощущаешь будущее скала? То есть тут как минимум есть противоречие между а, все, скала мертва, или пофиг, скала все равно развивается на деге университетов, чай не умрет. Я не вижу связи в том смысле, что компания была и она осталась, она переименовалась. Они переименовывались на Java Enterprise, как же так? И даже если компания не станет или они будут заниматься вообще чем-то другим, у тебя все лежит в open source и все кем-то поддерживается. Ну то есть я не вижу больших проблем. Ну вот про Groovy вы много в прошлый раз смеялись, год назад примерно, что вот мол Groovy все, и все. Но так Groovy-то и умер, а скала везде используется. Так Groovy тоже же везде используется, ты что. Так везде используется Groovy. Знаешь, мне кажется, что у этих языков была примерно одинаковая популярность. Вот у меня такой gut feeling. Я предлагаю перейти к следующей теме. Я согласен. Да, давайте хоронить Ирланг. Слушатель Ашинск принес ссылку на Medium-е статье за авторством Дмитрия Деманта, это бывший... Известный деятель российского комьюнити. Русскоговорящего. Создатель Ирлангер.ру. И он пишет о том, что Ирланг умер. И я с ним, что характерно, согласен. И речь идет именно о языке. И я с ним согласен, абсолютно. То есть, ну там суть статьи в том, что то, для чего Ирланг, казалось бы, был хорош, его так там... То есть я точно знаю, что его там используют, но это ничего не open-source, поэтому... Ну то есть у нас есть React-кор, который уже почти не развивается, потому что смотрите предыдущие выпуски, мои стинания по поводу того, что случилось с Zabasho. Есть React-кор, и это единственная такая вот вещь, которая до сих пор делает Ирланга лидером в некоторой области. Но в целом, то, что ему прочили, как языку и как платформе, оно до сих пор так и не случилось. Весь Distributed Big Data и вот это все, оно ушло на Java и Scala. Весь Cluster Management ушел на Go. И еще на C++. Cluster Management на C++. Mesos. Mesos на Java. С каких это пор? Mesos на Java. Ты говори, а я пока проверю. Вот. Я добавлю, он рассказывает, что... Валера, извини, а патч Mesos написан на C++. Сюрприз-сюрприз. Почему тогда Mesos Framework на Java пишут? Я не знаю. Вот. Но возвращаясь к статье, ну то есть тут все правильно написано. Ирланг, он язык, хороший для создания распределенных систем. На чем у нас пишут распределенные системы? Такие как Hadoop, Kafka, Elasticsearch, HBase, Cassandra, например. Вот, все пишется на Java. Или если это, например, вот вспомним, с целу Db ее переписали на C++, Mesos мы выяснили, написан на крестах. Что еще? Cacroach на Go. То есть распределенные системы не пишут на Ирланге. Ну, по крайней мере, те, которые в опенсорсе и вот это все. И поэтому, да, как бы не выстрелил в этой нише. Эта ниша занята другими языками и поэтому умирает. Тут как бы трудно с этим спорить. Ну да, он все еще лидер языков для чат-платформ. Если бы Bosho чувствовал себя лучше, возможно ситуация была бы получше. Но в целом ситуация, когда у нас было два мажорных продукта, кролик и бряк, и оба сейчас себя чувствуют не очень хорошо. Ну, в общем, это печальная ситуация. Но есть еще и JBRT, который как-то держится в лидерах ниши, но он тоже, ну, в целом, на мой взгляд, достаточно спорная штуковина. Мне очень понравился его тезис о том, что Алексир, который появился два года назад, он не сравним с языком Erlang, имеется в виду, по вот этому времени жизни, но он привлекает гораздо больше внимания, он развивается намного-намного быстрее и, возможно, является будущим. То есть, ну, на самом деле, если сравнивать эти два языка Erlang, там сколько релизов появилось, что они там нового добавили. То есть, ну, фактически ничего. Очень обидно это, конечно, смотреть. Ну, то есть, как бы, да, я бы сказал, что я верю в Beam как в виртуальную машину, в немного хороших идей. У него, конечно, есть свои заморочки, но в целом это одна из самых надежных вещей, которые я видел. То есть, Go сейчас, виртуальную, рентайм-Go сейчас приблизился к тому, чтобы быть достаточно хорошим, надежным и даже иметь низкий GC latency. В принципе, я при всей своей неприязни Go начинаю на него смотреть. Вот, да, в принципе, JVM давно у нас, так сказать, у всех в продакшене. И опять-таки с G1 и как бы с недавними даже привнесениями современных трендов внутри самой Java это тоже выглядит достаточно неплохо. Хотя, честно говоря, Java мне нравится. И Java и Scala мне нравятся в плане написания распределенности поменьше, чем Go даже. Вот. Beam, это... Beam как рентайм, он сравним, наверное, по своей истории как с JVM, разве что Go сильно моложе. Это очень хороший проверенный рентайм и, в принципе, на Elixir у меня очень приятные впечатления. Но, к сожалению, Elixir Community, оно больше про вебчик. И вот, то есть, Elixir Community это во многом такие просвещенные ребятки из Ruby Community, которые нашли более хороший инструмент. Но, скажем так, это не то чтобы ребята, которые решают самые интересные задачи на свете. То есть сравнить их деятельность с тем, что делают... То есть ребята, которые делают сам Elixir и Ecto, они делают интересные вещи. А вот в самой комьюнити языка, которая уже вокруг сформировалась, они делают, грубо говоря, вебсайты. И да, я прошу прощения за все умнички новосткательные. Я стараюсь это излечить. Я за Валерой записываю и пишу ему в чатик. И если мы посмотрим на то, что делали люди с Bash, это несравнимо более интересные задачи. Если мы посмотрим на то, как внутри устроен консул или ETCD, если мы посмотрим на внутренности кавки, это гораздо более интересные и сложные вещи. И, к сожалению, они происходят вне Erlang. И я пока не вижу никакого драйвера, который бы принес это обратно в Erlang. Хотя BIM как платформа, наверное, жить еще будет. Следующая тема, она связанная, принес ее Артем Никитин про то, что в Uber самый высоконагруженный сервис написан на Go. Честно, я статью не читал. И честно, я не то чтобы имею много чего сказать. Я посмотрел там цифры. 170 тысяч запросов в секунду на 40 серверах при нагрузке на процент 35% CPU. 170 тысяч запросов в секунду? Да. Я помню, что... На 30 серверах, на 40 серверах. Помнишь, я недавно постил ссылки, сколько запросов в секунду обрабатывает Postgres, когда все данные в памяти. Там было 135 тысяч. То есть всю эту нагрузку может держать два сервера таких обычных на Postgres. Серьезно, 400-500 запросов на один сервер, это не то чтобы очень впечатляющая цифра. Мы же знаем, что даже в 90-х была проблема с 10К. Так ведь, да? А тут меньше 10К на сервер. Я, конечно, понимаю, что он не в стадии, когда это что-то полезное делает. Там квырки какие-то более сложные. Ну да, возможно. Но все еще я бы не сказал, что 4000 запросов в секунду на сервер, и я подозреваю, это не самый скромный сервер, я подозреваю, это довольно мощная коробка. И что-то мне подсказывает, что... Что-то тут ребята накристелили. Это реально какие-то не самые высокие цифры. Я допускаю, что сервис сам по себе внутри может быть сложным, но это не очень понятно. То есть на HDD... Я тут с ребятами недавно делился цифрами. Хождение в HDD с настройками по умолчанию на обычном Postgres, 1000 запросов в секунду держится легко. На SSD это умножаем на 10, условно говоря. Но тут у ребят более сложные запросы, не все влезло в память, но все равно 4000 запросов на сервер как-то маловато. Но они там геокоординаты используют, какие-то полигоны строят, какие-то дополнительные... Ну на самом деле это уже более похоже на... Ну я честно скажу, я не читал статью, это уже более похоже на что-то честное. Работа с Джейсоном... Но с другой стороны, опять же, нам еще не понятно, во что они упираются, в CPU, в GC, в память или в диск. То есть может быть у них столько запросов на сервер, потому что им нужно какой-то кэш держать, который просто... Очень сильно от нагрузки зависит. Не то что от нагрузки даже, а просто от того, сколько у тебя памяти. То есть, не знаю, нам нужно пользователей побить, не знаю, даже по тем же геокускам, и у нас просто каждый геокусок занимается только памятью. То есть, ну серьезно, тяжело... На второй взгляд, тяжело сказать, много это или мало. Действительно нужно смотреть, что там они действительно делают. Следующая тема принес слушатель DNNX, но мы ее уже обсудили, это про Haskell в продакшене. Следующая тема принес слушатель Rux. Ксамарин купил... Кстати, тут забавно написано, что Ксамарин купила Майкрософт, кто кого купил. Я этому чертовски рад. Как пользователь Monodevelop, ну такой, я не то что прям пользователь, я периодически потрагиваю Unity левой лапой. И по умолчанию там Xamarin, прошу прощения, Monodevelop, и в общем, те, кто реально используют Unity для повседневной работы у нас, они все либо на Xamarin Studio, который сильно более стабильный и быстрее работает, либо на Visual Studio Code, который тоже самое, стабильнее и быстрее работает. И мне очень хочется верить, что Майкрософт это сделала, потому что они сейчас в целом взяли в курс на открытие своей бутнет-платформы и на делание ее кроссплатформенной. И я очень надеюсь, что покупка Xamarin была именно для того, чтобы инструментарий, который делают эти люди, чтобы он стал доступен более широко и, возможно, даже бесплатно.",
    "result": {
      "query": "разница сериализуемости и линеаризуемости"
    }
  }
]