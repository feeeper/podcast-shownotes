[
  {
    "segment_id": "e63bfcad-3c0a-4622-8e0a-272ee9c63482",
    "episode_id": "a55d18c1-537d-4465-a59c-a0ba90be4bfb",
    "episode_number": 465,
    "segment_number": 2,
    "text": "Когда ты проложил маршрут, они в зависимости от направления могут вибрировать немножко по-разному. И ты просто не глядя на них знаешь, чтобы налево или направо. Вот. Ну и да, это еще вещь, которая трекает мой сон. Собственно, это на... Трекинг сна и нотификации — это, в принципе, то, почему я их вообще изначально приобрел. Вот. Как-то так. Ну, вообще трекинг активности, да, что... Смотреть, насколько я ленивая жопка. Или наоборот, не ленивая. Кажется, эта тема себя исчерпала. Я предлагаю перейти к следующей. Какая у нас следующая тема? Следующая тема — то, что я. Почему в Postgres вдруг стало все очень сложно заносить? Что? Хотя их вроде никогда сильно просто не было. Ну, тема не совсем так называется. Это блокпост Роберта Хаса. Это широчайше известный в очень узких кругах коммитер и контрибьютор. И, по-моему, я не уверен, он в Core Team входит или не входит, но должен бы входить, по-моему. В общем, крупный контрибьютор в Postgres. И он пишет в блоге статью, которая называется... Хакать Postgres очень сложно. Hacking on PostgresQL is really hard. И такая статья, она, честно говоря, вот даже не на пересказ, а либо на кратенькое упоминание, либо на обсуждение, если получится. То есть он рассказывает с перспективы коммитера и с перспективы разработчика крупных фичей. И... Человека, который выполняет обе эти роли. То есть, на примере, фичи с ингриментальными бэкапами для Postgres и утилиты pgVerifyBackup. То есть он рассказывает, что предложил патч пару лет назад. И там несколько лет его нужно было разрабатывать. За это время люди его, этот патч, ревьювили, тестировали. И вроде как были выявлены все... Проблемы. После чего патч был смержен. И оказалось, что на BuildFarm что-то где-то разваливается. И уже после того, как ты этот патч коммитил, тебе нужно либо его ревертить, но обычно этого делать не хочется, либо тебе нужно сидеть и чинить Postgres, потому что ты тот человек, который все сломал. И делать это нужно в спешке, потому что... Другие коммитеры на тебя косо смотрят и не могут нормально смержевать свои патчи. Ну, в целом ты как бы всех блокируешь этим. Делать это нужно зачастую вечерами или в выходные. Проблемы могут быть сложные, они требуют много часов на изучение, отладку, понимание. В это время в твоей семье у кого-то праздник, день рождения, что-то, а ты вынужден его пропустить, потому что... Все очень плохо, но это приводит к конфликтам в семье. И, имея такой опыт, ты лучше понимаешь коммитеров, почему они такие дотошные, когда дело касается патчей. Они к чему-то придираются, и ты начинаешь понимать, почему они так много придираются. Ты понимаешь, почему так неохотно мерзнутся крупные фичи, и почему так много притирается. И, в целом, это не значит, что ты не можешь их заплатить. Потому что, если ты не коммитер, то ты не коммитер. Если ты автор, но ты не коммитер, то твои патчи замираживали, и ты свободен, и гуляешь. А коммитеру за... Ну, не то, что за тобой, но в случае, если он эту патч замираживал, ему его потом еще и стабилизировать, если что-то пойдет не так. И... Ну, по-моему, это не очень удобно. Это не очень удобно. И... Ну, помимо этого, в статье там разные другие мысли, что... Ну, например, на предмет, какие качества ожидаются от коммитеров по сгрэз, то есть, ну, какого человека скорее сделают коммитером, чем не сделают. То есть, если человек, он дотошный, если он внимательно изучает патчи, ну, если он вот как ревьюер, если он участвует в патче как ревьюер, если он ревьюил патч до такой степени, что потом этот патч мержуется, и с ним все нормально, или почти все нормально, то к такому человеку большое доверие, у него есть хорошие шансы когда-нибудь стать коммитером. Если ты ревьюируешь патчи, говоришь, этот патч офигенен, а потом мержуется, и он совсем не офигенен, то к тебе в сообществе доверие не будет расти, скорее наоборот. Что еще? Ну, и вообще такие вещи, что ревьюеров, как обычно, не хватает, все хотят писать код, никто не хочет его ревьюить и покрывать тестами, например. Не то чтобы у Postgres было плохое покрытие кода тестами, но у начинающих контрибьюторов в Postgres иногда такое наблюдается, что при ревьюировании кодов, например, приходит фича, она не очень хорошо покрыта тестами, ты говоришь, что нужно больше тестов, а человек куда-то пропадает. Ну, вот такой патч не примут. Бывает также, что авторы игнорируют фидбэк, то есть, вот я придумал такую классную фишку, тебе несколько человек говорят, что нет, она не классная, а человек продолжает настаивать на своем. Ну, такой патч, скорее всего, не дойдет до момента, когда он будет принят в ядро. Из забавного первой же комментарии к статье, что, возможно, проблем было бы несколько меньше, если бы код был написан на растя, в чем, наверное, есть доля правды, но мое субъективное мнение, если переписывать в Postgres, то, наверное, уже на го, потому что раст, он имеет такой недостаток... Давайте так. У него есть недостаток, что он резко увеличит время сборки проекта, при этом он, например, не дает того бенефита, который даст го, что ты можешь легко хендлить десятки, сотни тысяч соединений, а для Postgres это очень актуально. Слушай, в расте тоже есть, просто это не на уровне рантайма сделано, и, опять же, для чего-то вроде баз данных, может быть, скорее даже предпочтительно иметь более тонкий контроль. Я, как человек, который писал внутрь Postgres на расте, хочу сказать, что это... Короче, время сборки, ты прав про время сборки абсолютно, но это не будет самообщее панацеей. Там, не знаю, в системах размером с Postgres просто очень много чего сложного, очень много историй, очень много вещей, которые... сделаны с соображением совместимости или были сделаны давно. То есть, не знаю, короче, тот бенефит будет от переписывания, а не от переписывания на расте. Вот что я хочу сказать. Я нежно люблю раст. Я, скорее, с этим согласен, чем нет. У раста есть одно преимущество применительно к этой задаче, что, по крайней мере, мое дилетантское понимание раста... У тебя же, Валер, есть продакшн опыт, да, с растом? Напомню. Ну да, да, есть. Мы с тобой в одной компании работали в тот момент. Это в Black Xampp это, наверное, с растом? В Tanks Carry. Алло. Окей, окей. Но мы же над разными проектами работали. Ясно. Я к тому помню. Я работал над проектом, который до сих пор в open source на расте лежит. Вот в том факте, что сейчас Postgres написан на C, есть большое преимущество, что... Postgres активно использует то, что сейчас модно называть XeroCopy. То есть у тебя то, что прилетело из сети, ты так и интерпретируешь, может быть, с точностью до сетевого порядка байт. То есть там байта надо переставить, а потом у тебя вот пакет, он и есть пакет, у тебя нет действия реализации. То же самое с данными на диске. Ты вот считал данные с диска в память, и всё, ты не производишь никакую действие реализации. В Go... Опять же, моё дилетантское понимание, что это будет сделать сложненько, скорее всего, нормально не получится. Ты будешь иметь эти оверхеды. А в расте я не уверен. Вот как у раста с XeroCopy сейчас. Смотри, в расте можно технически сделать всё, что можно сделать в C. Просто вот прям абсолютно что угодно, что можно сделать в C, можно сделать в расте, потому что у тебя всегда есть unsavedRast. Тебе нужно будет к этому придумать safe-интерфейс, скорее всего. Но я не думаю, что это будет. Но я думаю, что это не должно быть прям большой проблемой. Больше того, в рамках раста есть фреймворки, которые отличаются тем, что они XeroCopy. Поэтому, да, это... Скажем так, это приседание можно выполнить, но я не знаю, насколько оно получится. То есть конкретно в дизайне Postgres есть очень специфичные вещи, вроде того, как моделируются те же самые узлы планировщика, которые... Здравствуйте, я узел. Здравствуйте, я... А теперь я не узел. Ну, теперь я там узел другого типа. А теперь я вообще узел третьего типа. Это все просто улыбненько в памяти лежит. Мы просто берем структуру в памяти и переинтерпретируем ее, как хотим. Вот. А если оно по CAN-у совместимо с тем, как мы его переинтерпретируем, прекрасно. В расте такое можно сделать через unsaved. Но если ты так сделаешь через unsaved, и у тебя будет две разные ссылки двух разных типов, вот тут ты, скорее всего, попадешь на неприятные проблемы. Угу. Еще ты озвучил мысль, что выигрыш будет не от раста, а от переписывания. Я с этим согласен. В моем идеальном Postgres было бы выкинуто ряд фичей. То есть в Postgres по историческим причинам есть фичи, которые были сделаны. Их теперь нельзя выкинуть, потому что люди ими пользуются. Если ты его перепишешь с выкидыванием фичей, то... Ну, я имею в виду, что мы переписываем совершенно отдельный проект. Я имею в виду прям полностью совместимый. И даже в этой ситуации получится проект, который, скорее всего, будет проще поддерживать просто потому, что в Postgres регулярно есть какие-то вещи в духе «ну, мы так написали в таком-то году, и вот теперь мы, короче, это не очень хотим трогать, поэтому оно так написано». Или... Вот так написано. Вот так оно было в версии, там, не знаю, текущая минус 2. И в версии текущая плюс 2 мы это выкинем. Но пока оно вот... Тут, короче, развилочка в пути. Типа, если вы выполняетесь на новой версии, типа, не мигрируете никакие данные, вы, типа, короче, смотрите, вот, короче, как оно сейчас работает. А если вот вам нужна совместимость, то вот так вот вроде совместимости оставлено. И еще куча такой фигни. А можешь привести пример? Слушай, вот сейчас сходу нет. Я помню, что из того, с чем я сталкивался... Да. Добавили какой-то параметр. В каком? Наверно, в шестнадцатом пасгрессе, что ли. В ap-шку какую-то. И потом нужно было везде лазить, короче, и тоже его использовать. Если ты, короче, компилируешься на несколько версий пасгресса, ты со своей стороны должен был... Правильно все, ZF-10. А до какого-то момента, типа, на стороне пасгресса, типа, просто функция была с минус одним... Типа, у тебя была функция с минусом, типа, с минусом. А потом, когда ты попал в пасгресс, и ты, короче, заполнил, ты понимаешь, что это просто... Да. Типа, это просто... Ну, да. И в какой-то момент в пасгрессе, в его внутреннем API, который в Extension торчит, у тебя было два варианта функции. Типа, скажем, у одного три аргумента, у другой четыре аргумента. Функцию с четырьмя аргументами добавили, а функцию с тремя аргументами сделали так, что она просто вместо последнего анала передавала. И оно так несколько версий жило, а потом в какую-то версию они взяли и убрали ту, которая с тремя аргументами, и оставили только с четырьмя. И тебе нужно теперь на стороне Extension делать то, что делала, типа, функция, которая раньше с тремя аргументами делала. Вот, такого рода вещи. Они совершенно точно случаются. Кстати, Extension... В любом случае, с Go будет сложновато сделать. Да. Ну, я такой, что там все равно можно динамически что-то загружать. Ты этого абсолютно точно не хочешь. Я это знаю по опыту работы в проекте, который что-то там динамически погружал. Динамически загружал на Go. Готов себе поверить на слово. Потому что оно сделано... Не хочу сам проверять. Оно сделано просто из рук вон плохого уровня. Я смутно помню, поэтому могу врать, но там уровни... А то у нас тут лучше. А? Нет. Я надеюсь, что это... Я надеюсь, что это выкинули окончательно. Потому что там уровни... У тебя бинарь и вот этот динамический библиотек. Они должны быть собраны на одной платформе, одной версии Go. Не дай бог у тебя там бампнулась минорная версия. У тебя бинарь откажется это загружать. Ну, какие-то такие странные вещи. Там оно не выгружается. Но оно, в принципе, по-моему, нигде не выгружается. Короче, это была такая боль. Я никому не рекомендую. Не, ну так-то, в принципе, ты же можешь даже сделать так, чтобы Extension был отдельным процессом. Он должен был быть через... Что это, наверное, работало, что-то такое. Накладные расходы уже. Вот тоже правда. У меня еще какая-то мысль была по поводу Rasta. Я хотел назвать вещи, которые я бы хотел выкинуть. Могу их показывать. Да, да, говори. Вот. Я могу повторяться по отношению к предыдущим выпускам. То есть наследование таблиц я бы однозначно выкинул. То есть это фича, добавленная на вебинар. Добавленная на волне моды, что все должно быть объектно ориентированным. Это поддержка Windows. Мне кажется, в современных реалиях никому не нужно на Windows запускать Postgres. Ну, потому что у тебя есть теперь свой в совместимости с Linux на Windows, например. И еще есть странная фича, которой я никогда не пользовался. Но я так краем глаза видел, что... Это... Типа библиотека, которая DSL для языка C, которая на языке C, вот прям в коде на C, позволяет тебе писать SQL, а оно потом транслируется в запросы к Postgres. Это очень странная штука, но... Да, я в прошлый раз от тебя про нее услышал. Не поверил, пошел искать, действительно есть. Это очень странное дерьмо, и оно существует. Оно не должно существовать. Ты не вспомнил про Rast? А, сейчас. Я потерял мысль. А, вспомнил, да, что на Rast, если бы я переписывал... Нет, ну ладно, переписывать не хочу говорить. Если бы я переписывал, я бы, наверное, просто на Rast переписывал. Если бы я делал принципиально новый проект... Мне очень нравится связка из Rast и Go. Rast хорош там, когда нужно вот прям в конкретном количестве памяти сделать конкретные вещи и... Как это... Быть максимально оптимальным. И когда у тебя есть время подумать, написать, два раза переписать, и сделать хорошую работу. И когда у тебя есть время подумать, написать, два раза переписать, и сделать хорошую работу. А Go хорош там, где есть что-то, что торчит в пользователя, где нужно охендлить сеть, где нужно часто переписывать, возможно, без того, чтобы... Ой, не часто переписывать, sorry. Часто что-то чуть-чуть менять, но не полностью. Проблема Rast как инструмента, который... С очень сильными статическими проверками. В том, что если ты что-то поменял так, что у тебя больше твоя старая... В том, что если ты что-то поменял так, что у тебя больше твоя старая... Назовем это архитектура типов. Примерно понятно, о чем я? Архитектура типов? Нет, разверни мысль. Вот как ты свою архитектуру приложения, как ты ее превратил в типы данных и в лайфтаймы этих типов данных, лайфтаймы твоих ссылок? Какие у тебя структуры, в каком классе лежит, в каком структуре, там нет класса, в какой структуре у тебя что лежит, кто на что как ссылается? Примерно понятно? Ну, в общих словах, да. Вот, у тебя же так или иначе оно отражается в типах данных, и в расте, поскольку у тебя еще есть ссылка, она часть типа, в смысле, время жизни ссылки, это часть типа, тебе это тоже в итоге проникает в твои типы. Если ты в какой-то момент хочешь так поменять архитектуру, что тебе нужно по-хорошему менять кто на что кого как где ссылается, привет рефакторинг. Это очень хорошо с точки зрения, что ты не забываешь, нечаянно где-то какую-то память, ты не забываешь нечаянно где-то какие-то поведущие объекты, или там, например, компиляторы регулярно помогают тебе найти ситуации в духе, ой, блин, а здесь же действительно надо вот так вот. Это здорово с этой точки зрения. Это не здорово с точки зрения, а мне завтра выкатывать это, и можно я вот сейчас починю, а потом подумаю, как это хорошо переписать. С этой точки зрения языки с управляемой памятью, они сильно проще в добежать до финиша. Вот. И, наверное, я бы в свой проект старался бы делать просто на комбинации чего-то такого Go, Elixir, Python, там, где часто меняющийся чуть-чуть код, который торчит в пользователя, и раз там, где есть один раз уже хорошо придуманный тестированный алгоритм, который почти никогда не меняется, его нужно один раз хорошо написать, протестировать и больше не трогать. Или в следующий раз полностью переписывать. Вот. Как-то так. Но в случае, если нужно делать по сгресс-совместимому систему, я не знаю, где там провести такую грань. Потому что вот уже, как бы, компилятор SQL и планировщик, ты в него хочешь расширение ссувать, ты, как бы, в принципе, сам компилятор можно было бы иметь в гошной части, но ты когда-то не сможешь его расширять, например. Ну и так далее. То есть это сложно одно от другого оторвать, чтобы не сделать слишком сложно. Вообще расширяемость бывает разная. Тебе не обязательно прям динамические библиотеки подгружать. То есть тот факт, что ты в фастгрессе можешь объявить собственные пользовательские типы и хранимые процедуры, это тоже расширяемость, правильно? И точно так же через например, если ты реализуешь исполнение какого-то байт-кода или какого-то скриптового языка, то ты можешь реализовать расширяемость через это, просто она будет как бы не совсем оптимальна. Ну просто красота фастгресса, опять же, если мы говорим про делать полностью фастгресс-совместимую систему, в том, что ты можешь объявить свой тип, типа createType, просто на уровне SQL, потом взять у него и подсказать, что у него какое-то представление, оно какое-то даже так, вначале сделать у него представление какое-то, которое будет, скажем, tuple, просто на уровне SQL, сделать функции хранимками, а в следующей версии своего расширения поменять, сделать у него какое-то внутреннее представление, или внутреннее представление поменять не факт, что получится, хотя, если аккуратно быть, то может и получиться. Функции точно совершенно можно переписать потом на нативные, и оно просто для пользователя расширения будет заметно, оно просто быстрее станет. Вот эта штука про расширяемость, она также сглаживает кривое обучение, если мы говорим об изучении кишок, то мы говорим об изучении баз данных, и в этом отношении Postgres имеет что-то общее с тем же ядром Linux, куда тоже легко заходить через модуль ядра. То есть расширяемость проекта, она полезна не только расширяемостью, но и тем, что людям легче въехать во внутренности этого проекта.",
    "result": {
      "error": "API request failed: Error code: 429 - {'error': {'message': 'Rate limit reached for gpt-4.1 in organization org-xSG9D345gtYlIKC330wCyrEG on tokens per min (TPM): Limit 30000, Used 26067, Requested 8080. Please try again in 8.294s. Visit https://platform.openai.com/account/rate-limits to learn more.', 'type': 'tokens', 'param': None, 'code': 'rate_limit_exceeded'}}",
      "stack_trace": "Traceback (most recent call last):\n  File \"/home/andrei/Projects/podcast-shownotes/scripts/build_search_eval_dataset.py\", line 157, in generate_search_query\n    response = await self.client.chat.completions.create(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/resources/chat/completions/completions.py\", line 1927, in create\n    return await self._post(\n           ^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1767, in post\n    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1461, in request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1547, in _request\n    return await self._retry_request(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1594, in _retry_request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1547, in _request\n    return await self._retry_request(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1594, in _retry_request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1562, in _request\n    raise self._make_status_error_from_response(err.response) from None\nopenai.RateLimitError: Error code: 429 - {'error': {'message': 'Rate limit reached for gpt-4.1 in organization org-xSG9D345gtYlIKC330wCyrEG on tokens per min (TPM): Limit 30000, Used 26067, Requested 8080. Please try again in 8.294s. Visit https://platform.openai.com/account/rate-limits to learn more.', 'type': 'tokens', 'param': None, 'code': 'rate_limit_exceeded'}}\n"
    }
  }
]