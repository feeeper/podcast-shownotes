[
  {
    "segment_id": "e380f258-061a-4e72-9034-4d640e10bd8e",
    "episode_id": "e4f00f34-8f2f-4df4-b658-90a03f0cf1df",
    "episode_number": 242,
    "segment_number": 6,
    "text": "С другой стороны, тестировать на каждый чих выкатку обновления, выкатку возвращения релиза и тестирование, что после этого у тебя все тесты проходят правильно, это тоже реально сложная задача. Я согласен, это совершенно отвратительная проблема, с которой приходится сталкиваться в реальной жизни, и единственное хорошее решение, которое мне известно, если нам действительно очень критично не потерять данные, состоит в том, что изменение схемы происходит на протяжении нескольких релизов, то есть сначала мы релизим версию, грубо говоря, допустим, мы хотим заменить интеджер-колонку на float, от балды пример, ну допустим. Первый релиз, который мы делаем, он все еще использует нашу старую интеджер-колонку для того, чтобы читать и писать, но параллельно, когда он пишет данные, он еще и пишет копию во float. Соответственно, когда этот релиз выкатывается, мы все еще не используем вот эту новую колонку, но при этом у нас есть старые данные и постепенно начинают накапливаться данные в новом формате. После того, как этот релиз полностью раскатился или параллельно с этим, мы можем сделать backfill нового формата для всех уже существующих записей, прогнав одну миграцию, грубо говоря. И благодаря тому, что наш новый релиз уже пишет данные и в новом формате тоже, все новые данные имеют в какой-то момент... все данные у нас находятся в двух форматах. Следующий релиз начинает читать и писать данные в новом формате, но при этом продолжает писать данные из старой колонки в старую колонку. Таким образом, опять же, у нас оба варианта данных хранятся, доступны и актуальны, и если нам в какой-то момент надо сделать шаг назад, то мы просто откатываемся на предыдущий релиз и у нас все еще есть валидная копия старых данных. После того, как мы перешли на релиз, который пишет две версии, но читает уже новую, и эта версия работает хорошо, мы можем выкатить следующий релиз, который перестает писать данные в старом формате, и опять же мы все еще храним ту старую колонку на всякий случай, если надо откатиться. И после того, как вот этот новый релиз уже достаточно... мы достаточно в нем уверены, он всюду раскатился и ничего нигде не показывает никаких тревожных знаков, после этого уже можно удалить вот эту колонку, а может даже и не надо удалять от греха подальше. Это достаточно надежный способ, который... на самом деле не я его придумал, его используют практически все компании, которые не хотят потерять пользовательские данные, но это очень западно.",
    "result": {
      "query": "безопасная смена схемы базы"
    }
  }
]