[
  {
    "segment_id": "9c562aa1-24ae-40ce-a2cf-42b3170229d5",
    "episode_id": "ee5f3e8c-ac1b-4ca9-be2a-62098f855a66",
    "episode_number": 19,
    "segment_number": 4,
    "text": "Я думаю, это довольно много. Так если ты две недели целиком, целыми днями с докером работаешь, мне кажется, ты неплохо погрузишься сюда. Ну для составления первого впечатления, конечно. Да нет, если продукт как бы нормальный, то две недели в принципе вполне время. То есть ты начинаешь его пользоваться, если он нормальный, то у тебя все вроде нормально, ты еще думаешь, а вдруг что-то я еще просто не нашел. Но когда ты сразу начинаешь ощущать такой поток проблем, то явно что-то не так в консерватории. Не знаю, мне в целом не погружался так глубоко, я имею в виду, что у нас нет в продакшене докера всевозможных комплектаций, но мне лично не кажется это большой проблемой. Но надо, видимо, окунуться так же, как он окунулся, а потом уже делать выводы. А вагрант у вас есть? На локале, то есть в продакшене нет. А что вы с его помощью делаете? С его помощью локальное окружение для тестирования и подъема всяких штучек. Ага, ну понятно. Слушай, а вот для тупых, а чем ему сеть не понравилась в докере? Вообще в докере довольно сложно настроить, как это сказать, скажем, если у тебя на одной машине работает один контейнер, это окей. В том плане, что один процесс на одну машину, одна роль, как сервис архитектуры. А если у тебя, скажем, на одной машине тебе необходимо запустить, скажем, три ноды орланговских, и при этом у тебя каждая из них должна открыть себе какой-то определенный порт, то здесь могут начаться проблемы. То есть, во-первых, как ты будешь открывать наружу, что у тебя в каждом контейнере есть, в каждой ноде есть три контейнера, а в трех контейнерах разные запущенные инстанции орланговские. То есть ты должен как-то EPMD говорить, что вот я здесь работаю, и неизвестные тебе заранее порты как-то транслировать наружу, чтобы все окружающие ноды видели. То есть вот с этим довольно сильная загвоздка. Нет, подожди, подожди, там же вроде мапятся порты, то есть ты можешь сказать, что вот там в гостевом процессе вот такой-то порт, мобильный локальный порт такой-то. Да, а теперь представь, что у тебя снаружи сетка, и EPMD знает, что он сидит на порту номер, я не помню, какой точно порту EPMD, у него же есть… Есть, есть. А теперь на той ноде у тебя к какому порту какой контейнер будет привязан? Я не понял, еще раз. Ну, скажем, у тебя на ноде А есть чисто-просто работа тареланга, на ноде Б у тебя контейнер с тремя нодами, и тебе надо, чтобы с ноды А все три контейнера, ну как бы как независимые ноды были видны у ноды Б. Для этого EPMD на ноде А должен знать, что на ноде Б есть три разных реланговских ноды, которые все видны в сети. Они все должны ссылаться на какие-то порты, известные ноде А. Ну, я понял, да, печаль. Вот, плюс у тебя, скажем, если у тебя есть необходимость поднять, ну там разные заворачивания сетью, скажем, если три разных инстанца, они все, скажем, должны ссылаться либо на один порт, который ты не можешь замапить на все три разных контейнера, потому что как только ты мапишь на один контейнер, на второй уже нельзя замапить. Ну, что-нибудь типа такого, то есть там бывают такие проблемы. Он еще, знаешь, что там из этой статейки, знаешь, по поводу сети следующего, когда у тебя есть два контейнера, они слушают на каких-то внешних портах и должны как-то между собой общаться. Ну, обычно там по Unix сокету, да, и ты не можешь это просто сделать, тебе надо обязательно делать shared volume, да, на котором будет этот сокет, и тогда они смогут только общаться, и все такие заморочки всякие. Вот-вот. Вы пробовали Base Image? Это ты... Я вот буквально вот то, что я сегодня открыл и прилепляю в шоу-ноды и рассказывал сегодня прямо в часике в нашем. Там это ламп? Нет-нет-нет. Сейчас я прилеплю ссылку. Идея вот в чем. Ты когда в контейнере запускаешь приложение, ты используешь образ какой-то операционной системы, да. На самом деле у тебя в контейнере есть файлики, но запускается только один процесс, правильно? То есть тот, который ты... Почему в докере обязательно нужно указать в качестве аргумента процесс? Потому что запускается на самом деле только он, а потом от него всякие челды. Да-да. Вот если ты запустил, например, твое Erlang-приложение, то оно работает в такой виртуальной среде, и у тебя нет систем-ди, у тебя нет систем-ди. И нита. Сис-лога, у тебя нету и нита, у тебя нету ротации логов и так далее. Это вообще очень странная конфигурация, там все как бы нечестно. Ну вот. И это может приводить к ряду проблем, и вообще это не очень удобно, согласись, да? Там запускать эту монгу-дб с ее десятью разными флагами. Что сделали вот эти ребята, которые выложили бейс-имидж? Бейс-имидж это такая прохаченная убунта, в которой... У них там самописан какой-то инит. И ты в своем контейнере говоришь, вот, использовать бейс-имидж, запустить в нем вот этот май-инит первым процессом, и у тебя такая получается на самом деле легковесная виртуалочка. У нее автоматически поднимается ssh, сис-лог, ротация логов, там чего-то еще, плюс она там как-то так подхачена, что обходят некоторые незакрытые баги докера. В общем, ребята это разрабатывали, они так говорят, что мы там нашли столько подводных кораблей, что, короче, просто караул, и вы не пытаетесь изобретать свое, вот, используйте наше готовое. Ну вот, что получается? Ты запускаешь этот бейс-имидж у себя в докере, потом идешь туда, пейс-ссх, и просто устанавливаешь сервисы, которые там через sudo service start и так далее. Понимаешь? То есть это намного удобнее, ты можешь запустить там твои три erlang-нода, и у тебя будет один epmd, который ты пробросишь через один порт и так далее. Да, да, понятно. Меня именно вот, хотя бы ради того, чтобы не прописывать кучу вот этих флагов тому единственному демону, который ты хочешь запустить, вот только ради этого, мне кажется, имеет смысл использовать. А в смысле каких флагов? Ну, отключить всякие там, не знаю, логирование и прочее, то, что обычно у всех нормальных каких-то сервисов есть по умолчанию из коробки, обычно куда-то пытаются там писать логи и прочее, а тут у тебя ничего нету, и ты должен это искусственно там на уровне конфига, либо там флагов у своего бинарника отключать, чтобы он никуда не пытался ничего ломиться. А тут у тебя маленький образ, где уже мини-операционка, и вроде все есть, и твоему сервису не надо париться. Я очень понимаю, для чего нужен инит, то есть, как бы я реально вижу плюс. Подожди, он у себя зэмби прикрывает. Я все равно не очень понимаю достоинства, то есть, как бы, ну да, у тебя есть как-то возможность поднять свой сервис, но чем это лучше? Намного вот лучше, чем, то есть у тебя все равно, скажем, если у тебя есть операционная система, и ты какой-то вольюм монтируешь, и ты можешь там, например, вставить в операционную систему, и ты какой-то вольюм монтируешь к контейнеру, то потом все эти логи и так далее, все складываются в этот вольюм, в какую-то папочку. Чем это хуже или лучше, чем если у тебя своя настройка будет внутри этого контейнера? Ну вот представь, ты взял, что ты хочешь завернуть в докер, допустим, у тебя там какой-нибудь графит со статсди, потому что их писали криворукие питанисты, которые не умеют нормально заворачивать в деп-пакеты и так далее, ты, чтобы не устраивать в сферочную систему, хочешь это развернуть, да? Это совершенно незнакомая тебе программа. Ты должен понять, есть ли у нее там какие-то флаги типа демонизировать сервис, ты должен прочитать все эти маны, указать все эти 100-500 флагов при запуске твоего докера. Понимаешь, какой это геморрой? Вместо того, чтобы просто зайти по SSH, сказать суду apt-get install такой-то, ну там то-то-то, или там pip install то-то-то-то и понеслось. Понимаешь? Нет, я не очень понимаю, потому что pip install, это значит, что у тебя образ изменится. А суть контейнеров в том, что ты этот образ раскидываешь уже как готовое нечто целое, то есть получается, после того, как ты раскидал этот образ, тебе необходимо зайти внутрь каждого контейнера и еще сделать… Нет, наоборот, смотри, ты один как раз-таки поднастроил под себя, как тебе надо, а потом, пожалуйста, раскидывай и раздавай, все, он уже у тебя готовый. Поднастроил, это как? Ну вот ты за SHRU там что-то подшаманил, и все. То есть подожди, еще раз, то есть у тебя есть какой-то контейнер, ты его скачал, с помощью папи-то, я не знаю, у тебя он подкачался, подгрузился, а потом ты заходишь туда ручками и запускаешь apt-get install, что ли? Нет, смотри, вот ты сидишь в Ubuntu, да, для… Да, допустим, без разницы. Ты говоришь там, я не помню, какие там точные команды, но, словно говоря, там, создать новый контейнер, да, ты заходишь в него локально, ставишь все, что тебе нужно, говоришь commit, или там, не помню, там можно экспортировать контейнеры без заливки их в этот репозиторий публичный, и вот потом вот то, что ты накоммитил, раскатываешь. Ну если это можно сделать как-то автоматически, то то еще более-менее, потому что обычно это выглядит по-другому, обычно это выглядит так, что ты сделал какой-то commit, скажем, в docker-файл, в agrand-файл, я не знаю, в puppet или еще куда-нибудь, и в каком-то окружении у тебя разворачивается автоматически сборка, которая подгружает",
    "result": {
      "query": "docker networking setup issues"
    }
  }
]