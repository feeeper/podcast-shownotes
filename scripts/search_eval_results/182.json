[
  {
    "segment_id": "2e920de7-8c72-4a1d-814f-31a30836061c",
    "episode_id": "2098e79f-74f2-4899-9be7-71aca7c42f79",
    "episode_number": 182,
    "segment_number": 8,
    "text": "Так, я должна сейчас быть осторожной, чтобы ничего лишнего не сказать. Ну, в общем, я всё время, когда училась в институте, я всё время боялась попасть в Enterprise. В итоге я в нём оказалась. Страшно? Какого там? Ну, сначала я даже не поняла, что это Enterprise, потому что компания была среднего размера, даже я бы сказала малого размера. Потом компания была поглощена другой большой компанией, которая тоже занимается поставкой платёжных сервисов. С точки зрения технологий практически ничего не изменилось, поэтому я пришла к выводу всё же, что это Enterprise. И хоть не самое ужасное, могло быть и хуже. В общем, мы работаем с... у нас несколько проектов. В общем, у нас один большой проект, но разбит на несколько частей. И в основном сейчас у нас мы используем Java 7 версию. И в некоторых проектах даже у нас есть compatibility с синтексой 6 Java. То есть мы не можем никак перейти, потому что некоторые библиотеки критические для нашей системы, они не работают с Java 8 вообще, и с Java 7 даже. То есть синтекси с них не совместим. А мне, кстати, если ты можешь сказать, что тут в библиотеке такие? Я так понимаю, это скорее security что-то связанное. Это не security. Я, наверное, не буду говорить, что это за библиотека, потому что, скорее всего, я не могу раскрывать такую информацию. Но эта библиотека критична для работы платежей, критична для работы интеграцией. И, в общем, она такая старая довольно и не обновляется. И поэтому, без нее мы отказаться не можем, потому что мы очень на ней завязаны. И отсюда возникают все проблемы с обновлениями. Но, несмотря на это, мы сейчас обновляемся, и, по крайней мере, многие некоторые части системы. Но самое смешное, что обновление, наше обновление до Java 8 немного запоздало, потому что в сентябре и уже нужно обновляться до 9 века. И получается так, что вместо того, чтобы размазать эти усилия по обновлению версии на более длинный временной отрезок, мы должны будем делать все по пх. Ну, такие реалии интерпрайза, потому что то ресурсов не хватает, то приоритеты другие. И потом оказывается, что в итоге мы делаем то, что нужно срочно делать. И сейчас обновление — это довольно срочная задача, потому что поддержка 7 и даже 8 Java уже заканчивается. А, кстати, можешь рассказать, каким образом у вас проходит код-ревью, Ксюша? Ну, вот, кстати, что касается код-ревью, у нас все очень хорошо. И есть continuous integration. Мы используем GATE, если вы знаете такую тулу для код-ревью. Она, по-моему, пришла из Google. В общем, это свободная тула. Она у нас интегрирована с Jenkins, с Jira. И, в общем, после того, как все билды Jenkins, все тесты прошли, задача ревьюется каким-либо разработчиком. И только после этого ее можно смножить мастером. В мастер мы напрямую смежить ничего не можем, это запрещено. Таким образом у нас мастер защищен от разработчика. Мне кажется, довольно такая традиционная практика — не коммитить в мастер. Галя, а как у вас с коммитами в мастер? У нас нет одного большого репозитория, куда все могут коммитить. И мне коммитить, когда разрабатывают, потому что мы делаем всякие ML-модели. И обычно для каждой своей системки небольшой есть свой отдельный репозиторий. И вообще, на самом деле, нужно не забывать, что я сейчас сижу в ресерче-деле внутри Avast. Поэтому там в же самых стандартных практиках, как и обычно в software-development. То есть есть репозитории, есть иногда ревью. Даже где-то есть Continuous Integration в особых этичных местах. Но конкретно у нас нет одного мастера, куда нельзя коммитить, я бы так сказала. Маша, а как у вас с ревью? У нас есть ревью. Но для нашей темы у нас есть и pre-commit, и post-commit. То есть на pre-commit ты рассказываешь, что ты сделал. И это один из пойнтов того, что я говорила, что на саб-кенде в принципе любой разработчик знает, что происходит во всех частях. То есть это сделано с этой целью. Ну и post-commit-ревью, чтобы посмотреть на какие-то более синтаксические, чем идеальные недостатки. Но вот, кстати, про commit и мастер, и про то, что ты спрашивала про Perforce, я сейчас вспомнила. У нас есть такая штука, что в мастер-ветку идет достаточно большая часть контента, потому что контент трудно переделывать и трудно мержить. А для фичей с кодом и чем-то смежным есть отдельные фичи-бранчи, где все дело-то сначала там. Спасибо. Я эту тему, собственно, поднимала по той причине, что у нас есть такая небольшая темка по поводу код-ревью. И дело в том, что код-ревью, обычно статьи, которые это покрывают, они говорят про очень общие темы насчет код-ревью, о том, что вот как правильно писать, как вообще процесс код-ревью устраивать. Эта статья меня зацепила тем, что здесь дается... здесь их мало советов, но они очень такие точечные и конкретные. И мне бы хотелось с вами их обсудить и вообще узнать, что вы думаете по поводу таких банальных вещей. Мы, наверное, все с этим так или иначе сталкиваемся. Вот, например, у нас есть какой-то метод, который... в этом методе вы идете в какой-то... вы можете делать какое-то сетевое соединение, сетевой запрос. И, разумеется, этот метод может выкинуть exception, какая-то сетевая проблема возникла. Но при этом метод должен возвращать вам список объектов каких-то. И в этой ситуации есть соблазн написать, что если выскочила какая-то ошибка, то мы вернем пустой список объектов. Что вы думаете по поводу такой идеи при разработке, при написании этого метода? И как вы считаете, нужно ли все-таки как-то пробрасывать выше exception, либо все-таки нормально вернуть пустой список? Можно я скажу? Да, конечно, вперед. И проблемы. Потому что малое... то есть проглатывание exception с одной стороны зло, но с другой стороны точно такое же зло. Это кидать exception и логировать ошибки, которые потом будут подхвачены мониторингом, и все в панику. И потом какой-то разработчик приходит и говорит, а, у нас этот exception уже несколько месяцев, не обращайте внимания. И в итоге получается, что мониторинг засоряется вот этими сообщениями, и логи засоряются этими сообщениями, и когда проект релизится, ты видишь эти exception логов, и все сразу, должны ли мы откатить релиз из-за этого. В итоге оказывается, что нет, потому что это нормально. Ну, конечно, это не может быть нормально. То есть если это не критично, то логирует warning. И может быть, действительно нужно вернуть просто пустой лист объектов в таком случае. Если это действительно индикатор неправильной работы системы, именно системы, они, не знаю, ты берешь с FTP, проверяешь какие-то файлы, а их там нету, потому что просто банк их туда не положил еще, и ты кидаешь exception. Ну, это неправильно, с моей точки зрения. То есть, вот твоя система работает неправильно, то да, а если это не работает постоянно, или с периодичностью в пятницу работает, а в субботу всегда не работает, то не нужно кидать exception, чтобы лишний раз людей не отвлекать от реально важных проблем. Это, кстати, такая тонкая тема. Я помню, у нас был такой проект, в котором мы работали с очень нагруженной базой данных, от которой уже уходили, и нам сказали, пожалуйста, используйте ее как можно меньше, она сбоит. И действительно, очень часто эта база давала в итоге exception, и какое-то время мы их логировали, но мы поняли, что в этом было мало смысла, и потом просто exception заменились на трассирование. У нас был мониторинг, который показывал, сколько exception в день мы получаем от этой базы данных, и это было приемлемо. Но да, сначала мы писали exception в лог, а потом мы просто ушли от них, потому что, ну, а смысл? Мы и так знаем, что есть такая проблема, она нам ни о чем не говорит, а вот количество этих exception, как часто они проявляются, если их количество увеличивается, значит, какая-то проблема есть. Но дело было не в exception, а вот в факте проблемы с connection. Вот такая была тема. Хорошо, с этим пунктом мы разобрались. Там еще есть парочка пунктов, которые такие интересные, и которые мне бы хотелось отметить особым образом о том, что человек просит, то есть последний момент, чтобы как можно меньше мы отдавали параметров и принимали параметры в методы общего типа, точнее, не общего, а типа контейнеров. То есть, пример — это список, это какой-то option, это какая-то future, и автор говорит о том, что если вы подаете вот такие завернутые объекты во что-то, и этим менее удобно пользоваться, чем методом, в котором просто понятные, то есть не контейнеры, а внутренность этого контейнера — типы. И это, кстати, момент, который я заметила, что я довольно часто такому принципу сама следовала, но у меня не было нигде такой формальности, что вот почему так легче, почему так удобнее, оно как-то мне само собой получалось. А вот интересно, вот у тебя, Ксюша, учитывая, что ты работаешь с Java, у тебя в практике кто-нибудь писал в code.review, что замените метод, потому что он возвращает список, а не конкретный объект, тип? На самом деле у меня лично таких ситуаций не было с code.review, но я думаю, что кто-нибудь да написал бы, потому что это действительно... В общем, в случае с Java у нас вот такого кода нет, вот я не припомню, чтобы такой код где-нибудь был. В общем-то все стараются возвращать либо оперировать объектами, чтобы было понятно, когда ты читаешь код, чтобы было понятно, что метод возвращает, то есть он возвращает какой-то объект, это в этом случае понятно, а если он возвращает какой-то там ArrayList чего-то там, ну сразу нужно идти туда и смотреть, почему и",
    "result": {
      "query": "code review best practices"
    }
  }
]