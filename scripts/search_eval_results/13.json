[
  {
    "segment_id": "759c8409-45fe-4f63-beb3-f64ca69efdfd",
    "episode_id": "c7ed107f-5fa7-410a-9e90-4b6f469409d3",
    "episode_number": 13,
    "segment_number": 7,
    "text": "То есть... А как же цианид где-нибудь в зубе? Свет. Я хочу рассказать про статью. Статью про то, как работает Postgres внутри. Я почитала интересный пост про то, как же работает SQL-запрос, в частности, достаточно простой селект. Он с ордером и лимитом. По сути, ничего сложного нет. В статье рассказывается про то, что же конкретно делает Postgres в это время. А на практике получается у нас несколько этапов. Сначала парсится запрос, потом анализируется и переписывается. Дальше строит планировщик план запроса, и только после этого запрос выполняется. Вообще, очень такая классная статья. Мне понравилось, насколько было всё здорово описано. Человеку захотелось разобраться, как же это работает. Он с использованием дебаггеров и с использованием двух дебаггеров. C-дебаггер и LLDB. Посмотрел, что же происходит. Как казалось, код у Postgres достаточно хорошо написан. И там всё понятно, много комментариев. И можно, в принципе, человеку, не из команды разработчиков, понять, что же творится. После первого этапа, после парсинга, у нас строится дерево, AST-дерево. И потом после этого дерево будет перестроено в ходе этапа анализа и перерисовки. Перерисовки, переписывания. Переписывания, да. Учитывая, что SQL-запрос может быть сложный, там могут быть как вложенные запросы, так и ещё что-то сделано разработчиком, быть может не всегда правильно и не всегда оптимально. Именно поэтому дерево будет перестраиваться. И только после этого оно будет отдано планировщику. И в статье тоже рассказывается, какие функции вызываются, какие методы вызываются в C-коде. Очень так интересно и здорово это всё расписано с картинками, с диаграммами. Прям красота. Чёрно-белые картинки 18 века тебе не особенно понравились. Мне понравились. Ну, это вообще очень интересная статья, прям здорово было. И к тому же в статье вопрос интересный поднимался про то, что это человек-бурбист, и он использует ActiveRecord. ActiveRecord по сути делает то же самое. Он тоже строит, он тоже парсит SQL-запрос. Там не парсит SQL-запрос, но фактически он тоже строит AST, потом его как-то перерабатывает и потом отдаёт Postgres, который делает фактически то же самое. И появился вопрос, зачем это нужно, потому что мы делаем дважды одну и ту же работу. Такая была тема. Там погружаются в индексы деревья и так далее, нет? Нет, тут даже про индексы только в конце, потому что рассказывалось, что насколько неэффективно выполняется такой запрос, а вот если сделать индексы, то это будет эффективно. Про то, как работают индексы, читайте во второй статье. Меня удивило то, что сортировка. Они используют Quicksort для сортировки. Мне показалось это немного странным решением, потому что это не оптимальный алгоритм и это странно. В Postgres? Да. А какой оптимальный? Сортировка Quicksort в худшем случае даёт тебе nQuadrat, при этом MergeSort даёт тебе nLogN. В той же Java используется определённый вариант Quicksort, не сам Quicksort, а называется она по-другому. Когда тебе вспомнить, называется это алгоритм DualPilotQuicksort. Три автора у него, Джош Блох, какой-то русский и ещё один человек, вот я не вспомню точно фамилии. По сути, та же сортировка, но как ты в Quicksort работаешь? Ты делаешь на две части, потом сортируешь меньше элементов в одной стороне оказывается, во второй стороне оказывается больше элементов, относительно опорного какого-то.",
    "result": {
      "query": "how Postgres executes SQL queries"
    }
  }
]