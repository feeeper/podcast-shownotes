[
  {
    "segment_id": "f85bd105-d85e-43fc-8c83-f91957c23b90",
    "episode_id": "0dc842e3-0adc-4b18-b900-523487b053b7",
    "episode_number": 51,
    "segment_number": 4,
    "text": "для Go вообще проблема сборки мусора стоит не так остро, как для JVM, и получается, что сейчас Go очень привлекательный язык для тех, кто хочет писать такие даже плюс-минус софт, скажем так, real-time системы. Еще у него эти легковесные потоки не такие уж дорогие и тормознутые, то есть там, я помню, три года назад Go был такой довольно тормознутый, в том смысле, что он был где-то между PHP и Java, да, посередине, сейчас он прям реально идет следом за C++ перед Java, или там на уровне Java, то есть он реально, его очень здорово разогнали, и прям-прям интересный становится язык от этого, и что характерно, его уже принимает индустрия, потому что у Амазона есть официальные SDK на Go, потому что к нам приходил гость из Индии, который писал про Intel и рассказывал, что там чуть ли не компилятор пишет Intel на Go, ну, в смысле, не на Go, а для Go, там, шибко оптимизирующий и так далее, то есть реально вот от этого языка в ближайшем будущем никуда не деться, и что самое важное, он действительно выглядит неплохо. Вот. А все это было в контексте тем, которые я добавлял, я случайно закрыл вкладку, секунду, да, тут несколько темок, во-первых, пройдет Go Meetup в сентябре в Киеве, вот, прям митапы повсюду, в Москве тоже был митап, мы обсуждали, ну, можно будет перейти по ссылке, посмотреть когда, где, по-моему, где-то в сентябре у них, если я правильно помню. Да-да-да. В сентябре, 6 сентября в Киеве. Там написано, там еще счетчик на главные, если есть 6 недель, сколько-то дней, все такое. Потом я тут занес пару статей про Go, мне, например, очень понравилось про синглтоны в Go, я сначала ловок не понравился, ну, какие-то там синглтоны, что за глупость вообще, вот, а потом начинаешь читать и действительно интересно, то есть, как сделать правильный синглтон, ну, самый простой вариант, у тебя есть какая-то глобальная переменная с ссылкой, ты проверяешь, что если ссылка не null, то там инициализировать объект, присылать ссылки и потом юзать этот синглтон, но у тебя есть очевидная гонка, поэтому что ты делаешь, заводишь Mutex, и все хорошо. Кстати, еще одна фишка в Go, у него есть этот defer, который делает правильное управление ресурсами, ты не забудешь что-нибудь освободить, когда выйдешь из scope. Ну, вот, сделал Mutex, все здорово, но это немножко тормознуто, поэтому у хардкорных C++-ников, у них есть техника, которая называется CheckLockCheck, которая работает так, ты проверяешь, что если ссылка null, то тогда ты захватываешь лок, проверяешь внутри, что у тебя ссылка действительно все еще null, и тогда только инициализируешь объект, у тебя таким образом не нужно постоянно Mutex брать. Это называется Double Checked Locking? Да, у него два названия, CheckLockCheck и Double Checked Locking, тут прямо в статье так и написано. Проблема в том, что кода получается довольно много, там можно ошибиться, забыть, и оказывается в Go есть готовый этот паттерн, он называется Once, который прям выполняет функцию ровно один раз, и в нем прям реализован этот Double Checking, Локинг, не важно. Да, тут еще есть тонкий момент, что компилятор при, ну, во время оптимизации может убрать твою проверку на null, поэтому там нужно использовать атомарную переменную, я вот не знал, что в Go есть атомарные переменные, но оказывается, что есть. Прям Mutex, атомарные переменные, все как у людей, не обязательно все копировать из кучи в кучу. Вот, вопросы, дополнения? Переходим на Go? Ну да, я уже полна решимости на работе протащить, прям всем-всем продаю. Ребята... А я обратил внимание, что ребята, которые писали на питоне, очень любят Go. И рубисты, они все любят. А вот рубисты больше любят Rust. Да, за синтаксис, наверное. Из-за синтаксис, из-за того, что несколько влиятельных таких человек из Ruby community в свое время сказали, что Rust это круто, и теперь рубисты им верят. А, еще что вспомнил, у Go, у него же такая фишка, он супер быстро компилируется, за счет, ну, поэтому там, в том числе, поэтому в нем там нет исключения генериков и так далее, чтобы он был такой простой, чтобы компилировался быстро. И меня удивило, я, ну, ну вот Света знает, как в Scala, когда там проект, он может, ну, у нас там, типа, он минуту или две компилируется, потом еще три минуты надо тесты прогнать. И на самом деле это действительно проблема, потому что ты отвлекаешься, тебе в это время нужно, ну, ну не будешь же ты там три минуты вот просто в монитор смотреть. Ты начинаешь там проверять почту, смотреть чатик какой-нибудь рабочий, потом нерабочий, и, в общем, через полчаса ты понимаешь, что отвлекся, и надо к работе возвращаться. А в Go я там написал небольшую, небольшую программку, жму в идее скомпилиться, сижу, жду, когда же он скомпилиться, и тут я понимаю, что он уже скомпилился, запустился и завершился, то есть там прям, прям моментально. Это, это очень, это очень другой экспириенс. Быстрее, чем Java, не Scala, а Java. Про Java ничего не знаю, никогда не писал на Java, ну, в смысле, писал какой-то очень простой проектик. На Rust-е, что же проблема, что компилируется долго? Я слышал, что на Scala компилируется дольше, чем на Rust-е, но в Rust-е сейчас сделали, вот буквально в последних релизах, сделали штуку, которая делает type-checking без компиляции, то есть она просто выдает тебе ошибки типов, поскольку в Rust-е сложно с типами, и получается, вот если вы новичок, то вот легко, легко именно начать с того, что просто запускать не Cargo, там, Run или Cargo Test, а Cargo Check, и он вам просто типа проверяет. Вот. У них, конечно, вот это, как ее зовут, умная компиляция, то есть он не будет компилировать то, что не менялось, он компилирует только измененные файлы, но все равно там, я так подозреваю, что какие-то вещи все-таки сильно долго делаются, поэтому в этом плане Rust сильно проигрывает. На самом деле, это действительно неприятно, когда язык долго компилируется. На самом деле, вот в Scala, там как, у тебя тоже есть инкрементальный сборка, если ты там поменял один-два класса, у тебя не так, что весь проект пересобирается. В крайнем случае, если у тебя прям реально большой проект, ты нарезаешь его на артефакты, которые тебе не надо перекомпилировать, потому что, ну, это JVM, и прям все здорово. То есть нет такой глобальной проблемы, что все медленно компилируется, но это все равно неприятно, то, что у тебя там, ну, никто не будет там из одной минуты компиляции запариваться там на разбиение на артефакты, а время все равно отжирается. Ну, в Rust, вот я вот играюсь по вечерам, это там полсекунды, секунда, может быть две секунды, но если это делать постоянно, то оно все-таки тоже начинает раздражать, надоедать, это неприятно. А вот когда вот Rust, и ты не заметил, это очень круто. Еще я занес статью, которая называется Stabbing Out Interfaces in Go, про то, как правильно мокать интерфейсы. То есть, допустим, у тебя есть большой интерфейс, там с кучей методов, и есть юнит-тест. И тебе, у тебя код, который ты тестируешь, вязать только пару методов из этого интерфейса. Но в большинстве языков тебе нужно прямо замокать все эти методы, иначе ты как бы не реализовал интерфейс, пошел нафиг. В Go есть специальная подпорочка на этот случай. Ты можешь реализовать, ну, там есть такая специальная синтактическая конструкция, когда ты делаешь стракт, в котором пишешь строчечку с названием интерфейса, и реализуешь только нужные тебе методы. В результате у тебя те методы, которые ты не реализовал, они реализуются по дефолту, внутри у них паник, то есть это в Go есть такой... Не просто упасть. Ну да, типа, в принципе их можно ловить, насколько я знаю, но никто не рекомендует. То есть это, если все очень-очень плохо, ты делаешь паник. Ну вот. И, в общем, таким образом можно мокать интерфейсы в тестах. Мне кажется, это прям здорово. То есть мне понравился прием. Так что, если вы уже пишете про докты на Go или Pet Project, берите на вооружение. На самом деле, это похоже на то, как это делают в динамических языках, там тоже питония или еще где-то, когда у тебя используются там 1-2 методы из объекта, и ты стабишь только их, или мокаешь только их. А здесь получается, просто у них вот эти интерфейсы, которые ты не обязан указывать заранее, как в Java, там говорится, что вот этот класс имплементирует вот это, вот это и вот это. Ты можешь потом сказать, а кстати, вот эта структура, она соответствует этому интерфейсу, и Go просто проверит, что оно не упадет, и все. Допустим, у вас в интерфейсе 5 методов, вы используете только один, вы как бы вызываете только один, она посмотрит, ну окей, ладно. Ты, Андрей, не помнишь, как называется все-таки этот подкаст про Akoi? Я пытался его найти, но не смог. Сейчас найду, сейчас найду. И ты обещал ссылки на Odessa.js, вот это все. Света, у тебя претензии к REST? Ну вернее не у меня, а у какого-то другого товарища, и мне просто статья понравилась. Почему REST не так хорош, как вы думаете? Вот я эту статью почитала, и в принципе в ней есть зерно правды. Собственно, можем начать обсуждение этой статьи.",
    "result": {
      "query": "Go language advantages"
    }
  }
]