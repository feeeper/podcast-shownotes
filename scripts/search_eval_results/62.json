[
  {
    "segment_id": "b4df7a82-045b-43f1-bcb4-cb3f518a79a3",
    "episode_id": "4b923f57-3f19-4019-912c-f77942267ebc",
    "episode_number": 62,
    "segment_number": 3,
    "text": "в принципе, интересно и понятно, но вот что мне было не совсем очевидно, что на самом деле это же, в принципе, натягивается на data log языки запросов, и вот это уже гораздо интереснее, то есть он провел параллель, ну, то есть он провел этот параллель дальше, что вот, мол, у нас есть база данных, есть языки запросов типа SQL для баз данных, потом у нас есть стриминг, языки запросов для стриминга, и больше того, сейчас появились гибридные системы, на самом деле, вот, как бы, ddaus и data log, они, в принципе, могут, ну, data log в меньшей степени, ddaus в особенности, могут выражать подобные системы как просто декларативные запросы, что звучит довольно круто и необычно, на мой взгляд. Можно какой-нибудь пример, а то что-то я уже запутал. Слушай, ну, я не знаю, там примеры из дровских видео, но я не знаю, как так вот, текст там тебе, то есть там пример писать нужно, это же язык запросов, как я тебе пример напишу. Ну, как-то в декларативном виде. Ну, сейчас я найду тут на слайдах пример, чтобы просто зачитать тебе, что ли. Он тут так вот условно очень говорит что-то типа, а вот было бы, наверное, прикольно, если бы мы могли написать что-то вроде, и дальше он приводит, значит, типа такой SQL запроса, который моделирует сервер, что-то, ну, как бы звучит полнейшим мозговыносом, но на самом деле он потом развивает мысль, и да, вот что-то типа ну, то есть, как бы, типа такой запрос пишешь, который похож на SQL, и вот на самом деле он написывает, как у тебя в системе компоненты взаимодействуют. Надо очень любить SQL. Нет, на самом деле это очень похоже на то, что можно написать в AkStreams на самом деле, на их DSL, ну вот прям очень похоже, уже даже прямо сейчас. При этом ты можешь еще какие-то условия специфицировать дополнительно. Ну, да, да, да, ну, как бы, DataLog, он похож на Prolog, но, в общем, но точнее даже так, DataLog, он, наверное, под множество Prolog, скорее так, потому что там нет отрицания. А да, еще он поднял пару забавных тем, вроде того, что, вот что если мы хотим детерминированно, ну, то есть, если мы хотим легко и просто рассуждать о программах, которые написаны на подобном языке, нам нужно либо не иметь отрицания, либо не иметь самореференции. И, как бы, если у нас есть то и другое, у нас сразу случаются парадоксы и недетерминированность, или зависимость, или как бы, зависимость выполнения от того, в каком, ну, порядке операции. Ну, то есть, по сути, нет детерминированности относительно порядка операции. Вот, и он там довольно забавно проходится, потому что, ну, в общем-то, все существующие парадоксы, они, как бы, включают оба, самореференцию и отрицание, то есть там, типа, все парикмахеры, парикмахеры, которые сами, ну, в общем, да, множество всех таких множеств, которые не включают самого себя или что-то такое. Да, все парадоксы самореференции, они тоже, на самом деле, всегда включают не только самореференцию, но еще и отрицание. Вот, это довольно забавно, то есть, забавное наблюдение. А дальше не совсем прораспределенные системы, но все же еще один тоже академический доклад, есть такой очень занятный товарищ, его зовут Фил Вадлер, он же Филипп Вадлер. Он рассказывал про изомархизм Кори Говарда, доклад называется Proposition and Sustypes. Даже если вы пишете на языках с зависимыми типами и уже все это знаете, я все равно настоятельно рекомендую посмотреть доклад Фила Вадлера. Ну, на самом деле, скорее всего, если вы пишете на этих языках, скорее всего, вы уже посмотрели пару его докладов и знаете, что он просто всегда прикольно рассказывает. Там два его доклада, ты в курсе? Я вполне сказал, я обозначил какой из них, Proposition and Sustypes. На самом деле, там в конце случается небольшой сюрприз, что меня дополнительно доставило, я даже не знаю, наверное, чтобы не спойлерить, чтобы вызвать некоторый интерес, досмотрите доклад до последних 7 минут, там где-то в области последних 7 минут случается очень прикольное, в последних 10 минут даже. Я не знаю, чтобы у Филиппа Вадлера были скучные доклады, я просто таких не знаю, не видел. Следующий в моем топе докладов – это доклад Питера Бейлиса When Worst is Best, про то, как дизайн для предельно фигового сценария может на самом деле сильно улучшить качество работы системы в нормальных условиях. И как пример он приводит свой собственный ресерч, что если мы предполагаем, что у нас реплики вообще не могут разговаривать долгое время, а не в качестве какого-то какого-то кавериного сбоя, то на самом деле, если мы работаем в таких предположениях, то мы можем выяснить, что на самом деле многие инварианты, в частности баз данных, которые классически считают, что им нужна координация, на самом деле они не очень требуют координации. То есть можно сохранить ACID-семантику очень часто, вообще не занимаясь никакой координацией, ни распределенными транзакциями, ну если там нужны будут какие-то распределенные транзакции, но при определенных условиях они не обязаны случаться везде изолировано. То есть атомарность там все еще достигать можно, а изолированность, ну в общем она не очень нужна, как выясняется, изолированность с точки зрения ACID. И там в принципе довольно много еще других примеров, и все довольно интересный доклад. Дальше доклады, которые лично мне, там есть еще доклады, которые я не смотрел, но я про них говорить не буду, есть еще доклады, которые я глянул, мне в принципе в них для себя ничего особо интересного и нового не нашел, потому что либо я уже их слышал, либо я просто",
    "result": {
      "query": "datalog vs sql declarative queries"
    }
  }
]