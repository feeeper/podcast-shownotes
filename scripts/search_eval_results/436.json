[
  {
    "segment_id": "b21a585b-0903-460d-baf8-6460b88c834d",
    "episode_id": "b9efcd83-15ca-454d-a208-236e6b1ceb65",
    "episode_number": 436,
    "segment_number": 8,
    "text": "Внутрь пластиковой коробки металлическую коробку. Ну, в принципе, тоже возможное решение. Такая информация. Только проводящие краски нифига не работают. А еще я читаю замечательную книжку, она называется Understanding Digital Signal Processing автор Ричард Лоинс. И это очень доступная книга о цифровой обработке сигналов с относительно пологим порогом хождения. Там все равно есть какая-то математика, но она достаточно вменяемо объясняется. Можно въехать и можно даже угореть. То есть я внезапно понял, откуда берутся отрицательные частоты в преобразовании фурье, например. В преобразовании фурье я все еще не понимаю, и я слышал, большинство людей на планете не понимают, поэтому если вы тоже не понимаете, то вы в хорошей компании. Но, по крайней мере, я понимаю физический смысл отрицательных частот. Но рассказать я хотел про интерполяцию данных. Напомню, интерполяция это когда у тебя есть энное количество точек, ты сэмплируешь, например, какой-то временной ряд. Временной ряд. А сэмплируешь в заданный интервал времени. Принял, Александр. И получаешь какие-то чиселки. А тебе хочется увеличить свою частоту дискретизации и получить точечки между теми, ну, с правдоподобными значениями, между теми, которые ты сэмплировал. Понятно, ты не знаешь, какое там на самом деле значение, но ты можешь, собственно, интерполировать. И, ну, мое вот как бы интуитивное, вот, первое, что приходит в голову, а вот, допустим, мы хотим интерполировать данные в два раза, ну, или в какое-то целое число. Тогда мы берем на вооружение линейную интерполяцию, соединяем точечки прямыми, соединяем точечки отрезками посередине, точнее, не посередине отрезка, а вот там, где он пересекает этот отрезок, пересекает вот эту горизонтальную отечку, где мы хотим новый сэмпл, там рисуем точку и говорим, что это наша интерполяция. В принципе, есть такой алгоритм, да, он называется линейная интерполяция. Вот. Но в этой книге предлагают совершенно другой вариант. Там говорится, что давайте мы наши сэмплы между теми, которые мы знаем, мы заполним нулями. А потом результирующий сигнал прогоним через фильтры нижних частот. И на первый взгляд кажется, что это интересно, что это очень интересный подход, но потом становится понятно, почему авторы так предлагают. Оказывается, что когда ты реализуешь цифровой фильтр нижних частот и умножаешь, не вдаваясь слишком глубоко в детали реализации, в этом фильтре происходит много умножений. А ты в исходном сигнале добавил много нулей. Умножение нуля на любые коэффициенты твоего фильтра – это, по-моему, операция, которую можно не делать. Поэтому такой подход, за счет того, что ты добавлял много нулей в исходных данных, он вычислительно эффективен. Например, пока он еще не более эффективен, чем линейная интерполяция. Но смотрите, еще возникают два момента. Во-первых, опять же, я не знаю, что сказать, я не смогу это пересказать в подкасте, потому что нужно рисовать картинки, но есть история под названием полифазные фильтры, которые позволяют тебе делать меньше вычислений конкретно применительно к этой задаче. Плюс к этому у тебя коэффициенты в твоем фильтре, они на самом деле симметричные. Представляешь, массив чисел, вот он слева выглядит точно так же, как справа. Левая половина выглядит точно так же, как правая половина. И за счет этого ты можешь сократить все эти значения. И таким образом, используя такой подход к интерполяции, что мы добавили нулей, а потом сигнал отфильтровали, он выходит достаточно вычислительно эффективен. Возможно, более вычислительно эффективен, более вычислительно эффективен, чем линейная интерполяция, хотя это еще нужно сесть и посчитать. Но самое главное, что даже если ты делаешь, во многих задачах, тебе нежелательно подмешивать в сигналы гармоники, которых там изначально не было. Например, если у тебя есть аудиосигнал с битрейтом 48 кбит, а тебе нужно поднять битрейт до 96 кбит, и ты работаешь с аудио или с какой-то записью, ты не хочешь туда какой-то фигни намешать. Это означает, что даже если ты сделал линейную интерполяцию, тебе потом все равно сигнал отфильтровать. Но в этот раз у тебя уже нету нулей на фигни, потому что ты заполнил данные не нулями. Такая вот интересная информация, если вы нашли ее интересной. И в этом контексте мне еще вспоминается, что знаете, часто считается, что алгоритмист это тот, кто шарит в деревьях, сортировках и всяком таком. Нет, алгоритмы бывают очень разные, применительно к разным задачам, и не только в книжке Кнута. Поэтому, если вы интересуетесь алгоритмами, почитайте про цифровую обработку сигналов, это интересно. У меня по этой теме все. Слишком сумбурно получилось. Да нет, много интересного. Звучит как кошмар аудиофила. Да ладно, на фоне как раз играет, рассказываешь. Почему это звучит как кошмар аудиофила? С сигналом что-то непотребное делают, еще не линейная интерполяция, а какими-то странными вычислительно оптимальными способами, не дай боже. Потом у тебя в результирующем сигнале получается как раз ровненько, гладенько, ну, кривая, с точки зрения того, что это все еще сэмплы, но смысл в том, что у тебя результат лучше, чем линейная интерполяция. Окей. Давайте я расскажу, что я научился за неделю, раз уж пошла такая движуха. Давай. И из программерского, я конечно не смогу так долго рассказывать, но тем не менее, из программерского я посмотрел доклад Ивана Угольданского про Thread Wars и Project Loom. Наносит ответный удар, так и называется. Этот доклад рассказывает, как сейчас планируют сделать в Java виртуальные потоки и какие вообще есть подходы к асинхронному программированию, потому что для меня это было очень интересно. Для меня сейчас такая псевдоболь с Python, что там везде нужно писать await async, по сути это классический такой способ, как делать асинхронщину. Но вот в Java такого не было и вот сейчас появляются виртуальные потоки и там довольно много интересного, как реализованы Garoutine в Go, как реализованы в Java они будут, ну, по крайней мере, как реализованы на текущий момент. Вот, это из программерского, а не из программерского. Я буквально, наверное, недели две назад увлекся такой штукой, как приготовление джерок. Джерки это такие мясные чипсы к пивку, вообще самый топ. И я в итоге настолько увлекся, что купил уже там слайсер, машину для приготовления джерок и она у меня там круглые сутки какое-то время работала. Купил уже вторую машину, для приготовления джерок. Вчера сделал мясные джерки, мясные из свинины, я имею ввиду, из индейки в первый раз сделал. И, в общем, сделал получилось 15 пачек, осталось, наверное, пачек 7. То есть половину я уже за один день съел и, в общем, улетают у меня конкретно за раз. Вот. Попробовал сделать джерки из свинины, не кошерных, конечно же, и из индейки. Ну, прикольно получилось. Где ты вообще достал свинину? В Израиле есть возможность достать свинину. Да, в обычных магазинах она не продается, но я живу недалеко от китайского рынка и там чего только нету. Мне на самом деле, да, понравился You have lost karma в чатике. Думаю, тут самое время прореклабировать чатик Девзена, потому что тут частенько интересные мемчики прилетают и все это, я так понимаю, контролируется здесь. Присоединяйтесь. Так, дальше у нас тема и вопрос... Нет, дальше у меня тема одной строкой. Это почти чему я научился за неделю, но не могу сказать, что я это впервые увидел на этой неделе. Это просто так, как это пролетело у меня... Я летел... Я доехал долго на поезде и листал свои видео, отложенные на потом. Я ничего... Ничего для себя я ничего... Прямо совсем супер нового не почерпнул, потому что у нас в универе была похожая штука. Вот. Но... Это интересно скорее для тех, кто никогда не видел, как... Ладно, я, наверное, объясню еще, о чем речь. Я, как обычно, с конца захожу. Ужасно. В общем, у господина Клепмана, который автор книжки с кабанчиком, вышло... Еще в году 19-м был доклад на Strange Loop'е про то, как доказывать, что корректность определенных систем при помощи Изабель. В чем отличие от какой-нибудь TLI+, которую мы обсуждали больше, чем раз в этом подкасте? TLI+, он... Ваша спецификация, она может быть сколь угодно точной, но TLI+, как инструмент, вот TLI+, чекер, он чекает какое-то конечное количество шагов, и он делает дискретный... Дискретный процесс прибора всех возможных вариантов. Есть экспериментальный чекер, про который я, по-моему, тоже говорил, который умеет TLI+, пытаться индуктивно доказать для бесконечно большого случая, но он не для всего и не для всегда работает. Вот. А есть система типа Изабель, и тоже того же самого COQ, и... Я уже не помню, как он назывался, что у нас в универе было, там был какой-то лиспообразный язык. Их все объединяет то, что они не автоматически какую-то спецификацию проверяют, а они помогают вам написать спецификацию, которую они потом сами же проверят. В данном случае он такой простенький алгоритм, Мартин такой простенький алгоритм консенсуса записывает, а потом теорема и лемма для его доказательства. И вот там интересно в этом видео, и я не буду пытаться это пересказывать, потому что это бессмысленно, это нужно взять и посмотреть, что он делает, если вы таким интересуетесь.",
    "result": {
      "error": "API request failed: Error code: 429 - {'error': {'message': 'Rate limit reached for gpt-4.1 in organization org-xSG9D345gtYlIKC330wCyrEG on tokens per min (TPM): Limit 30000, Used 30000, Requested 4380. Please try again in 8.76s. Visit https://platform.openai.com/account/rate-limits to learn more.', 'type': 'tokens', 'param': None, 'code': 'rate_limit_exceeded'}}",
      "stack_trace": "Traceback (most recent call last):\n  File \"/home/andrei/Projects/podcast-shownotes/scripts/build_search_eval_dataset.py\", line 157, in generate_search_query\n    response = await self.client.chat.completions.create(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/resources/chat/completions/completions.py\", line 1927, in create\n    return await self._post(\n           ^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1767, in post\n    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1461, in request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1547, in _request\n    return await self._retry_request(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1594, in _retry_request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1547, in _request\n    return await self._retry_request(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1594, in _retry_request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1562, in _request\n    raise self._make_status_error_from_response(err.response) from None\nopenai.RateLimitError: Error code: 429 - {'error': {'message': 'Rate limit reached for gpt-4.1 in organization org-xSG9D345gtYlIKC330wCyrEG on tokens per min (TPM): Limit 30000, Used 30000, Requested 4380. Please try again in 8.76s. Visit https://platform.openai.com/account/rate-limits to learn more.', 'type': 'tokens', 'param': None, 'code': 'rate_limit_exceeded'}}\n"
    }
  }
]