[
  {
    "segment_id": "0f488184-0cfd-4190-9126-cefb4ed2f828",
    "episode_id": "eb8bc1ab-a149-4d85-b45b-54ae7fc5dd8d",
    "episode_number": 92,
    "segment_number": 5,
    "text": "заточены, я бы так отметил, они довольно прикладные, то есть это не какой-то rocket science, это просто прикладная фича, но она довольно полезная. Известная из них, одна из них это Type Provider, это когда у вас есть какой-то тип данных, не знаю, JSON, XML, что угодно, и вы как бы говорите, вот есть кусок XML, и я его заворачиваю, грубо говоря, в тип, и в конструктор этого типа передаю этот просто XML, как строку пишу, и после этого компайлер мне выводит типы все на нем, то есть у меня реально тип, вот этот XML делается типизированный, или JSON, я по нему могу бегать. Его парсить, не знаю, что угодно, но у меня реально, если там был, например, поле name, и оно string, там строка, content строка, то F-Sharp понимает, что это строка, и он тебе уже говорит, ты пишешь dot, name, и у тебя name это string, это типизированный, то есть очень удобно, если ты с данными какими-то работаешь. Например, то, что я сейчас дизайню, туда F-Sharp большого смысла я не вижу, но мы очень много работаем с всякими payment, ну там, с всякими payment провайдерами, с всякими такими gateway, шлюзами, и мы работаем много с разными данными, типа JSON, нам надо парсить ответы, все такое, то есть нам много проще это все, ну там не так много, что надо парсить, по сути можно просто на C-Sharp, но вот если бы был F-Sharp, это вообще обрешалось просто на раз-два, вставляешь просто response, и все, и у тебя он типизированный. Подожди секундочку, я вот как не F-Sharper, я далекий от мира технологий Microsoft, ну то есть я C-Sharp видел в Unity, на этом мое знакомство с C-Sharp ограничено, ты говоришь, вот, type провайдеры выводят типы на основе JSON, скажем, на JSON он ведь в рантайме, а compiler в компайл тайме. Да, да, да, вот эта штука, она как бы, что сделала, грубо F-Sharp сделали спецификацию, как описывать вот эти type провайдеры, и это что-то типа вроде как плагины, которые ваше IDE запускает, вот когда вы идитете какой-то код, и эти плагины, они имитят для вас, ну, грубо говоря, они имитят код, и все, и это compile код, и ты уже используешь, они метаинформацию, грубо говоря, в тип засовывают, и у тебя уже compiler выводит тип, то есть ты уже когда энтришь свой код, ты реально понимаешь, что это string, это integer и так далее, то есть это типизировано. То есть мы берем типа sample данных, а не любые данные, а просто sample данных, и вводим себе типы по этому sample, так понятно? Ну да, это прям VDE происходит, вот для этого тебе IDE удобно, тебе нужна IDE, по сути, это как плагинчик такой можно. В F-Sharp, кроме этого всего, есть тоже фича, которая называется unit of measure, она вам позволяет работать с разными системами измерений, то есть, грубо говоря, у вас есть метры, километры, сантиметры, килограммы, и вы просто, у вас есть переменные какие-то, и вы просто ставите некий атрибут и говорите, что это миллиметры, сантиметры, метры. И дальше, когда вы работаете с этим типом, и вы, например, пульсуете метры с килограммами, то он видит, что эта операция, она не может происходить, то есть они из разных систем измерения, они не могут нормально складываться, и компайлер вам это ругается. Так это просто решать, в принципе, просто заводить типы, но это очень неудобно. Но кроме этого всего, он умеет, если у вас есть, я уже так не помню, это очень специфичная фича, то есть, если у вас домен как-то затрагивается с такими вещами, вы ее можете использовать, что он, по сути, может вам с километров, с километров в метры, он может автоматично переводить данные. Он вам говорит, что вот это value надо разделить на тысячу, или умножить на тысячу, чтобы ты мог использовать этот тип дальше с километрами, это с метров в километры, ну вот такие штуки. То есть, нужно некий подвид type анализа, но он очень узкий, он именно заточен под эту фичу. Мне, если так взять, в Fsharp те фичи, которые в нем есть, которых нет, например, в Scala, они не делают большой, не знаю, они не захламляют вам синтаксис, но если вам нужна эта фича, вы в этот момент ее используете и радуетесь. Мне нравится, что в нем довольно прагматично все сделано, то есть, четко под какие-то кейсы, но при этом у вас не захламляется язык и у вас не появляются кейворды. Та же фишка есть, например, for comprehension в Scala, в Fsharp эта фишка намного вынесена дальше, они там называются monad comprehension, я не помню, computation expression, по-моему, они называются в Fsharp. Кроме того, что вы можете bind и эти методы unwrap ваши monad, кроме этого вы можете свои кейворды вводить и на этом всем очень прикольно DSL писать. В Fsharp community есть проект, если я не ошибаюсь, что-то типа Storm или Embrace, и они просто делают computation expression, который называется Cloud, вы заворачиваете ваше expression, ваше data processing в этот Cloud, просто curly braces и пишешь Cloud. И оно само параллелить это все на нодах, делает какой-то MapReduce, не знаю, я его не пробовал, но его тоже рекламируют. Мы у себя, например, в Орлянке тоже используем такой же comprehension expression для task, у нас есть, смотрите, в Fsharp есть своя task, она называется async, это монада, которая правильная монада, можно так сказать. То есть это не, вот есть в Scala Future, который ты инициализируешь, он тебе ранится моментально, она не все правила монад содержит. У вас есть Scala Z, и там есть task, которая правильно сделана. В Fsharp есть такая же async, она by default правильно уже была сделана. И нам, например, в Орлянке понадобилось работать как раз с неправильной, то есть фишка Орлинса, что он использует свой task scheduler кооперативный, когда вы создаете task, он их не делает под каждую task новый thread. Он очень затюнен, и мы использовали, нам понадобилось работать с их task, но для этого нам нужен был какой-то DSL, и вот мы использовали это в Fsharp feature и заимплементировали такой DSL с помощью этих computation expression. То есть очень прикольно выглядит и пользоваться удобно. Ну вот что касается, ты сказал, что в Fsharp в Scala не монада, на самом деле этот try тоже не является монадой в Scala, если мы говорим по определению. Но здесь же про другое идет речь, говорит про, я имею в виду юзабельность. Просто мы же пишем production code, мы не занимаемся здесь, не знаю, теоретическим программированием. Если оно, да, пусть оно не все свойства выполняет, ну и что с того, но мы по-прежнему можем использовать всё как монаду, и по-прежнему работаем с ней как с монадой. И от этого ничего плохого не становится. Мне, например, сложно понять тот подход людей, которые говорят, что вот мы притянулись к Scala, потому что там правильные монады, они всё делают по Fp. Ну какой смысл в этом? Ради Fp, да, в юзике ты убиваешься. Я не вижу в этом какого-то смысла. Я тебя в этом полностью поддерживаю, да. Надо смотреть на вещи прагматично, да. То есть фишка в этом есть какая-то, что ты можешь лейзи делать, то есть она не ранится моментально, у тебя какой-то ризнинг появляется о коде. Это та штука, которую они постоянно, очень часто упоминают, что ты можешь ризнинг о коде делать, а не просто ты создал там что-то, оно запустилось, бахнуло где-то и всё, и классно всем.",
    "result": {
      "query": "F# type providers features"
    }
  }
]