[
  {
    "segment_id": "542baedd-b281-4cb8-850c-1ebe3bf21f4b",
    "episode_id": "6f26d3e9-7a24-44a2-9a07-bf712df8418e",
    "episode_number": 374,
    "segment_number": 5,
    "text": "StarDog, нет, я не слышала такое. И последний вопрос, вам не известно, откуда они придумывают такие названия? Ну, вообще, потому что есть такая история, то, что можно соединить два слова, одно из них какое-то существительное, а второе из них, а название животного, и получится классное название для стартапа, знаешь, как дейта дог, вот у нас появился теперь StarDog для названия продукта, поэтому подумайте об этом больше, если вы думаете, как назвать ваш проект или продукт, какое кодовое слово выбрать, что-то и животное, желательно животное, чтобы были классные фоточки, и это сразу же добавляет няшности вашему продукту, и скорее всего оно выстрелит, если будет классное название. Доклад, который мы в этом выпуске обсуждаем, посвящен системе под названием StarDog, читает доклад Павел Клинов, я не помню его тайтлов в компании, но он основатель, и то ли сетевого, то ли кто-то из очень важных технологий в этой компании, простите, я просто банально забыл. Стартап, вообще они себя вроде как не позиционируют как компания про базу данных, они позиционируют себя как стартап для дейта интегрэйшн, для разных интерпрайзов, и среди своих клиентов они называют eBay, Бош, ЦИСК, NASA и так далее. ЦИСК, Света. Там же 70 тысяч человек, мне кажется, в ЦИСК можно найти все, учитывая масштабы, где-нибудь, да что-нибудь будет использоваться, это гигантская корпорация, там чего только нет. Верю, верю, верю. Вот, и вот под этой платформой своей они переграфывают СУБД, и идея, как я ее по крайней мере понял, в том, что если ты компания ЦИСК, у тебя куча разных СУБД, которые хранят разные источники, разные информации, и тебе хочется по ней искать по всей сразу, то ты берешь эту информацию и сливаешь ее в граф СУБД или в платформу Datadog, и потом, используя специальный этот запрос, можешь извлекать нечто. И еще, мне кажется, что в целом основной use-кейс у графовых баз данных он вот такой-то такой, я смутно припоминаю, что мы в предыдущих выпусках обсуждали, по-моему, Neo4j и что-то еще, и use-кейс был примерно такого же плана, но в некоторых случаях ты это используешь не обязательно для поиска по интерпрайзу, а, например, у тебя есть... ты пишешь в App Service, и ты хочешь сделать опишечку, из которой, чтобы клиенты искали данные какие-то, но ты не знаешь заранее какие, и ты просто все, что есть в графовых базах, сливаешь, наружу же прорасываешь редон или API, и пускай клиенты сами решают, чего они хотят. Дальше говорится, что они используют RDF как модель, то есть это тройка из Subject, Predicate и Object. Пример это John, Nose, Mary, John это Subject, Mary это Object и Predicate это Nose. То есть и вот таким образом ты можешь представить любые данные, что у тебя есть там два объекта, и между ними какое-то отношение. Отсюда и графовая база данных, потому что это два узла графа и дуга между ними. Дальше говорится, что в обреки распространенному заблуждению RDF не обязательно<|de|>. Абсолютно skimless есть такая штука, как RDFS, RDF Skima. Из того, что я увидел на слайдах, никогда не работал с RDF Skima, но у тебя просто появляется еще одна дуга на графе с предрекатом RDF Type, и она указывает, что этот узел является типом таким-то, а в остальном это все то же самое. Говорится, что как систему хранения они используют RocksDB с седьмой версией DataDog, а шесть предыдущих версий они сделали на самопальной реализации B-дереви. Дальше они говорят, что их система является ASET и поддерживается Snapshot and Elation с MVCC. Системы распределенные, можно настроить High Availability Cluster, они в распределенном сетапе предоставляют высокую доступность, strong consistency, то есть наоборот в ущерб доступности получается, но зато консистентно. Язык запросов они используют Spark QL, это стандартный язык запросов для графовых баз данных, другой это GraphQL. Spark QL немножко от него веет SQL, но кроме ключевых слов Select, Distinct и так далее, к нему на самом деле не так много от SQL. Реализована система на связке C++ и Java, при том C++ в основном используется для хождения в RocksDB, большая часть системы написана на Java. Основная часть доклада посвящена оптимизатору запросов, он Cost-based, использует статистику, использует Cardinality, в которую мы сейчас вернемся, и очень большую роль играет порядок джойнов, прямо в предыдущем выпуске мы говорили, что это одна из наиболее исследованных частей оптимизации запросов. Под кардинальностью они понимают, что хранят не просто статистику по значениям, как честно не встречаются, они хранят корреляцию, что у тебя есть два значения, и представляй себе матричку, они хранят не просто гистограмму, они хранят двухмерную гистограмму, как значения с друг другом коррелируют. И отмечается, что в мире краховых баз данных без кардиналити, без этой корреляции, можно даже не начинать писать оптимизатор запросов, если ты предполагаешь, что твои данные всегда не коррелируют с друг другом, то можно сразу расходиться, это будет очень плохо работать. На этом моменте пока есть какие-то вопросы? Возвращение, комментарии? Хорошо, если будут. Можешь какой-нибудь пример дать, почему высокая, как эта высокая кардинальность важна для пользователей?",
    "result": {
      "query": "cardinality importance for users"
    }
  }
]