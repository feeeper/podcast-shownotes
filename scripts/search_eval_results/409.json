[
  {
    "segment_id": "826ec29e-3d98-4c8b-a912-55569c7b98d3",
    "episode_id": "6ce72374-78e6-4b1a-91f2-3e8feb91df7b",
    "episode_number": 409,
    "segment_number": 3,
    "text": "Да. Ну вот, и нас в первую очередь интересовала такая поломка, что сделает СУБД, если увидит признак этой поломки. И посыл был в том, что в граничном случае СУБД может ее игнорировать, ну потому что, ну, на первый взгляд, это нормально, скипнуть ошибку. Сейчас после нашего обсуждения, мне кажется, что это было бы очень ненормально. Это все определяется тем, насколько ты веришь в существование Bitrot, который не детектится смартом и контроллером жесткого диска и так далее и тому подобное. Ну, то есть, вообще, в теории у тебя и должны быть еще счет того, что у тебя выступает день. Я задумался на тему, насколько дорогой некомьюнити с железом может само в железе детексить Bitrot и выше уровнем в софте ты можешь предполагать, что Bitrot не бывает. Но даже если его не бывает, у тебя бывают баги в драйверах, у тебя бывают баги в реализациях файловых систем и так далее. Лучше перебдеть, когда дело касается СУБД. Ну, зависит от СУБД, может там не очень важные котики хранятся. Я могу перестать гадеть. Да, но только не называй больше котиков неважными. Хорошо. А еще я много узнал про transaction ID в Postgres, они же XID. Мы ранее в DevZen говорили о том, что в Postgres transaction ID является 32-битным числом. И в частности, имея не очень большие нагрузки вроде тысячи транзакций в секунду, если сесть и посчитать, приходит осознание, что уникальные transaction ID могут кончиться за пару месяцев. Это на не слишком безумных нагрузках. В Postgres transaction ID сравнивается по модулю 2 в 32-й. Это означает, что для любого ID-транзакция есть около 2 млрд. транзакций, которые относительно этой считаются как будто в будущем и примерно 2 млрд., которые как будто находятся в прошлом. И можно это представить в виде кольца из ID-шенков. Если мы рассмотрим случай, когда у нас есть N-ная транзакция с N-ом ID, допустим мы ее выполнили, после этого мы исполняем еще 2 млрд. транзакций. Пока все хорошо. Когда мы запускаем 2 млрд. плюс первую транзакцию, получается такой сценарий, что вот у нас была N-ная транзакция, она была в прошлом, но из-за целочисленного переполнения, потому что у нас все по модулю 2 относительно этой 2 млрд. плюс первой транзакции, она оказывается не в прошлом, а в будущем. И эта ситуация называется Transaction ID Wrap Around. Сказано было не слишком запутанно. Мы это уже обсуждали и мне вроде было все понятно. Хорошо. В позверсе Transaction ID Wrap Around невозможен. То есть вот этот сценарий, который я описал, фактически он означает потерю данных, потому что в новой транзакции данные, которые должен был видеть, ты их перестаешь видеть, потому что думаешь, что они в будущем. Транзакция исполняется, видя только часть данных, что-то коммитит. Фактически это означает потерю данных. В позверсе Transaction ID Wrap Around невозможен и предпринимаются шаги, почему он невозможен. Есть алгоритм, который его предвращает. Идея заключается в использовании специального ID транзакции. Он называется Frozen Transaction ID или, проще говоря, мы в какой-то момент говорим, что вот эти данные видны всем. Они были очень давно. Транзакция, которая их создала, она давно закоммитилась. Транзакции, которые могли их не видеть, они давно либо закоммитились, либо заборжились. Все новые транзакции эти данные точно видят. Такие данные помещаются как замороженные. Другими словами, замороженные данные, которые видны всем. Когда данные замораживаются, присвоенный им в поле xmin Transaction ID может быть переиспользован. Postgres держит в памяти структуру, которая хранит, а вот где у нас сейчас максимальный xID, который мы можем выделить без потери данных. И по мере заморозки старых данных, этот лимит он двигается по кольцу. Заморозкой данных занимается вакуум. И другой способ смотреть на замороженные данные, это говорить, что это данные находятся бесконечно далеко в прошлом, а не на кольце. Это было предустоя. Но, на всякий случай, если вы недавно слушаете DevZen, потому что приходят люди про Spotify и спрашивают. Если открыть документацию по Postgres и посмотреть, а что происходит в случае, если Postgres не успевает достаточно быстро замораживать данные. Действительно есть документация на эту тему. Документация и сообщение об ошибках, которые Postgres начинает бросать по мере приближения раппа раунда. Документация говорит, что когда Postgres приближается опасно близко к раппа раунда, то система выключается, там так и написано Shutdown, и перестает принимать новые транзакции. И сообщения об ошибках, которые тебя заранее предупреждают, сообщают то же самое. В какой-то момент, работая над текущими почами, я заподозрил, что это не совсем правда. И решил это проверить. Я проверил, и действительно оказывается, что документация не верна. И сообщения об ошибках тоже. Они давно были написаны и с тех пор не обновлялись. На самом деле, система работает не так. Я пришел в сообщество и предложил серию почей, которые это исправляют, но они пока на рассмотрение. Оказывается, несколько моментов. В Postgres Transaction ID выделяется лениво по мере надобности. Надобность возникает в Transaction ID только если транзакция пишет новые данные в диск. Если транзакция только читает данные, то для проверки видимости кортежей Transaction ID этой транзакции не нужен. И поэтому он не выделяется. На первый взгляд, это противоречит интуиции моей. Но я ожидаю, что если я создал новую транзакцию, у транзакции должен быть идентификатор. Логично. У тебя есть сущность, ты ее можешь во вью посмотреть. Но вопреки интуиции, это не так работает. Ты в Postgres создаешь транзакции, и у нее нет ID. В этой в активите что прорывается? No. И ID возникает только в случае, если ты попытаешься что-то записать или если ты запросишь, в Postgres есть несколько процедур, PG Current, Exact ID, которые возвращают тебе ID текущей транзакции. Если у тебя транзакция явно спросит, а какой у меня ID, если его нет, то присвой, тогда Postgres его выделит. Но до тех пор он не выделяется. Если об этом подумать, это очень логично, потому что если бы Transaction ID был нужен для чтения данных, мы не могли бы иметь ход standby реплики. Я отвлекаюсь на чат, поэтому сорянчик. То есть мы не могли бы выделять ID транзакций на репликах, не имели бы легкого способа выделять ID транзакций на репликах, не имея конфликтов с мастером, потому что мастер тоже исполняет транзакции, и не могли бы на репликах читать. Поэтому если подумать, то это в какой-то мере логично, что данные можно читать, не имея ID транзакций. Что же происходит с Postgres, когда он приближается опасно близко к Rapparound? На самом деле он переходит... Да я предположу. Он будет позволять читать, потому что не надо создавать новые транзакции, даже если ты приблизился максимально близко. Ты почти прав. Действительно, на самом деле он просто отказывается выделять новые Transaction ID и бросает ошибки, если ты пытаешься их делать. Если у тебя читающая транзакция, то все нормально, ты можешь читать сколько угодно, о Postgres возражать не будет. Более того, если у тебя была пишущая транзакция, которая была создана, которая был присвоена Transaction ID, когда-то давно, до того как мы к этому лимиту приблизились, то с этой транзакцией тоже все нормально. Она будет и писать, и читать, и она может успешно закоммуниститься. Postgres возражать не будет. Более того, после того как я отправил этот patchset, мне коллега, в третей на 10 детали, сообщил, что есть еще одна ошибка в документации, помимо тех, что я нашел. Документация говорит, что когда вы опасно приблизились к wrap-round, чтобы его починить, вам нужно Postgres выключить, запустить его в специальном режиме, Single User Mode, и под админом в Single User Mode запустить вакуум. Тогда вакуум, он пройдется по данным, заморозит их, подвинет счетчики, вы сможете присваивать новые Transaction ID. Это тоже неправда. На самом деле, ну в смысле это было когда-то правдой, но теперь это не так. Вам не нужно остановить Postgres, вам не нужно запускать его в Single User Mode. Вам достаточно просто под админом на живом рабочем позверсе, который перешел в Redon, прогнать вакуум или вакуум фриз. И это нормально отработает. Когда мы обсудили Transaction ID wrap-around, это звучало как жуткая проблема, потому что пользователи про него не знают, а когда они узнают, слишком поздно, потому что система умирает, и ее нужно как-то чинить в офлайне. На самом деле, система переходит в Redon и может быть починина, пока она находится в этом режиме. У тебя читающие транзакции продолжают читать данные, что тоже не совсем желательно, но звучит не так страшно, как «о боже мой, у меня мой Postgres остановился и ничего не может сделать». Упал и только ВИБИП. На самом деле, когда мы это обсудили, то что «а как же реплики читают без Transaction ID», это все очень логично и даже как-то неловко, что я этого раньше не знал, но я об этом раньше особо и не задумывался.",
    "result": {
      "query": "Postgres transaction ID wrap around"
    }
  }
]