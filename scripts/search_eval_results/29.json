[
  {
    "segment_id": "129a2a01-bb20-49f6-aab7-844535d0f09e",
    "episode_id": "453790f0-4a12-4432-ac0b-6b7a354e8ca0",
    "episode_number": 29,
    "segment_number": 2,
    "text": "То бишь, как бы там тред создали, и потом он никем не используется, что-то такое. Для справки, я довольно сильно уверен, что чувак, наверное, не разобрался или не нашел список рассылок, которые бы спросить. Я уверен, что настоящие знатоки Go придут на ваши комментарии и объяснят, как можно решить эту проблему. Я с удовольствием почитаю, на самом деле. Ну, я с трудом. Я сильно сомневаюсь, что это никак решить до сих пор. Я вот тебе открою сайту, и к нему даже второй коммент пришел. Ну, все-таки, понимаешь, возможно, большинство проблем с памятью можно решить, но проблема, которая там описывается, что для каждой сишной функции нужен тред новый или тред-пул специального, это, простите, дорогая редакция, просто полный пипец. Так можно просто недонастроил как-то, либо банально не разобрался. Нет, именно с этим он пытался разобраться, нельзя никак этого найти. Та тема, которую Валера упомянул, как бы вторая от меня, она на самом деле не такая уж тема, просто небольшое замечание, которое я запостил в Твиттере. Обычно всякие фанаты Go любят говорить, что генерики не нужны, потому что они не нужны в принципе. Я почитал факт по GoLang у них на сайте и выяснил, для меня это было открытие, что на самом деле в Go нет генериков, потому что не придумали, как их правильно сделать. И их собираются сделать, просто пока нет единого мнения, как это сделать правильно. Так что вот, собственно, и всё. Но при этом они говорят, что в принципе и так всё хорошо, и может быть даже и вам не нужно. Света, а ты что добавила? Может быть, а что ещё в Go хорошо? Появилась статья, в комментарии добавили статью, она такая, троллинг языка программирования Go. И всё начинается с того, что вы не понимаете и не любите Go, потому что вы слишком маленькие. Вот Google, который решает большие задачи, они всё хорошо понимают, вот они знают, что делают. И даны были некоторые примеры, довольно интересные примеры, на мой взгляд. Например, у вас есть опциональный какой-то параметр, и вы хотите у этого параметра вызвать некоторый атрибут. И в обычном языке программирования вы бы написали, если параметр там не null, значит вызвать какой-то метод у этого параметра, иначе вернут что-то. То есть, как правило, некоторое подобие тернарного оператора, либо что-то вроде этого. В Go вам нужно явно писать, что если у вас параметр не равен нулю, тогда вы должны делать то-то, то-то, то-то. То есть, это не очень, скажем, легко, не то чтобы не легко, это просто многословно. Ты знаешь, я вот тут немножко не соглашусь с ним. Ну то есть, чуваку не понравилось, что нету как си двоеточия, и то, что теперь мы из-за этого должны чуть более многословно писать. Ну я вот по своему коду, по си я двоеточие использую очень редко. Ну да, но чуть подольше писать. Но это просто выбор писателя языка, некоторые другие вещи не позволяют учить. Опять же, по поводу того, что он любитель. И дальше идёт пример того, очень типичное и привычное всем программистам операции, это перегрузка методов. Когда вы в один и тот же метод подаёте параметры другого типа. И в обычном языке программирования вы бы написали методы с одинаковыми именами, но будут разные типы. В Go так нельзя. Например, у вас метод add, который работает с двумя int, либо работает с двумя строками. В Go вы должны пойти в тип int, там добавить функцию, которая складывает два int. Пойти в тип string, там добавить метод, который складывает два int. И только после этого оно у вас будет работать. Короче, я прочитав эту статью понял, что человек пришёл из C или C++. Ну, оно, знаешь, не очень интуитивно. Там явно C++. Более того. Ну да, так нельзя. И в Haskell тоже так нельзя делать. Смотрите, тоже с интерфейсами прекрасный был пример. В Erlang так нельзя. А про интерфейсы ты читал? Продолжай. Обычная ситуация. У вас есть какой-то интерфейс. Вы имплементируете этот интерфейс. И если вы какой-то метод не заимплементировали, значит вам компилятор угнётся. В Go тоже такого нет. И программист должен сам это проверить. Нет возможности нагрузить компилятор, чтобы он это за вас проверил. То есть если вы ошибаетесь в каком-то там типе, то всё, программист сам дурак. И то же самое с виртуальными функциями. Их тоже нет. Вы должны это сами предусмотреть. Ну подождите, ну вот вы набросились на Go. Я на Go защищаю. И я хочу защитить. Можно я тоже? Давай. Вот если Go такой ужасный язык, как вы его критикуете, то почему на нём так много людей пишут? Почему на нём EDCD написан? Почему до этого никто не написал EDCD на чём-то другом? Саша, можно я тебе отвечу? Я тоже в данном случае не занимаюсь стороной автора статьи, но я хочу тебе ответить почему так. У меня есть по этому поводу очень чёткое предположение. То есть Go даёт достаточно удобный инструментарий для написания конкретных программ. При этом в Ирландии инструментарий в 100 раз лучше. Но в Go он достаточно удобный, при этом Go язык достаточно знакомый тем, кто знаком с C. То есть он очень хорошую нишу занял. То есть если тебе хочется писать какую-то софт-контролирующую сетку, и ты знаешь уже C, ты просто берёшь и начинаешь писать на Go. Ещё такой пойнт. Опять же в конце этой статьи, опять же я не занимаю позицию, когда я не осуждаю Go, я не набрасываюсь на него. Тут в конце ещё есть приписка такая, что автор тоже не является каким-то поборником за то, что Go плохой. Он говорит про то, что Go действительно простой язык, его можно легко понять. Соответственно это всё сделано для того, чтобы упростить язык, чтобы он был более понятным. Вот. Основная идея. Я не помню, рассказывал я или нет, мне всегда казалось, что где-то внутри Гугла есть, как правильно назвать, есть спека, как правильный программистам на C++ писать на C++ в Гугле. Она даже где-то опубликована. И вот наверняка они сделали Go по мотивам этой спеки, что типа, ну мы там в C++ используем наши самоправильные каналы, что-нибудь ещё, и вот, а мы это сделаем в виде DSL и назовём Go, например. У меня есть такие подозрения. Ну не знаю. Мне кажется, чувак просто не догнал идею Go. Я к тому, что, например, где-то в Гугле сказано, что терминальный оператор – это зло. Я, кстати, реально видел туториал, гайды, где так и написано. Да, я тоже. Что там не очевидно, и там ещё какие-то приводятся надуманные причины, но не суть. И, например, где-то в Гугле сказано, что так нельзя, и поэтому в Go так нельзя. Почему нет? Ну, мне кажется, ты полностью прав, потому что писатели языка всегда решают, что надо добавлять, что не надо. То есть, если они считали, что это не надо, они это и не добавили. Хотя ничего не мешало эту синтаксическую конструкцию добавить. И я думаю, это легко добавляется в виде каких-нибудь макросов, которые там допиливаются самостоятельно. Ну, знаешь, макросы – это тоже такая скользкая тема. Да-да-да. Не всегда у тебя есть хорошая поддержка макросов. Скажем, нужно хорошо понимать, когда следует использовать макросы. Правда, Саша? И метапрограммирование. Это действительно так. Это я намекаю на статью Саши. Я понял. Слушатели тоже догадались. Ну, если кто не читал, могут посмотреть. Мне интересно, какое пересечение у нас с слушателями и читателями. Я подозреваю, что оно далеко не 100%.",
    "result": {
      "query": "Go language criticisms"
    }
  }
]