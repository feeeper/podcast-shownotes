[
  {
    "segment_id": "23fc7b7f-fc4a-4346-ae90-ef172c4227a4",
    "episode_id": "28e51d85-11cf-476b-aea2-3b6423c1f8dc",
    "episode_number": 480,
    "segment_number": 5,
    "text": "Ну, во-первых, он 4004. Ну, 40, ну да. Ну хорошо. Я просто думал, что мы нашли комбинацию цифр, которая активирует Сашу. Саша активирует все 4-битные микропроцессоры. Если честно, это единственный 4-битный микро процессор, про который я знаю, но я не специалист в этой области. Я могу немножко истории для контекста рассказать. Во-первых, это первый микропроцессор в принципе в истории. То есть до него компьютеры делали на дискретной логике, на лампах, отдельных транзисторах и так далее. То есть не существовало такой сущности как микропроцессор, интегральная схема. Во-вторых, занимательно, что как продукт он позиционировался как решение для калькуляторов. То есть был большой спрос на калькуляторы, потому что людям сложно считать в уме. И это можно отследить в тех инструкциях, которые в нем поддерживаются. Так, стой-стой, спойлеры. Мы про это поговорим отдельно. Хорошо, тогда замолкаю. Ладно, прежде чем мы погрузимся в статью, пара заметок. Во-первых, написал ее господин по имени Дмитрий Гринберг, который в прошлом отличился тем, что он запустил Linux на 8-битном AVR микроконтроллере. Вот и в какой-то момент ему показалось, что нужно найти еще более серьезный вызов и он решил, что нет ничего более серьезного, чем как раз портировать Linux на самый первый микропроцессор, как Саша уже сказал. Вот статья на самом деле очень длинная, очень детальная, очень классная. Там много интересных технических нюансов, поэтому все пересказать я просто не смогу. Я выписал некоторые занимательные факты, но я сильно рекомендую всем, кому это покажется интересным, пойти открыть статью и просто ее полистать. Статья очень хорошая. Вот. Что касается спойлеров. Это действительно процессор, который был очень сильно заточен именно для реализации калькуляторов. И у него это существенно повлияло на его архитектуру и набор команд. Например Прости, прервал, подальше от микрофона, пожалуйста. Хорошо. Так вот, например, у него нету логических операций. В мануале intel приводит собрутины, которые позволяют реализовать эквивалентные операции с помощью сложения и вычитания, но это несколько команд на каждую логическую операцию. Так что это уже не очень быстро. Что еще следует заметить, как уже было сказано, это четырех битный процессор, поэтому все команды работают только на полубайтах. У каждой команды не больше чем один операнд. Это гарвардская архитектура, то есть в отличие от современных intel процессоров, когда и память и данные живут в одном адресном пространстве, здесь есть два адресных пространства: одно для кода, одно для данных. Что еще интересного можно сказать? Частота по МГц насколько я помню. Частота, по-моему, 740 МГц из коробки. Килогерц. Килогерц, да. Из интересных особенностей архитектуры и еще один след калькуляторного наследия, это то, что у него есть команды сложения и вычитания значений прямо из памяти. То есть это не то, что вот мы загружаем число из памяти одной командой и вычитаем другой командой. Так тоже можно делать, но не обязательно. У него есть выделенная команда вот конкретно взять и вычесть число, лежащее в определенной ячейке памяти. Еще поправочка. Я сейчас смотрю в веке, потому что 4004 я в руках не держал. Смотрите, тактовая частота 740 килогерц это максимальная, но это опорная частота, то есть это частота твоего генератора, который подает сигнал на микропроцессор. Сам микропроцессор одну инструкцию выполняет за 8 тактов, что дает нам эффективную частоту, которая сравнима с той, которую мы обычно имеем в виду под частотой процессора 926 килогерц. Понимаете, сколько он инструкций выполняет? Еще у него довольно занимательно работает команда условного перехода. У команды есть три флага, которые определяют какие условия могут быть, какие условия влияют на условный переход. Первое поддерживаемое это что аккумулятор не равен нулю и регистр аккумулятора это где по сути результаты всей арифметики хранятся. Второе возможное условие это что флаг переноса не равен нулю и третье это что тест пин на самом процессоре притянут к логическому нулю. Что интересно, это что команда позволяет поставить хоть все три, то есть использовать хоть все три этих условия одновременно и если вот все эти три флага включены, то условия будут считаться истинным, если любое из этих отдельных условий истинно. Плюс есть еще дополнительный флаг, чтобы инвертировать результат и делать это не истинно. Хочу подчеркнуть просто может кому-то кажется странным, но как так четырехбитный процессор? Почему четырех? По той причине, что четырьмя битами можно закодировать одну цифру, Поскольку это микропроцессор для калькуляторов, он работает с цифрами. Кроме того, у них были сильные ограничения по количеству транзисторов. 8-битный было бы гораздо сложнее и дороже делать. 8-битный вышел через год, по-моему. Смотри, в этом транзисторах, я считаю, 2300, а 8-бит в два раза больше. То есть да, он был дороже, но как бы техпроцессы позволяли. Поправь меня, если я не прав, но по-моему 8-битный он уже был не для калькуляторов. Он был как продукт нацелен на терминалы. То есть как бы на монитор с клавиатурой, который по кабелю куда-то к большому к большому компьютеру шкафу идет. И поскольку он работал уже не с числами, а с символами, там в этом продукте нужно было поддерживать 8 бит, чтобы ASC мочь. Но ты еще не забывай, что ценовой диапазон терминалов и калькуляторов довольно разный. И в случае с калькулятором цена это гораздо больший фактор. Да. Там вообще еще есть смешная история, что после intel 8008 сейчас я секунду 8 008 вышел в 72 году этот вышел в 71 то есть intel выпустила 8-битный процессор 8008 в 72 а еще по-моему через полгода вышел Motorola 6800 и прикол был в том что Motorola 6800 был сильно дешевле интеловских процессоров то есть там речь была я по памяти говорю типа интеловский стоил 120 долларов а Motorola там 25 долларов и сначала никто не мог в это поверить потому что ну не может. Понимаешь, да? Если у всех микропроцессоры стоят в 5 раз дороже, то скорее всего тебя где-то обманывают. Но спустя короткое время Intel снизил цены на свои микропроцессоры, чтобы ну как бы оставаться плюс-минус конкурентоспособными, по-моему, до 60 долларов. И было была теория, что мы снизим цены на наши микропроцессоры и их будут более активно покупать, потому что они по цене стали более сравнимы с конкурентами, хотя бы все еще дороже, а эффект оказался противоположный Intel подтвердила, что Motorola'овские микропроцессоры, они могут быть рабочими, несмотря на низкую стоимость, и поскольку они все равно дешевле, а по функционалу плюс-минус такие же, то их стали люто раскупать. Понимаешь, да? Ты снизил цену на свой продукт, а стали лучше покупать конкурентов, потому что подтвердил, что да, конкурент мог сделать нормальный микропроцессор. Это немножко странно для меня, потому что они же могли просто заказать пробник того и другого и сравнить. Если ты производитель устройств, тебе не очень сложно заказать и попробовать эти процессоры на практике, прежде чем коммититься. Это хороший аргумент. Я не знаю как это объясняется. Так совпало чисто случайно, что я прямо сейчас читаю книжку называется Введение в микропроцессоры автор Левенталь. Ленс Левенталь, по-моему. Вот это старая книжка, но там вот как раз эта история, она очень красочно описана, и вот так совпало, что мы говорим за микропроцессоры, и у меня эта информация свежа. Это не то, что где я постоянно помнил такие штуки. Получается, я к теме подготовился, да, неслыханно. То есть, у тебя нету в памяти все время актуальной истории ретро-компьютера наготове? Получается, что так. Кто ты такой, куда ты дел Сашу? Я пытаюсь книжку позвонить. Ладно, возвращаясь к своим заметочкам. Что еще интересного про 4 004 процессор можно сказать это что архитектурно чипы памяти на самом деле являлись как бы сопроцессором, потому что когда процессор обрабатывал команды чтения и записи из памяти, он не декодировал их полностью и потом управлял памятью. Он, когда он определял, что имеет дело с командой работы с памятью, он просто выставлял эту команду на шину и уже чип памяти сам разбирался, что с этой командой надо сделать: либо надо прочитать следующее значение с шины и сохранить его, или наоборот прочитать адрес и выдать то, что там хранится и так далее. То есть, по сути, Intel делегировал часть логики процессора своим чипам памяти, что вроде как тоже было сделано из соображений уменьшения количества транзисторов на основном чипе. Чипе. Что касается самой памяти, то как я уже говорил, там есть два типа памяти. Есть память инструкции, которая также называется rom это 8 чипов по 256 байт, соответственно это всего 4 килобайта в сумме. Занимательный факт, что основной чип для read-only памяти он назывался 4001 и он изготавливался Intel. То есть его нельзя было записать самому. Если вы использовали эту архитектуру и вам нужно было создать вашей, типа записать вашу прошивку вот в эту память, то что вы делали это вы писали код, распечатали его на бумажке, клали в конверт, отправляли в Intel. Intel на фабрику печатал набор чипов с вот этим вашим кодом и присылал вам обратно их. И вы можете протестировать после этого ваш девайс. Вот и Такой цикл итерации над кодом, честно говоря, меня привел в некоторый шок. Но люди действительно так работали. Интересно, как сейчас это обходится? Я не думаю, что Intel сейчас прошивает чипы 4 000-1. Их эмулируется чем-то? Позже они вроде как выпустили чипы, которые совместимы по интерфейсу, но которые перепрограммируемые. Но изначально это был единственный вариант. Может быть можно было там не знаю какой-то, хотя опять же тогда не было FPGA, так что я не знаю как они это делали. Но видимо вот отправляли почту в intel и ждали два месяца, я не знаю. Что еще можно упомянуть? Также intel позже выпустил чип под названием 4308, который по сути был 4001 просто в одном корпусе. И это упрощало разводку на плате, но по сути архитектурно это оставался все тот же самый чип. Что касается памяти, память там тоже очень интересно устроена. С помощью двоичного декодера этот процессор может работать, поддерживать до восьми банков памяти. Вот и в каждом банке памяти есть 256 полубайт, которые можно адресовать напрямую, то есть у них вот есть именно линейная адресация и можно соответственно там по адресу читать или записывать. Но кроме того, у него была интересная фича, что 64 полубайта дополнительных не имели адреса и доступ к ним производился с помощью специальных команд чтения-записи, которые читали там, грубо говоря, из первой группы байтов, из той группы байтов. То есть ты, грубо говоря, когда ты используешь команду выбора банка, это также настраивало на то, из каких у байтов состояния можно читать и писать специальными командами процессора, то есть у процессора были отдельные op-коды, которые позволяли читать вот конкретно из этих ячеек памяти. Зачем это нужно было? Это было удобно для хранения всяких глобальных переменных, когда вы сохраняете результат в памяти в калькуляторе или хотите его наоборот считать. Это как раз было удобно реализовать с помощью такой не адресуемой памяти. Но в общей сложности это получается 1280 байт оперативной памяти. Вот. Стоит для сравнения, почему вот эти статусные ячейки памяти были полезны и удобны, потому что как я говорил, там по сути тебе нужно две команды, чтобы выбрать банк, чтобы считать или чтобы записать. А адресуемая память там в худшем случае нужно было до пяти команд: две для того, чтобы выбрать банк, две для того чтобы загрузить адрес в регистр и плюс одна чтобы собственно сделать чтение или запись. Вот это все занимательные факты которые я выписал про архитектуру процессора, но это далеко не все что есть в статье, так что опять же если вам интересно, рекомендую прочитать. Прежде чем я перейду к тому как собственно на этом Linux упускать вопросы, дополнения. Но ведь Linux не поместится. Это правда, зато поместится одна из проблем использования такой странной архитектуры, это то что она ну типа совершенно не соответствует ожиданиям, которые Linux предъявляет к процессору, на котором он может исполняться. Поэтому решено было написать эмулятор другой архитектуры, которую линукс уже поддерживает, запустить этот эмулятор на интеловском микропроцессоре и собственно линукс будет запускаться внутри этого эмулятора. После некоторого рассмотрения вариантов, выбор был сделан на архитектуре Mips32. Основная причина, основная причина в том, что он очень, это очень компактная архитектура для того, чтобы декодировать команду, ему, автору статьи, потребовалось всего 141 байт кода. И под декодированием команды я имею ввиду, вот когда у вас есть ваше значение и вы его интерпретируете и передаете управление в ту часть эмулятора которая отвечает за собственно исполнение команды. То есть я хотел бы уточнить правильно ли я все понял На 4 004 пишется эмулятор инструкции Mips32, а потом этот эмулятор работает с какой-то дополнительной периферией, какой-то матерью запускает Linux. Именно Окей, окей, окей. Вот. О том, как этот эмулятор работает опять же детали в статье, но интересные Некоторые интересные аспекты эмуляции состоят в том, что у 4004 процессора, у него на самом деле довольно много регистров и так получилось, что использовать регистры с 8 по 15 их как раз хватает для того, чтобы сохранить 32-битный указатель на текущую инструкцию в архитектуре MIPS, вот что оказалось важно потому что это позволяет очень быстро как раз работать с указателем на текущую инструкцию. Почти вся нативная оперативная память интеловского процессора, она ушла на представление внутреннего состояния MIPS эмулируемого процессора. Например 32 регистра по 32 бита, которые MIPS имеет, это как раз, здесь 56 полубайт это ровно один банк памяти из восьми. Кроме того нужно место на как минимум на один блок вывода у SD карты, которая являлась устройством хранения данных для этой системы и плюс там нужен буфер трансляции адресов и еще несколько вещей. В общем, в итоге получается, что практически вся нативная память, она вся нативная память процессора 4004 она нужна для представления состояния одного современного микропроцессора. Просто чтобы сравнить вычислительную мощь тогдашней и современной архитектуры. Стоит заметить, что в процессе работы над проектом львиная доля работы делалась не на настоящем железе, да? Да, прости. Есть маленькое замечание насчет современной архитектуры MIPS. Проверка по Википедии говорит, что это 1985 год. Погоди, именно по моему их несколько же поколений было. 32 и 64. Ну ладно. Тем более. Значит, не такая уж и далеко ушедшая архитектура. Занимательный факт: на момент появления Intel 4004 уже были и 32-битные, и насчёт 64-битных не на 100% уверен, но были компьютеры по разрядности сопоставимые с современными. Просто они были очень дорогими, занимались расчётами космических полётов или чего-то. Но не нужно думать, что на тот момент все компьютеры были 8-битными или 32-битными.",
    "result": {
      "error": "API request failed: Error code: 429 - {'error': {'message': 'Rate limit reached for gpt-4.1 in organization org-xSG9D345gtYlIKC330wCyrEG on tokens per min (TPM): Limit 30000, Used 30000, Requested 6940. Please try again in 13.88s. Visit https://platform.openai.com/account/rate-limits to learn more.', 'type': 'tokens', 'param': None, 'code': 'rate_limit_exceeded'}}",
      "stack_trace": "Traceback (most recent call last):\n  File \"/home/andrei/Projects/podcast-shownotes/scripts/build_search_eval_dataset.py\", line 157, in generate_search_query\n    response = await self.client.chat.completions.create(\n               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/resources/chat/completions/completions.py\", line 1927, in create\n    return await self._post(\n           ^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1767, in post\n    return await self.request(cast_to, opts, stream=stream, stream_cls=stream_cls)\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1461, in request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1547, in _request\n    return await self._retry_request(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1594, in _retry_request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1547, in _request\n    return await self._retry_request(\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1594, in _retry_request\n    return await self._request(\n           ^^^^^^^^^^^^^^^^^^^^\n  File \"/home/andrei/Projects/podcast-shownotes/envs/lib/python3.12/site-packages/openai/_base_client.py\", line 1562, in _request\n    raise self._make_status_error_from_response(err.response) from None\nopenai.RateLimitError: Error code: 429 - {'error': {'message': 'Rate limit reached for gpt-4.1 in organization org-xSG9D345gtYlIKC330wCyrEG on tokens per min (TPM): Limit 30000, Used 30000, Requested 6940. Please try again in 13.88s. Visit https://platform.openai.com/account/rate-limits to learn more.', 'type': 'tokens', 'param': None, 'code': 'rate_limit_exceeded'}}\n"
    }
  }
]