[
  {
    "segment_id": "c6dee1a7-dd02-48b5-b2e3-31bd4d892faf",
    "episode_id": "b339a75b-0c63-4d07-997f-f6b2b60878b0",
    "episode_number": 379,
    "segment_number": 7,
    "text": "чуть подробнее расскажет, вот, фактически идея примерно такая, чтобы описать эту предметную область, вводит такой trait, ну иначе query interface, который называется future, который включен в стандартную библиотеку и у него есть метод POLL и фактически, когда мы хотим продвинуться дальше по исполнению, мы вызываем POLL, ну точнее это делает за нас executor, но в принципе ничто не мешает, когда ты пишешь какой-то GLUE код, самому вызывай POLL, а такое возникает, необходимость делать такое возникает, к сожалению, достаточно часто в текущем расте, то есть хотелось бы верить, что когда-то настанет, ну точнее определенное настанет такое время, когда тебе не нужно будет писать такой код, который сам пуг дергает, но фактически прямо сейчас это все-таки требуется делать, ну и соответственно ты вызываешь POLL и исполнение продолжается дальше, ну и в конечном счете, пока мы не получим конечные результаты, ну или иначе нужно будет перевозывать POLL много раз, еще одно отличие раста заключается в том, что когда ты спаунишь новую future, точнее не спаунишь, а создаешь ее, она не начинает тут же исполнение, это конечно отличается от go и это очень важный момент, потому что фактически до того, как ты первый раз не вызвал POLL, future не делает ничего, то есть она просто висит как объект, ничего не происходит, только после того, как ты вызвешь POLL, она в конечном счете при первой остановке будет зарегистрирована экзекьютором и вот тут на сцену выходит еще одна вещь, то есть фактически когда ты получил из POLL a yield, то есть ты знаешь, что ты не можешь дальше продолжать исполнение, тебе нужно эту future сохранить и затем в будущем тебе когда-то надо узнать все-таки, когда же она продолжит исполнение и для этого каждый такой зеленой нитке выдается экзекьютором такой объект, который называется waker и вот тут конечно возникает необходимость создателя runtime написать немножко unsafe кода, потому что waker это тоже тип стандартной библиотеки, который позволяет как раз будить наш код по событию, ну и поскольку мы пишем обвеску над POLL или KQ или бог знает чем еще, нам нужно будет написать немножко unsafe кода, как создателя runtime для того, чтобы предоставить возможность будиться, просыпаться и продолжать работу, то есть именно через waker мы... я не понял почему нужно unsafe код для этого писать? ну потому что ты никогда не знаешь какие побочные эффекты нужно будет выполнить для того, чтобы выполнить пробуждение и передать события от именно истинного периметила, который дает тебе операционная система, до того чтобы твоя нитка проснулась и продолжила работу, это может быть общение с каким-то компьютером, который тебе 42 ответит, это может быть общение с POLL, в общем случае это какой-то низкововневый код, поэтому стандартный библиотет представляет для этого единственный... а, значит что E-POLL не обернут в стандартной библиотеке? конечно, да, то есть безусловно он не обернут, но даже если бы он был обернут, совершенно не факт, что ты работаешь именно под Linux с E-POLL, потому что асинхронный код... давай так, ты говоришь как будто прям необходимо это сделать, но ведь в принципе может сделать наивный экзекютер, который просто, или не экзекутер, как правильно сказать, наивный какой-то вот тот, кто дергает за вейкеры, который просто берет их, кладет в пуфер по очереди, дергает по очереди, типа эй, пробудись, не получилось пробудиться, ну ладно, короче, следующий и так далее. ну это было бы возможно, но прямо сейчас Steed API задизайнен так, что без OnSafe кода это сделать нельзя, потому что так устроен вейкер, то есть в принципе я советую заглянуть в стандартную библиотеку, там тогда станет понятно, почему так сделано, но на самом деле это не так важно, любезно, нам в общем-то больше ничего не нужно знать, что вот есть такая концепция вейкера, которая позволяет пробудить заснувшую нитку, вот, просто чтобы быть в контексте, о чем мы говорим, ну и соответственно, когда мы пишем... подожди, подожди, пока мы дальше не ушли, а можешь объяснить, это стандартно, когда у тебя нитка по умолчанию не выполняется, какой-то lazy execution получается в модели? да, это абсолютно так, то есть это стандартно, и до того как первый раз был вызван POLL, объект Future, ну который по сути является то, что в C++ называется функтором, метод продолжит выполнять, но он висит в себе, только когда ты вызываешь POLL, он начинает выполнять какую-то логику, если хочешь, то есть нужно различать исполнение самой нити, то есть вот именно Future, и то как нитка создается, то есть если ты хочешь создать именно отдельную нить, которая живет своей жизнью, ты используешь именно примитивы runtime, в TOKYO это будет TOKYO Spawn, в Async Steed или где-то еще, ну аналогичные методы, они обычно везде называются Spawn, и ты передаешь им объект Future, но как бы если ты пишешь stack Future, то есть ты в своей Future вызываешь просто какой-то метод и выйдешь его, то конечно это сводится просто к вызву POLL, и если до его этого дела не дошло, то и до POLL дело не дошло, и Future ничего не делает, она просто сконстралирована как объект, я думаю теперь должно было стать понятнее. Да стало немножко понятнее, еще такой вопрос, не ладно давай потом. Я хочу сказать, что на самом деле в Scalo в скайпс системе есть Future, которые сами запускаются, и есть, ну которые встроены в Scalo, есть вот всяких катах и с кота совместимых опишках, там есть task и task обычно, если я правильно помню, сами не запускаются, как раз потому что они тогда, если есть что-то, что работает почти как monado, но запускается само по себе каждый раз, когда ты конструируешь объект, оно перестает быть, ну короче, нормально комбинируемым объектом, то есть ты не можешь что-то комбинировать, а потом запустить всю программу вместе, тебе нужно значит короче, как-то, ну, как это, ну короче, перестают выполняться, как-то, не могу придумать, сказать нормально, чтобы не звучать как, абсурдно, в общем, у тебя есть объект A, объект B, есть контипирация над ними, типа выполнить A после B, и когда у тебя ленивое выполнение, ну если или там, в начале создается объект, а потом выполняется, ты можешь создавать объектов, как-то их скомбинировать, потом запустить весь граф, а когда у тебя вот создал Future, а тут же запустилось, то на самом деле к тому моменту, когда ты конструировал граф, у тебя уже какой-то код выполнился, и ты, например, не можешь переставить вычисления местами, если ты хочешь какую-то оптимизацию произвести или что-то такое, вот это вот это вот ломание законов операторов над объектами, оно очень бесило людей, которые делали чисто функциональные прибыли для скалы, вот поэтому там такое тоже ответвление, которое так делает, и в принципе это исключая рантаймы, типа Гошного и Ирландкового, где весь менеджмент продолжений уже встроен в сам рантайм, это на дневнику контроля из языка не имеешь, внутри языка обычно лучше делать объекты, которые сами по себе не начинают стрелять. Да, я полностью согласен, и как раз то поведение, которое я описал, то, что ожидается от Future Rast, и одна из проблем, это если кто-то, кто пишет такой код, который подразумевает реализацию низкого уровня в Future, потому что если брать все примитивы, а синхронные, которые отвечают за EO, они должны быть реализованы так или иначе в рантайме, и если предположить, что рантайм реализован некорректно, и он начинает играли выполнять какой-то код, то есть энергично, то что называется, то возникает проблема, что нарушается базовая ассумпшнш, когда ты создал Future, ничего не должно происходить, кроме как бы тех случаев, когда ты делаешь явный спаун через рантайм и создаешь новую нитку, есть такая проблема, когда не совсем корректно реализована. Так, ну и соответственно, мы немножко поговорили об этом, о том, что тут при чем тут генераторы, вот при таком подходе есть одна небольшая проблема, что в принципе, когда ты работаешь с таким синхронным кодом, тебе компилятор негенерил из красивого синхронного, выглядящего синхронным кодом, он из него негенерил тебе бог и что, то есть объект, у которых есть пол, у которых есть возможность туда-сюда входить и выходить, и это вызывает такую проблему, что отложивать все это становится намного сложнее, то есть, да, у нас есть поддержка GDB и LODB, но когда ты сталкиваешься с синхронным кодом, ты оттачиваешься к процессу,",
    "result": {
      "query": "Rust Future trait poll method"
    }
  }
]