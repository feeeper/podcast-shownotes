[
  {
    "segment_id": "b203a4e0-da30-461c-af27-3961021a7823",
    "episode_id": "7a769113-8941-4c39-8620-b7ba4b05d27c",
    "episode_number": 96,
    "segment_number": 6,
    "text": "Нет, у них свое. У них есть обертки, которые умеют транслировать фьючеры одну в другую, но они до сих пор разные. Вот, ну, я могу быть неправ, но насколько я понимаю, что если ты сел на твиттеровский стэк, то ты на нем залипаешь. И как бы, с одной стороны, в этом ничего особо плохого нет, ну, то есть это естественно, что люди сидят в конторе, сидят под себя, офенсорсят, и у них все совсем интегрировано и так далее. Но, с другой стороны, иногда это возникает, как бы заставляет определенный дискомфорт, особенно в продакшене, ну, как бы полагаться на одну контору, а вот если они завтра передумают поддерживать, какой-нибудь там, не знаю, финейбл или еще какую-то поменьше библиотеку, которая вот... Просто там прикол в чем, что если ты одно берешь, то у тебя сразу появляется куча других решений, которые вот уже очень сильно хочется взять, потому что вот это уже хорошо интегрируется с этим, а это с этим, а это с этим, и ты уже выбираешь, как бы ищешь библиотеки не снаружи, а берешь просто вот эти готовые, потому что они все отлично интегрируются. Вот с этим только проблема. А как бы по качеству и по API, опять же, я в продакшене не использовал, но из того, что я знаю, это очень хорошее решение. То есть по качеству это отличная вещь. Если кто-то не боится залохаться на твиттер, то ради бога, рекомендую. Давайте теперь поговорим о чем-нибудь другом, например о том, почему все функциональное программирование внезапно говно. Так я же бампнула эту тему, мы же и так немножко ее коснулись. Ну вот немножко, там же статья есть, можно обсудить. Но это же неправильно, что оно прям совсем говно. Это неправильно, конечно неправильно, я не согласен. Я вообще считаю, что это такая плохая, там только половина пунктов из нее правильные, но вот тем не менее, можно же обсудить. Да там один самый главный пункт, это что нет нормальных дикшнеры. Вот, да. Ну и на самом деле в большинстве языков тот же самый человек приводит, например, акамель, тот же самый акамель, он вполне себе мутабельный. В той же самой скале есть и викоши, и мутабельные коллекции. Я вот честно говоря не очень понимаю, к чему я придавался. То есть да, есть проблемы со всем пьюр-языками, но со всем пьюр-языков мало в природе вообще, насколько я знаю. Дальше он говорит, что типа у всех у них имплементации плохие, что явно говорит о том, что человек, ну не знаю, не очень далеко смотрел, потому что есть имплементации, которым даже garbage collector не очень нужен. Так он же говорит, понимаешь, он же говорит не конкретно язык плохой, он говорит то, что чисто функциональное программирование, вот проблема, а не конкретная реализация. Я не вижу почему эта проблема, этот инструмент. Ну чисто функциональное программирование в природе не бывает, потому что чисто функциональное программирование это такая штука, которая как бы греет процессор. Не работает его. Да. И бизнесу очевидно, что бизнесу чистое функциональное программирование нужно не очень. Оно может быть нужно для того, чтобы доказать, что это где-то, и всё. Любой, сколько-нибудь практический язык, даже theory improvers, они все так или иначе имеют какой-то интерфейс с внешним миром, они имеют какую-то мутабельность, и в том же самом Haskellе, может быть там не самым эффективным образом реализованной, есть мутабельная коллекция. И дальше это уже всё вопрос реализации и того, насколько качественна эта реализация. Ну тоже по поводу функционального программирования, давай я сейчас сама с собой поспорю. Почему оно может быть хорошо и почему его не следует использовать? Допустим, мы большая компания, типа Google, и мы говорим о том, что мы хотим сделать свою базу данных либо какое-то распределённое хранилище. И я говорю, я хочу сделать своё, потому что существующие решения меня не устраивают. И когда я что-то делаю на, опять же, объёмах данных Google, мне нужно будет доказать, что моё решение действительно работает. Мне нужно будет его доказать математически. И показать, что да, действительно, это то, что нам нужно, и оно нам подходит, и оно будет таким же стабильным и даже лучше, чем то, что у нас есть. И когда мы говорим о функциональном программировании, оно хорошо ложится на математику и на эти доказательства. Может быть, для этих целей оно как раз таки хорошо подходит. Что вы скажете по этому поводу? Скажу, что это как бы артыгнуло. Оно хорошо подходит, но это не единственное применение. Вот был недавно доклад, не помню на какой конференции, Facebook рассказывал, что они Haskell используют. Вы не видели такое? Нет, не видел. Если найдёшь ссылку, то добавляй в шоу-маркет. Да, сейчас найду. И есть задачи, для которых действительно, конкретные задачи, типа той, про которую Facebook рассказывали, которые действительно неплохо решаются, прям красиво. Я думаю, если их обобщить, то это что-то типа того, что когда вам нужно абстрагироваться над структурой программы. То есть, когда программу можно рассматривать как данные и её извлекать из этого какую-то пользу, как часть функциональности это использовать. То есть, они, например, запросы какие-то, скажем так, касательно пользователей своих, кто у кого друзья и так далее, всё это дело формулируют в виде такого тахасковского DSL, и потом по-разному его рассматривают в зависимости от ситуации. То есть, грубо говоря, получается некий граф вот этого запроса, который по сути программа является. И вы эту программу можете по-разному рассматривать. Можно её интерпретировать одним образом, а можно другим. Мне кажется, что в задачах такого типа чисто функциональное программирование, оно прям хорошо работает. Когда программа, написанная в конце, представляется в виде некой структуры данных, которую можно по-разному интерпретировать. Так вот, может это получается такой, что функциональное программирование для обычного промышленного программиста, оно не так-то и нужно? Не знаю. Обычный промышленный программист, мне кажется, это слишком раскрученное понятие. Вот опять же, Spark, допустим, он как раз подпадает под то описание, которое я только что дал. То есть запрос на Spark, это как раз та самая чисто функциональная, какой-то чисто функциональный граф, ну не запрос, а как его назвать, программа на Spark, скажем так, преобразование всех этих датасетов, Spark-овских, это как раз и есть вот этот чисто функциональный граф, который Spark как раз берет, например, и оптимизирует нужным ему способом, потому что у него вот как раз перед глазами граф, а не какая-то, скажем, там, не знаю, обычная, там, не знаю, Java bytecode или что-то еще, которое невозможно анализировать на том уровне, на котором хотелось бы. То есть более высокоуровневым, и который можно оптимизировать во что угодно. Вот какие-то такие вещи, я думаю, как раз, тот же Spark, допустим, он очень промышленный в этом смысле, и мне кажется, чем дальше, тем больше будет таких вещей. Всякие, ну просто все, что касается данных, все, что в смежных областях лежит, все точно так же подпадает под это. Я все еще считаю, что есть вот такие, они не pure functional, но functional языки, как Elixir, Erlang, Haskell, Scala, на которых просто хорошо и удобно писать веб и прочие сервисы. Они просто офигенно удобные для этого, и намного удобнее, чем многие другие не pure и не functional языки. И вот там есть странный point в этой статье, типа того, что да как же так, нету правильных concurrent коллекций. Ну в том же Erlang есть ETS, в той же Scala есть concurrent коллекции. Ну и вообще, как правило, не очень это нужно. Почему люди ведь выбирают Scala и Erlang? Потому что акторы, на которых довольно удобно можно абстрагировать стейдж, чтобы не нужно было в нем уходить с кучи мест. Ну и в общем, у меня смешное отношение к этой статье. Мне кажется, что первые пункты 2, они более-менее адекватные, а дальше идет что-то, я уже говорил. Да даже первые пункты 2, они мало имеют отношения к реальности. Ну да, на чистом языке сложно реализовать, но кто мешает библиотеке и все это делать на мутабельном языке? Ну тот же ETS, он же написан не на Erlang. Ну да, да, да. Я еще хотел фидбэр дать, что вот у нас большинство бизнес-логики, которые имеют сложную структуру и тяжело реализуются на нефункциональных языках, они на всяком Acamli, Haskell и так далее, очень отлично представляются. И не будь там вот этого высокоуровневого, абстрактного уровня, было бы все намного сложнее сделать. Ну да, так и получается, что как раз вещи высокоуровневые, они отлично влажатся на все это дело, но каждый раз, когда приходится опускаться куда-то, какие-то специализированные вещи, структуры данных писать, тогда подобных языков не хватает. Все, в общем, довольно очевидно. Опять же, надо вспомнить еще девиз Haskell, приводит саксес, как там, отолкост или типа того. Да, да, именно так. Так что все вполне естественно, и на самом деле просто, ну как, я не знаю, тут надо просто понимать границы и пытаться как-то одним гвоздем забивать, в смысле одним молотком забивать все, что можно. Все, то есть под соответствующие задачи это отличный инструмент, но пытаться все подряд писать на чисто функциональном подходе, мне кажется, это просто неправильно. Он не для этого. А вот что для этого, это язык Rust. Тут давеча в Берлине был Rust-метап, на который я, конечно же, сходил. Там было три доклада, мне понравились два интересные, был один. Ну как так, потому что тот, который другой, он тоже был, в общем-то, он был хороший, но просто лично мне был не очень интересен. Первый доклад был от человека из Core Team Rust. Вот человек прям специально прилетел из Сан-Франциско в Берлин, чтобы вот на метапе в честь того, что языку исполнил за год, поговорить за будущее Rust и прошлое Rust. И вот я тут сделал себе несколько моментов, как-то сильно будущего. Во-первых, ребята очень сильно фокусируются на Cross-компиляции, то есть прям вот совсем сильно. Это для них одно из приоритетных направлений. Во-вторых, мир, так называемое серединное представление, то есть там есть High-Level Representation, есть LLVM Internal Representation, вот есть этот Middle Internal Representation, который они сейчас активно впиливают. Это огроменный рефакторинг компилятора, который по сути это как бы то же самое, что Doty делает с... Как сказать, что скала Doty, что у них есть Doty-теория, и вот это сильно более упрощенное представление скалы, к которому в итоге вся основная скала сводится. Здесь очень похожий процесс идет, то есть весь Rust сводится к такому специальному супер-эксплисит языку, в котором можно делать unsafe вещи, но понятное дело, что программист на нем писать не может. На нем может писать только компилятор, который уже транслирует из сейф-языка. И в этом коде гораздо проще делать весь этот анализ заимствований, анализ ownership, в нем гораздо проще... Точнее, типа к тому времени обычно уже проверены, но вот всякие такие вещи в нем где гораздо проще, во-вторых, там гораздо проще от оптимизации. В частности, он приводил пример, насколько здорово и классно у них будут выкидываться всякие костыли, насколько кто-нибудь, кто там очень сильно ёрзает, пожалуйста, это прям сильно слышно. И, соответственно, borrow-checking станет сильно более умным. То есть там тоже проявились примеры, как вот у нас есть, например, какой-то borrow, который только воднует keyfie, и иногда это ставит borrow-checker немножко в странное положение, и он пытается заставить программиста идти какими-то околеми путями, потому что не может понять, что на самом деле в else там не сам что-нибудь, а none, и все равно пытается сказать, что здесь у нас какой-то borrow какое-то протекает. Это больше не станет после того, как мир закончит спиливать, и это очень здорово. Дальше другое очень важное для них направление – это асинхронность. Мне было достаточно интересно послушать, потому что, если кто помнит, я понимал, что язык, в котором асинхронность должна быть прямо в виде языка, а ближе к релизу 1.0 они развернулись на 180 градусов и сказали, что нет, это все будет в библиотеках. И в итоге язык получился очень низкоуровневым, что здорово, потому что у него можно вообще весь рантайм выключить, и нет никаких завязок ни на какие специальные особенности рантайма. Сейчас назрела как минимум одна великолепная библиотека Mio для асинхронного водовывода, но она как бы... Это даже, наверное, хардкорнее, чем писать на голом нете на Java. Это еще более многословно, это примерно так же хардкорно. Вокруг этого уже есть библиотеки с фичами и есть библиотеки с карутинами. В принципе, сейчас core team Rasta планирует инвестировать свое время в экосистему с фьючерами. Я так понял, что фьючер окажется в стандартной библиотеке, чтобы были совместимые имплементации. В то же время они не хотят отталкивать людей от использования карутин, что, на мой взгляд, довольно опасно, потому что может произойти некоторое разделение в экосистеме.",
    "result": {
      "query": "чистое функциональное программирование плюсы"
    }
  }
]