[
  {
    "segment_id": "711a76bf-d095-480a-b9b0-8bfd7bb965e4",
    "episode_id": "c3c2ccac-7e79-4f29-924c-bd95a12103d0",
    "episode_number": 43,
    "segment_number": 4,
    "text": "Но у нас не бывает Олегов, не знаю, пусть будет какой-нибудь... Пока ты думаешь, я скажу, почему я про Олега вспомнил. Какой-нибудь Крис, короче, да. У нас нет программиста Криса, вот пусть будет какой-нибудь Крис. Эй, Крис, не думаешь ли ты, что нужно вот тут вместе сесть и это вместе сделать? Да, думаю, давай, сейчас закончу вот тут с этим, и через 5 минуточек сядем вместе, попишем. Или наоборот, ну нет, это фигня, я сам справлюсь, или нет, это фигня, давай ты замешай с чем-нибудь другим, или что-нибудь такое. То есть это просто здравый смысл. И бывает так, что ты начинаешь писать, понимая, что на самом деле тебе твоего личного здравого смысла маловато, хотя у нас так глупо, мне кажется, за мое время всего один раз, и как-то все довольно... То есть обычно просто собственная оценка, сложить из задач, она обычно нормально оказывается. Про Олега и здравый смысл, я почему это имя назвал, на кухоньке подслушивал загадку. В 2015 году Олегу было 30 лет, но в 2010 году ему было 35. Как такое возможно? А можно еще раз повторить ее? В 2015 году Олегу 30 лет, но в 2010 году Олегу 30 лет. Как такое возможно? А Олег один и тот же? Чего? Олег один и тот же? Да. А интегер у него сколькибитный? Вектор времени в другую сторону направлен. И? Ну и уменьшается? Вот вам хорошая загадка перед сном, подумайте. Да, спасибо. Или интегер у него какой-то там, может быть, переполняется где-нибудь, нет? Это не программисты загадывали, если что. А, окей, окей. Майор, ты нам обещал рассказать, как ты писал мультигет. А, ну короче, не знаю, стоит ли вообще об этом рассказывать, у нас с вами не такая интересная история. Но есть у нас такая задача, мы сейчас кое-что кэшируем в Reddise, на самом деле мы очень много что кэшируем в Reddise, но есть вещи, которые, если кэш потерялся, то они будут туда очень долго наполняться, если, конечно, ручками его не прогреть. Но если его прогревать ручками, то смысла от этого кэша, конечно, немного. Вот, я так подумал, они сделали бы что-нибудь такое, чтобы вообще нас это не волновало, и чтобы просто React нам отвечало, чтобы у нас React удовлетворял в плане этих запросов. То есть чем React плох в данном случае, тем что у нас, точнее ванильная, кейвэйлию модельна не только React, а чего угодно. Если у нас есть запрос, типа, отдай-ка мне значение какого-нибудь свойства всех моих друзей, и каждый друг разбросан по всем машинам кластера, и друзей у тебя, например, сотня, и ты начинаешь каждого друга спрашивать его значение, понятное дело, что работать это будет небыстро, мягко говоря. Вот, в Redis есть функционал, типа, можешь каждому отдельному узлу сказать, эй, узел, отдай-ка мне, пожалуйста, вот каждый из этих ключей, и, как бы это, вы скажите, все, конец набора команд, и теперь давай мне результаты. Вот, в принципе, я подумал, что в React есть React Pipe, и, наверное, можно взять и поверх пайпа и в одно место в протокол буферс приходишь, говоришь, хочу вот эти вот айдишники, таких-то вот, ребята, пожалуйста, отрежь мне документы, все ненужное, кроме вот того, что мне нужно. Ну, там, у нас там JSON хранится в React. Вот, и, в общем-то, успешно написал, тестировал, прям даже там и юнит-тест, и интеграционный тест написал, и даже подхачил RubyGem, чтобы он мои кастомные портабаф-сообщения умел. И вот в тот момент, когда я уже заканчивал хачить RubyGem, я наткнулся в коде GEM на то, что у обычного React-овского Reduce внезапно принимает, кроме всяких параметров, обозначающих какую-то большую пачку ключей, чтобы выцепить нужно прошарашиться по всему узлу, оказывается, принимает просто набор primary ключей. И я что-то поглядел, как он реализован, и понял, что примерно там такая же фигня, как внутри у меня получается. Вот, я, конечно, померил, но это было бы немножечко быстрее, потому что у меня нет общего кода, который там... то есть, мое решение не такое генерик, как мой Reduce в общем случае. Но в целом оно настолько незначительно, что если вам вдруг нужен Multiget, и при этом нужно отрезать кусок от документа ненужного, вы просто пишете на Erlang, я не думаю, что на JavaScript это будет быстро работать, поэтому лучше на Erlang штуку, которая отрезает от JavaScript ненужные куски, и просто использовать MapReduce с набором primary ключей, это важно, чтобы это не... В таком случае это может работать даже быстрее, чем честные ряковские геты, потому что оно делает меньше работы, чем честный ряковский гет. Мы это еще в продакшен не тащили, но выглядит многообещающе. Скорее всего мы будем использовать MapReduce, потому что к нему никаких костылей на стороне Ruby не нужно. Мы можем подгрузить мой модуль, который делает Multiget, либо модуль, который будет внутри MapReduce крутиться и отрезать лишнее от документа, в любом случае его подтаскивать. На стороне Ruby хотя бы костыли ставить не нужно, поэтому, наверное, будет MapReduce, но на самом деле еще погоняем тесты, нам пока не до того, чтобы больше тащить в продакшен наступного фича. Такие дела. У меня пара вопросов по ряку. Вопрос первый. Насколько он у вас в реальных условиях в памяти горячие данные держит? 100% в горячих данных в памяти. То есть у него там нормальные кэшики, в этом смысле все хорошо? Во-первых, у нас данные не такие большие, во-вторых, у нас машин много. У нас 10 ряков стоит. Я не знаю, сколько у нас оффлайн пользователей. Я не уверен, что я могу называть нашу дневную аудиторию, но, скажем так, это шестизначное число. Вы просто памяти побольше выделили? Ну, кстати, на ряках машинах не так много памяти. Например, на MySQL машинах там больше гораздо памяти, чем на ряках. В ряке стоит биткаск. Я работал с ряком раньше с LVDB, тут биткаск. В биткаске, как известно, что? Все понятно, дальше можешь не продолжать. Для слушателей в биткаске там все ключи в памяти. Ключи, да, не данные, ключи. Кейсплейс. Но и в принципе у нас, на самом деле, и данные в памяти лежат. Только если к нам приходит юзер, вернувшийся юзер, которого давно не было. А вот этот фактор репликации вы какой поставили? Троечка. А вас в кэшах, при хожительстве в кэшах ходить три раза не смущает? В кэшах три раза? В смысле? Ты о чем? Вы когда читаете, вы со скольких узлов читаете? В смысле? Ну, я думаю, что там классические, я не уверен точно, я не помню точно настройки, думаю, классические. Плюем данные в все три, ждем от первых двух я не буду, потому что не помню, честно говоря. Окей, просто мне кажется, это дороговато для кэшек. Подожди, React не кэшек, радис кэшек. А, React у вас не как кэшек, понятно. React у нас основная база данных, то есть, грубо говоря, идея в том, что у нас есть один-единственный радис, который, точнее, не один-единственный, он решардированный, но который реплицируется, потому что если он отваливается, то там некому будет сериализовывать транзакции юзерские, чтобы пользователь, чтобы запросы обрабатывать in order. Не идеальное решение, но вроде работает. И кроме этого, то есть, грубо говоря, если у нас отваливается какой-нибудь побочный сервис, какой-нибудь побочный кэш, игра должна продолжать работать. То есть, если там отвалился кэш с какими-то, например, данными пользователей, то, ну, просто мы покажем нолики, но игра продолжит работать. А поскольку игра не может работать без такой штуки, как данные пользователя, то они в React, и React, он как бы не работает.",
    "result": {
      "query": "Riak database MapReduce Multiget"
    }
  }
]