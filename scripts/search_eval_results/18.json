[
  {
    "segment_id": "0caca657-d2a9-4696-b6fe-86b10a604ae4",
    "episode_id": "778e4fb9-aa9f-4531-bf02-b9a0453e2afa",
    "episode_number": 18,
    "segment_number": 7,
    "text": "Собственно, в чем идея? Есть такой сервис, который называется... Не помню как. Сейчас посмотрим. Ну, собственно, идея сервиса следующая. Есть какие-то задачи, и можно решать эти задачи, выкладывать свое решение. Есть пользователи, которые смотрят на решение и ставят плюс один, если решение нравится. И была задача найти длину по хэммингу. Вы знаете, что это такое? Либо все-таки рассказать. Я думаю, не лишним. Как минимум для пользователей. Для меня тоже. В чем идея? Длина, дифф, разница по хэммингу. Основная идея какая? У нас есть строки, одинаковые длины. И нам нужно вычислить этот разный строк. По сути, это просто количество символов, которые отличаются в этих двух строках. Допустим, строка ААА и снова ААА. Разность будет ноль. Если будет строка ААА и ААБ, разность будет один. Ну, идея понятна. И есть влайнер на питоне, который решает эту задачу. И есть другая функция, которая решает эту задачу в 17 строк. И при этом второе решение, оно написано в чистом императивном стиле, с комментариями. Все понятно, что происходит. Ты можешь легко дебажить. В каждой строке происходит ровно одно действие. Все понятно, просто. И при этом этот код не набрал никаких плюсов. А код, которым это пишется, определяется в одну строку. С использованием функции map набрал кучу плюсов. И автор возмущается, негодует и говорит о том, что первый код, я имею ввиду первый, который короткий, короткий код набрал больше плюсов. И при этом этот код по сути пишется людьми исключительно для себя. То есть автор не предполагает, что этот код будет почитаться еще кем-то. И он не будет вообще как-то просто показать, какой я классный, какой я хороший. И посмотрите, как я умею писать короткие решения быстро. И я примерно посмотрела эту статью, мне она стала очень интересной, потому что я примерно выступаю за ту же идею. Пускай у нас будет более какая-то длинная функция, но она будет понятна, она будет читаема. Вместо коротких, может быть даже более изящных решений, на которые приходится долго вникать, смотреть и думать, что же там, черт побери, происходит. Что вы думаете по поводу этого? Я считаю, что это сильно завязанно и диаматику языка, на котором написано. Я не могу говорить запятон, потому что я не писатель на питоне. Смотри, у нас язык такой, он предоставляет тебе возможность писать как в императивном, так и функциональном стиле. У тебя есть свобода, ты можешь писать и так, и так. Ну вот, например, на скале я совершенно точно предпочту решение с мэпом, фолдом и всем таким. Во-первых, потому что на скале это принято так делать. То есть императивщина это уже такой стиль, типа как не надо. В ирландии у меня вообще нет вариантов. И я буду стараться придерживаться каких-то функциональных паттернов, типа сверток и всякого такого, потому что если я знаю, что здесь свертка, я могу вообще не читать этот код. Ну свертка и свертка, я представляю что там может быть за свертка. Если это свертка на маноиде, то это вообще очевидно, можно вообще не читать. Свертка на маноиде, что может быть проще? Ну понимаешь, я тебе говорю о том, что открывает человек код, который не программировал на языке Python. И он читает функцию, которая написана, понятно, с комментариями, всё как положено. Ему в принципе не нужно понимать, как работает Python. Он просто открывает и понимает ага, вот мне нужно там что-то поменять, это дело 5 минут. Вместо этого, если он читает первый вариант, который короткий, он пытается вникнуть, а что же там происходит, как же эта штука работает, он потратит куда больше времени, если ему придётся внести туда какие-то изменения. Вот про что я говорю. Если в этом коротком решении нет какой-то суперспецифики для Python, а просто неимперативный подход, то тут, знаешь, может быть наоборот так, что функциональщик быстрее разберётся в коротком коде, вот тут мы используем map of all the code, а императивщик быстрее разберётся в коде, который... Ну, понимаешь, здесь, скажем, примеры то, что императивный и функциональный подход. Есть другие варианты, когда в однострочник делается куда больше работы, и не обязательно, что это именно функциональный стиль, просто вот в однострочник так красиво сделали, смотрите, не понятно, но красота. Однострочник у нас есть. С моей точки зрения, главное, чтобы было понятно, однострочник и однострочник и однострочник, это неважно, и нет смысла стараться прям всё идеально вылезать до идеальной понятности. Если есть какие-то идиомы, которые свойственны языку, то их можно лепить смело, совершенно, если они сокращают код. Но вот есть такая идиома, любой человек, который пишет на этом языке, её поймёт. Тут ещё вопрос, понимаешь, Свет, для кого предназначен этот код? То есть, в принципе, короткий код тоже вполне имеет право на жизнь, если, допустим, он пишется в какой-то команде, где все так пишут, и все это понимают, ну и в чём в этом плохое? Если идёт речь о том, чтобы написать кусок какой-то кода, который надо предоставить обществу, где, возможно, разного уровня, так сказать, разработчики с ним столкнутся, то, конечно, надо писать более развернуто, подробно. Но, опять-таки, я вот соглашусь с Валерой, что если есть какие-то, действительно, там, идиомы, которые приняты в языке, то их искусственно игнорировать, наоборот, это кажется плохо. Вот так. Да, давайте не будем игнорировать идиомы, принятые в языке. А вот есть такая интересная идиома в языке Rust, называется... По-моему, это произносится крейтс. Валер, поправь меня. Это не идиом... О-ло-ло, нейтрали. Это не идиома, это способ доставлять в библиотеке, вот как гемы в рубях, сраные гидрепозитории в фрланге, питонии яйца в питоне, там что ещё где, в хаскеле. Как кабальги, пакеты в хаскеле называются? Да, это не просто называются пакеты. Ну да. Просто пакеты. Ну, в общем, короче, это всё, это фигня, это просто пакеты с библиотечкой. Короче, местное название артефактов переводится на нормальный язык. Ха-ха, вот даже теперь как, да? То есть теперь нормальный язык это артефакты. Ну вот, и новое заключается в том, что запустился сайт, называется kreyts.io, я надеюсь, я это правильно произношу, где есть разные пакетики для языка Rust, можно посмотреть их версии, сколько раз их качали, тут есть всякие прикольные вещи типа аватарок на гитхабе авторов, графички, зависимости, такой очень приятный сайт с каталогом пакетов для Rust. Вот Rust, там сколько, лет 5, наверное, и даже у него есть нормальный пакет менеджер. А, понимаешь, тут очень забавно, они его, во-первых, делали без этого Legacy, во-вторых, они его делали буквально за последний, наверное, год. То есть, его начали делать, когда Rust был, наверное, в версии 0.9, или там даже 10, и вот он уже почти готовый, считай. То есть у них сразу была идея, что должны быть какие-то крейты, вот они какие-то будут. Вот, а пакеты и менеджер пакетов появился буквально недавно, и меня очень радует, что ребята из Mozilla, они прям конкретно вкладывают бабла в такое развитие. То есть в Orlogia это пилит полтора человека, которому за это никто не платит. Mozilla наняла чувака, который пишет документацию, несколько чуваков, которые пишут по системам пакетов, и так далее, и так далее, и так далее. Это не говоря уже о том, что ребята, которые пилят сам Rust, тоже работают в Mozilla за бабло. То есть ребятам просто конкретно отсыпают бабла за то, чтобы они допиливали до идеального состояния, которое всем понравится. Константин, что вы думаете о Rust? Ты знаешь, я на него так немножко посмотрю, я-то вообще далек от таких системных языков, там, в СИАХ и прочее. Я из мира веб, ну, бетон и подобные штуки. Так на него можно веб писать, и он такой быстрый будет, что ты упадешь, какой он быстрый. Знаешь, я больше как-то на Go пока что посматриваю. Ну, кстати, да, для веба Go может быть даже получше, хотя, блин, Go там совершенно идиотский хендлинг ошибок, его там, считай, нету. И там есть легковесные процессы, которых хендлинг падения, которых тоже сделал странно. Вот, я не знаю, но можно любить Go. Что касается Go, то самое интересное, на мой взгляд, вот это как раз такие Go-рутины. Это единственный большой плюс этого языка. Но хендлинг ошибок, это, конечно, это что-то невообразимое. А вот какой плюс у Go перед Erlang'ом, простите? Он быстрый. Кто, Go быстрый? Да. По сравнению с Erlang'ом, с скомпилированным хайпом, что-то знаешь там, по-моему, ноздря в ноздрю. И опять-таки, быстро для чего? Числа подробить, может, побыстрее. Горбачков и Лектору Go до сих пор просасывают. Ну, он там активно как раз-таки пилится. Товарищ Венюков рассказывал про это дело, что должно все-таки быть лучше уже вот скоро. То есть, понимаешь, у них в любом случае до сих пор общая куча. Ну, пока у них общая куча, они никуда не придут. А что ты имеешь против общей кучи? Ну, навалили общую кучу, и потом один крымч коллекторов парится, не может ее разобрать. Гораздо лучше, когда у нас не общая куча, у нас коллекторы вообще не привязаны. То есть, у нас там гуррутина или Erlang'овый процесс пошел поспать, его там вытеснили с планировщика. Мы за это время можем его собрать. Пока какие-то другие процессы занимаются полезной работой. Ну, то есть, ты предлагаешь поднять по одной куче на процесс, постоянно копировать данные туда-обратно? Я тебе уже, кажется, рассказывал как-то раз в оффлайне фантазии по этому поводу. Во-первых, можно говорить, что у этой группы процессов общая куча, например, если они постоянно работают с общими данными, между собой гоняют в этот раз. Второй момент, можно делать, как это делали в Rust, пока они не выкинули легковесные процессы из языка в библиотеку. Ну, собственно, там и сейчас все это есть, просто сейчас это библиотека уже, а не язык, и это не вполне можно говорить про именно Rust как язык. Rust, скорее, в данном случае, как система. А у них просто есть разные примитивы. У них разные кучи. Если тебе нужен зашаренный объект, ты вместо одного примитива работы с памятью берешь другой примитив работы с памятью, и у тебя получается пошаренный объект. Ну, то есть, по сути, ты предлагаешь написать там 10 микросервисов на Go, и чтобы у каждого была своя куча? Понимаешь, в чем плохие микросервисы? Тебе потом нужно будет как-то присесть со штанга, чтобы эти микросервисы между собой связать. А что там связывать-то? Ну, здрасте, у тебя это все будет через сеть общаться, скорее всего. Или через какой-нибудь IPC. Соответственно, нужен какой-то фреймворк для обвязки этого всего. Берешь какой-нибудь... По сравнению с просто гурутиной каналом, или с просто ирланговым процессом, это много лишних действий. Много лишней боли. Зачем? Ну, хрен знает. Я не вижу такой большой проблемы в том, чтобы сходить по Ресту один лишний раз. Просто понимаешь, вот тут все эти микросервисы, и вот это все придет стишник, и напишет программу, которая в 5 мегабайтах константной памяти работает, и из интерфейса у нее только стейд-ин и стейд-аут. И ты сидишь такой, думаешь, блин, я каким-то говном занимаюсь. Ну, в этом смысле Рест, конечно, намного интереснее, там вообще нет сборки мусора, как таковой. Ну, в смысле нет сборщика. Он там есть, но он в библиотеке. И ты можешь им не пользоваться. Он в библиотеке? Серьезно? У них есть такой полноценный, как в ГО? Ну, нет, у них там до сих пор референс-каунтинг, где все спланируют к релизу заперись в ГЦН, сколько знаю. Угу. Ну, понимаешь, референс-каунтинг тоже заборка мусора, на самом деле, формально считается. Ну, да, я поэтому... Я бы не называл это сборщиком мусора, но да. Кстати, насчет обработки исключений, на самом деле в Расте и в ГО она довольно одинаковая. За тем исключением, что в Расте у тебя... Компилятор это все проверяет, вот да. Ты не можешь просто забить на возвращаемый результат. Но я другое хотел сказать, что у тебя там есть парочка макросов, которые позволяют тебе писать чуть меньше кода. Ты куда-то пропал. Сделать какую-то откровенную херню, то есть если у тебя функция возвращает... Повтори, пожалуйста, с самого начала. Смотри, если у тебя в Расте принято возвращать either или option, или как это там называется. Result и, по-моему, option. Ну, в общем, да. И у тебя, раз проверяешь, что ты считаешь как Haskell или как Scala в случае с Sealed Trait, что ты все кейсы сматчил. Слушай, там такая проверка из серии, что вот эта фигня вернула мне optional и теперь считать, что она мне всегда вернула конкретный результат, а не NULL. Там прям вот вернуть optional. и взять результат. Вот так вот пишут на Расте. Понимаешь, я такого кода не видел. Я видел как раз наоборот, что все честно проверяют NULL. Все честно проверяют NULL. Ну, понятно, что, смотри, просто, когда у тебя есть тип, этот дополнительный optional, ты в любом случае на него посмотришь и подумаешь, а что же мне с ним делать? Когда у тебя функция возвращает значение, ну, там, или NULL иногда, ты про этот NULL иногда можешь вообще не подумать. То есть, ну, она возвращает значение и возвращает. Там даже у тебя тип вообще никак не отражает, что у тебя там иногда может что-то, чего-то не быть. Ты просто пишешь код и пишешь, и даже не задумываешься о том, что у тебя там может сломаться. А вот он возьмет и раз, на 100 случаев сломается. Слушай, зачем вообще нужна эта контроль со стороны компилятора? У тебя есть код REVIEW. Ага, вот так. Ну, мне же нечего было тебе проверить. Мы просмотрели. Да, и тестами можно все покрыть. Ты в каком-то абстрактном мире живешь, что у тебя 100% покрытие тестами, хочешь сказать? Нет, конечно, 98% процентное. Ну, вот эти 2% из 100 тебе все испортит. Нет, ну, во-первых, начнем с того, что покрытие тестами и наличие тупых ошибок это такие параллельные вещи. То есть, ну, покрытие тестами, оно выловит ошибки в интерфейсах, может быть, и какие-то простые ошибки в логике. Ну, иногда, в редких случаях, сложные ошибки в логике. Как тебе тест поможет выловить, что у тебя в одном из 10 случаев, про которые ты вообще не подумал, когда ты это писал, и, соответственно, у тебя теста на это нет, что у тебя где-то вернется нива. Константин, ты за хаскели или за тесты? Я за лоа. Вот так вот. Ну, там все на тестах. Конечно, конечно.",
    "result": {
      "query": "императивный vs функциональный стиль"
    }
  }
]